{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport convert from './convert'; // GeoJSON conversion and preprocessing\nimport clip from './clip'; // stripe clipping algorithm\nimport wrap from './wrap'; // date line processing\nimport transform from './transform'; // coordinate transformation\nimport createTile from './tile'; // final simplified tile generation\n\nexport default function geojsonvt(data, options) {\n  return new GeoJSONVT(data, options);\n}\nfunction GeoJSONVT(data, options) {\n  options = this.options = extend(Object.create(this.options), options);\n  var debug = options.debug;\n  if (debug) console.time('preprocess data');\n  if (options.maxZoom < 0 || options.maxZoom > 24) throw new Error('maxZoom should be in the 0-24 range');\n  if (options.promoteId && options.generateId) throw new Error('promoteId and generateId cannot be used together.');\n  var features = convert(data, options);\n  this.tiles = {};\n  this.tileCoords = [];\n  if (debug) {\n    console.timeEnd('preprocess data');\n    console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n    console.time('generate tiles');\n    this.stats = {};\n    this.total = 0;\n  }\n  features = wrap(features, options);\n\n  // start slicing from the top tile down\n  if (features.length) this.splitTile(features, 0, 0, 0);\n  if (debug) {\n    if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);\n    console.timeEnd('generate tiles');\n    console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n  }\n}\nGeoJSONVT.prototype.options = {\n  maxZoom: 14,\n  // max zoom to preserve detail on\n  indexMaxZoom: 5,\n  // max zoom in the tile index\n  indexMaxPoints: 100000,\n  // max number of points per tile in the tile index\n  tolerance: 3,\n  // simplification tolerance (higher means simpler)\n  extent: 4096,\n  // tile extent\n  buffer: 64,\n  // tile buffer on each side\n  lineMetrics: false,\n  // whether to calculate line metrics\n  promoteId: null,\n  // name of a feature property to be promoted to feature.id\n  generateId: false,\n  // whether to generate feature ids. Cannot be used with promoteId\n  debug: 0 // logging level (0, 1 or 2)\n};\n\nGeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {\n  var stack = [features, z, x, y],\n    options = this.options,\n    debug = options.debug;\n\n  // avoid recursion by using a processing queue\n  while (stack.length) {\n    y = stack.pop();\n    x = stack.pop();\n    z = stack.pop();\n    features = stack.pop();\n    var z2 = 1 << z,\n      id = toID(z, x, y),\n      tile = this.tiles[id];\n    if (!tile) {\n      if (debug > 1) console.time('creation');\n      tile = this.tiles[id] = createTile(features, z, x, y, options);\n      this.tileCoords.push({\n        z: z,\n        x: x,\n        y: y\n      });\n      if (debug) {\n        if (debug > 1) {\n          console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)', z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n          console.timeEnd('creation');\n        }\n        var key = 'z' + z;\n        this.stats[key] = (this.stats[key] || 0) + 1;\n        this.total++;\n      }\n    }\n\n    // save reference to original geometry in tile so that we can drill down later if we stop now\n    tile.source = features;\n\n    // if it's the first-pass tiling\n    if (!cz) {\n      // stop tiling if we reached max zoom, or if the tile is too simple\n      if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;\n\n      // if a drilldown to a specific tile\n    } else {\n      // stop tiling if we reached base zoom or our target tile zoom\n      if (z === options.maxZoom || z === cz) continue;\n\n      // stop tiling if it's not an ancestor of the target tile\n      var m = 1 << cz - z;\n      if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) continue;\n    }\n\n    // if we slice further down, no need to keep source geometry\n    tile.source = null;\n    if (features.length === 0) continue;\n    if (debug > 1) console.time('clipping');\n\n    // values we'll use for clipping\n    var k1 = 0.5 * options.buffer / options.extent,\n      k2 = 0.5 - k1,\n      k3 = 0.5 + k1,\n      k4 = 1 + k1,\n      tl,\n      bl,\n      tr,\n      br,\n      left,\n      right;\n    tl = bl = tr = br = null;\n    left = clip(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);\n    right = clip(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);\n    features = null;\n    if (left) {\n      tl = clip(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n      bl = clip(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n      left = null;\n    }\n    if (right) {\n      tr = clip(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n      br = clip(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n      right = null;\n    }\n    if (debug > 1) console.timeEnd('clipping');\n    stack.push(tl || [], z + 1, x * 2, y * 2);\n    stack.push(bl || [], z + 1, x * 2, y * 2 + 1);\n    stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n    stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n  }\n};\nGeoJSONVT.prototype.getTile = function (z, x, y) {\n  var options = this.options,\n    extent = options.extent,\n    debug = options.debug;\n  if (z < 0 || z > 24) return null;\n  var z2 = 1 << z;\n  x = (x % z2 + z2) % z2; // wrap tile x coordinate\n\n  var id = toID(z, x, y);\n  if (this.tiles[id]) return transform(this.tiles[id], extent);\n  if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);\n  var z0 = z,\n    x0 = x,\n    y0 = y,\n    parent;\n  while (!parent && z0 > 0) {\n    z0--;\n    x0 = Math.floor(x0 / 2);\n    y0 = Math.floor(y0 / 2);\n    parent = this.tiles[toID(z0, x0, y0)];\n  }\n  if (!parent || !parent.source) return null;\n\n  // if we found a parent tile containing the original geometry, we can drill down from it\n  if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);\n  if (debug > 1) console.time('drilling down');\n  this.splitTile(parent.source, z0, x0, y0, z, x, y);\n  if (debug > 1) console.timeEnd('drilling down');\n  return this.tiles[id] ? transform(this.tiles[id], extent) : null;\n};\nfunction toID(z, x, y) {\n  return ((1 << z) * y + x) * 32 + z;\n}\nfunction extend(dest, src) {\n  for (var i in src) dest[i] = src[i];\n  return dest;\n}","map":{"version":3,"names":["convert","clip","wrap","transform","createTile","geojsonvt","data","options","GeoJSONVT","extend","Object","create","debug","console","time","maxZoom","Error","promoteId","generateId","features","tiles","tileCoords","timeEnd","log","indexMaxZoom","indexMaxPoints","stats","total","length","splitTile","numFeatures","numPoints","JSON","stringify","prototype","tolerance","extent","buffer","lineMetrics","z","x","y","cz","cx","cy","stack","pop","z2","id","toID","tile","push","numSimplified","key","source","m","Math","floor","k1","k2","k3","k4","tl","bl","tr","br","left","right","minX","maxX","minY","maxY","getTile","z0","x0","y0","parent","dest","src","i"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/geojson-vt/src/index.js"],"sourcesContent":["\nimport convert from './convert';     // GeoJSON conversion and preprocessing\nimport clip from './clip';           // stripe clipping algorithm\nimport wrap from './wrap';           // date line processing\nimport transform from './transform'; // coordinate transformation\nimport createTile from './tile';     // final simplified tile generation\n\nexport default function geojsonvt(data, options) {\n    return new GeoJSONVT(data, options);\n}\n\nfunction GeoJSONVT(data, options) {\n    options = this.options = extend(Object.create(this.options), options);\n\n    var debug = options.debug;\n\n    if (debug) console.time('preprocess data');\n\n    if (options.maxZoom < 0 || options.maxZoom > 24) throw new Error('maxZoom should be in the 0-24 range');\n    if (options.promoteId && options.generateId) throw new Error('promoteId and generateId cannot be used together.');\n\n    var features = convert(data, options);\n\n    this.tiles = {};\n    this.tileCoords = [];\n\n    if (debug) {\n        console.timeEnd('preprocess data');\n        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n        console.time('generate tiles');\n        this.stats = {};\n        this.total = 0;\n    }\n\n    features = wrap(features, options);\n\n    // start slicing from the top tile down\n    if (features.length) this.splitTile(features, 0, 0, 0);\n\n    if (debug) {\n        if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);\n        console.timeEnd('generate tiles');\n        console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n    }\n}\n\nGeoJSONVT.prototype.options = {\n    maxZoom: 14,            // max zoom to preserve detail on\n    indexMaxZoom: 5,        // max zoom in the tile index\n    indexMaxPoints: 100000, // max number of points per tile in the tile index\n    tolerance: 3,           // simplification tolerance (higher means simpler)\n    extent: 4096,           // tile extent\n    buffer: 64,             // tile buffer on each side\n    lineMetrics: false,     // whether to calculate line metrics\n    promoteId: null,        // name of a feature property to be promoted to feature.id\n    generateId: false,      // whether to generate feature ids. Cannot be used with promoteId\n    debug: 0                // logging level (0, 1 or 2)\n};\n\nGeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {\n\n    var stack = [features, z, x, y],\n        options = this.options,\n        debug = options.debug;\n\n    // avoid recursion by using a processing queue\n    while (stack.length) {\n        y = stack.pop();\n        x = stack.pop();\n        z = stack.pop();\n        features = stack.pop();\n\n        var z2 = 1 << z,\n            id = toID(z, x, y),\n            tile = this.tiles[id];\n\n        if (!tile) {\n            if (debug > 1) console.time('creation');\n\n            tile = this.tiles[id] = createTile(features, z, x, y, options);\n            this.tileCoords.push({z: z, x: x, y: y});\n\n            if (debug) {\n                if (debug > 1) {\n                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',\n                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n                    console.timeEnd('creation');\n                }\n                var key = 'z' + z;\n                this.stats[key] = (this.stats[key] || 0) + 1;\n                this.total++;\n            }\n        }\n\n        // save reference to original geometry in tile so that we can drill down later if we stop now\n        tile.source = features;\n\n        // if it's the first-pass tiling\n        if (!cz) {\n            // stop tiling if we reached max zoom, or if the tile is too simple\n            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;\n\n        // if a drilldown to a specific tile\n        } else {\n            // stop tiling if we reached base zoom or our target tile zoom\n            if (z === options.maxZoom || z === cz) continue;\n\n            // stop tiling if it's not an ancestor of the target tile\n            var m = 1 << (cz - z);\n            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) continue;\n        }\n\n        // if we slice further down, no need to keep source geometry\n        tile.source = null;\n\n        if (features.length === 0) continue;\n\n        if (debug > 1) console.time('clipping');\n\n        // values we'll use for clipping\n        var k1 = 0.5 * options.buffer / options.extent,\n            k2 = 0.5 - k1,\n            k3 = 0.5 + k1,\n            k4 = 1 + k1,\n            tl, bl, tr, br, left, right;\n\n        tl = bl = tr = br = null;\n\n        left  = clip(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);\n        right = clip(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);\n        features = null;\n\n        if (left) {\n            tl = clip(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n            bl = clip(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n            left = null;\n        }\n\n        if (right) {\n            tr = clip(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n            br = clip(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n            right = null;\n        }\n\n        if (debug > 1) console.timeEnd('clipping');\n\n        stack.push(tl || [], z + 1, x * 2,     y * 2);\n        stack.push(bl || [], z + 1, x * 2,     y * 2 + 1);\n        stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n        stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n    }\n};\n\nGeoJSONVT.prototype.getTile = function (z, x, y) {\n    var options = this.options,\n        extent = options.extent,\n        debug = options.debug;\n\n    if (z < 0 || z > 24) return null;\n\n    var z2 = 1 << z;\n    x = ((x % z2) + z2) % z2; // wrap tile x coordinate\n\n    var id = toID(z, x, y);\n    if (this.tiles[id]) return transform(this.tiles[id], extent);\n\n    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);\n\n    var z0 = z,\n        x0 = x,\n        y0 = y,\n        parent;\n\n    while (!parent && z0 > 0) {\n        z0--;\n        x0 = Math.floor(x0 / 2);\n        y0 = Math.floor(y0 / 2);\n        parent = this.tiles[toID(z0, x0, y0)];\n    }\n\n    if (!parent || !parent.source) return null;\n\n    // if we found a parent tile containing the original geometry, we can drill down from it\n    if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);\n\n    if (debug > 1) console.time('drilling down');\n    this.splitTile(parent.source, z0, x0, y0, z, x, y);\n    if (debug > 1) console.timeEnd('drilling down');\n\n    return this.tiles[id] ? transform(this.tiles[id], extent) : null;\n};\n\nfunction toID(z, x, y) {\n    return (((1 << z) * y + x) * 32) + z;\n}\n\nfunction extend(dest, src) {\n    for (var i in src) dest[i] = src[i];\n    return dest;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}