{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __assign, __awaiter, __extends, __generator, __read, __spreadArray, __values } from \"tslib\";\nimport { getAdjust as getAdjustClass } from '@antv/adjust';\nimport { getAttribute as getAttributeClass } from '@antv/attr';\nimport { clone, deepMix, each, flatten, get, isArray, isEmpty, isEqual, isFunction, isNil, isNumber, isObject, isPlainObject, isString, set } from '@antv/util';\nimport { doGroupAppearAnimate, getDefaultAnimateCfg } from '../animate';\nimport Base from '../base';\nimport { FIELD_ORIGIN, GEOMETRY_LIFE_CIRCLE, GROUP_ATTRS } from '../constant';\nimport { uniq } from '../util/helper';\nimport Element from './element';\nimport { getGeometryLabel } from './label';\nimport { getShapeFactory } from './shape/base';\nimport { group } from './util/group-data';\nimport { isModelChange } from './util/is-model-change';\nimport { parseFields } from './util/parse-fields';\nimport { diff } from './util/diff';\nimport { inferScaleType } from '../util/scale';\nimport { getXDimensionLength } from '../util/coordinate';\n/**\n * Geometry 几何标记基类，主要负责数据到图形属性的映射以及绘制逻辑。\n */\nvar Geometry = /** @class */function (_super) {\n  __extends(Geometry, _super);\n  /**\n   * 创建 Geometry 实例。\n   * @param cfg\n   */\n  function Geometry(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    /** Geometry 几何标记类型。 */\n    _this.type = 'base';\n    // 内部产生的属性\n    /** Attribute map  */\n    _this.attributes = {};\n    /** Element map */\n    _this.elements = [];\n    /** 使用 key-value 结构存储 Element，key 为每个 Element 实例对应的唯一 ID */\n    _this.elementsMap = {};\n    /** animate 配置项 */\n    _this.animateOption = true;\n    /** 图形属性映射配置 */\n    _this.attributeOption = {};\n    /** 存储上一次渲染时的 element 映射表，用于更新逻辑 */\n    _this.lastElementsMap = {};\n    /** 是否生成多个点来绘制图形。 */\n    _this.generatePoints = false;\n    /** 存储发生图形属性映射前的数据 */\n    _this.beforeMappingData = null;\n    _this.adjusts = {};\n    _this.idFields = [];\n    _this.hasSorted = false;\n    _this.isCoordinateChanged = false;\n    var container = cfg.container,\n      labelsContainer = cfg.labelsContainer,\n      coordinate = cfg.coordinate,\n      data = cfg.data,\n      _a = cfg.sortable,\n      sortable = _a === void 0 ? false : _a,\n      _b = cfg.visible,\n      visible = _b === void 0 ? true : _b,\n      theme = cfg.theme,\n      _c = cfg.scales,\n      scales = _c === void 0 ? {} : _c,\n      _d = cfg.scaleDefs,\n      scaleDefs = _d === void 0 ? {} : _d,\n      // 柱状图间隔与宽度相关配置\n      intervalPadding = cfg.intervalPadding,\n      dodgePadding = cfg.dodgePadding,\n      maxColumnWidth = cfg.maxColumnWidth,\n      minColumnWidth = cfg.minColumnWidth,\n      columnWidthRatio = cfg.columnWidthRatio,\n      roseWidthRatio = cfg.roseWidthRatio,\n      multiplePieWidthRatio = cfg.multiplePieWidthRatio,\n      zIndexReversed = cfg.zIndexReversed,\n      sortZIndex = cfg.sortZIndex,\n      useDeferredLabel = cfg.useDeferredLabel;\n    _this.container = container;\n    _this.labelsContainer = labelsContainer;\n    _this.coordinate = coordinate;\n    _this.data = data;\n    _this.sortable = sortable;\n    _this.visible = visible;\n    _this.userTheme = theme;\n    _this.scales = scales;\n    _this.scaleDefs = scaleDefs;\n    // 柱状图间隔与宽度相关配置\n    _this.intervalPadding = intervalPadding;\n    _this.dodgePadding = dodgePadding;\n    _this.maxColumnWidth = maxColumnWidth;\n    _this.minColumnWidth = minColumnWidth;\n    _this.columnWidthRatio = columnWidthRatio;\n    _this.roseWidthRatio = roseWidthRatio;\n    _this.multiplePieWidthRatio = multiplePieWidthRatio;\n    _this.zIndexReversed = zIndexReversed;\n    _this.sortZIndex = sortZIndex;\n    _this.useDeferredLabel = useDeferredLabel ? typeof useDeferredLabel === 'number' ? useDeferredLabel : Infinity : null;\n    return _this;\n  }\n  /**\n   * 配置 position 通道映射规则。\n   *\n   * @example\n   * ```typescript\n   * // 数据结构: [{ x: 'A', y: 10, color: 'red' }]\n   * geometry.position('x*y');\n   * geometry.position([ 'x', 'y' ]);\n   * geometry.position({\n   *   fields: [ 'x', 'y' ],\n   * });\n   * ```\n   *\n   * @param cfg 映射规则\n   * @returns\n   */\n  Geometry.prototype.position = function (cfg) {\n    var positionCfg = cfg;\n    if (!isPlainObject(cfg)) {\n      // 字符串字段或者数组字段\n      positionCfg = {\n        fields: parseFields(cfg)\n      };\n    }\n    var fields = get(positionCfg, 'fields');\n    if (fields.length === 1) {\n      // 默认填充一维 1*xx\n      fields.unshift('1');\n      set(positionCfg, 'fields', fields);\n    }\n    set(this.attributeOption, 'position', positionCfg);\n    return this;\n  };\n  Geometry.prototype.color = function (field, cfg) {\n    this.createAttrOption('color', field, cfg);\n    return this;\n  };\n  Geometry.prototype.shape = function (field, cfg) {\n    this.createAttrOption('shape', field, cfg);\n    return this;\n  };\n  Geometry.prototype.size = function (field, cfg) {\n    this.createAttrOption('size', field, cfg);\n    return this;\n  };\n  /**\n   * 设置数据调整方式。G2 目前内置了四种类型：\n   * 1. dodge\n   * 2. stack\n   * 3. symmetric\n   * 4. jitter\n   *\n   *\n   * **Tip**\n   * + 对于 'dodge' 类型，可以额外进行如下属性的配置:\n   * ```typescript\n   * geometry.adjust('dodge', {\n   *   marginRatio: 0, // 取 0 到 1 范围的值（相对于每个柱子宽度），用于控制一个分组中柱子之间的间距\n   *   dodgeBy: 'x', // 该属性只对 'dodge' 类型生效，声明以哪个数据字段为分组依据\n   * });\n   * ```\n   *\n   * + 对于 'stack' 类型，可以额外进行如下属性的配置:\n   * ```typescript\n   * geometry.adjust('stack', {\n   *   reverseOrder: false, // 用于控制是否对数据进行反序操作\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * geometry.adjust('stack');\n   *\n   * geometry.adjust({\n   *   type: 'stack',\n   *   reverseOrder: false,\n   * });\n   *\n   * // 组合使用 adjust\n   * geometry.adjust([ 'stack', 'dodge' ]);\n   *\n   * geometry.adjust([\n   *   { type: 'stack' },\n   *   { type: 'dodge', dodgeBy: 'x' },\n   * ]);\n   * ```\n   *\n   * @param adjustCfg 数据调整配置\n   * @returns\n   */\n  Geometry.prototype.adjust = function (adjustCfg) {\n    var adjusts = adjustCfg;\n    if (isString(adjustCfg) || isPlainObject(adjustCfg)) {\n      adjusts = [adjustCfg];\n    }\n    each(adjusts, function (adjust, index) {\n      if (!isObject(adjust)) {\n        adjusts[index] = {\n          type: adjust\n        };\n      }\n    });\n    this.adjustOption = adjusts;\n    return this;\n  };\n  Geometry.prototype.style = function (field, styleFunc) {\n    if (isString(field)) {\n      var fields = parseFields(field);\n      this.styleOption = {\n        fields: fields,\n        callback: styleFunc\n      };\n    } else {\n      var _a = field,\n        fields = _a.fields,\n        callback = _a.callback,\n        cfg = _a.cfg;\n      if (fields || callback || cfg) {\n        this.styleOption = field;\n      } else {\n        this.styleOption = {\n          cfg: field\n        };\n      }\n    }\n    return this;\n  };\n  Geometry.prototype.tooltip = function (field, cfg) {\n    if (isString(field)) {\n      var fields = parseFields(field);\n      this.tooltipOption = {\n        fields: fields,\n        callback: cfg\n      };\n    } else {\n      this.tooltipOption = field;\n    }\n    return this;\n  };\n  /**\n   * Geometry 动画配置。\n   *\n   * + `animate(false)` 关闭动画\n   * + `animate(true)` 开启动画，默认开启。\n   *\n   * 我们将动画分为四个场景：\n   * 1. appear: 图表第一次加载时的入场动画；\n   * 2. enter: 图表绘制完成，发生更新后，产生的新图形的进场动画；\n   * 3. update: 图表绘制完成，数据发生变更后，有状态变更的图形的更新动画；\n   * 4. leave: 图表绘制完成，数据发生变更后，被销毁图形的销毁动画。\n   *\n   * @example\n   * ```typescript\n   * animate({\n   *   enter: {\n   *     duration: 1000, // enter 动画执行时间\n   *   },\n   *   leave: false, // 关闭 leave 销毁动画\n   * });\n   * ```\n   *\n   * @param cfg 动画配置\n   * @returns\n   */\n  Geometry.prototype.animate = function (cfg) {\n    this.animateOption = cfg;\n    return this;\n  };\n  Geometry.prototype.label = function (field, secondParam, thirdParam) {\n    if (isString(field)) {\n      var labelOption = {};\n      var fields = parseFields(field);\n      labelOption.fields = fields;\n      if (isFunction(secondParam)) {\n        labelOption.callback = secondParam;\n      } else if (isPlainObject(secondParam)) {\n        labelOption.cfg = secondParam;\n      }\n      if (thirdParam) {\n        labelOption.cfg = thirdParam;\n      }\n      this.labelOption = labelOption;\n    } else {\n      this.labelOption = field;\n    }\n    return this;\n  };\n  /**\n   * 设置状态对应的样式。\n   *\n   * @example\n   * ```ts\n   * chart.interval().state({\n   *   selected: {\n   *     animate: { duration: 100, easing: 'easeLinear' },\n   *     style: {\n   *       lineWidth: 2,\n   *       stroke: '#000',\n   *     },\n   *   },\n   * });\n   * ```\n   *\n   * 如果图形 shape 是由多个 shape 组成，即为一个 G.Group 对象，那么针对 group 中的每个 shape，我们需要使用下列方式进行状态样式设置：\n   * 如果我们为 group 中的每个 shape 设置了 'name' 属性(shape.set('name', 'xx'))，则以 'name' 作为 key，否则默认以索引值（即 shape 的 添加顺序）为 key。\n   *\n   * ```ts\n   * chart.interval().shape('groupShape').state({\n   *   selected: {\n   *     style: {\n   *       0: { lineWidth: 2 },\n   *       1: { fillOpacity: 1 },\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * @param cfg 状态样式\n   */\n  Geometry.prototype.state = function (cfg) {\n    this.stateOption = cfg;\n    return this;\n  };\n  /**\n   * 用于向 shape 中传入自定义的数据。目前可能仅仅可能用于在自定义 shape 的时候，像自定义 shape 中传入自定义的数据，方便实现自定义 shape 的配置能力。\n   *\n   * @example\n   * ```ts\n   * chart.interval().customInfo({ yourData: 'hello, g2!' });\n   * ```\n   *\n   * 然后在自定义 shape 的时候，可以拿到这个信息。\n   *\n   * ```ts\n   * registerShape('interval', 'your-shape', {\n   *   draw(shapeInfo, container) {\n   *     const { customInfo } = shapeInfo;\n   *     console.log(customInfo); // will log { yourData: 'hello, g2!' }.\n   *   }\n   * });\n   * ```\n   *\n   * @param cfg\n   */\n  Geometry.prototype.customInfo = function (cfg) {\n    this.customOption = cfg;\n    return this;\n  };\n  /**\n   * 初始化 Geomtry 实例：\n   * 创建 [[Attribute]] and [[Scale]] 实例，进行数据处理，包括分组、数值化以及数据调整。\n   */\n  Geometry.prototype.init = function (cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    this.setCfg(cfg);\n    this.initAttributes(); // 创建图形属性\n    // 数据加工：分组 -> 数字化 -> adjust\n    this.processData(this.data);\n    // 调整 scale\n    this.adjustScale();\n  };\n  /**\n   * Geometry 更新。\n   * @param [cfg] 更新的配置\n   */\n  Geometry.prototype.update = function (cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    var data = cfg.data,\n      isDataChanged = cfg.isDataChanged,\n      isCoordinateChanged = cfg.isCoordinateChanged;\n    var _a = this,\n      attributeOption = _a.attributeOption,\n      lastAttributeOption = _a.lastAttributeOption;\n    if (!isEqual(attributeOption, lastAttributeOption)) {\n      // 映射发生改变，则重新创建图形属性\n      this.init(cfg);\n    } else if (data && (isDataChanged || !isEqual(data, this.data))) {\n      // 数据发生变化\n      this.setCfg(cfg);\n      this.initAttributes(); // 创建图形属性\n      this.processData(data); // 数据加工：分组 -> 数字化 -> adjust\n    } else {\n      // 有可能 coordinate 变化\n      this.setCfg(cfg);\n    }\n    // 调整 scale\n    this.adjustScale();\n    this.isCoordinateChanged = isCoordinateChanged;\n  };\n  /**\n   * 将原始数据映射至图形空间，同时创建图形对象。\n   */\n  Geometry.prototype.paint = function (isUpdate) {\n    var _this = this;\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    if (this.animateOption) {\n      this.animateOption = deepMix({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);\n    }\n    this.defaultSize = undefined;\n    this.elementsMap = {};\n    this.elements = [];\n    var offscreenGroup = this.getOffscreenGroup();\n    offscreenGroup.clear();\n    var beforeMappingData = this.beforeMappingData;\n    var dataArray = this.beforeMapping(beforeMappingData);\n    this.dataArray = new Array(dataArray.length);\n    for (var i = 0; i < dataArray.length; i++) {\n      var data = dataArray[i];\n      this.dataArray[i] = this.mapping(data);\n    }\n    this.updateElements(this.dataArray, isUpdate);\n    this.lastElementsMap = this.elementsMap;\n    if (this.canDoGroupAnimation(isUpdate)) {\n      // 如果用户没有配置 appear.animation，就默认走整体动画\n      var container = this.container;\n      var type = this.type;\n      var coordinate = this.coordinate;\n      var animateCfg = get(this.animateOption, 'appear');\n      var yScale = this.getYScale();\n      var yMinPoint = coordinate.convert({\n        x: 0,\n        y: yScale.scale(this.getYMinValue())\n      });\n      doGroupAppearAnimate(container, animateCfg, type, coordinate, yMinPoint);\n    }\n    // 添加 label\n    if (this.labelOption) {\n      var deferred = this.useDeferredLabel;\n      var callback = function () {\n        return _this.renderLabels(flatten(_this.dataArray), isUpdate);\n      }.bind(this);\n      if (typeof deferred === 'number') {\n        // Use `requestIdleCallback` to render labels in idle time (like react fiber)\n        var timeout = typeof deferred === 'number' && deferred !== Infinity ? deferred : 0;\n        if (!window.requestIdleCallback) {\n          setTimeout(callback, timeout);\n        } else {\n          var options = timeout && timeout !== Infinity ? {\n            timeout: timeout\n          } : undefined;\n          window.requestIdleCallback(callback, options);\n        }\n      } else {\n        callback();\n      }\n    }\n    // 缓存，用于更新\n    this.lastAttributeOption = __assign({}, this.attributeOption);\n    if (this.visible === false) {\n      // 用户在初始化的时候声明 visible: false\n      this.changeVisible(false);\n    }\n  };\n  /**\n   * 清空当前 Geometry，配置项仍保留，但是内部创建的对象全部清空。\n   * @override\n   */\n  Geometry.prototype.clear = function () {\n    var _a = this,\n      container = _a.container,\n      geometryLabel = _a.geometryLabel,\n      offscreenGroup = _a.offscreenGroup;\n    if (container) {\n      container.clear();\n    }\n    if (geometryLabel) {\n      geometryLabel.clear();\n    }\n    if (offscreenGroup) {\n      offscreenGroup.clear();\n    }\n    // 属性恢复至出厂状态\n    this.scaleDefs = undefined;\n    this.attributes = {};\n    this.scales = {};\n    this.elementsMap = {};\n    this.lastElementsMap = {};\n    this.elements = [];\n    this.adjusts = {};\n    this.dataArray = null;\n    this.beforeMappingData = null;\n    this.lastAttributeOption = undefined;\n    this.defaultSize = undefined;\n    this.idFields = [];\n    this.groupScales = undefined;\n    this.hasSorted = false;\n    this.isCoordinateChanged = false;\n  };\n  /**\n   * 销毁 Geometry 实例。\n   */\n  Geometry.prototype.destroy = function () {\n    this.clear();\n    var container = this.container;\n    container.remove(true);\n    if (this.offscreenGroup) {\n      this.offscreenGroup.remove(true);\n      this.offscreenGroup = null;\n    }\n    if (this.geometryLabel) {\n      this.geometryLabel.destroy();\n      this.geometryLabel = null;\n    }\n    this.theme = undefined;\n    this.shapeFactory = undefined;\n    _super.prototype.destroy.call(this);\n  };\n  /**\n   * 获取决定分组的图形属性对应的 scale 实例。\n   * @returns\n   */\n  Geometry.prototype.getGroupScales = function () {\n    return this.groupScales;\n  };\n  /**\n   * 根据名字获取图形属性实例。\n   */\n  Geometry.prototype.getAttribute = function (name) {\n    return this.attributes[name];\n  };\n  /** 获取 x 轴对应的 scale 实例。 */\n  Geometry.prototype.getXScale = function () {\n    return this.getAttribute('position').scales[0];\n  };\n  /** 获取 y 轴对应的 scale 实例。 */\n  Geometry.prototype.getYScale = function () {\n    return this.getAttribute('position').scales[1];\n  };\n  /**\n   * 获取决定分组的图形属性实例。\n   */\n  Geometry.prototype.getGroupAttributes = function () {\n    var rst = [];\n    each(this.attributes, function (attr) {\n      if (GROUP_ATTRS.includes(attr.type)) {\n        rst.push(attr);\n      }\n    });\n    return rst;\n  };\n  /** 获取图形属性默认的映射值。 */\n  Geometry.prototype.getDefaultValue = function (attrName) {\n    var value;\n    var attr = this.getAttribute(attrName);\n    if (attr && isEmpty(attr.scales)) {\n      // 获取映射至常量的值\n      value = attr.values[0];\n    }\n    return value;\n  };\n  /**\n   * 获取该数据发生图形映射后对应的 Attribute 图形空间数据。\n   * @param attr Attribute 图形属性实例。\n   * @param obj 需要进行映射的原始数据。\n   * @returns\n   */\n  Geometry.prototype.getAttributeValues = function (attr, obj) {\n    var params = [];\n    var scales = attr.scales;\n    for (var index = 0, length_1 = scales.length; index < length_1; index++) {\n      var scale = scales[index];\n      var field = scale.field;\n      if (scale.isIdentity) {\n        params.push(scale.values);\n      } else {\n        params.push(obj[field]);\n      }\n    }\n    return attr.mapping.apply(attr, __spreadArray([], __read(params), false));\n  };\n  /**\n   * 获取对应的 adjust 实例\n   * @param adjustType\n   * @returns\n   */\n  Geometry.prototype.getAdjust = function (adjustType) {\n    return this.adjusts[adjustType];\n  };\n  /**\n   * 获得 coordinate 实例\n   * @returns\n   */\n  Geometry.prototype.getCoordinate = function () {\n    return this.coordinate;\n  };\n  Geometry.prototype.getData = function () {\n    return this.data;\n  };\n  /**\n   * 获取 shape 对应的 marker 样式。\n   * @param shapeName shape 具体名字\n   * @param cfg marker 信息\n   * @returns\n   */\n  Geometry.prototype.getShapeMarker = function (shapeName, cfg) {\n    var shapeFactory = this.getShapeFactory();\n    return shapeFactory.getMarker(shapeName, cfg);\n  };\n  /**\n   * 根据一定的规则查找 Geometry 的 Elements。\n   *\n   * ```typescript\n   * getElementsBy((element) => {\n   *   const data = element.getData();\n   *\n   *   return data.a === 'a';\n   * });\n   * ```\n   *\n   * @param condition 定义查找规则的回调函数。\n   * @returns\n   */\n  Geometry.prototype.getElementsBy = function (condition) {\n    return this.elements.filter(function (element) {\n      return condition(element);\n    });\n  };\n  /**\n   * 获取 Geometry 的所有 Elements。\n   *\n   * ```typescript\n   * getElements();\n   * ```\n   */\n  Geometry.prototype.getElements = function () {\n    return this.elements;\n  };\n  /**\n   * 获取数据对应的唯一 id。\n   * @param data Element 对应的绘制数据\n   * @returns\n   */\n  Geometry.prototype.getElementId = function (data) {\n    data = isArray(data) ? data[0] : data;\n    var originData = data[FIELD_ORIGIN];\n    // 如果用户声明了使用哪些字段作为 id 值\n    if (this.idFields.length) {\n      var elementId = originData[this.idFields[0]];\n      for (var index = 1; index < this.idFields.length; index++) {\n        elementId += '-' + originData[this.idFields[index]];\n      }\n      return elementId;\n    }\n    var type = this.type;\n    var xScale = this.getXScale();\n    var yScale = this.getYScale();\n    var xField = xScale.field || 'x';\n    var yField = yScale.field || 'y';\n    var yVal = originData[yField];\n    var xVal;\n    if (xScale.type === 'identity') {\n      xVal = xScale.values[0];\n    } else {\n      xVal = originData[xField];\n    }\n    var id;\n    if (type === 'interval' || type === 'schema') {\n      id = \"\".concat(xVal);\n    } else if (type === 'line' || type === 'area' || type === 'path') {\n      id = type;\n    } else {\n      id = \"\".concat(xVal, \"-\").concat(yVal);\n    }\n    var groupScales = this.groupScales;\n    for (var index = 0, length_2 = groupScales.length; index < length_2; index++) {\n      var groupScale = groupScales[index];\n      var field = groupScale.field;\n      id = \"\".concat(id, \"-\").concat(originData[field]);\n    }\n    // 用户在进行 dodge 类型的 adjust 调整的时候设置了 dodgeBy 属性\n    var dodgeAdjust = this.getAdjust('dodge');\n    if (dodgeAdjust) {\n      var dodgeBy = dodgeAdjust.dodgeBy;\n      if (dodgeBy) {\n        id = \"\".concat(id, \"-\").concat(originData[dodgeBy]);\n      }\n    }\n    if (this.getAdjust('jitter')) {\n      id = \"\".concat(id, \"-\").concat(data.x, \"-\").concat(data.y);\n    }\n    return id;\n  };\n  /**\n   * 获取所有需要创建 scale 的字段名称。\n   */\n  Geometry.prototype.getScaleFields = function () {\n    var fields = [];\n    var tmpMap = new Map();\n    var _a = this,\n      attributeOption = _a.attributeOption,\n      labelOption = _a.labelOption,\n      tooltipOption = _a.tooltipOption;\n    // 获取图形属性上的 fields\n    for (var attributeType in attributeOption) {\n      if (attributeOption.hasOwnProperty(attributeType)) {\n        var eachOpt = attributeOption[attributeType];\n        if (eachOpt.fields) {\n          uniq(eachOpt.fields, fields, tmpMap);\n        } else if (eachOpt.values) {\n          // 考虑 size(10), shape('circle') 等场景\n          uniq(eachOpt.values, fields, tmpMap);\n        }\n      }\n    }\n    // 获取 label 上的字段\n    if (labelOption && labelOption.fields) {\n      uniq(labelOption.fields, fields, tmpMap);\n    }\n    // 获取 tooltip 上的字段\n    if (isObject(tooltipOption) && tooltipOption.fields) {\n      uniq(tooltipOption.fields, fields, tmpMap);\n    }\n    return fields;\n  };\n  /**\n   * 显示或者隐藏 geometry。\n   * @param visible\n   */\n  Geometry.prototype.changeVisible = function (visible) {\n    _super.prototype.changeVisible.call(this, visible);\n    var elements = this.elements;\n    for (var index = 0, length_3 = elements.length; index < length_3; index++) {\n      var element = elements[index];\n      element.changeVisible(visible);\n    }\n    if (visible) {\n      if (this.container) {\n        this.container.show();\n      }\n      if (this.labelsContainer) {\n        this.labelsContainer.show();\n      }\n    } else {\n      if (this.container) {\n        this.container.hide();\n      }\n      if (this.labelsContainer) {\n        this.labelsContainer.hide();\n      }\n    }\n  };\n  /**\n   * 获得所有的字段\n   */\n  Geometry.prototype.getFields = function () {\n    var uniqMap = new Map();\n    var fields = [];\n    Object.values(this.attributeOption).forEach(function (cfg) {\n      var fs = (cfg === null || cfg === void 0 ? void 0 : cfg.fields) || [];\n      fs.forEach(function (f) {\n        if (!uniqMap.has(f)) {\n          fields.push(f);\n        }\n        uniqMap.set(f, true);\n      });\n    }, []);\n    return fields;\n  };\n  /**\n   * 获取当前配置中的所有分组 & 分类的字段。\n   * @return fields string[]\n   */\n  Geometry.prototype.getGroupFields = function () {\n    var groupFields = [];\n    var tmpMap = new Map(); // 用于去重过滤\n    for (var index = 0, length_4 = GROUP_ATTRS.length; index < length_4; index++) {\n      var attributeName = GROUP_ATTRS[index];\n      var cfg = this.attributeOption[attributeName];\n      if (cfg && cfg.fields) {\n        uniq(cfg.fields, groupFields, tmpMap);\n      }\n    }\n    return groupFields;\n  };\n  /**\n   * 获得图形的 x y 字段。\n   */\n  Geometry.prototype.getXYFields = function () {\n    var _a = __read(this.attributeOption.position.fields, 2),\n      x = _a[0],\n      y = _a[1];\n    return [x, y];\n  };\n  /**\n   * x 字段\n   * @returns\n   */\n  Geometry.prototype.getXField = function () {\n    return get(this.getXYFields(), [0]);\n  };\n  /**\n   * y 字段\n   * @returns\n   */\n  Geometry.prototype.getYField = function () {\n    return get(this.getXYFields(), [1]);\n  };\n  /**\n   * 获取该 Geometry 下所有生成的 shapes。\n   * @returns shapes\n   */\n  Geometry.prototype.getShapes = function () {\n    return this.elements.map(function (element) {\n      return element.shape;\n    });\n  };\n  /**\n   * 获取虚拟 Group。\n   * @returns\n   */\n  Geometry.prototype.getOffscreenGroup = function () {\n    if (!this.offscreenGroup) {\n      var GroupCtor = this.container.getGroupBase(); // 获取分组的构造函数\n      this.offscreenGroup = new GroupCtor({});\n    }\n    return this.offscreenGroup;\n  };\n  // 对数据进行排序\n  Geometry.prototype.sort = function (mappingArray) {\n    if (!this.hasSorted) {\n      // 未发生过排序\n      var xScale_1 = this.getXScale();\n      var xField_1 = xScale_1.field;\n      for (var index = 0; index < mappingArray.length; index++) {\n        var itemArr = mappingArray[index];\n        itemArr.sort(function (obj1, obj2) {\n          return xScale_1.translate(obj1[FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[FIELD_ORIGIN][xField_1]);\n        });\n      }\n    }\n    this.hasSorted = true;\n  };\n  /**\n   * 调整度量范围。主要针对发生层叠以及一些特殊需求的 Geometry，比如 Interval 下的柱状图 Y 轴默认从 0 开始。\n   */\n  Geometry.prototype.adjustScale = function () {\n    var yScale = this.getYScale();\n    // 如果数据发生过 stack adjust，需要调整下 yScale 的数据范围\n    if (yScale && this.getAdjust('stack')) {\n      this.updateStackRange(yScale, this.beforeMappingData);\n    }\n  };\n  /**\n   * 获取当前 Geometry 对应的 Shape 工厂实例。\n   */\n  Geometry.prototype.getShapeFactory = function () {\n    var shapeType = this.shapeType;\n    if (!getShapeFactory(shapeType)) {\n      return;\n    }\n    if (!this.shapeFactory) {\n      this.shapeFactory = clone(getShapeFactory(shapeType)); // 防止多个 view 共享一个 shapeFactory 实例，导致 coordinate 被篡改\n    }\n    // 因为这里缓存了 shapeFactory，但是外部可能会变更 coordinate，导致无法重新设置到 shapeFactory 中\n    this.shapeFactory.coordinate = this.coordinate;\n    // theme 原因同上\n    this.shapeFactory.theme = this.theme.geometries[shapeType] || {};\n    return this.shapeFactory;\n  };\n  /**\n   * 获取每个 Shape 对应的关键点数据。\n   * @param obj 经过分组 -> 数字化 -> adjust 调整后的数据记录\n   * @returns\n   */\n  Geometry.prototype.createShapePointsCfg = function (obj) {\n    var xScale = this.getXScale();\n    var yScale = this.getYScale();\n    var x = this.normalizeValues(obj[xScale.field], xScale);\n    var y; // 存在没有 y 的情况\n    if (yScale) {\n      y = this.normalizeValues(obj[yScale.field], yScale);\n    } else {\n      y = obj.y ? obj.y : 0.1;\n    }\n    return {\n      x: x,\n      y: y,\n      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined\n    };\n  };\n  /**\n   * 创建 Element 实例。\n   * @param mappingDatum Element 对应的绘制数据\n   * @param [isUpdate] 是否处于更新阶段\n   * @returns element 返回创建的 Element 实例\n   */\n  Geometry.prototype.createElement = function (mappingDatum, index, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    var container = this.container;\n    var shapeCfg = this.getDrawCfg(mappingDatum); // 获取绘制图形的配置信息\n    var shapeFactory = this.getShapeFactory();\n    var element = new Element({\n      shapeFactory: shapeFactory,\n      container: container,\n      offscreenGroup: this.getOffscreenGroup(),\n      elementIndex: index\n    });\n    element.animate = this.animateOption;\n    element.geometry = this;\n    element.draw(shapeCfg, isUpdate); // 绘制\n    return element;\n  };\n  /**\n   * 获取每条数据对应的图形绘制数据。\n   * @param mappingDatum 映射后的数据\n   * @returns draw cfg\n   */\n  Geometry.prototype.getDrawCfg = function (mappingDatum) {\n    var originData = mappingDatum[FIELD_ORIGIN]; // 原始数据\n    var cfg = {\n      mappingData: mappingDatum,\n      data: originData,\n      x: mappingDatum.x,\n      y: mappingDatum.y,\n      color: mappingDatum.color,\n      size: mappingDatum.size,\n      isInCircle: this.coordinate.isPolar,\n      customInfo: this.customOption\n    };\n    var shapeName = mappingDatum.shape;\n    if (!shapeName && this.getShapeFactory()) {\n      shapeName = this.getShapeFactory().defaultShapeType;\n    }\n    cfg.shape = shapeName;\n    // 获取默认样式\n    var theme = this.theme.geometries[this.shapeType];\n    cfg.defaultStyle = get(theme, [shapeName, 'default'], {}).style;\n    if (!cfg.defaultStyle && this.getShapeFactory()) {\n      cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme);\n    }\n    var styleOption = this.styleOption;\n    if (styleOption) {\n      cfg.style = this.getStyleCfg(styleOption, originData);\n    }\n    if (this.generatePoints) {\n      cfg.points = mappingDatum.points;\n      cfg.nextPoints = mappingDatum.nextPoints;\n    }\n    return cfg;\n  };\n  Geometry.prototype.updateElements = function (mappingDataArray, isUpdate) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    var keyDatum = new Map();\n    var keys = [];\n    // 用来保持 diff 元素之后 added, updated 的相对顺序\n    var keyIndex = new Map();\n    var index = 0;\n    // 获得更新数据所有的 keys\n    // 将更新的数据用 key 索引\n    for (var i = 0; i < mappingDataArray.length; i++) {\n      var mappingData = mappingDataArray[i];\n      for (var j = 0; j < mappingData.length; j++) {\n        var mappingDatum = mappingData[j];\n        var key = this.getElementId(mappingDatum);\n        var finalKey = keyDatum.has(key) ? \"\".concat(key, \"-\").concat(i, \"-\").concat(j) : key;\n        keys.push(finalKey);\n        keyDatum.set(finalKey, mappingDatum);\n        keyIndex.set(finalKey, index);\n        index++;\n      }\n    }\n    this.elements = new Array(index);\n    var _d = diff(this.lastElementsMap, keys),\n      added = _d.added,\n      updated = _d.updated,\n      removed = _d.removed;\n    try {\n      // 新建 element\n      for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {\n        var key = added_1_1.value;\n        var mappingDatum = keyDatum.get(key);\n        var i = keyIndex.get(key);\n        var element = this.createElement(mappingDatum, i, isUpdate);\n        this.elements[i] = element;\n        this.elementsMap[key] = element;\n        if (element.shape) {\n          element.shape.set('zIndex', this.zIndexReversed ? this.elements.length - i : i);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (added_1_1 && !added_1_1.done && (_a = added_1.return)) _a.call(added_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    try {\n      // 更新 element\n      for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {\n        var key = updated_1_1.value;\n        var element = this.lastElementsMap[key];\n        var mappingDatum = keyDatum.get(key);\n        var currentShapeCfg = this.getDrawCfg(mappingDatum);\n        var preShapeCfg = element.getModel();\n        var i = keyIndex.get(key);\n        if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {\n          element.animate = this.animateOption;\n          // 通过绘制数据的变更来判断是否需要更新，因为用户有可能会修改图形属性映射\n          element.update(currentShapeCfg); // 更新对应的 element\n        }\n\n        this.elements[i] = element;\n        this.elementsMap[key] = element;\n        if (element.shape) {\n          element.shape.set('zIndex', this.zIndexReversed ? this.elements.length - i : i);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return)) _b.call(updated_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    // 全部 setZIndex 之后，再执行 sort\n    if (this.container) {\n      this.container.sort();\n    }\n    try {\n      // 销毁被删除的 elements\n      for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {\n        var key = removed_1_1.value;\n        var element = this.lastElementsMap[key];\n        // 更新动画配置，用户有可能在更新之前有对动画进行配置操作\n        element.animate = this.animateOption;\n        element.destroy();\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return)) _c.call(removed_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n  /**\n   * 获取渲染的 label 类型。\n   */\n  Geometry.prototype.getLabelType = function () {\n    var _a = this,\n      labelOption = _a.labelOption,\n      coordinate = _a.coordinate,\n      type = _a.type;\n    var coordinateType = coordinate.type,\n      isTransposed = coordinate.isTransposed;\n    var labelType = get(labelOption, ['cfg', 'type']);\n    if (!labelType) {\n      // 用户未定义，则进行默认的逻辑\n      if (coordinateType === 'polar') {\n        // 极坐标下使用通用的极坐标文本，转置则使用饼图\n        labelType = isTransposed ? 'pie' : 'polar';\n      } else if (coordinateType === 'theta') {\n        // theta 坐标系下使用饼图文本\n        labelType = 'pie';\n      } else if (type === 'interval' || type === 'polygon') {\n        labelType = 'interval';\n      } else {\n        labelType = 'base';\n      }\n    }\n    return labelType;\n  };\n  /**\n   * 获取 Y 轴上的最小值。\n   */\n  Geometry.prototype.getYMinValue = function () {\n    var yScale = this.getYScale();\n    var min = yScale.min,\n      max = yScale.max;\n    var value;\n    if (min >= 0) {\n      value = min;\n    } else if (max <= 0) {\n      // 当值全位于负区间时，需要保证 ymin 在区域内，不可为 0\n      value = max;\n    } else {\n      value = 0;\n    }\n    return value;\n  };\n  // 创建图形属性相关的配置项\n  Geometry.prototype.createAttrOption = function (attrName, field, cfg) {\n    if (isNil(field) || isObject(field)) {\n      if (isObject(field) && isEqual(Object.keys(field), ['values'])) {\n        // shape({ values: [ 'funnel' ] })\n        set(this.attributeOption, attrName, {\n          fields: field.values\n        });\n      } else {\n        set(this.attributeOption, attrName, field);\n      }\n    } else {\n      var attrCfg = {};\n      if (isNumber(field)) {\n        // size(3)\n        attrCfg.values = [field];\n      } else {\n        attrCfg.fields = parseFields(field);\n      }\n      if (cfg) {\n        if (isFunction(cfg)) {\n          attrCfg.callback = cfg;\n        } else {\n          attrCfg.values = cfg;\n        }\n      }\n      set(this.attributeOption, attrName, attrCfg);\n    }\n  };\n  Geometry.prototype.initAttributes = function () {\n    var _this = this;\n    var _a = this,\n      attributes = _a.attributes,\n      attributeOption = _a.attributeOption,\n      theme = _a.theme,\n      shapeType = _a.shapeType;\n    this.groupScales = [];\n    var tmpMap = {};\n    var _loop_1 = function (attrType) {\n      if (attributeOption.hasOwnProperty(attrType)) {\n        var option = attributeOption[attrType];\n        if (!option) {\n          return {\n            value: void 0\n          };\n        }\n        var attrCfg = __assign({}, option);\n        var callback = attrCfg.callback,\n          values = attrCfg.values,\n          _b = attrCfg.fields,\n          fields = _b === void 0 ? [] : _b;\n        // 获取每一个字段对应的 scale\n        var scales = fields.map(function (field) {\n          var scale = _this.scales[field];\n          if (!tmpMap[field] && GROUP_ATTRS.includes(attrType)) {\n            var inferedScaleType = inferScaleType(scale, get(_this.scaleDefs, field), attrType, _this.type);\n            if (inferedScaleType === 'cat') {\n              _this.groupScales.push(scale);\n              tmpMap[field] = true;\n            }\n          }\n          return scale;\n        });\n        attrCfg.scales = scales;\n        if (attrType !== 'position' && scales.length === 1 && scales[0].type === 'identity') {\n          // 用户在图形通道上声明了常量字段 color('red'), size(5)\n          attrCfg.values = scales[0].values;\n        } else if (!callback && !values) {\n          // 用户没有指定任何规则，则使用默认的映射规则\n          if (attrType === 'size') {\n            attrCfg.values = theme.sizes;\n          } else if (attrType === 'shape') {\n            attrCfg.values = theme.shapes[shapeType] || [];\n          } else if (attrType === 'color') {\n            if (scales.length) {\n              // 根据数值个数使用对应的色板\n              attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;\n            } else {\n              attrCfg.values = theme.colors10;\n            }\n          }\n        }\n        var AttributeCtor = getAttributeClass(attrType);\n        attributes[attrType] = new AttributeCtor(attrCfg);\n      }\n    };\n    // 遍历每一个 attrOption，各自创建 Attribute 实例\n    for (var attrType in attributeOption) {\n      var state_1 = _loop_1(attrType);\n      if (typeof state_1 === \"object\") return state_1.value;\n    }\n  };\n  // 处理数据：分组 -> 数字化 -> adjust 调整\n  Geometry.prototype.processData = function (data) {\n    var e_4, _a;\n    this.hasSorted = false;\n    var scales = this.getAttribute('position').scales;\n    var categoryScales = scales.filter(function (scale) {\n      return scale.isCategory;\n    });\n    var groupedArray = this.groupData(data); // 数据分组\n    var beforeAdjust = [];\n    for (var i = 0, len = groupedArray.length; i < len; i++) {\n      var subData = groupedArray[i];\n      var arr = [];\n      for (var j = 0, subLen = subData.length; j < subLen; j++) {\n        var originData = subData[j];\n        var item = {};\n        // tslint:disable-next-line: forin\n        for (var k in originData) {\n          item[k] = originData[k];\n        }\n        item[FIELD_ORIGIN] = originData;\n        try {\n          // 将分类数据翻译成数据, 仅对位置相关的度量进行数字化处理\n          for (var categoryScales_1 = (e_4 = void 0, __values(categoryScales)), categoryScales_1_1 = categoryScales_1.next(); !categoryScales_1_1.done; categoryScales_1_1 = categoryScales_1.next()) {\n            var scale = categoryScales_1_1.value;\n            var field = scale.field;\n            item[field] = scale.translate(item[field]);\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (categoryScales_1_1 && !categoryScales_1_1.done && (_a = categoryScales_1.return)) _a.call(categoryScales_1);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n        arr.push(item);\n      }\n      beforeAdjust.push(arr);\n    }\n    var dataArray = this.adjustData(beforeAdjust); // 进行 adjust 数据调整\n    this.beforeMappingData = dataArray;\n    return dataArray;\n  };\n  // 调整数据\n  Geometry.prototype.adjustData = function (dataArray) {\n    var adjustOption = this.adjustOption;\n    var _a = this,\n      intervalPadding = _a.intervalPadding,\n      dodgePadding = _a.dodgePadding,\n      theme = _a.theme;\n    // 兼容theme配置\n    var maxColumnWidth = this.maxColumnWidth || theme.maxColumnWidth;\n    var minColumnWidth = this.minColumnWidth || theme.minColumnWidth;\n    var columnWidthRatio = this.columnWidthRatio || theme.columnWidthRatio;\n    var result = dataArray;\n    if (adjustOption) {\n      var xScale_2 = this.getXScale();\n      var yScale = this.getYScale();\n      var xField = xScale_2.field;\n      var yField = yScale ? yScale.field : null;\n      var xDimensionLength = getXDimensionLength(this.coordinate);\n      var groupNum = xScale_2.values.length;\n      // 传入size计算相关参数，默认宽度、最大最小宽度约束\n      var sizeAttr = this.getAttribute('size');\n      var defaultSize = void 0;\n      if (sizeAttr) {\n        defaultSize = sizeAttr.values[0];\n      }\n      for (var i = 0, len = adjustOption.length; i < len; i++) {\n        var adjust = adjustOption[i];\n        var adjustCfg = __assign({\n          xField: xField,\n          yField: yField,\n          intervalPadding: intervalPadding,\n          dodgePadding: dodgePadding,\n          xDimensionLength: xDimensionLength,\n          groupNum: groupNum,\n          defaultSize: defaultSize,\n          maxColumnWidth: maxColumnWidth,\n          minColumnWidth: minColumnWidth,\n          columnWidthRatio: columnWidthRatio\n        }, adjust);\n        var type = adjust.type;\n        if (type === 'dodge') {\n          var adjustNames = [];\n          if (xScale_2.isCategory || xScale_2.type === 'identity') {\n            adjustNames.push('x');\n          } else if (!yScale) {\n            adjustNames.push('y');\n          } else {\n            throw new Error('dodge is not support linear attribute, please use category attribute!');\n          }\n          adjustCfg.adjustNames = adjustNames;\n          // 每个分组内每条柱子的宽度占比，用户不可指定，用户需要通过 columnWidthRatio 指定\n          // 兼容theme配置\n          adjustCfg.dodgeRatio = columnWidthRatio;\n        } else if (type === 'stack') {\n          var coordinate = this.coordinate;\n          if (!yScale) {\n            // 一维的情况下获取高度和默认size\n            adjustCfg.height = coordinate.getHeight();\n            var size = this.getDefaultValue('size') || 3;\n            adjustCfg.size = size;\n          }\n          // 不进行 transpose 时，用户又没有设置这个参数时，默认从上向下\n          if (!coordinate.isTransposed && isNil(adjustCfg.reverseOrder)) {\n            adjustCfg.reverseOrder = true;\n          }\n        }\n        var adjustCtor = getAdjustClass(type);\n        adjustCfg.dimValuesMap = {};\n        //生成dimValuesMap\n        if (xScale_2 && xScale_2.values) {\n          adjustCfg.dimValuesMap[xScale_2.field] = xScale_2.values.map(function (v) {\n            return xScale_2.translate(v);\n          });\n        }\n        var adjustInstance = new adjustCtor(adjustCfg);\n        result = adjustInstance.process(result);\n        this.adjusts[type] = adjustInstance;\n      }\n    }\n    return result;\n  };\n  // 对数据进行分组\n  Geometry.prototype.groupData = function (data) {\n    var groupScales = this.getGroupScales();\n    var scaleDefs = this.scaleDefs;\n    var appendConditions = {};\n    var groupFields = [];\n    for (var index = 0; index < groupScales.length; index++) {\n      var scale = groupScales[index];\n      var field = scale.field;\n      groupFields.push(field);\n      if (get(scaleDefs, [field, 'values'])) {\n        // 用户通过 view.scale() 接口指定了 values 属性\n        appendConditions[field] = scaleDefs[field].values;\n      }\n    }\n    return group(data, groupFields, appendConditions);\n  };\n  // 更新发生层叠后的数据对应的度量范围\n  Geometry.prototype.updateStackRange = function (scale, dataArray) {\n    var mergeArray = flatten(dataArray);\n    var field = scale.field;\n    var min = scale.min;\n    var max = scale.max;\n    for (var index = 0; index < mergeArray.length; index++) {\n      var obj = mergeArray[index];\n      var tmpMin = Math.min.apply(null, obj[field]);\n      var tmpMax = Math.max.apply(null, obj[field]);\n      if (tmpMin < min) {\n        min = tmpMin;\n      }\n      if (tmpMax > max) {\n        max = tmpMax;\n      }\n    }\n    var scaleDefs = this.scaleDefs;\n    var cfg = {};\n    if (min < scale.min && !get(scaleDefs, [field, 'min'])) {\n      // 用户如果在列定义中定义了 min，则以用户定义的为准\n      cfg.min = min;\n    }\n    if (max > scale.max && !get(scaleDefs, [field, 'max'])) {\n      // 用户如果在列定义中定义了 max\n      cfg.max = max;\n    }\n    scale.change(cfg);\n  };\n  // 将数据映射至图形空间前的操作：排序以及关键点的生成\n  Geometry.prototype.beforeMapping = function (beforeMappingData) {\n    // 当初加 clone 是因为 points 的引用关系，导致更新失败，可是现在貌似复现不出来了，所以暂时不进行 clone\n    // const source = clone(beforeMappingData);\n    var source = beforeMappingData;\n    if (this.sortable) {\n      this.sort(source);\n    }\n    if (this.generatePoints) {\n      // 需要生成关键点\n      for (var index = 0, length_5 = source.length; index < length_5; index++) {\n        var currentData = source[index];\n        this.generateShapePoints(currentData);\n        var nextData = source[index + 1];\n        if (nextData) {\n          this.generateShapePoints(nextData);\n          currentData[0].nextPoints = nextData[0].points;\n        }\n      }\n    }\n    return source;\n  };\n  // 生成 shape 的关键点\n  Geometry.prototype.generateShapePoints = function (data) {\n    var shapeFactory = this.getShapeFactory();\n    var shapeAttr = this.getAttribute('shape');\n    for (var index = 0; index < data.length; index++) {\n      var obj = data[index];\n      var cfg = this.createShapePointsCfg(obj);\n      var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;\n      var points = shapeFactory.getShapePoints(shape, cfg);\n      obj.points = points;\n    }\n  };\n  // 将数据归一化\n  Geometry.prototype.normalizeValues = function (values, scale) {\n    var rst = [];\n    if (isArray(values)) {\n      for (var index = 0; index < values.length; index++) {\n        var value = values[index];\n        rst.push(scale.scale(value));\n      }\n    } else {\n      rst = scale.scale(values);\n    }\n    return rst;\n  };\n  // 将数据映射至图形空间\n  Geometry.prototype.mapping = function (data) {\n    var attributes = this.attributes;\n    var mappingData = [];\n    for (var index = 0; index < data.length; index++) {\n      var record = data[index];\n      var newRecord = {\n        _origin: record[FIELD_ORIGIN],\n        points: record.points,\n        nextPoints: record.nextPoints\n      };\n      for (var k in attributes) {\n        if (attributes.hasOwnProperty(k)) {\n          var attr = attributes[k];\n          var names = attr.names;\n          var values = this.getAttributeValues(attr, record);\n          if (names.length > 1) {\n            // position 之类的生成多个字段的属性\n            for (var j = 0; j < values.length; j += 1) {\n              var val = values[j];\n              var name_1 = names[j];\n              newRecord[name_1] = isArray(val) && val.length === 1 ? val[0] : val; // 只有一个值时返回第一个属性值\n            }\n          } else {\n            // values.length === 1 的判断是以下情况，获取用户设置的图形属性值\n            // shape('a', ['dot', 'dash']), color('a', ['red', 'yellow'])\n            newRecord[names[0]] = values.length === 1 ? values[0] : values;\n          }\n        }\n      }\n      this.convertPoint(newRecord); // 将 x、y 转换成画布坐标\n      mappingData.push(newRecord);\n    }\n    return mappingData;\n  };\n  // 将归一化的坐标值转换成画布坐标\n  Geometry.prototype.convertPoint = function (mappingRecord) {\n    var x = mappingRecord.x,\n      y = mappingRecord.y;\n    var rstX;\n    var rstY;\n    var obj;\n    var coordinate = this.coordinate;\n    if (isArray(x) && isArray(y)) {\n      rstX = [];\n      rstY = [];\n      for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {\n        obj = coordinate.convert({\n          x: x[i],\n          y: y[j]\n        });\n        rstX.push(obj.x);\n        rstY.push(obj.y);\n      }\n    } else if (isArray(y)) {\n      rstY = [];\n      for (var index = 0; index < y.length; index++) {\n        var yVal = y[index];\n        obj = coordinate.convert({\n          x: x,\n          y: yVal\n        });\n        if (rstX && rstX !== obj.x) {\n          if (!isArray(rstX)) {\n            rstX = [rstX];\n          }\n          rstX.push(obj.x);\n        } else {\n          rstX = obj.x;\n        }\n        rstY.push(obj.y);\n      }\n    } else if (isArray(x)) {\n      rstX = [];\n      for (var index = 0; index < x.length; index++) {\n        var xVal = x[index];\n        obj = coordinate.convert({\n          x: xVal,\n          y: y\n        });\n        if (rstY && rstY !== obj.y) {\n          if (!isArray(rstY)) {\n            rstY = [rstY];\n          }\n          rstY.push(obj.y);\n        } else {\n          rstY = obj.y;\n        }\n        rstX.push(obj.x);\n      }\n    } else {\n      var point = coordinate.convert({\n        x: x,\n        y: y\n      });\n      rstX = point.x;\n      rstY = point.y;\n    }\n    mappingRecord.x = rstX;\n    mappingRecord.y = rstY;\n  };\n  // 获取 style 配置\n  Geometry.prototype.getStyleCfg = function (styleOption, originData) {\n    var _a = styleOption.fields,\n      fields = _a === void 0 ? [] : _a,\n      callback = styleOption.callback,\n      cfg = styleOption.cfg;\n    if (cfg) {\n      // 用户直接配置样式属性\n      return cfg;\n    }\n    var params = fields.map(function (field) {\n      return originData[field];\n    });\n    return callback.apply(void 0, __spreadArray([], __read(params), false));\n  };\n  Geometry.prototype.setCfg = function (cfg) {\n    var _this = this;\n    var coordinate = cfg.coordinate,\n      data = cfg.data,\n      theme = cfg.theme,\n      scaleDefs = cfg.scaleDefs;\n    if (coordinate) {\n      this.coordinate = coordinate;\n    }\n    if (data) {\n      this.data = data;\n    }\n    if (scaleDefs) {\n      this.scaleDefs = scaleDefs;\n      this.idFields = [];\n      each(scaleDefs, function (scaleDef, field) {\n        if (scaleDef && scaleDef.key) {\n          _this.idFields.push(field);\n        }\n      });\n    }\n    if (theme) {\n      this.theme = this.userTheme ? deepMix({}, theme, this.userTheme) : theme; // 支持 geometry 层级的主题设置\n    }\n  };\n\n  Geometry.prototype.renderLabels = function (mappingArray, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var geometryLabel, labelType, GeometryLabelsCtor, labelsMap, elementLabels, _a, _b, _c, element, labels;\n      var e_5, _d;\n      var _this = this;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            geometryLabel = this.geometryLabel;\n            this.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_RENDER_LABEL);\n            if (!geometryLabel) {\n              labelType = this.getLabelType();\n              GeometryLabelsCtor = getGeometryLabel(labelType);\n              geometryLabel = new GeometryLabelsCtor(this);\n              this.geometryLabel = geometryLabel;\n            }\n            return [4 /*yield*/, geometryLabel.render(mappingArray, isUpdate)];\n          case 1:\n            _e.sent();\n            labelsMap = geometryLabel.labelsRenderer.shapesMap;\n            elementLabels = new Map();\n            each(labelsMap, function (labelGroup, labelGroupId) {\n              var labelChildren = labelGroup.getChildren() || [];\n              for (var j = 0; j < labelChildren.length; j++) {\n                var labelShape = labelChildren[j];\n                var element = _this.elementsMap[labelShape.get('elementId') || labelGroupId.split(' ')[0]];\n                if (element) {\n                  labelShape.cfg.name = ['element', 'label'];\n                  labelShape.cfg.element = element;\n                  var labels = elementLabels.get(element) || new Set();\n                  labels.add(labelGroup);\n                  elementLabels.set(element, labels);\n                }\n              }\n            });\n            try {\n              for (_a = __values(elementLabels.entries()), _b = _a.next(); !_b.done; _b = _a.next()) {\n                _c = __read(_b.value, 2), element = _c[0], labels = _c[1];\n                element.labelShape = __spreadArray([], __read(labels), false);\n              }\n            } catch (e_5_1) {\n              e_5 = {\n                error: e_5_1\n              };\n            } finally {\n              try {\n                if (_b && !_b.done && (_d = _a.return)) _d.call(_a);\n              } finally {\n                if (e_5) throw e_5.error;\n              }\n            }\n            this.emit(GEOMETRY_LIFE_CIRCLE.AFTER_RENDER_LABEL);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * 是否需要进行群组入场动画\n   * 规则：\n   * 1. 如果发生更新，则不进行\n   * 2. 如果用户关闭 geometry 动画，则不进行\n   * 3. 如果用户关闭了 appear 动画，则不进行\n   * 4. 如果用户配置了 appear.animation，则不进行\n   */\n  Geometry.prototype.canDoGroupAnimation = function (isUpdate) {\n    return !isUpdate && this.animateOption && (get(this.animateOption, 'appear') === undefined || get(this.animateOption, 'appear') && get(this.animateOption, ['appear', 'animation']) === undefined);\n  };\n  return Geometry;\n}(Base);\nexport default Geometry;","map":{"version":3,"names":["getAdjust","getAdjustClass","getAttribute","getAttributeClass","clone","deepMix","each","flatten","get","isArray","isEmpty","isEqual","isFunction","isNil","isNumber","isObject","isPlainObject","isString","set","doGroupAppearAnimate","getDefaultAnimateCfg","Base","FIELD_ORIGIN","GEOMETRY_LIFE_CIRCLE","GROUP_ATTRS","uniq","Element","getGeometryLabel","getShapeFactory","group","isModelChange","parseFields","diff","inferScaleType","getXDimensionLength","Geometry","_super","__extends","cfg","_this","call","type","attributes","elements","elementsMap","animateOption","attributeOption","lastElementsMap","generatePoints","beforeMappingData","adjusts","idFields","hasSorted","isCoordinateChanged","container","labelsContainer","coordinate","data","_a","sortable","_b","visible","theme","_c","scales","_d","scaleDefs","intervalPadding","dodgePadding","maxColumnWidth","minColumnWidth","columnWidthRatio","roseWidthRatio","multiplePieWidthRatio","zIndexReversed","sortZIndex","useDeferredLabel","userTheme","Infinity","prototype","position","positionCfg","fields","length","unshift","color","field","createAttrOption","shape","size","adjust","adjustCfg","index","adjustOption","style","styleFunc","styleOption","callback","tooltip","tooltipOption","animate","label","secondParam","thirdParam","labelOption","state","stateOption","customInfo","customOption","init","setCfg","initAttributes","processData","adjustScale","update","isDataChanged","lastAttributeOption","paint","isUpdate","defaultSize","undefined","offscreenGroup","getOffscreenGroup","clear","dataArray","beforeMapping","Array","i","mapping","updateElements","canDoGroupAnimation","animateCfg","yScale","getYScale","yMinPoint","convert","x","y","scale","getYMinValue","deferred","renderLabels","bind","timeout","window","requestIdleCallback","setTimeout","options","__assign","changeVisible","geometryLabel","groupScales","destroy","remove","shapeFactory","getGroupScales","name","getXScale","getGroupAttributes","rst","attr","includes","push","getDefaultValue","attrName","value","values","getAttributeValues","obj","params","length_1","isIdentity","apply","__spreadArray","__read","adjustType","getCoordinate","getData","getShapeMarker","shapeName","getMarker","getElementsBy","condition","filter","element","getElements","getElementId","originData","elementId","xScale","xField","yField","yVal","xVal","id","concat","length_2","groupScale","dodgeAdjust","dodgeBy","getScaleFields","tmpMap","Map","attributeType","hasOwnProperty","eachOpt","length_3","show","hide","getFields","uniqMap","Object","forEach","fs","f","has","getGroupFields","groupFields","length_4","attributeName","getXYFields","getXField","getYField","getShapes","map","GroupCtor","getGroupBase","sort","mappingArray","xScale_1","xField_1","itemArr","obj1","obj2","translate","updateStackRange","shapeType","geometries","createShapePointsCfg","normalizeValues","y0","createElement","mappingDatum","shapeCfg","getDrawCfg","elementIndex","geometry","draw","mappingData","isInCircle","isPolar","defaultShapeType","defaultStyle","getDefaultStyle","getStyleCfg","points","nextPoints","mappingDataArray","keyDatum","keys","keyIndex","j","key","finalKey","added","updated","removed","added_1","__values","added_1_1","next","done","updated_1","updated_1_1","currentShapeCfg","preShapeCfg","getModel","removed_1","removed_1_1","getLabelType","coordinateType","isTransposed","labelType","min","max","attrCfg","attrType","option","inferedScaleType","sizes","shapes","colors10","colors20","AttributeCtor","categoryScales","isCategory","groupedArray","groupData","beforeAdjust","len","subData","arr","subLen","item","k","categoryScales_1","e_4","categoryScales_1_1","adjustData","result","xScale_2","xDimensionLength","groupNum","sizeAttr","adjustNames","Error","dodgeRatio","height","getHeight","reverseOrder","adjustCtor","dimValuesMap","v","adjustInstance","process","appendConditions","mergeArray","tmpMin","Math","tmpMax","change","source","length_5","currentData","generateShapePoints","nextData","shapeAttr","getShapePoints","record","newRecord","_origin","names","val","name_1","convertPoint","mappingRecord","rstX","rstY","xLen","yLen","point","scaleDef","emit","BEFORE_RENDER_LABEL","GeometryLabelsCtor","render","_e","sent","labelsMap","labelsRenderer","shapesMap","elementLabels","labelGroup","labelGroupId","labelChildren","getChildren","labelShape","split","labels","Set","add","entries","AFTER_RENDER_LABEL"],"sources":["../../src/geometry/base.ts"],"sourcesContent":["import { Adjust, getAdjust as getAdjustClass } from '@antv/adjust';\nimport { Attribute, getAttribute as getAttributeClass } from '@antv/attr';\nimport {\n  clone,\n  deepMix,\n  each,\n  flatten,\n  get,\n  isArray,\n  isEmpty,\n  isEqual,\n  isFunction,\n  isNil,\n  isNumber,\n  isObject,\n  isPlainObject,\n  isString,\n  set,\n} from '@antv/util';\nimport { doGroupAppearAnimate, getDefaultAnimateCfg } from '../animate';\nimport Base from '../base';\nimport { FIELD_ORIGIN, GEOMETRY_LIFE_CIRCLE, GROUP_ATTRS } from '../constant';\nimport { BBox, Coordinate, IGroup, IShape, Scale } from '../dependents';\nimport {\n  AdjustOption,\n  AdjustType,\n  AnimateOption,\n  AttributeOption,\n  ColorAttrCallback,\n  Data,\n  Datum,\n  GeometryLabelCfg,\n  GeometryTooltipOption,\n  LabelCallback,\n  LabelOption,\n  LooseObject,\n  MappingDatum,\n  ScaleOption,\n  ShapeAttrCallback,\n  ShapeFactory,\n  ShapeInfo,\n  ShapeMarkerCfg,\n  ShapeMarkerAttrs,\n  ShapePoint,\n  SizeAttrCallback,\n  StateOption,\n  StyleCallback,\n  StyleOption,\n  TooltipCallback,\n  CustomOption,\n} from '../interface';\nimport { uniq } from '../util/helper';\nimport Element from './element';\nimport { getGeometryLabel } from './label';\nimport GeometryLabel from './label/base';\nimport { getShapeFactory } from './shape/base';\nimport { group } from './util/group-data';\nimport { isModelChange } from './util/is-model-change';\nimport { parseFields } from './util/parse-fields';\nimport { diff } from './util/diff';\nimport { inferScaleType } from '../util/scale';\nimport { getXDimensionLength } from '../util/coordinate';\n\n/** @ignore */\ninterface AttributeInstanceCfg {\n  fields?: string[];\n  callback?: (...args) => any;\n  values?: string[] | number[];\n  scales?: Scale[];\n}\ninterface DimValuesMapType {\n  [dim: string]: number[];\n}\n/** @ignore */\ninterface AdjustInstanceCfg {\n  type: AdjustType;\n  adjustNames?: string[];\n  xField?: string;\n  yField?: string;\n\n  dodgeBy?: string;\n  marginRatio?: number;\n  dodgeRatio?: number;\n\n  size?: number;\n  height?: number;\n  reverseOrder?: boolean;\n\n  /** 像素级柱间宽度，调整offset */\n  intervalPadding?: number;\n  dodgePadding?: number;\n  /** x维度长度，计算归一化padding使用 */\n  xDimensionLength?: number;\n  /** 分组数，计算offset */\n  groupNum?: number;\n  /** 用户配置宽度 size */\n  defaultSize?: number;\n  /** 最大最小宽度约束 */\n  maxColumnWidth?: number;\n  minColumnWidth?: number;\n  /** 柱宽比例 */\n  columnWidthRatio?: number;\n  /** 用户自定义的dimValuesMap */\n  dimValuesMap?: DimValuesMapType;\n}\n\n/** geometry.init() 传入参数 */\nexport interface InitCfg {\n  /** 坐标系 */\n  coordinate?: Coordinate;\n  /** 数据 */\n  data?: Data;\n  /** 主题对象 */\n  theme?: LooseObject;\n  /** 列定义 */\n  scaleDefs?: Record<string, ScaleOption>;\n  /** 因为数据使用的引用，所以需要有一个标识位标识数据是否发生了更新 */\n  isDataChanged?: boolean;\n  isCoordinateChanged?: boolean;\n}\n\n/** Geometry 构造函数参数 */\nexport interface GeometryCfg {\n  /** Geometry shape 的容器。 */\n  container: IGroup;\n  /** 绘制的坐标系对象。 */\n  coordinate?: Coordinate;\n  /** 绘制数据。 */\n  data?: Data;\n  /** 需要的 scales。 */\n  scales?: Record<string, Scale>;\n  /** 列定义 */\n  scaleDefs?: Record<string, ScaleOption>;\n  /** Geometry labels 的容器 */\n  labelsContainer?: IGroup;\n  /** 是否对数据进行排序 */\n  sortable?: boolean;\n  /** elements 的 zIndex 默认按顺序提升，通过 zIndexReversed 可以反序，从而数据越前，层级越高 */\n  zIndexReversed?: boolean;\n  /** 是否需要对 zIndex 进行 sort。因为耗时长，由具体场景自行决定 */\n  sortZIndex?: boolean;\n  /** 延迟渲染 Geometry 数据标签. 设置为 true 时，会在浏览器空闲时期被调用, 也可以指定具体 timeout 时间 */\n  useDeferredLabel?: boolean | number;\n  /** 是否可见 */\n  visible?: boolean;\n  /** 主题配置 */\n  theme?: LooseObject;\n\n  /** 组间距 */\n  intervalPadding?: number;\n  /** 组内间距 */\n  dodgePadding?: number;\n  /** 柱状图最大宽度 */\n  maxColumnWidth?: number;\n  /** 柱状图最小宽度 */\n  minColumnWidth?: number;\n  /** 默认宽度占比，interval类型和schema类型通用 */\n  columnWidthRatio?: number;\n  /** 玫瑰图占比 */\n  roseWidthRatio?: number;\n  /** 多层饼图/环图占比 */\n  multiplePieWidthRatio?: number;\n}\n\n/**\n * Geometry 几何标记基类，主要负责数据到图形属性的映射以及绘制逻辑。\n */\nexport default class Geometry<S extends ShapePoint = ShapePoint> extends Base {\n  /** Geometry 几何标记类型。 */\n  public readonly type: string = 'base';\n  /** ShapeFactory 对应的类型。 */\n  public readonly shapeType: string;\n\n  // 在创建 Geometry 实例时可以传入的属性\n  /** Coordinate 坐标系实例。 */\n  public coordinate: Coordinate;\n  /** 用户绘制数据。 */\n  public data: Data;\n  /** 图形绘制容器。 */\n  public readonly container: IGroup;\n  /** label 绘制容器。 */\n  public readonly labelsContainer: IGroup;\n  /** 是否对数据进行排序，默认为 false。  */\n  public sortable: boolean;\n  /** 当前 Geometry 实例主题。  */\n  public theme: LooseObject;\n  /** 存储 geometry 需要的 scales，需要外部传入。 */\n  public scales: Record<string, Scale>;\n  /** scale 定义，需要外部传入。 */\n  public scaleDefs: Record<string, ScaleOption>;\n  /** 画布区域，用于 label 布局。 */\n  public canvasRegion: BBox;\n\n  // 内部产生的属性\n  /** Attribute map  */\n  public attributes: Record<string, Attribute> = {};\n  /** Element map */\n  public elements: Element[] = [];\n  /**\n   * 存储处理后的数据，\n   * + init() 及 updateData() 逻辑后, 结构为 Data[]；\n   * + paint() 逻辑后，结构为 MappingDatum[][]。\n   */\n  public dataArray: MappingDatum[][];\n  /** 存储 tooltip 配置信息。 */\n  public tooltipOption: GeometryTooltipOption | boolean;\n  /** 存储 label 配置信息。 */\n  public labelOption: LabelOption | false;\n  /** 状态量相关的配置项 */\n  public stateOption: StateOption;\n  /** 使用 key-value 结构存储 Element，key 为每个 Element 实例对应的唯一 ID */\n  public elementsMap: Record<string, Element> = {};\n  /** animate 配置项 */\n  public animateOption: AnimateOption | boolean = true;\n  /** 图形属性映射配置 */\n  protected attributeOption: Record<string, AttributeOption> = {};\n  /** adjust 配置项 */\n  protected adjustOption: AdjustOption[];\n  /** style 配置项 */\n  protected styleOption: StyleOption;\n  /** custom 自定义的配置项 */\n  protected customOption: CustomOption;\n  /** 每个 Geometry 对应的 Shape 工厂实例，用于创建各个 Shape */\n  protected shapeFactory: ShapeFactory;\n  /** 存储上一次渲染时的 element 映射表，用于更新逻辑 */\n  protected lastElementsMap: Record<string, Element> = {};\n  /** 是否生成多个点来绘制图形。 */\n  protected generatePoints: boolean = false;\n  /** 存储发生图形属性映射前的数据 */\n  protected beforeMappingData: Data[] = null;\n  /** 存储每个 shape 的默认 size，用于 Interval、Schema 几何标记 */\n  protected defaultSize: number;\n\n  // 用户通过 geometry 构造函数设置的主题\n  private userTheme: LooseObject;\n  private adjusts: Record<string, Adjust> = {};\n  private lastAttributeOption;\n  private idFields: string[] = [];\n  private geometryLabel: GeometryLabel;\n\n  // 柱状图间距相关配置\n  /** 组间距 */\n  protected intervalPadding: number;\n  /** 组内间距 */\n  protected dodgePadding: number;\n  /** 柱状图最大宽度 */\n  protected maxColumnWidth: number;\n  /** 柱状图最小宽度 */\n  protected minColumnWidth: number;\n  /** 一般柱状图宽度占比 */\n  protected columnWidthRatio: number;\n  /** 玫瑰图占比 */\n  protected roseWidthRatio: number;\n  /** 多层饼图/环图占比 */\n  protected multiplePieWidthRatio: number;\n  /** elements 的 zIndex 默认按顺序提升，通过 zIndexReversed 可以反序，从而数据越前，层级越高 */\n  public zIndexReversed?: boolean;\n  /** 是否需要对 zIndex 进行 sort。因为耗时长，由具体场景自行决定 */\n  public sortZIndex?: boolean;\n  protected useDeferredLabel?: null | number;\n\n  /** 虚拟 Group，用于图形更新 */\n  private offscreenGroup: IGroup;\n  private groupScales: Scale[];\n  private hasSorted: boolean = false;\n  protected isCoordinateChanged: boolean = false;\n\n  /**\n   * 创建 Geometry 实例。\n   * @param cfg\n   */\n  constructor(cfg: GeometryCfg) {\n    super(cfg);\n\n    const {\n      container,\n      labelsContainer,\n      coordinate,\n      data,\n      sortable = false,\n      visible = true,\n      theme,\n      scales = {},\n      scaleDefs = {},\n      // 柱状图间隔与宽度相关配置\n      intervalPadding,\n      dodgePadding,\n      maxColumnWidth,\n      minColumnWidth,\n      columnWidthRatio,\n      roseWidthRatio,\n      multiplePieWidthRatio,\n      zIndexReversed,\n      sortZIndex,\n      useDeferredLabel,\n    } = cfg;\n\n    this.container = container;\n    this.labelsContainer = labelsContainer;\n    this.coordinate = coordinate;\n    this.data = data;\n    this.sortable = sortable;\n    this.visible = visible;\n    this.userTheme = theme;\n    this.scales = scales;\n    this.scaleDefs = scaleDefs;\n    // 柱状图间隔与宽度相关配置\n    this.intervalPadding = intervalPadding;\n    this.dodgePadding = dodgePadding;\n    this.maxColumnWidth = maxColumnWidth;\n    this.minColumnWidth = minColumnWidth;\n    this.columnWidthRatio = columnWidthRatio;\n    this.roseWidthRatio = roseWidthRatio;\n    this.multiplePieWidthRatio = multiplePieWidthRatio;\n    this.zIndexReversed = zIndexReversed;\n    this.sortZIndex = sortZIndex;\n    this.useDeferredLabel = useDeferredLabel ? (typeof useDeferredLabel === 'number' ? useDeferredLabel : Infinity) : null;\n  }\n\n  /**\n   * 配置 position 通道映射规则。\n   *\n   * @example\n   * ```typescript\n   * // 数据结构: [{ x: 'A', y: 10, color: 'red' }]\n   * geometry.position('x*y');\n   * geometry.position([ 'x', 'y' ]);\n   * geometry.position({\n   *   fields: [ 'x', 'y' ],\n   * });\n   * ```\n   *\n   * @param cfg 映射规则\n   * @returns\n   */\n  public position(cfg: string | string[] | AttributeOption): Geometry {\n    let positionCfg = cfg;\n    if (!isPlainObject(cfg)) {\n      // 字符串字段或者数组字段\n      positionCfg = {\n        fields: parseFields(cfg),\n      };\n    }\n\n    const fields = get(positionCfg, 'fields');\n    if (fields.length === 1) {\n      // 默认填充一维 1*xx\n      fields.unshift('1');\n      set(positionCfg, 'fields', fields);\n    }\n    set(this.attributeOption, 'position', positionCfg);\n\n    return this;\n  }\n\n  /**\n   * 配置 color 通道映射规则。\n   *\n   * @example\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   * geometry.color({\n   *   fields: [ 'x' ],\n   *   values: [ '#1890ff', '#5AD8A6' ],\n   * });\n   * ```\n   *\n   * @param field 映射规则\n   * @returns\n   */\n  public color(field: AttributeOption): Geometry;\n  /**\n   * @example\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   *\n   * // 使用 '#1890ff' 颜色渲染图形\n   * geometry.color('#1890ff');\n   *\n   * // 根据 x 字段的数据值进行颜色的映射，这时候 G2 会在内部调用默认的回调函数，读取默认提供的颜色进行数据值到颜色值的映射。\n   * geometry.color('x');\n   *\n   * // 将 'x' 字段的数据值映射至指定的颜色值 colors（可以是字符串也可以是数组），此时用于通常映射分类数据\n   * geometry.color('x', [ '#1890ff', '#5AD8A6' ]);\n   *\n   * // 使用回调函数进行颜色值的自定义；可以使用多个字段使用、*号连接\n   * geometry.color('x', (xVal) => {\n   *   if (xVal === 'a') {\n   *     return 'red';\n   *   }\n   *   return 'blue';\n   * });\n   *\n   * // 指定颜色的渐变路径，用于映射连续的数据\n   * geometry.color('x', '#BAE7FF-#1890FF-#0050B3');\n   * ```\n   *\n   * @param field 参与颜色映射的数据字段，多个字段使用 '*' 连接符进行连接。\n   * @param cfg Optional, color 映射规则。\n   * @returns\n   */\n  public color(field: string, cfg?: string | string[] | ColorAttrCallback): Geometry;\n  public color(field: AttributeOption | string, cfg?: string | string[] | ColorAttrCallback): Geometry {\n    this.createAttrOption('color', field, cfg);\n\n    return this;\n  }\n\n  /**\n   * 配置 shape 通道映射规则。\n   *\n   * @example\n   *\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   * geometry.shape({\n   *   fields: [ 'x' ],\n   * });\n   * ```\n   *\n   * @param field 映射规则配置。\n   * @returns\n   */\n  public shape(field: AttributeOption): Geometry;\n  /**\n   *\n   * @example\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   *\n   * // 指定常量，将所有数据值映射到固定的 shape\n   * geometry.shape('circle');\n   *\n   * // 将指定的字段映射到内置的 shapes 数组中\n   * geometry.shape('x');\n   *\n   * // 将指定的字段映射到指定的 shapes 数组中\n   * geometry.shape('x', [ 'circle', 'diamond', 'square' ]);\n   *\n   * // 使用回调函数获取 shape，用于个性化的 shape 定制，可以根据单个或者多个字段确定\n   * geometry.shape('x', (xVal) => {\n   *   if (xVal === 'a') {\n   *     return 'circle';\n   *   }\n   *   return 'diamond';\n   * });\n   * ```\n   *\n   * @param field 参与 shape 映射的数据字段，多个字段使用 '*' 连接符进行连接。\n   * @param cfg Optional, shape 映射规则。\n   * @returns\n   */\n  public shape(field: string, cfg?: string[] | ShapeAttrCallback): Geometry;\n  public shape(field: AttributeOption | string, cfg?: string[] | ShapeAttrCallback): Geometry {\n    this.createAttrOption('shape', field, cfg);\n\n    return this;\n  }\n\n  /**\n   * 配置 size 通道映射规则。\n   *\n   * @example\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   * geometry.size({\n   *   values: [ 10 ],\n   * })\n   * ```\n   *\n   * @param field 映射规则。\n   * @returns\n   */\n  public size(field: AttributeOption): Geometry;\n  /**\n   *\n   * @example\n   * ```typescript\n   * // data: [{ x: 'A', y: 10, color: 'red' }, { x: 'B', y: 30, color: 'yellow' }]\n   *\n   * // 直接指定像素大小\n   * geometry.size(10);\n   *\n   * // 指定映射到 size 的字段，使用内置的默认大小范围为 [1, 10]\n   * geometry.size('x');\n   *\n   * // 指定映射到 size 字段外，还提供了 size 的最大值和最小值范围\n   * geometry.size('x', [ 5, 30 ]);\n   *\n   * // 使用回调函数映射 size，用于个性化的 size 定制，可以使用多个字段进行映射\n   * geometry.size('x', (xVal) => {\n   *   if (xVal === 'a') {\n   *     return 10;\n   *   }\n   *   return 5;\n   * });\n   * ```\n   *\n   * @param field 参与 size 映射的数据字段，多个字段使用 '*' 连接符进行连接。\n   * @param cfg Optional, size 映射规则\n   * @returns\n   */\n  public size(field: number | string, cfg?: [number, number] | SizeAttrCallback): Geometry;\n  public size(field: AttributeOption | number | string, cfg?: [number, number] | SizeAttrCallback): Geometry {\n    this.createAttrOption('size', field, cfg);\n\n    return this;\n  }\n\n  /**\n   * 设置数据调整方式。G2 目前内置了四种类型：\n   * 1. dodge\n   * 2. stack\n   * 3. symmetric\n   * 4. jitter\n   *\n   *\n   * **Tip**\n   * + 对于 'dodge' 类型，可以额外进行如下属性的配置:\n   * ```typescript\n   * geometry.adjust('dodge', {\n   *   marginRatio: 0, // 取 0 到 1 范围的值（相对于每个柱子宽度），用于控制一个分组中柱子之间的间距\n   *   dodgeBy: 'x', // 该属性只对 'dodge' 类型生效，声明以哪个数据字段为分组依据\n   * });\n   * ```\n   *\n   * + 对于 'stack' 类型，可以额外进行如下属性的配置:\n   * ```typescript\n   * geometry.adjust('stack', {\n   *   reverseOrder: false, // 用于控制是否对数据进行反序操作\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * geometry.adjust('stack');\n   *\n   * geometry.adjust({\n   *   type: 'stack',\n   *   reverseOrder: false,\n   * });\n   *\n   * // 组合使用 adjust\n   * geometry.adjust([ 'stack', 'dodge' ]);\n   *\n   * geometry.adjust([\n   *   { type: 'stack' },\n   *   { type: 'dodge', dodgeBy: 'x' },\n   * ]);\n   * ```\n   *\n   * @param adjustCfg 数据调整配置\n   * @returns\n   */\n  public adjust(adjustCfg: string | string[] | AdjustOption | AdjustOption[]): Geometry {\n    let adjusts: any = adjustCfg;\n    if (isString(adjustCfg) || isPlainObject(adjustCfg)) {\n      adjusts = [adjustCfg];\n    }\n    each(adjusts, (adjust, index) => {\n      if (!isObject(adjust)) {\n        adjusts[index] = { type: adjust };\n      }\n    });\n\n    this.adjustOption = adjusts;\n    return this;\n  }\n\n  /**\n   * 图形样式配置。\n   *\n   * @example\n   * ```typescript\n   * // 配置图形样式\n   * style({\n   *   lineWidth: 2,\n   *   stroke: '#1890ff',\n   * });\n   *\n   * // 根据具体的数据进行详细配置\n   * style({\n   *   fields: [ 'x', 'y' ], // 数据字段\n   *   callback: (xVal, yVal) => {\n   *     const style = { lineWidth: 2, stroke: '#1890ff' };\n   *     if (xVal === 'a') {\n   *       style.lineDash = [ 2, 2 ];\n   *     }\n   *     return style;\n   *   },\n   * });\n   * ```\n   *\n   * @param field 配置样式属性或者样式规则。\n   * @returns\n   */\n  public style(field: StyleOption | LooseObject): Geometry;\n  /**\n   * @example\n   * ```typescript\n   * style('x*y', (xVal, yVal) => {\n   *   const style = { lineWidth: 2, stroke: '#1890ff' };\n   *   if (xVal === 'a') {\n   *     style.lineDash = [ 2, 2 ];\n   *   }\n   *   return style;\n   * });\n   * ```\n   *\n   * @param field 数据字段或者样式配置规则。\n   * @param styleFunc Optional, 样式配置回调函数。\n   * @returns\n   */\n  public style(field: string, styleFunc: StyleCallback): Geometry;\n  public style(field: StyleOption | LooseObject | string, styleFunc?: StyleCallback): Geometry {\n    if (isString(field)) {\n      const fields = parseFields(field);\n      this.styleOption = {\n        fields,\n        callback: styleFunc,\n      };\n    } else {\n      const { fields, callback, cfg } = field as StyleOption;\n      if (fields || callback || cfg) {\n        this.styleOption = field;\n      } else {\n        this.styleOption = {\n          cfg: field,\n        };\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * 配置 Geometry 显示的 tooltip 内容。\n   *\n   * `tooltip(false)` 代表关闭 tooltip。\n   * `tooltip(true)` 代表开启 tooltip。\n   *\n   * Geometry 默认允许 tooltip 展示，我们可以使用以下方法对 tooltip 的展示内容进行配置：\n   *\n   * @example\n   * ```typescript\n   * // data: [{x: 'a', y: 10}]\n   * tooltip({\n   *   fields: [ 'x' ],\n   * });\n   * ```\n   * ![](https://gw.alipayobjects.com/mdn/rms_2274c3/afts/img/A*268uQ50if60AAAAAAAAAAABkARQnAQ)\n   *\n   * ```typescript\n   * tooltip({\n   *   fields: [ 'x', 'y' ],\n   * });\n   * ```\n   * ![](https://gw.alipayobjects.com/mdn/rms_2274c3/afts/img/A*A_ujSa8QhtcAAAAAAAAAAABkARQnAQ)\n   *\n   * tooltip() 方法同样支持数据映射及回调用法：\n   *\n   * @example\n   * ```typescript\n   * chart.tooltip({\n   *   itemTpl: '<li>{x}: {y}</li>',\n   * });\n   *\n   * chart.line()\n   *   .position('x*y')\n   *   .tooltip({\n   *     fields: [ 'x', 'y' ],\n   *     callback: (x, y) => {\n   *       return {\n   *         x,\n   *         y,\n   *       };\n   *     },\n   *   });\n   * ```\n   *\n   * 其返回的值必须为对象，该值中的属性同 chart.tooltip() 的 itemTpl 模板相对应，返回的变量可用于 itemTpl 的字符串模板。\n   *\n   * @param field tooltip 配置信息。\n   * @returns\n   */\n  public tooltip(field: GeometryTooltipOption | boolean): Geometry;\n  /**\n   * @example\n   * ```typescript\n   * // data: [{x: 'a', y: 10}]\n   *\n   * // 等同于 tooltip({ fields: [ 'x' ] })\n   * tooltip('x');\n   *\n   * // 等同于 tooltip({ fields: [ 'x', 'y' ] })\n   * tooltip('x*y');\n   *\n   * // 等同于 tooltip({ fields: [ 'x', 'y' ], callback: (x, y) => { x, y } })\n   * tooltip('x*y', (x, y) => {\n   *   return {\n   *     x,\n   *     y,\n   *   };\n   * });\n   * ```\n   *\n   * @param field 参与映射的字段。\n   * @param cfg Optional, 回调函数\n   * @returns\n   */\n  public tooltip(field: string, cfg?: TooltipCallback): Geometry;\n  public tooltip(field: GeometryTooltipOption | boolean | string, cfg?: TooltipCallback): Geometry {\n    if (isString(field)) {\n      const fields = parseFields(field);\n      this.tooltipOption = {\n        fields,\n        callback: cfg,\n      };\n    } else {\n      this.tooltipOption = field;\n    }\n\n    return this;\n  }\n\n  /**\n   * Geometry 动画配置。\n   *\n   * + `animate(false)` 关闭动画\n   * + `animate(true)` 开启动画，默认开启。\n   *\n   * 我们将动画分为四个场景：\n   * 1. appear: 图表第一次加载时的入场动画；\n   * 2. enter: 图表绘制完成，发生更新后，产生的新图形的进场动画；\n   * 3. update: 图表绘制完成，数据发生变更后，有状态变更的图形的更新动画；\n   * 4. leave: 图表绘制完成，数据发生变更后，被销毁图形的销毁动画。\n   *\n   * @example\n   * ```typescript\n   * animate({\n   *   enter: {\n   *     duration: 1000, // enter 动画执行时间\n   *   },\n   *   leave: false, // 关闭 leave 销毁动画\n   * });\n   * ```\n   *\n   * @param cfg 动画配置\n   * @returns\n   */\n  public animate(cfg: AnimateOption | boolean): Geometry {\n    this.animateOption = cfg;\n    return this;\n  }\n\n  /**\n   * Geometry label 配置。\n   *\n   * @example\n   * ```ts\n   * // data: [ {x: 1, y: 2, z: 'a'}, {x: 2, y: 2, z: 'b'} ]\n   * // 在每个图形上显示 z 字段对应的数值\n   * label({\n   *   fields: [ 'z' ]\n   * });\n   *\n   * label(false); // 不展示 label\n   *\n   * // 在每个图形上显示 x 字段对应的数值，同时配置文本颜色为红色\n   * label('x', {\n   *   style: {\n   *     fill: 'red',\n   *   },\n   * })\n   *\n   * // 以 type 类型的 label 渲染每个图形上显示 x 字段对应的数值，同时格式化文本内容\n   * label('x', (xValue) => {\n   *   return {\n   *     content: xValue + '%',\n   *   };\n   * }, {\n   *   type: 'base' // 声明 label 类型\n   * })\n   * ```\n   *\n   * @param field\n   * @returns label\n   */\n  public label(field: LabelOption | false | string): Geometry;\n  public label(field: string, secondParam: GeometryLabelCfg | LabelCallback): Geometry;\n  public label(field: string, secondParam: LabelCallback, thirdParam: GeometryLabelCfg): Geometry;\n  public label(\n    field: string | LabelOption | false,\n    secondParam?: GeometryLabelCfg | LabelCallback,\n    thirdParam?: GeometryLabelCfg\n  ): Geometry {\n    if (isString(field)) {\n      const labelOption: LabelOption = {};\n      const fields = parseFields(field);\n      labelOption.fields = fields;\n      if (isFunction(secondParam)) {\n        labelOption.callback = secondParam;\n      } else if (isPlainObject(secondParam)) {\n        labelOption.cfg = secondParam;\n      }\n\n      if (thirdParam) {\n        labelOption.cfg = thirdParam;\n      }\n      this.labelOption = labelOption;\n    } else {\n      this.labelOption = field;\n    }\n\n    return this;\n  }\n\n  /**\n   * 设置状态对应的样式。\n   *\n   * @example\n   * ```ts\n   * chart.interval().state({\n   *   selected: {\n   *     animate: { duration: 100, easing: 'easeLinear' },\n   *     style: {\n   *       lineWidth: 2,\n   *       stroke: '#000',\n   *     },\n   *   },\n   * });\n   * ```\n   *\n   * 如果图形 shape 是由多个 shape 组成，即为一个 G.Group 对象，那么针对 group 中的每个 shape，我们需要使用下列方式进行状态样式设置：\n   * 如果我们为 group 中的每个 shape 设置了 'name' 属性(shape.set('name', 'xx'))，则以 'name' 作为 key，否则默认以索引值（即 shape 的 添加顺序）为 key。\n   *\n   * ```ts\n   * chart.interval().shape('groupShape').state({\n   *   selected: {\n   *     style: {\n   *       0: { lineWidth: 2 },\n   *       1: { fillOpacity: 1 },\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * @param cfg 状态样式\n   */\n  public state(cfg: StateOption) {\n    this.stateOption = cfg;\n    return this;\n  }\n\n  /**\n   * 用于向 shape 中传入自定义的数据。目前可能仅仅可能用于在自定义 shape 的时候，像自定义 shape 中传入自定义的数据，方便实现自定义 shape 的配置能力。\n   *\n   * @example\n   * ```ts\n   * chart.interval().customInfo({ yourData: 'hello, g2!' });\n   * ```\n   *\n   * 然后在自定义 shape 的时候，可以拿到这个信息。\n   *\n   * ```ts\n   * registerShape('interval', 'your-shape', {\n   *   draw(shapeInfo, container) {\n   *     const { customInfo } = shapeInfo;\n   *     console.log(customInfo); // will log { yourData: 'hello, g2!' }.\n   *   }\n   * });\n   * ```\n   *\n   * @param cfg\n   */\n  public customInfo(cfg: any) {\n    this.customOption = cfg;\n    return this;\n  }\n\n  /**\n   * 初始化 Geomtry 实例：\n   * 创建 [[Attribute]] and [[Scale]] 实例，进行数据处理，包括分组、数值化以及数据调整。\n   */\n  public init(cfg: InitCfg = {}) {\n    this.setCfg(cfg);\n    this.initAttributes(); // 创建图形属性\n\n    // 数据加工：分组 -> 数字化 -> adjust\n    this.processData(this.data);\n\n    // 调整 scale\n    this.adjustScale();\n  }\n\n  /**\n   * Geometry 更新。\n   * @param [cfg] 更新的配置\n   */\n  public update(cfg: InitCfg = {}) {\n    const { data, isDataChanged, isCoordinateChanged } = cfg;\n    const { attributeOption, lastAttributeOption } = this;\n\n    if (!isEqual(attributeOption, lastAttributeOption)) {\n      // 映射发生改变，则重新创建图形属性\n      this.init(cfg);\n    } else if (data && (isDataChanged || !isEqual(data, this.data))) {\n      // 数据发生变化\n      this.setCfg(cfg);\n      this.initAttributes(); // 创建图形属性\n      this.processData(data); // 数据加工：分组 -> 数字化 -> adjust\n    } else {\n      // 有可能 coordinate 变化\n      this.setCfg(cfg);\n    }\n\n    // 调整 scale\n    this.adjustScale();\n    this.isCoordinateChanged = isCoordinateChanged;\n  }\n\n  /**\n   * 将原始数据映射至图形空间，同时创建图形对象。\n   */\n  public paint(isUpdate: boolean = false) {\n    if (this.animateOption) {\n      this.animateOption = deepMix({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);\n    }\n\n    this.defaultSize = undefined;\n    this.elementsMap = {};\n    this.elements = [];\n    const offscreenGroup = this.getOffscreenGroup();\n    offscreenGroup.clear();\n\n    const beforeMappingData = this.beforeMappingData;\n    const dataArray = this.beforeMapping(beforeMappingData);\n\n    this.dataArray = new Array(dataArray.length);\n    for (let i = 0; i < dataArray.length; i++) {\n      const data = dataArray[i];\n      this.dataArray[i] = this.mapping(data);\n    }\n    this.updateElements(this.dataArray, isUpdate);\n    this.lastElementsMap = this.elementsMap;\n\n    if (this.canDoGroupAnimation(isUpdate)) {\n      // 如果用户没有配置 appear.animation，就默认走整体动画\n      const container = this.container;\n      const type = this.type;\n      const coordinate = this.coordinate;\n      const animateCfg = get(this.animateOption, 'appear');\n      const yScale = this.getYScale();\n      const yMinPoint = coordinate.convert({\n        x: 0,\n        y: yScale.scale(this.getYMinValue()),\n      });\n      doGroupAppearAnimate(container, animateCfg, type, coordinate, yMinPoint);\n    }\n\n    // 添加 label\n    if (this.labelOption) {\n      const deferred = this.useDeferredLabel;\n      const callback = (() => this.renderLabels(flatten(this.dataArray) as unknown as MappingDatum[], isUpdate)).bind(this);\n      if (typeof deferred === 'number') {\n        // Use `requestIdleCallback` to render labels in idle time (like react fiber)\n        const timeout = (typeof deferred === 'number' && deferred !== Infinity) ? deferred : 0;\n        if (!window.requestIdleCallback) {\n          setTimeout(callback, timeout);\n        } else {\n          const options = timeout && timeout !== Infinity ? { timeout } : undefined;\n          window.requestIdleCallback(callback, options);\n        }\n      } else {\n        callback();\n      }\n    }\n\n    // 缓存，用于更新\n    this.lastAttributeOption = {\n      ...this.attributeOption,\n    };\n\n    if (this.visible === false) {\n      // 用户在初始化的时候声明 visible: false\n      this.changeVisible(false);\n    }\n  }\n\n  /**\n   * 清空当前 Geometry，配置项仍保留，但是内部创建的对象全部清空。\n   * @override\n   */\n  public clear() {\n    const { container, geometryLabel, offscreenGroup } = this;\n    if (container) {\n      container.clear();\n    }\n\n    if (geometryLabel) {\n      geometryLabel.clear();\n    }\n\n    if (offscreenGroup) {\n      offscreenGroup.clear();\n    }\n\n    // 属性恢复至出厂状态\n    this.scaleDefs = undefined;\n    this.attributes = {};\n    this.scales = {};\n    this.elementsMap = {};\n    this.lastElementsMap = {};\n    this.elements = [];\n    this.adjusts = {};\n    this.dataArray = null;\n    this.beforeMappingData = null;\n    this.lastAttributeOption = undefined;\n    this.defaultSize = undefined;\n    this.idFields = [];\n    this.groupScales = undefined;\n    this.hasSorted = false;\n    this.isCoordinateChanged = false;\n  }\n\n  /**\n   * 销毁 Geometry 实例。\n   */\n  public destroy() {\n    this.clear();\n    const container = this.container;\n    container.remove(true);\n\n    if (this.offscreenGroup) {\n      this.offscreenGroup.remove(true);\n      this.offscreenGroup = null;\n    }\n\n    if (this.geometryLabel) {\n      this.geometryLabel.destroy();\n      this.geometryLabel = null;\n    }\n    this.theme = undefined;\n    this.shapeFactory = undefined;\n\n    super.destroy();\n  }\n\n  /**\n   * 获取决定分组的图形属性对应的 scale 实例。\n   * @returns\n   */\n  public getGroupScales(): Scale[] {\n    return this.groupScales;\n  }\n\n  /**\n   * 根据名字获取图形属性实例。\n   */\n  public getAttribute(name: string): Attribute {\n    return this.attributes[name];\n  }\n\n  /** 获取 x 轴对应的 scale 实例。 */\n  public getXScale(): Scale {\n    return this.getAttribute('position').scales[0];\n  }\n\n  /** 获取 y 轴对应的 scale 实例。 */\n  public getYScale(): Scale {\n    return this.getAttribute('position').scales[1];\n  }\n\n  /**\n   * 获取决定分组的图形属性实例。\n   */\n  public getGroupAttributes(): Attribute[] {\n    const rst = [];\n    each(this.attributes, (attr: Attribute) => {\n      if (GROUP_ATTRS.includes(attr.type)) {\n        rst.push(attr);\n      }\n    });\n    return rst;\n  }\n\n  /** 获取图形属性默认的映射值。 */\n  public getDefaultValue(attrName: string) {\n    let value: any;\n    const attr = this.getAttribute(attrName);\n    if (attr && isEmpty(attr.scales)) {\n      // 获取映射至常量的值\n      value = attr.values[0];\n    }\n    return value;\n  }\n\n  /**\n   * 获取该数据发生图形映射后对应的 Attribute 图形空间数据。\n   * @param attr Attribute 图形属性实例。\n   * @param obj 需要进行映射的原始数据。\n   * @returns\n   */\n  public getAttributeValues(attr: Attribute, obj: Datum) {\n    const params = [];\n    const scales = attr.scales;\n    for (let index = 0, length = scales.length; index < length; index++) {\n      const scale = scales[index];\n      const field = scale.field;\n      if (scale.isIdentity) {\n        params.push(scale.values);\n      } else {\n        params.push(obj[field]);\n      }\n    }\n\n    return attr.mapping(...params);\n  }\n\n  /**\n   * 获取对应的 adjust 实例\n   * @param adjustType\n   * @returns\n   */\n  public getAdjust(adjustType: string) {\n    return this.adjusts[adjustType];\n  }\n\n  /**\n   * 获得 coordinate 实例\n   * @returns\n   */\n  public getCoordinate() {\n    return this.coordinate;\n  }\n\n  public getData() {\n    return this.data;\n  }\n\n  /**\n   * 获取 shape 对应的 marker 样式。\n   * @param shapeName shape 具体名字\n   * @param cfg marker 信息\n   * @returns\n   */\n  public getShapeMarker(shapeName: string, cfg: ShapeMarkerCfg): ShapeMarkerAttrs {\n    const shapeFactory = this.getShapeFactory();\n    return shapeFactory.getMarker(shapeName, cfg);\n  }\n\n  /**\n   * 根据一定的规则查找 Geometry 的 Elements。\n   *\n   * ```typescript\n   * getElementsBy((element) => {\n   *   const data = element.getData();\n   *\n   *   return data.a === 'a';\n   * });\n   * ```\n   *\n   * @param condition 定义查找规则的回调函数。\n   * @returns\n   */\n  public getElementsBy(condition: (element: Element) => boolean): Element[] {\n    return this.elements.filter((element) => condition(element));\n  }\n\n  /**\n   * 获取 Geometry 的所有 Elements。\n   *\n   * ```typescript\n   * getElements();\n   * ```\n   */\n  public getElements() {\n    return this.elements;\n  }\n\n  /**\n   * 获取数据对应的唯一 id。\n   * @param data Element 对应的绘制数据\n   * @returns\n   */\n  public getElementId(data: MappingDatum | MappingDatum[]) {\n    data = isArray(data) ? data[0] : data;\n    const originData = data[FIELD_ORIGIN];\n\n    // 如果用户声明了使用哪些字段作为 id 值\n    if (this.idFields.length) {\n      let elementId = originData[this.idFields[0]];\n      for (let index = 1; index < this.idFields.length; index++) {\n        elementId += '-' + originData[this.idFields[index]];\n      }\n\n      return elementId;\n    }\n\n    const type = this.type;\n    const xScale = this.getXScale();\n    const yScale = this.getYScale();\n    const xField = xScale.field || 'x';\n    const yField = yScale.field || 'y';\n    const yVal = originData[yField];\n    let xVal;\n    if (xScale.type === 'identity') {\n      xVal = xScale.values[0];\n    } else {\n      xVal = originData[xField];\n    }\n\n    let id: string;\n    if (type === 'interval' || type === 'schema') {\n      id = `${xVal}`;\n    } else if (type === 'line' || type === 'area' || type === 'path') {\n      id = type;\n    } else {\n      id = `${xVal}-${yVal}`;\n    }\n\n    const groupScales = this.groupScales;\n\n    for (let index = 0, length = groupScales.length; index < length; index++) {\n      const groupScale = groupScales[index];\n      const field = groupScale.field;\n      id = `${id}-${originData[field]}`;\n    }\n\n    // 用户在进行 dodge 类型的 adjust 调整的时候设置了 dodgeBy 属性\n    const dodgeAdjust = this.getAdjust('dodge');\n    if (dodgeAdjust) {\n      const dodgeBy = dodgeAdjust.dodgeBy;\n      if (dodgeBy) {\n        id = `${id}-${originData[dodgeBy]}`;\n      }\n    }\n\n    if (this.getAdjust('jitter')) {\n      id = `${id}-${data.x}-${data.y}`;\n    }\n\n    return id;\n  }\n\n  /**\n   * 获取所有需要创建 scale 的字段名称。\n   */\n  public getScaleFields(): string[] {\n    const fields = [];\n    const tmpMap = new Map();\n    const { attributeOption, labelOption, tooltipOption } = this;\n    // 获取图形属性上的 fields\n    for (const attributeType in attributeOption) {\n      if (attributeOption.hasOwnProperty(attributeType)) {\n        const eachOpt = attributeOption[attributeType];\n        if (eachOpt.fields) {\n          uniq(eachOpt.fields, fields, tmpMap);\n        } else if (eachOpt.values) {\n          // 考虑 size(10), shape('circle') 等场景\n          uniq(eachOpt.values, fields, tmpMap);\n        }\n      }\n    }\n    // 获取 label 上的字段\n    if (labelOption && labelOption.fields) {\n      uniq(labelOption.fields, fields, tmpMap);\n    }\n\n    // 获取 tooltip 上的字段\n    if (isObject(tooltipOption) && tooltipOption.fields) {\n      uniq(tooltipOption.fields, fields, tmpMap);\n    }\n\n    return fields;\n  }\n\n  /**\n   * 显示或者隐藏 geometry。\n   * @param visible\n   */\n  public changeVisible(visible: boolean) {\n    super.changeVisible(visible);\n    const elements = this.elements;\n    for (let index = 0, length = elements.length; index < length; index++) {\n      const element = elements[index];\n      element.changeVisible(visible);\n    }\n    if (visible) {\n      if (this.container) {\n        this.container.show();\n      }\n      if (this.labelsContainer) {\n        this.labelsContainer.show();\n      }\n    } else {\n      if (this.container) {\n        this.container.hide();\n      }\n      if (this.labelsContainer) {\n        this.labelsContainer.hide();\n      }\n    }\n  }\n\n  /**\n   * 获得所有的字段\n   */\n  public getFields() {\n    const uniqMap = new Map<string, boolean>();\n    const fields = [];\n\n    Object.values(this.attributeOption).forEach((cfg) => {\n      const fs = cfg?.fields || [];\n      fs.forEach((f) => {\n        if (!uniqMap.has(f)) {\n          fields.push(f);\n        }\n        uniqMap.set(f, true);\n      });\n    }, []);\n\n    return fields;\n  }\n\n  /**\n   * 获取当前配置中的所有分组 & 分类的字段。\n   * @return fields string[]\n   */\n  public getGroupFields(): string[] {\n    const groupFields = [];\n    const tmpMap = new Map(); // 用于去重过滤\n    for (let index = 0, length = GROUP_ATTRS.length; index < length; index++) {\n      const attributeName = GROUP_ATTRS[index];\n      const cfg = this.attributeOption[attributeName];\n      if (cfg && cfg.fields) {\n        uniq(cfg.fields, groupFields, tmpMap);\n      }\n    }\n\n    return groupFields;\n  }\n\n  /**\n   * 获得图形的 x y 字段。\n   */\n  public getXYFields() {\n    const [x, y] = this.attributeOption.position.fields;\n    return [x, y];\n  }\n\n  /**\n   * x 字段\n   * @returns\n   */\n  public getXField(): string {\n    return get(this.getXYFields(), [0]);\n  }\n\n  /**\n   * y 字段\n   * @returns\n   */\n  public getYField(): string {\n    return get(this.getXYFields(), [1]);\n  }\n\n  /**\n   * 获取该 Geometry 下所有生成的 shapes。\n   * @returns shapes\n   */\n  public getShapes(): (IShape | IGroup)[] {\n    return this.elements.map((element: Element) => element.shape);\n  }\n\n  /**\n   * 获取虚拟 Group。\n   * @returns\n   */\n  public getOffscreenGroup() {\n    if (!this.offscreenGroup) {\n      const GroupCtor = this.container.getGroupBase(); // 获取分组的构造函数\n      this.offscreenGroup = new GroupCtor({});\n    }\n    return this.offscreenGroup;\n  }\n\n  // 对数据进行排序\n  public sort(mappingArray: Data[]) {\n    if (!this.hasSorted) {\n      // 未发生过排序\n      const xScale = this.getXScale();\n      const xField = xScale.field;\n      for (let index = 0; index < mappingArray.length; index++) {\n        const itemArr = mappingArray[index];\n        itemArr.sort((obj1: Datum, obj2: Datum) => {\n          return xScale.translate(obj1[FIELD_ORIGIN][xField]) - xScale.translate(obj2[FIELD_ORIGIN][xField]);\n        });\n      }\n    }\n\n    this.hasSorted = true;\n  }\n\n  /**\n   * 调整度量范围。主要针对发生层叠以及一些特殊需求的 Geometry，比如 Interval 下的柱状图 Y 轴默认从 0 开始。\n   */\n  protected adjustScale() {\n    const yScale = this.getYScale();\n    // 如果数据发生过 stack adjust，需要调整下 yScale 的数据范围\n    if (yScale && this.getAdjust('stack')) {\n      this.updateStackRange(yScale, this.beforeMappingData);\n    }\n  }\n\n  /**\n   * 获取当前 Geometry 对应的 Shape 工厂实例。\n   */\n  protected getShapeFactory() {\n    const shapeType = this.shapeType;\n    if (!getShapeFactory(shapeType)) {\n      return;\n    }\n    if (!this.shapeFactory) {\n      this.shapeFactory = clone(getShapeFactory(shapeType)); // 防止多个 view 共享一个 shapeFactory 实例，导致 coordinate 被篡改\n    }\n    // 因为这里缓存了 shapeFactory，但是外部可能会变更 coordinate，导致无法重新设置到 shapeFactory 中\n    this.shapeFactory.coordinate = this.coordinate;\n    // theme 原因同上\n    this.shapeFactory.theme = this.theme.geometries[shapeType] || {};\n\n    return this.shapeFactory;\n  }\n\n  /**\n   * 获取每个 Shape 对应的关键点数据。\n   * @param obj 经过分组 -> 数字化 -> adjust 调整后的数据记录\n   * @returns\n   */\n  protected createShapePointsCfg(obj: Datum): S {\n    const xScale = this.getXScale();\n    const yScale = this.getYScale();\n    const x = this.normalizeValues(obj[xScale.field], xScale);\n    let y; // 存在没有 y 的情况\n\n    if (yScale) {\n      y = this.normalizeValues(obj[yScale.field], yScale);\n    } else {\n      y = obj.y ? obj.y : 0.1;\n    }\n\n    return {\n      x,\n      y,\n      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined,\n    } as S;\n  }\n\n  /**\n   * 创建 Element 实例。\n   * @param mappingDatum Element 对应的绘制数据\n   * @param [isUpdate] 是否处于更新阶段\n   * @returns element 返回创建的 Element 实例\n   */\n  protected createElement(mappingDatum: MappingDatum, index: number, isUpdate: boolean = false): Element {\n    const { container } = this;\n\n    const shapeCfg = this.getDrawCfg(mappingDatum); // 获取绘制图形的配置信息\n    const shapeFactory = this.getShapeFactory();\n\n    const element = new Element({\n      shapeFactory,\n      container,\n      offscreenGroup: this.getOffscreenGroup(),\n      elementIndex: index,\n    });\n    element.animate = this.animateOption;\n    element.geometry = this;\n    element.draw(shapeCfg, isUpdate); // 绘制\n\n    return element;\n  }\n\n  /**\n   * 获取每条数据对应的图形绘制数据。\n   * @param mappingDatum 映射后的数据\n   * @returns draw cfg\n   */\n  protected getDrawCfg(mappingDatum: MappingDatum): ShapeInfo {\n    const originData = mappingDatum[FIELD_ORIGIN]; // 原始数据\n    const cfg: ShapeInfo = {\n      mappingData: mappingDatum, // 映射后的数据\n      data: originData, // 原始数据\n      x: mappingDatum.x,\n      y: mappingDatum.y,\n      color: mappingDatum.color,\n      size: mappingDatum.size,\n      isInCircle: this.coordinate.isPolar,\n      customInfo: this.customOption,\n    };\n\n    let shapeName = mappingDatum.shape;\n    if (!shapeName && this.getShapeFactory()) {\n      shapeName = this.getShapeFactory().defaultShapeType;\n    }\n    cfg.shape = shapeName;\n    // 获取默认样式\n    const theme = this.theme.geometries[this.shapeType];\n    cfg.defaultStyle = get(theme, [shapeName, 'default'], {}).style;\n    if (!cfg.defaultStyle && this.getShapeFactory()) {\n      cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme);\n    }\n\n    const styleOption = this.styleOption;\n    if (styleOption) {\n      cfg.style = this.getStyleCfg(styleOption, originData);\n    }\n    if (this.generatePoints) {\n      cfg.points = mappingDatum.points;\n      cfg.nextPoints = mappingDatum.nextPoints;\n    }\n\n    return cfg;\n  }\n\n  protected updateElements(mappingDataArray: MappingDatum[][], isUpdate: boolean = false): void {\n    const keyDatum = new Map<string, MappingDatum>();\n    const keys: string[] = [];\n\n    // 用来保持 diff 元素之后 added, updated 的相对顺序\n    const keyIndex = new Map<string, number>();\n    let index = 0;\n\n    // 获得更新数据所有的 keys\n    // 将更新的数据用 key 索引\n    for (let i = 0; i < mappingDataArray.length; i++) {\n      const mappingData = mappingDataArray[i];\n      for (let j = 0; j < mappingData.length; j++) {\n        const mappingDatum = mappingData[j];\n        const key = this.getElementId(mappingDatum);\n        const finalKey = keyDatum.has(key) ? `${key}-${i}-${j}` : key;\n        keys.push(finalKey);\n        keyDatum.set(finalKey, mappingDatum);\n        keyIndex.set(finalKey, index);\n        index++;\n      }\n    }\n\n    this.elements = new Array(index);\n\n    const { added, updated, removed } = diff(this.lastElementsMap, keys);\n\n    // 新建 element\n    for (const key of added) {\n      const mappingDatum = keyDatum.get(key);\n      const i = keyIndex.get(key);\n      const element = this.createElement(mappingDatum, i, isUpdate);\n      this.elements[i] = element;\n      this.elementsMap[key] = element;\n      if (element.shape) {\n        element.shape.set('zIndex', this.zIndexReversed ? this.elements.length - i : i);\n      }\n    }\n\n    // 更新 element\n    for (const key of updated) {\n      const element = this.lastElementsMap[key];\n      const mappingDatum = keyDatum.get(key);\n      const currentShapeCfg = this.getDrawCfg(mappingDatum);\n      const preShapeCfg = element.getModel();\n      const i = keyIndex.get(key);\n      if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {\n        element.animate = this.animateOption;\n        // 通过绘制数据的变更来判断是否需要更新，因为用户有可能会修改图形属性映射\n        element.update(currentShapeCfg); // 更新对应的 element\n      }\n      this.elements[i] = element;\n      this.elementsMap[key] = element;\n      if (element.shape) {\n        element.shape.set('zIndex', this.zIndexReversed ? this.elements.length - i : i);\n      }\n    }\n\n    // 全部 setZIndex 之后，再执行 sort\n    if (this.container) {\n      this.container.sort();\n    }\n\n    // 销毁被删除的 elements\n    for (const key of removed) {\n      const element = this.lastElementsMap[key];\n      // 更新动画配置，用户有可能在更新之前有对动画进行配置操作\n      element.animate = this.animateOption;\n      element.destroy();\n    }\n  }\n\n  /**\n   * 获取渲染的 label 类型。\n   */\n  protected getLabelType(): string {\n    const { labelOption, coordinate, type } = this;\n    const { type: coordinateType, isTransposed } = coordinate;\n    let labelType = get(labelOption, ['cfg', 'type']);\n    if (!labelType) {\n      // 用户未定义，则进行默认的逻辑\n      if (coordinateType === 'polar') {\n        // 极坐标下使用通用的极坐标文本，转置则使用饼图\n        labelType = isTransposed ? 'pie' : 'polar';\n      } else if (coordinateType === 'theta') {\n        // theta 坐标系下使用饼图文本\n        labelType = 'pie';\n      } else if (type === 'interval' || type === 'polygon') {\n        labelType = 'interval';\n      } else {\n        labelType = 'base';\n      }\n    }\n\n    return labelType;\n  }\n\n  /**\n   * 获取 Y 轴上的最小值。\n   */\n  protected getYMinValue(): number {\n    const yScale = this.getYScale();\n    const { min, max } = yScale;\n    let value: number;\n\n    if (min >= 0) {\n      value = min;\n    } else if (max <= 0) {\n      // 当值全位于负区间时，需要保证 ymin 在区域内，不可为 0\n      value = max;\n    } else {\n      value = 0;\n    }\n    return value;\n  }\n\n  // 创建图形属性相关的配置项\n  protected createAttrOption(attrName: string, field: AttributeOption | string | number, cfg?) {\n    if (isNil(field) || isObject(field)) {\n      if (isObject(field) && isEqual(Object.keys(field), ['values'])) {\n        // shape({ values: [ 'funnel' ] })\n        set(this.attributeOption, attrName, {\n          fields: field.values,\n        });\n      } else {\n        set(this.attributeOption, attrName, field);\n      }\n    } else {\n      const attrCfg: AttributeOption = {};\n      if (isNumber(field)) {\n        // size(3)\n        attrCfg.values = [field];\n      } else {\n        attrCfg.fields = parseFields(field);\n      }\n\n      if (cfg) {\n        if (isFunction(cfg)) {\n          attrCfg.callback = cfg;\n        } else {\n          attrCfg.values = cfg;\n        }\n      }\n\n      set(this.attributeOption, attrName, attrCfg);\n    }\n  }\n\n  protected initAttributes() {\n    const { attributes, attributeOption, theme, shapeType } = this;\n    this.groupScales = [];\n    const tmpMap = {};\n\n    // 遍历每一个 attrOption，各自创建 Attribute 实例\n    for (const attrType in attributeOption) {\n      if (attributeOption.hasOwnProperty(attrType)) {\n        const option: AttributeOption = attributeOption[attrType];\n        if (!option) {\n          return;\n        }\n        const attrCfg: AttributeInstanceCfg = {\n          ...option,\n        };\n        const { callback, values, fields = [] } = attrCfg;\n\n        // 获取每一个字段对应的 scale\n        const scales = fields.map((field) => {\n          const scale = this.scales[field];\n          if (!tmpMap[field] && GROUP_ATTRS.includes(attrType)) {\n            const inferedScaleType = inferScaleType(scale, get(this.scaleDefs, field), attrType, this.type);\n            if (inferedScaleType === 'cat') {\n              this.groupScales.push(scale);\n              tmpMap[field] = true;\n            }\n          }\n          return scale;\n        });\n\n        attrCfg.scales = scales;\n\n        if (attrType !== 'position' && scales.length === 1 && scales[0].type === 'identity') {\n          // 用户在图形通道上声明了常量字段 color('red'), size(5)\n          attrCfg.values = scales[0].values;\n        } else if (!callback && !values) {\n          // 用户没有指定任何规则，则使用默认的映射规则\n          if (attrType === 'size') {\n            attrCfg.values = theme.sizes;\n          } else if (attrType === 'shape') {\n            attrCfg.values = theme.shapes[shapeType] || [];\n          } else if (attrType === 'color') {\n            if (scales.length) {\n              // 根据数值个数使用对应的色板\n              attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;\n            } else {\n              attrCfg.values = theme.colors10;\n            }\n          }\n        }\n        const AttributeCtor = getAttributeClass(attrType);\n        attributes[attrType] = new AttributeCtor(attrCfg);\n      }\n    }\n  }\n\n  // 处理数据：分组 -> 数字化 -> adjust 调整\n  private processData(data: Data) {\n    this.hasSorted = false;\n    const { scales } = this.getAttribute('position');\n    const categoryScales = scales.filter((scale: Scale) => scale.isCategory);\n\n    const groupedArray = this.groupData(data); // 数据分组\n    const beforeAdjust = [];\n    for (let i = 0, len = groupedArray.length; i < len; i++) {\n      const subData = groupedArray[i];\n      const arr = [];\n      for (let j = 0, subLen = subData.length; j < subLen; j++) {\n        const originData = subData[j];\n        const item = {};\n        // tslint:disable-next-line: forin\n        for (const k in originData) {\n          item[k] = originData[k];\n        }\n        item[FIELD_ORIGIN] = originData;\n\n        // 将分类数据翻译成数据, 仅对位置相关的度量进行数字化处理\n        for (const scale of categoryScales) {\n          const field = scale.field;\n          item[field] = scale.translate(item[field]);\n        }\n        arr.push(item);\n      }\n      beforeAdjust.push(arr);\n    }\n\n    const dataArray = this.adjustData(beforeAdjust); // 进行 adjust 数据调整\n    this.beforeMappingData = dataArray;\n\n    return dataArray;\n  }\n\n  // 调整数据\n  private adjustData(dataArray: Data[]): Data[] {\n    const adjustOption = this.adjustOption;\n    const { intervalPadding, dodgePadding, theme } = this;\n    // 兼容theme配置\n    const maxColumnWidth = this.maxColumnWidth || theme.maxColumnWidth;\n    const minColumnWidth = this.minColumnWidth || theme.minColumnWidth;\n    const columnWidthRatio = this.columnWidthRatio || theme.columnWidthRatio;\n    let result = dataArray;\n\n    if (adjustOption) {\n      const xScale = this.getXScale();\n      const yScale = this.getYScale();\n      const xField = xScale.field;\n      const yField = yScale ? yScale.field : null;\n      const xDimensionLength = getXDimensionLength(this.coordinate);\n      const groupNum = xScale.values.length;\n      // 传入size计算相关参数，默认宽度、最大最小宽度约束\n      const sizeAttr = this.getAttribute('size');\n      let defaultSize;\n      if (sizeAttr) {\n        defaultSize = sizeAttr.values[0];\n      }\n      for (let i = 0, len = adjustOption.length; i < len; i++) {\n        const adjust = adjustOption[i];\n        const adjustCfg: AdjustInstanceCfg = {\n          xField,\n          yField,\n          intervalPadding,\n          dodgePadding,\n          xDimensionLength,\n          groupNum,\n          defaultSize,\n          maxColumnWidth,\n          minColumnWidth,\n          columnWidthRatio,\n          ...adjust,\n        };\n        const type = adjust.type;\n        if (type === 'dodge') {\n          const adjustNames = [];\n          if (xScale.isCategory || xScale.type === 'identity') {\n            adjustNames.push('x');\n          } else if (!yScale) {\n            adjustNames.push('y');\n          } else {\n            throw new Error('dodge is not support linear attribute, please use category attribute!');\n          }\n          adjustCfg.adjustNames = adjustNames;\n          // 每个分组内每条柱子的宽度占比，用户不可指定，用户需要通过 columnWidthRatio 指定\n          // 兼容theme配置\n          adjustCfg.dodgeRatio = columnWidthRatio;\n        } else if (type === 'stack') {\n          const coordinate = this.coordinate;\n          if (!yScale) {\n            // 一维的情况下获取高度和默认size\n            adjustCfg.height = coordinate.getHeight();\n            const size = this.getDefaultValue('size') || 3;\n            adjustCfg.size = size;\n          }\n          // 不进行 transpose 时，用户又没有设置这个参数时，默认从上向下\n          if (!coordinate.isTransposed && isNil(adjustCfg.reverseOrder)) {\n            adjustCfg.reverseOrder = true;\n          }\n        }\n        const adjustCtor = getAdjustClass(type);\n        adjustCfg.dimValuesMap = {};\n        //生成dimValuesMap\n        if (xScale && xScale.values) {\n          adjustCfg.dimValuesMap[xScale.field] = xScale.values.map((v) => xScale.translate(v));\n        }\n        const adjustInstance = new adjustCtor(adjustCfg);\n\n        result = adjustInstance.process(result);\n\n        this.adjusts[type] = adjustInstance;\n      }\n    }\n\n    return result;\n  }\n\n  // 对数据进行分组\n  private groupData(data: Data): Data[] {\n    const groupScales = this.getGroupScales();\n    const scaleDefs = this.scaleDefs;\n    const appendConditions = {};\n    const groupFields = [];\n    for (let index = 0; index < groupScales.length; index++) {\n      const scale = groupScales[index];\n      const field = scale.field;\n      groupFields.push(field);\n      if (get(scaleDefs, [field, 'values'])) {\n        // 用户通过 view.scale() 接口指定了 values 属性\n        appendConditions[field] = scaleDefs[field].values;\n      }\n    }\n\n    return group(data, groupFields, appendConditions);\n  }\n\n  // 更新发生层叠后的数据对应的度量范围\n  private updateStackRange(scale: Scale, dataArray: Data[]) {\n    const mergeArray = flatten(dataArray);\n    const field = scale.field;\n    let min = scale.min;\n    let max = scale.max;\n    for (let index = 0; index < mergeArray.length; index++) {\n      const obj = mergeArray[index];\n      const tmpMin = Math.min.apply(null, obj[field]);\n      const tmpMax = Math.max.apply(null, obj[field]);\n      if (tmpMin < min) {\n        min = tmpMin;\n      }\n      if (tmpMax > max) {\n        max = tmpMax;\n      }\n    }\n    const scaleDefs = this.scaleDefs;\n    const cfg: LooseObject = {};\n    if (min < scale.min && !get(scaleDefs, [field, 'min'])) {\n      // 用户如果在列定义中定义了 min，则以用户定义的为准\n      cfg.min = min;\n    }\n    if (max > scale.max && !get(scaleDefs, [field, 'max'])) {\n      // 用户如果在列定义中定义了 max\n      cfg.max = max;\n    }\n\n    scale.change(cfg);\n  }\n\n  // 将数据映射至图形空间前的操作：排序以及关键点的生成\n  private beforeMapping(beforeMappingData: Data[]) {\n    // 当初加 clone 是因为 points 的引用关系，导致更新失败，可是现在貌似复现不出来了，所以暂时不进行 clone\n    // const source = clone(beforeMappingData);\n    const source = beforeMappingData;\n    if (this.sortable) {\n      this.sort(source);\n    }\n    if (this.generatePoints) {\n      // 需要生成关键点\n      for (let index = 0, length = source.length; index < length; index++) {\n        const currentData = source[index];\n        this.generateShapePoints(currentData);\n        const nextData = source[index + 1];\n        if (nextData) {\n          this.generateShapePoints(nextData);\n          currentData[0].nextPoints = nextData[0].points;\n        }\n      }\n    }\n\n    return source;\n  }\n\n  // 生成 shape 的关键点\n  private generateShapePoints(data: Data) {\n    const shapeFactory = this.getShapeFactory();\n    const shapeAttr = this.getAttribute('shape');\n    for (let index = 0; index < data.length; index++) {\n      const obj = data[index];\n      const cfg = this.createShapePointsCfg(obj);\n      const shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;\n      const points = shapeFactory.getShapePoints(shape, cfg);\n      obj.points = points;\n    }\n  }\n\n  // 将数据归一化\n  private normalizeValues(values, scale) {\n    let rst = [];\n    if (isArray(values)) {\n      for (let index = 0; index < values.length; index++) {\n        const value = values[index];\n        rst.push(scale.scale(value));\n      }\n    } else {\n      rst = scale.scale(values);\n    }\n    return rst;\n  }\n\n  // 将数据映射至图形空间\n  private mapping(data: Data): MappingDatum[] {\n    const attributes = this.attributes;\n    const mappingData = [];\n    for (let index = 0; index < data.length; index++) {\n      const record = data[index];\n      const newRecord: MappingDatum = {\n        _origin: record[FIELD_ORIGIN],\n        points: record.points,\n        nextPoints: record.nextPoints,\n      };\n      for (const k in attributes) {\n        if (attributes.hasOwnProperty(k)) {\n          const attr = attributes[k];\n          const names = attr.names;\n          const values = this.getAttributeValues(attr, record);\n          if (names.length > 1) {\n            // position 之类的生成多个字段的属性\n            for (let j = 0; j < values.length; j += 1) {\n              const val = values[j];\n              const name = names[j];\n              newRecord[name] = isArray(val) && val.length === 1 ? val[0] : val; // 只有一个值时返回第一个属性值\n            }\n          } else {\n            // values.length === 1 的判断是以下情况，获取用户设置的图形属性值\n            // shape('a', ['dot', 'dash']), color('a', ['red', 'yellow'])\n            newRecord[names[0]] = values.length === 1 ? values[0] : values;\n          }\n        }\n      }\n\n      this.convertPoint(newRecord); // 将 x、y 转换成画布坐标\n      mappingData.push(newRecord);\n    }\n\n    return mappingData;\n  }\n\n  // 将归一化的坐标值转换成画布坐标\n  private convertPoint(mappingRecord: MappingDatum) {\n    const { x, y } = mappingRecord;\n\n    let rstX;\n    let rstY;\n    let obj;\n    const coordinate = this.coordinate;\n    if (isArray(x) && isArray(y)) {\n      rstX = [];\n      rstY = [];\n      for (let i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {\n        obj = coordinate.convert({\n          x: x[i],\n          y: y[j],\n        });\n        rstX.push(obj.x);\n        rstY.push(obj.y);\n      }\n    } else if (isArray(y)) {\n      rstY = [];\n      for (let index = 0; index < y.length; index++) {\n        const yVal = y[index];\n        obj = coordinate.convert({\n          x: x as number,\n          y: yVal,\n        });\n        if (rstX && rstX !== obj.x) {\n          if (!isArray(rstX)) {\n            rstX = [rstX];\n          }\n          rstX.push(obj.x);\n        } else {\n          rstX = obj.x;\n        }\n        rstY.push(obj.y);\n      }\n    } else if (isArray(x)) {\n      rstX = [];\n      for (let index = 0; index < x.length; index++) {\n        const xVal = x[index];\n        obj = coordinate.convert({\n          x: xVal,\n          y,\n        });\n        if (rstY && rstY !== obj.y) {\n          if (!isArray(rstY)) {\n            rstY = [rstY];\n          }\n          rstY.push(obj.y);\n        } else {\n          rstY = obj.y;\n        }\n        rstX.push(obj.x);\n      }\n    } else {\n      const point = coordinate.convert({\n        x,\n        y,\n      });\n      rstX = point.x;\n      rstY = point.y;\n    }\n    mappingRecord.x = rstX;\n    mappingRecord.y = rstY;\n  }\n\n  // 获取 style 配置\n  private getStyleCfg(styleOption: StyleOption, originData: Datum) {\n    const { fields = [], callback, cfg } = styleOption;\n    if (cfg) {\n      // 用户直接配置样式属性\n      return cfg;\n    }\n\n    const params = fields.map((field) => {\n      return originData[field];\n    });\n\n    return callback(...params);\n  }\n\n  private setCfg(cfg: InitCfg) {\n    const { coordinate, data, theme, scaleDefs } = cfg;\n    if (coordinate) {\n      this.coordinate = coordinate;\n    }\n    if (data) {\n      this.data = data;\n    }\n    if (scaleDefs) {\n      this.scaleDefs = scaleDefs;\n      this.idFields = [];\n      each(scaleDefs, (scaleDef, field) => {\n        if (scaleDef && scaleDef.key) {\n          this.idFields.push(field);\n        }\n      });\n    }\n    if (theme) {\n      this.theme = this.userTheme ? deepMix({}, theme, this.userTheme) : theme; // 支持 geometry 层级的主题设置\n    }\n  }\n\n  private async renderLabels(mappingArray: MappingDatum[], isUpdate: boolean = false) {\n    let geometryLabel = this.geometryLabel;\n\n    this.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_RENDER_LABEL);\n\n    if (!geometryLabel) {\n      // 初次创建\n      const labelType = this.getLabelType();\n      const GeometryLabelsCtor = getGeometryLabel(labelType);\n      geometryLabel = new GeometryLabelsCtor(this);\n      this.geometryLabel = geometryLabel;\n    }\n    await geometryLabel.render(mappingArray, isUpdate);\n\n    // 将 label 同 element 进行关联\n    const labelsMap = geometryLabel.labelsRenderer.shapesMap;\n    // Store labels for every element.\n    const elementLabels = new Map<Element, Set<IGroup>>();\n    each(labelsMap, (labelGroup: IGroup, labelGroupId: string) => {\n      const labelChildren = labelGroup.getChildren() || [];\n      for (let j = 0; j < labelChildren.length; j++) {\n        const labelShape = labelChildren[j];\n        const element = this.elementsMap[labelShape.get('elementId') || labelGroupId.split(' ')[0]];\n        if (element) {\n          labelShape.cfg.name = ['element', 'label'];\n          labelShape.cfg.element = element;\n          const labels = elementLabels.get(element) || new Set();\n          labels.add(labelGroup);\n          elementLabels.set(element, labels);\n        }\n      }\n    });\n    for (const [element, labels] of elementLabels.entries()) {\n      element.labelShape = [...labels];\n    }\n\n    this.emit(GEOMETRY_LIFE_CIRCLE.AFTER_RENDER_LABEL);\n  }\n  /**\n   * 是否需要进行群组入场动画\n   * 规则：\n   * 1. 如果发生更新，则不进行\n   * 2. 如果用户关闭 geometry 动画，则不进行\n   * 3. 如果用户关闭了 appear 动画，则不进行\n   * 4. 如果用户配置了 appear.animation，则不进行\n   */\n  private canDoGroupAnimation(isUpdate: boolean) {\n    return (\n      !isUpdate &&\n      this.animateOption &&\n      (get(this.animateOption, 'appear') === undefined ||\n        (get(this.animateOption, 'appear') && get(this.animateOption, ['appear', 'animation']) === undefined))\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}