{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { arcLineAtOffset } from \"./arc\";\nimport { greatCircleLineAtOffset } from \"./greatCircle\";\nimport { pathLineAtOffset } from \"./line\";\nexport function lineAtOffset(source, option) {\n  var featureId = option.featureId;\n  var features = source.data.dataArray;\n  if (typeof featureId === 'number') {\n    features = features.filter(function (_ref) {\n      var id = _ref.id;\n      return id === featureId;\n    });\n  }\n  return features.map(function (feature) {\n    var position = getLineOffsetPosition(feature, option);\n    return _objectSpread(_objectSpread({}, feature), position);\n  });\n}\nexport function lineAtOffsetAsyc(source, option) {\n  return new Promise(function (resolve) {\n    if (source.inited) {\n      resolve(lineAtOffset(source, option));\n    } else {\n      source.once('update', function () {\n        resolve(lineAtOffset(source, option));\n      });\n    }\n  });\n}\nfunction getLineOffsetPosition(feature, option) {\n  var offset = option.offset,\n    shape = option.shape,\n    thetaOffset = option.thetaOffset,\n    mapVersion = option.mapVersion,\n    _option$segmentNumber = option.segmentNumber,\n    segmentNumber = _option$segmentNumber === void 0 ? 30 : _option$segmentNumber,\n    _option$autoFit = option.autoFit,\n    autoFit = _option$autoFit === void 0 ? true : _option$autoFit;\n  var coordinates = feature.coordinates;\n  if (shape === 'line') {\n    return pathLineAtOffset(coordinates, offset);\n  }\n  var source = coordinates[0];\n  var target = coordinates[1];\n  var linetheatOffset = typeof thetaOffset === 'string' ? feature[thetaOffset] || 0 : thetaOffset;\n  var calFunc;\n  switch (shape) {\n    case 'arc':\n      calFunc = arcLineAtOffset;\n      break;\n    case 'greatcircle':\n      calFunc = greatCircleLineAtOffset;\n      break;\n    default:\n      calFunc = arcLineAtOffset;\n  }\n  var _calFunc = calFunc(source, target, offset, linetheatOffset, mapVersion, segmentNumber, autoFit),\n    _calFunc2 = _slicedToArray(_calFunc, 3),\n    lng = _calFunc2[0],\n    lat = _calFunc2[1],\n    height = _calFunc2[2];\n  return {\n    lng: lng,\n    lat: lat,\n    height: height\n  };\n}","map":{"version":3,"names":["_slicedToArray","_objectSpread","arcLineAtOffset","greatCircleLineAtOffset","pathLineAtOffset","lineAtOffset","source","option","featureId","features","data","dataArray","filter","_ref","id","map","feature","position","getLineOffsetPosition","lineAtOffsetAsyc","Promise","resolve","inited","once","offset","shape","thetaOffset","mapVersion","_option$segmentNumber","segmentNumber","_option$autoFit","autoFit","coordinates","target","linetheatOffset","calFunc","_calFunc","_calFunc2","lng","lat","height"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-utils/es/lineAtOffset/index.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { arcLineAtOffset } from \"./arc\";\nimport { greatCircleLineAtOffset } from \"./greatCircle\";\nimport { pathLineAtOffset } from \"./line\";\nexport function lineAtOffset(source, option) {\n  var featureId = option.featureId;\n  var features = source.data.dataArray;\n  if (typeof featureId === 'number') {\n    features = features.filter(function (_ref) {\n      var id = _ref.id;\n      return id === featureId;\n    });\n  }\n  return features.map(function (feature) {\n    var position = getLineOffsetPosition(feature, option);\n    return _objectSpread(_objectSpread({}, feature), position);\n  });\n}\nexport function lineAtOffsetAsyc(source, option) {\n  return new Promise(function (resolve) {\n    if (source.inited) {\n      resolve(lineAtOffset(source, option));\n    } else {\n      source.once('update', function () {\n        resolve(lineAtOffset(source, option));\n      });\n    }\n  });\n}\nfunction getLineOffsetPosition(feature, option) {\n  var offset = option.offset,\n    shape = option.shape,\n    thetaOffset = option.thetaOffset,\n    mapVersion = option.mapVersion,\n    _option$segmentNumber = option.segmentNumber,\n    segmentNumber = _option$segmentNumber === void 0 ? 30 : _option$segmentNumber,\n    _option$autoFit = option.autoFit,\n    autoFit = _option$autoFit === void 0 ? true : _option$autoFit;\n  var coordinates = feature.coordinates;\n  if (shape === 'line') {\n    return pathLineAtOffset(coordinates, offset);\n  }\n  var source = coordinates[0];\n  var target = coordinates[1];\n  var linetheatOffset = typeof thetaOffset === 'string' ? feature[thetaOffset] || 0 : thetaOffset;\n  var calFunc;\n  switch (shape) {\n    case 'arc':\n      calFunc = arcLineAtOffset;\n      break;\n    case 'greatcircle':\n      calFunc = greatCircleLineAtOffset;\n      break;\n    default:\n      calFunc = arcLineAtOffset;\n  }\n  var _calFunc = calFunc(source, target, offset, linetheatOffset, mapVersion, segmentNumber, autoFit),\n    _calFunc2 = _slicedToArray(_calFunc, 3),\n    lng = _calFunc2[0],\n    lat = _calFunc2[1],\n    height = _calFunc2[2];\n  return {\n    lng: lng,\n    lat: lat,\n    height: height\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}