{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exchangeEdges = exports.enterEdge = exports.leaveEdge = exports.initLowLimValues = exports.calcCutValue = exports.initCutValues = void 0;\nvar feasible_tree_1 = require(\"./feasible-tree\");\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"../util\");\nvar graphlib_1 = require(\"@antv/graphlib\");\nvar preorder = graphlib_1.algorithm.preorder,\n  postorder = graphlib_1.algorithm.postorder;\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nvar networkSimplex = function (og) {\n  var g = (0, util_2.simplify)(og);\n  (0, util_1.longestPath)(g);\n  var t = (0, feasible_tree_1.feasibleTree)(g);\n  (0, exports.initLowLimValues)(t);\n  (0, exports.initCutValues)(t, g);\n  var e;\n  var f;\n  while (e = (0, exports.leaveEdge)(t)) {\n    f = (0, exports.enterEdge)(t, g, e);\n    (0, exports.exchangeEdges)(t, g, e, f);\n  }\n};\n/*\n * Initializes cut values for all edges in the tree.\n */\nvar initCutValues = function (t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs === null || vs === void 0 ? void 0 : vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);\n  vs === null || vs === void 0 ? void 0 : vs.forEach(function (v) {\n    assignCutValue(t, g, v);\n  });\n};\nexports.initCutValues = initCutValues;\nvar assignCutValue = function (t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edgeFromArgs(child, parent).cutvalue = (0, exports.calcCutValue)(t, g, child);\n};\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nvar calcCutValue = function (t, g, child) {\n  var _a;\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edgeFromArgs(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edgeFromArgs(parent, child);\n  }\n  cutValue = graphEdge.weight;\n  (_a = g.nodeEdges(child)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n    var isOutEdge = e.v === child;\n    var other = isOutEdge ? e.w : e.v;\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail;\n      var otherWeight = g.edge(e).weight;\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edgeFromArgs(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n  return cutValue;\n};\nexports.calcCutValue = calcCutValue;\nvar initLowLimValues = function (tree, root) {\n  if (root === void 0) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n};\nexports.initLowLimValues = initLowLimValues;\nvar dfsAssignLowLim = function (tree, visited, nextLim, v, parent) {\n  var _a;\n  var low = nextLim;\n  var useNextLim = nextLim;\n  var label = tree.node(v);\n  visited[v] = true;\n  (_a = tree.neighbors(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (w) {\n    if (!visited[w]) {\n      useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w, v);\n    }\n  });\n  label.low = low;\n  label.lim = useNextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n  return useNextLim;\n};\nvar leaveEdge = function (tree) {\n  return tree.edges().find(function (e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n};\nexports.leaveEdge = leaveEdge;\nvar enterEdge = function (t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n  var candidates = g.edges().filter(function (edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) && flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n  return (0, util_2.minBy)(candidates, function (edge) {\n    return (0, util_1.slack)(g, edge);\n  });\n};\nexports.enterEdge = enterEdge;\nvar exchangeEdges = function (t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  (0, exports.initLowLimValues)(t);\n  (0, exports.initCutValues)(t, g);\n  updateRanks(t, g);\n};\nexports.exchangeEdges = exchangeEdges;\nvar updateRanks = function (t, g) {\n  var root = t.nodes().find(function (v) {\n    var _a;\n    return !((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.parent);\n  });\n  var vs = preorder(t, root);\n  vs = vs === null || vs === void 0 ? void 0 : vs.slice(1);\n  vs === null || vs === void 0 ? void 0 : vs.forEach(function (v) {\n    var parent = t.node(v).parent;\n    var edge = g.edgeFromArgs(v, parent);\n    var flipped = false;\n    if (!edge) {\n      edge = g.edgeFromArgs(parent, v);\n      flipped = true;\n    }\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n};\n/*\n * Returns true if the edge is in the tree.\n */\nvar isTreeEdge = function (tree, u, v) {\n  return tree.hasEdge(u, v);\n};\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nvar isDescendant = function (tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n};\nexports.default = networkSimplex;","map":{"version":3,"names":["feasible_tree_1","require","util_1","util_2","graphlib_1","preorder","algorithm","postorder","networkSimplex","og","g","simplify","longestPath","t","feasibleTree","exports","initLowLimValues","initCutValues","e","f","leaveEdge","enterEdge","exchangeEdges","vs","nodes","slice","length","forEach","v","assignCutValue","child","childLab","node","parent","edgeFromArgs","cutvalue","calcCutValue","childIsTail","graphEdge","cutValue","weight","_a","nodeEdges","isOutEdge","other","w","pointsToHead","otherWeight","edge","isTreeEdge","otherCutValue","tree","root","dfsAssignLowLim","visited","nextLim","low","useNextLim","label","neighbors","lim","edges","find","hasEdge","vLabel","wLabel","tailLabel","flip","candidates","filter","isDescendant","minBy","slack","removeEdge","setEdge","updateRanks","flipped","rank","minlen","u","rootLabel","default"],"sources":["../../../../../src/layout/dagre/src/rank/network-simplex.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}