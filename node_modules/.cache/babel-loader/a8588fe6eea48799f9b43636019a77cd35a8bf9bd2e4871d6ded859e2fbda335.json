{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { vec2 } from 'gl-matrix';\nimport { aProjectFlat } from \"../geo\";\nvar tmp = vec2.create();\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nvar capEnd = vec2.create();\nvar lineA = vec2.create();\nvar lineB = vec2.create();\nvar tangent = vec2.create();\nexport function computeMiter(lineTangent, miter, start, end, halfThick) {\n  vec2.add(lineTangent, start, end);\n  vec2.normalize(lineTangent, lineTangent);\n  miter = vec2.fromValues(-lineTangent[1], lineTangent[0]);\n  var tmpvec = vec2.fromValues(-start[1], start[0]);\n  return [halfThick / vec2.dot(miter, tmpvec), miter];\n}\nexport function computeNormal(out, dir) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\nexport function direction(out, a, b) {\n  vec2.sub(out, a, b);\n  vec2.normalize(out, out);\n  return out;\n}\nfunction isPointEqual(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\nexport function getArrayUnique(matrix) {\n  var map = new Map();\n  for (var i = 0; i < matrix.length; i++) {\n    var key = matrix[0].toString() + '-' + matrix[1].toString();\n    if (map.get(key)) {\n      matrix.splice(i, 1);\n      i++;\n    } else {\n      map.set(key, key);\n    }\n  }\n  return matrix;\n}\nvar ExtrudePolyline = /*#__PURE__*/function () {\n  function ExtrudePolyline() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ExtrudePolyline);\n    _defineProperty(this, \"lastFlip\", -1);\n    _defineProperty(this, \"miter\", vec2.fromValues(0, 0));\n    _defineProperty(this, \"started\", false);\n    _defineProperty(this, \"dash\", false);\n    _defineProperty(this, \"totalDistance\", 0);\n    _defineProperty(this, \"currentIndex\", 0);\n    this.join = opts.join || 'miter';\n    this.cap = opts.cap || 'butt';\n    this.miterLimit = opts.miterLimit || 10;\n    this.thickness = opts.thickness || 1;\n    this.dash = opts.dash || false;\n    this.complex = {\n      positions: [],\n      indices: [],\n      normals: [],\n      startIndex: 0,\n      indexes: []\n    };\n  }\n  _createClass(ExtrudePolyline, [{\n    key: \"extrude_gaode2\",\n    value: function extrude_gaode2(points, originPoints) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var _originPoints$, _originPoints$i$, _originPoints$2;\n        var last = points[i - 1];\n        last.push((_originPoints$ = originPoints[i - 1][2]) !== null && _originPoints$ !== void 0 ? _originPoints$ : 0);\n        // @ts-ignore\n        var originLast = originPoints[i - 1];\n        var cur = points[i];\n        cur.push((_originPoints$i$ = originPoints[i][2]) !== null && _originPoints$i$ !== void 0 ? _originPoints$i$ : 0);\n        // @ts-ignore\n        var originCur = originPoints[i];\n        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$2 = originPoints[i + 1][2]) !== null && _originPoints$2 !== void 0 ? _originPoints$2 : 0]) : null;\n        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;\n        var amt = this.segment_gaode2(complex, count,\n        // @ts-ignore\n        last,\n        // @ts-ignore\n        cur,\n        // @ts-ignore\n        next,\n        // @ts-ignore\n        originLast, originCur,\n        // @ts-ignore\n        originNext);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i = 0; _i < complex.positions.length / 6; _i++) {\n          complex.positions[_i * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"simpleExtrude_gaode2\",\n    value: function simpleExtrude_gaode2(points, originPoints) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var _originPoints$3, _originPoints$i$2, _originPoints$4;\n        var last = points[i - 1];\n        last.push((_originPoints$3 = originPoints[i - 1][2]) !== null && _originPoints$3 !== void 0 ? _originPoints$3 : 0);\n        // @ts-ignore\n        var originLast = originPoints[i - 1];\n        var cur = points[i];\n        cur.push((_originPoints$i$2 = originPoints[i][2]) !== null && _originPoints$i$2 !== void 0 ? _originPoints$i$2 : 0);\n        // @ts-ignore\n        var originCur = originPoints[i];\n        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$4 = originPoints[i + 1][2]) !== null && _originPoints$4 !== void 0 ? _originPoints$4 : 0]) : null;\n        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;\n        var amt = this.simpleSegment(complex, count,\n        // @ts-ignore\n        last,\n        // @ts-ignore\n        cur,\n        // @ts-ignore\n        next,\n        // @ts-ignore\n        originLast, originCur,\n        // @ts-ignore\n        originNext);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i2 = 0; _i2 < complex.positions.length / 6; _i2++) {\n          complex.positions[_i2 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"extrude\",\n    value: function extrude(points) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var cur = points[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var amt = this.segment(complex, count, last, cur, next);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i3 = 0; _i3 < complex.positions.length / 6; _i3++) {\n          complex.positions[_i3 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"simpleExtrude\",\n    value: function simpleExtrude(points) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var cur = points[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var amt = this.simpleSegment(complex, count, last, cur, next);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i4 = 0; _i4 < complex.positions.length / 6; _i4++) {\n          complex.positions[_i4 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"segment_gaode2\",\n    value: function segment_gaode2(complex, index, last, cur, next, originLast, originCur,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    originNext) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([originCur[0], originCur[1]]);\n      var flatLast = aProjectFlat([originLast[0], originLast[1]]);\n      // @ts-ignore\n      direction(lineA, cur, last);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n\n        // if the end cap is type square, we can just push the verts out a bit\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        if (capSquare) {\n          var _out = vec2.create();\n          var _out2 = vec2.create();\n          vec2.sub(_out2, lineA, this.normal);\n          vec2.add(_out, lineA, this.normal);\n          normals.push(_out2[0], _out2[1], 0);\n          normals.push(_out[0], _out[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        // @ts-ignore\n        if (isPointEqual(cur, next)) {\n          vec2.add(\n          // @ts-ignore\n          next,\n          // @ts-ignore\n          cur, vec2.normalize(\n          // @ts-ignore\n          next,\n          // @ts-ignore\n          vec2.subtract(next, cur, last)));\n        }\n        // @ts-ignore\n        direction(lineB, next, cur);\n        // stores tangent & miter\n\n        var _computeMiter = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter2 = _slicedToArray(_computeMiter, 2),\n          miterLen = _computeMiter2[0],\n          miter = _computeMiter2[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n\n          // now add the bevel triangle\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp); // store normal for next round\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n\n          // the miter is now the normal for our next join\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"simpleSegment\",\n    value: function simpleSegment(complex, index, last, cur, next) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var flatCur = aProjectFlat([cur[0], cur[1]]);\n      var flatLast = aProjectFlat([last[0], last[1]]);\n      // @ts-ignore\n      direction(lineA, flatCur, flatLast);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n        this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        var flatNext = aProjectFlat([next[0], next[1]]);\n        if (isPointEqual(flatCur, flatNext)) {\n          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n        }\n        direction(lineB, flatNext, flatCur);\n\n        // stores tangent & miter\n\n        var _computeMiter3 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter4 = _slicedToArray(_computeMiter3, 2),\n          miterLen = _computeMiter4[0],\n          miter = _computeMiter4[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        flip = -1;\n\n        // the miter is now the normal for our next join\n        vec2.copy(this.normal, miter);\n        count += 2;\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"segment\",\n    value: function segment(complex, index, last, cur, next) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([cur[0], cur[1]]);\n      var flatLast = aProjectFlat([last[0], last[1]]);\n      // @ts-ignore\n      direction(lineA, flatCur, flatLast);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n\n        // if the end cap is type square, we can just push the verts out a bit\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          // this.extrusions(positions, normals, last, out, this.thickness);\n          // last = capEnd;\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, cur, lineA, this.thickness);\n          // cur = capEnd;\n          var _out3 = vec2.create();\n          var _out4 = vec2.create();\n          vec2.sub(_out4, lineA, this.normal);\n          vec2.add(_out3, lineA, this.normal);\n          // this.extrusions(positions, normals, cur, out, this.thickness);\n          normals.push(_out4[0], _out4[1], 0);\n          normals.push(_out3[0], _out3[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n\n        // this.extrusions(positions, normals, cur, this.normal, this.thickness);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        var flatNext = aProjectFlat([next[0], next[1]]);\n        if (isPointEqual(flatCur, flatNext)) {\n          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n        }\n        direction(lineB, flatNext, flatCur);\n\n        // stores tangent & miter\n\n        var _computeMiter5 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter6 = _slicedToArray(_computeMiter5, 2),\n          miterLen = _computeMiter6[0],\n          miter = _computeMiter6[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n\n          // now add the bevel triangle\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp); // store normal for next round\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n\n          // the miter is now the normal for our next join\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"extrusions\",\n    value: function extrusions(positions, normals, point,\n    // 顶点\n    normal,\n    // 法向量\n    thickness,\n    // 高度\n    distanceRadio) {\n      normals.push(normal[0], normal[1], 0);\n      normals.push(normal[0], normal[1], 0);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, -thickness, point[2] | 0);\n      this.complex.indexes.push(this.currentIndex);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, thickness, point[2] | 0);\n      this.complex.indexes.push(this.currentIndex);\n      this.currentIndex++;\n    }\n  }, {\n    key: \"lineSegmentDistance\",\n    value: function lineSegmentDistance(b1, a1) {\n      var dx = a1[0] - b1[0];\n      var dy = a1[1] - b1[1];\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  }]);\n  return ExtrudePolyline;\n}();\nexport { ExtrudePolyline as default };","map":{"version":3,"names":["_slicedToArray","_toConsumableArray","_classCallCheck","_createClass","_defineProperty","vec2","aProjectFlat","tmp","create","capEnd","lineA","lineB","tangent","computeMiter","lineTangent","miter","start","end","halfThick","add","normalize","fromValues","tmpvec","dot","computeNormal","out","dir","set","direction","a","b","sub","isPointEqual","getArrayUnique","matrix","map","Map","i","length","key","toString","get","splice","ExtrudePolyline","opts","arguments","undefined","join","cap","miterLimit","thickness","dash","complex","positions","indices","normals","startIndex","indexes","value","extrude_gaode2","points","originPoints","lastFlip","started","normal","totalDistance","total","count","_originPoints$","_originPoints$i$","_originPoints$2","last","push","originLast","cur","originCur","next","concat","originNext","amt","segment_gaode2","_i","simpleExtrude_gaode2","_originPoints$3","_originPoints$i$2","_originPoints$4","simpleSegment","_i2","extrude","segment","_i3","simpleExtrude","_i4","index","capSquare","joinBevel","flatCur","flatLast","segmentDistance","lineSegmentDistance","out1","out2","currentIndex","extrusions","_out","_out2","apply","subtract","_computeMiter","_computeMiter2","miterLen","flip","bevel","limit","copy","flatNext","_computeMiter3","_computeMiter4","_out3","_out4","_computeMiter5","_computeMiter6","point","distanceRadio","b1","a1","dx","dy","Math","sqrt","default"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-utils/es/workers/extrude_polyline.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { vec2 } from 'gl-matrix';\nimport { aProjectFlat } from \"../geo\";\nvar tmp = vec2.create();\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nvar capEnd = vec2.create();\nvar lineA = vec2.create();\nvar lineB = vec2.create();\nvar tangent = vec2.create();\nexport function computeMiter(lineTangent, miter, start, end, halfThick) {\n  vec2.add(lineTangent, start, end);\n  vec2.normalize(lineTangent, lineTangent);\n  miter = vec2.fromValues(-lineTangent[1], lineTangent[0]);\n  var tmpvec = vec2.fromValues(-start[1], start[0]);\n  return [halfThick / vec2.dot(miter, tmpvec), miter];\n}\nexport function computeNormal(out, dir) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\nexport function direction(out, a, b) {\n  vec2.sub(out, a, b);\n  vec2.normalize(out, out);\n  return out;\n}\nfunction isPointEqual(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\nexport function getArrayUnique(matrix) {\n  var map = new Map();\n  for (var i = 0; i < matrix.length; i++) {\n    var key = matrix[0].toString() + '-' + matrix[1].toString();\n    if (map.get(key)) {\n      matrix.splice(i, 1);\n      i++;\n    } else {\n      map.set(key, key);\n    }\n  }\n  return matrix;\n}\nvar ExtrudePolyline = /*#__PURE__*/function () {\n  function ExtrudePolyline() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ExtrudePolyline);\n    _defineProperty(this, \"lastFlip\", -1);\n    _defineProperty(this, \"miter\", vec2.fromValues(0, 0));\n    _defineProperty(this, \"started\", false);\n    _defineProperty(this, \"dash\", false);\n    _defineProperty(this, \"totalDistance\", 0);\n    _defineProperty(this, \"currentIndex\", 0);\n    this.join = opts.join || 'miter';\n    this.cap = opts.cap || 'butt';\n    this.miterLimit = opts.miterLimit || 10;\n    this.thickness = opts.thickness || 1;\n    this.dash = opts.dash || false;\n    this.complex = {\n      positions: [],\n      indices: [],\n      normals: [],\n      startIndex: 0,\n      indexes: []\n    };\n  }\n  _createClass(ExtrudePolyline, [{\n    key: \"extrude_gaode2\",\n    value: function extrude_gaode2(points, originPoints) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var _originPoints$, _originPoints$i$, _originPoints$2;\n        var last = points[i - 1];\n        last.push((_originPoints$ = originPoints[i - 1][2]) !== null && _originPoints$ !== void 0 ? _originPoints$ : 0);\n        // @ts-ignore\n        var originLast = originPoints[i - 1];\n        var cur = points[i];\n        cur.push((_originPoints$i$ = originPoints[i][2]) !== null && _originPoints$i$ !== void 0 ? _originPoints$i$ : 0);\n        // @ts-ignore\n        var originCur = originPoints[i];\n        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$2 = originPoints[i + 1][2]) !== null && _originPoints$2 !== void 0 ? _originPoints$2 : 0]) : null;\n        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;\n        var amt = this.segment_gaode2(complex, count,\n        // @ts-ignore\n        last,\n        // @ts-ignore\n        cur,\n        // @ts-ignore\n        next,\n        // @ts-ignore\n        originLast, originCur,\n        // @ts-ignore\n        originNext);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i = 0; _i < complex.positions.length / 6; _i++) {\n          complex.positions[_i * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"simpleExtrude_gaode2\",\n    value: function simpleExtrude_gaode2(points, originPoints) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var _originPoints$3, _originPoints$i$2, _originPoints$4;\n        var last = points[i - 1];\n        last.push((_originPoints$3 = originPoints[i - 1][2]) !== null && _originPoints$3 !== void 0 ? _originPoints$3 : 0);\n        // @ts-ignore\n        var originLast = originPoints[i - 1];\n        var cur = points[i];\n        cur.push((_originPoints$i$2 = originPoints[i][2]) !== null && _originPoints$i$2 !== void 0 ? _originPoints$i$2 : 0);\n        // @ts-ignore\n        var originCur = originPoints[i];\n        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$4 = originPoints[i + 1][2]) !== null && _originPoints$4 !== void 0 ? _originPoints$4 : 0]) : null;\n        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;\n        var amt = this.simpleSegment(complex, count,\n        // @ts-ignore\n        last,\n        // @ts-ignore\n        cur,\n        // @ts-ignore\n        next,\n        // @ts-ignore\n        originLast, originCur,\n        // @ts-ignore\n        originNext);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i2 = 0; _i2 < complex.positions.length / 6; _i2++) {\n          complex.positions[_i2 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"extrude\",\n    value: function extrude(points) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var cur = points[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var amt = this.segment(complex, count, last, cur, next);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i3 = 0; _i3 < complex.positions.length / 6; _i3++) {\n          complex.positions[_i3 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"simpleExtrude\",\n    value: function simpleExtrude(points) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var cur = points[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var amt = this.simpleSegment(complex, count, last, cur, next);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i4 = 0; _i4 < complex.positions.length / 6; _i4++) {\n          complex.positions[_i4 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"segment_gaode2\",\n    value: function segment_gaode2(complex, index, last, cur, next, originLast, originCur,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    originNext) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([originCur[0], originCur[1]]);\n      var flatLast = aProjectFlat([originLast[0], originLast[1]]);\n      // @ts-ignore\n      direction(lineA, cur, last);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n\n        // if the end cap is type square, we can just push the verts out a bit\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        if (capSquare) {\n          var _out = vec2.create();\n          var _out2 = vec2.create();\n          vec2.sub(_out2, lineA, this.normal);\n          vec2.add(_out, lineA, this.normal);\n          normals.push(_out2[0], _out2[1], 0);\n          normals.push(_out[0], _out[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        // @ts-ignore\n        if (isPointEqual(cur, next)) {\n          vec2.add(\n          // @ts-ignore\n          next,\n          // @ts-ignore\n          cur, vec2.normalize(\n          // @ts-ignore\n          next,\n          // @ts-ignore\n          vec2.subtract(next, cur, last)));\n        }\n        // @ts-ignore\n        direction(lineB, next, cur);\n        // stores tangent & miter\n\n        var _computeMiter = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter2 = _slicedToArray(_computeMiter, 2),\n          miterLen = _computeMiter2[0],\n          miter = _computeMiter2[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n\n          // now add the bevel triangle\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp); // store normal for next round\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n\n          // the miter is now the normal for our next join\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"simpleSegment\",\n    value: function simpleSegment(complex, index, last, cur, next) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var flatCur = aProjectFlat([cur[0], cur[1]]);\n      var flatLast = aProjectFlat([last[0], last[1]]);\n      // @ts-ignore\n      direction(lineA, flatCur, flatLast);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n        this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        var flatNext = aProjectFlat([next[0], next[1]]);\n        if (isPointEqual(flatCur, flatNext)) {\n          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n        }\n        direction(lineB, flatNext, flatCur);\n\n        // stores tangent & miter\n\n        var _computeMiter3 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter4 = _slicedToArray(_computeMiter3, 2),\n          miterLen = _computeMiter4[0],\n          miter = _computeMiter4[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        flip = -1;\n\n        // the miter is now the normal for our next join\n        vec2.copy(this.normal, miter);\n        count += 2;\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"segment\",\n    value: function segment(complex, index, last, cur, next) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([cur[0], cur[1]]);\n      var flatLast = aProjectFlat([last[0], last[1]]);\n      // @ts-ignore\n      direction(lineA, flatCur, flatLast);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n\n        // if the end cap is type square, we can just push the verts out a bit\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          // this.extrusions(positions, normals, last, out, this.thickness);\n          // last = capEnd;\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, cur, lineA, this.thickness);\n          // cur = capEnd;\n          var _out3 = vec2.create();\n          var _out4 = vec2.create();\n          vec2.sub(_out4, lineA, this.normal);\n          vec2.add(_out3, lineA, this.normal);\n          // this.extrusions(positions, normals, cur, out, this.thickness);\n          normals.push(_out4[0], _out4[1], 0);\n          normals.push(_out3[0], _out3[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n\n        // this.extrusions(positions, normals, cur, this.normal, this.thickness);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        var flatNext = aProjectFlat([next[0], next[1]]);\n        if (isPointEqual(flatCur, flatNext)) {\n          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n        }\n        direction(lineB, flatNext, flatCur);\n\n        // stores tangent & miter\n\n        var _computeMiter5 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter6 = _slicedToArray(_computeMiter5, 2),\n          miterLen = _computeMiter6[0],\n          miter = _computeMiter6[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n\n          // now add the bevel triangle\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp); // store normal for next round\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n\n          // the miter is now the normal for our next join\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"extrusions\",\n    value: function extrusions(positions, normals, point,\n    // 顶点\n    normal,\n    // 法向量\n    thickness,\n    // 高度\n    distanceRadio) {\n      normals.push(normal[0], normal[1], 0);\n      normals.push(normal[0], normal[1], 0);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, -thickness, point[2] | 0);\n      this.complex.indexes.push(this.currentIndex);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, thickness, point[2] | 0);\n      this.complex.indexes.push(this.currentIndex);\n      this.currentIndex++;\n    }\n  }, {\n    key: \"lineSegmentDistance\",\n    value: function lineSegmentDistance(b1, a1) {\n      var dx = a1[0] - b1[0];\n      var dy = a1[1] - b1[1];\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  }]);\n  return ExtrudePolyline;\n}();\nexport { ExtrudePolyline as default };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}