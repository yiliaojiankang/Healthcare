{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { PointFillTriangulation } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { ShaderLocation } from \"../../core/CommonStyleAttribute\";\n/* babel-plugin-inline-import '../shaders/fill/fill_frag.glsl' */\nvar pointFillFrag = \"\\nlayout(std140) uniform commonUniforms {\\n  vec3 u_blur_height_fixed;\\n  float u_stroke_width;\\n  float u_additive;\\n  float u_stroke_opacity;\\n  float u_size_unit;\\n  float u_time;\\n  vec4 u_animate;\\n};\\n\\nin vec4 v_color;\\nin vec4 v_stroke;\\nin vec4 v_data;\\nin float v_radius;\\n\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"sdf_2d\\\"\\n#pragma include \\\"picking\\\"\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n  int shape = int(floor(v_data.w + 0.5));\\n  lowp float antialiasblur = v_data.z;\\n  float r = v_radius / (v_radius + u_stroke_width);\\n\\n  float outer_df;\\n  float inner_df;\\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\\n  if (shape == 0) {\\n    outer_df = sdCircle(v_data.xy, 1.0);\\n    inner_df = sdCircle(v_data.xy, r);\\n  } else if (shape == 1) {\\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\\n  } else if (shape == 2) {\\n    outer_df = sdBox(v_data.xy, vec2(1.));\\n    inner_df = sdBox(v_data.xy, vec2(r));\\n  } else if (shape == 3) {\\n    outer_df = sdPentagon(v_data.xy, 0.8);\\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\\n  } else if (shape == 4) {\\n    outer_df = sdHexagon(v_data.xy, 0.8);\\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\\n  } else if (shape == 5) {\\n    outer_df = sdOctogon(v_data.xy, 1.0);\\n    inner_df = sdOctogon(v_data.xy, r);\\n  } else if (shape == 6) {\\n    outer_df = sdHexagram(v_data.xy, 0.52);\\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\\n  } else if (shape == 7) {\\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\\n    inner_df = sdRhombus(v_data.xy, vec2(r));\\n  } else if (shape == 8) {\\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\\n  }\\n\\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\\n\\n  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\\n    antialiasblur,\\n    0.0,\\n    inner_df\\n  );\\n\\n  float PI = 3.14159;\\n  float N_RINGS = 3.0;\\n  float FREQ = 1.0;\\n\\n  if(u_stroke_width < 0.01) {\\n    outputColor = v_color;\\n  } else {\\n    outputColor = mix(v_color, v_stroke * u_stroke_opacity, color_t);\\n  }\\n  float intensity = 1.0;\\n  if(u_time!=-1.0){\\n    //wave\\u76F8\\u5173\\u903B\\u8F91\\n    float d = length(v_data.xy);\\n    if(d > 0.5) {\\n      discard;\\n    }\\n    intensity = clamp(cos(d * PI), 0.0, 1.0) * clamp(cos(2.0 * PI * (d * 2.0 * u_animate.z - u_animate.y * u_time)), 0.0, 1.0);\\n  }\\n\\n  if(u_additive > 0.0) {\\n    outputColor *= opacity_t;\\n    outputColor *= intensity;//wave\\n    outputColor = filterColorAlpha(outputColor, outputColor.a);\\n  } else {\\n    outputColor.a *= opacity_t;\\n    outputColor.a *= intensity;//wave \\n    outputColor = filterColor(outputColor);\\n  }\\n   // \\u4F5C\\u4E3A mask \\u6A21\\u677F\\u65F6\\u9700\\u8981\\u4E22\\u5F03\\u900F\\u660E\\u7684\\u50CF\\u7D20\\n  if(outputColor.a < 0.01) {\\n    discard;\\n  } \\n}\\n\";\n/* babel-plugin-inline-import '../shaders/fill/fill_vert.glsl' */\nvar pointFillVert = \"layout(location = 0) in vec3 a_Position;\\nlayout(location = 1) in vec4 a_Color;\\nlayout(location = 9) in float a_Size;\\nlayout(location = 10) in float a_Shape;\\nlayout(location = 11) in vec3 a_Extrude;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec3 u_blur_height_fixed;\\n  float u_stroke_width;\\n  float u_additive;\\n  float u_stroke_opacity;\\n  float u_size_unit;\\n  float u_time;\\n  vec4 u_animate;   \\n};\\n\\nout vec4 v_color;\\nout vec4 v_stroke;\\nout vec4 v_data;\\nout float v_radius;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n#pragma include \\\"rotation_2d\\\"\\n\\nvoid main() {\\n  // \\u900F\\u660E\\u5EA6\\u8BA1\\u7B97\\n   v_stroke = stroke;  \\n  vec3 extrude = a_Extrude;\\n  float shape_type = a_Shape;\\n  /*\\n  *  setPickingSize \\u8BBE\\u7F6E\\u62FE\\u53D6\\u5927\\u5C0F\\n  *  u_meter2coord \\u5728\\u7B49\\u9762\\u79EF\\u5927\\u5C0F\\u7684\\u65F6\\u5019\\u8BBE\\u7F6E\\u5355\\u4F4D\\n  */\\n  float newSize = setPickingSize(a_Size);\\n  // float newSize = setPickingSize(a_Size) * 0.00001038445708445579;\\n\\n\\n\\n  // unpack color(vec2)\\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\\n\\n  if(u_size_unit == 1.0) {\\n    newSize = newSize  * u_PixelsPerMeter.z;\\n  }\\n\\n   v_radius = newSize;\\n\\n  // anti-alias\\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, u_blur_height_fixed.x);\\n\\n  vec2 offset = (extrude.xy * (newSize + u_stroke_width) + u_offsets);\\n  vec3 aPosition = a_Position;\\n\\n  offset = project_pixel(offset);\\n  offset = rotate_matrix(offset,rotation);\\n  \\n  // TODP: /abs(extrude.x) \\u662F\\u4E3A\\u4E86\\u517C\\u5BB9\\u5730\\u7403\\u6A21\\u5F0F\\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\\n\\n\\n  // vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\\n  vec4 project_pos = project_position(vec4(aPosition.xy, 0.0, 1.0));\\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\\n\\n  float raisingHeight = u_blur_height_fixed.y;\\n\\n  if(u_blur_height_fixed.z < 1.0) { // false\\n    raisingHeight = project_pixel(u_blur_height_fixed.y);\\n  } else {\\n     if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\\n      raisingHeight = u_blur_height_fixed.y * mapboxZoomScale;\\n    }\\n  }\\n  \\n  gl_Position = project_common_position_to_clipspace_v2(vec4(project_pos.xy + offset, raisingHeight, 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nimport { SizeUnitType } from \"../../core/interface\";\nvar FillModel = /*#__PURE__*/function (_BaseModel) {\n  _inherits(FillModel, _BaseModel);\n  var _super = _createSuper(FillModel);\n  function FillModel() {\n    _classCallCheck(this, FillModel);\n    return _super.apply(this, arguments);\n  }\n  _createClass(FillModel, [{\n    key: \"getCommonUniformsInfo\",\n    value: function getCommonUniformsInfo() {\n      var _ref = this.layer.getLayerConfig(),\n        _ref$strokeOpacity = _ref.strokeOpacity,\n        strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,\n        _ref$strokeWidth = _ref.strokeWidth,\n        strokeWidth = _ref$strokeWidth === void 0 ? 0 : _ref$strokeWidth,\n        blend = _ref.blend,\n        _ref$blur = _ref.blur,\n        blur = _ref$blur === void 0 ? 0 : _ref$blur,\n        _ref$raisingHeight = _ref.raisingHeight,\n        raisingHeight = _ref$raisingHeight === void 0 ? 0 : _ref$raisingHeight,\n        _ref$heightfixed = _ref.heightfixed,\n        heightfixed = _ref$heightfixed === void 0 ? false : _ref$heightfixed,\n        _ref$unit = _ref.unit,\n        unit = _ref$unit === void 0 ? 'pixel' : _ref$unit;\n      var u_time = this.getAnimateUniforms().u_time;\n      if (isNaN(u_time)) {\n        u_time = -1.0;\n      }\n      var commonOptions = {\n        u_blur_height_fixed: [blur, Number(raisingHeight), Number(heightfixed)],\n        u_stroke_width: strokeWidth,\n        u_additive: blend === 'additive' ? 1.0 : 0.0,\n        u_stroke_opacity: strokeOpacity,\n        u_size_unit: SizeUnitType[unit],\n        u_time: u_time,\n        u_animate: this.getAnimateUniforms().u_animate\n      };\n      var commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n      return commonBufferInfo;\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      var _ref2 = this.layer.getLayerConfig(),\n        _ref2$animateOption = _ref2.animateOption,\n        animateOption = _ref2$animateOption === void 0 ? {\n          enable: false\n        } : _ref2$animateOption;\n      return {\n        u_animate: this.animateOption2Array(animateOption),\n        u_time: this.layer.getLayerAnimateTime()\n      };\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute() {\n      return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);\n    }\n  }, {\n    key: \"initModels\",\n    value: function () {\n      var _initModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.buildModels());\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function initModels() {\n        return _initModels.apply(this, arguments);\n      }\n      return initModels;\n    }()\n  }, {\n    key: \"buildModels\",\n    value: function () {\n      var _buildModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _ref3, _ref3$animateOption, animateOption, _this$getShaders, frag, vert, type, model;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _ref3 = this.layer.getLayerConfig(), _ref3$animateOption = _ref3.animateOption, animateOption = _ref3$animateOption === void 0 ? {\n                enable: false\n              } : _ref3$animateOption;\n              _this$getShaders = this.getShaders(animateOption), frag = _this$getShaders.frag, vert = _this$getShaders.vert, type = _this$getShaders.type;\n              this.layer.triangulation = PointFillTriangulation;\n              this.initUniformsBuffer();\n              _context2.next = 6;\n              return this.layer.buildLayerModel({\n                moduleName: type,\n                vertexShader: vert,\n                fragmentShader: frag,\n                inject: this.getInject(),\n                triangulation: PointFillTriangulation,\n                depth: {\n                  enable: false\n                }\n              });\n            case 6:\n              model = _context2.sent;\n              return _context2.abrupt(\"return\", [model]);\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function buildModels() {\n        return _buildModels.apply(this, arguments);\n      }\n      return buildModels;\n    }()\n    /**\n     * 根据 animateOption 的值返回对应的 shader 代码\n     * @returns\n     */\n  }, {\n    key: \"getShaders\",\n    value: function getShaders(animateOption) {\n      return {\n        frag: pointFillFrag,\n        vert: pointFillVert,\n        type: 'pointFill'\n      };\n    }\n\n    // overwrite baseModel func\n  }, {\n    key: \"animateOption2Array\",\n    value: function animateOption2Array(option) {\n      return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      // 注册 Style 参与数据映射的内置属性\n      var shape2d = this.layer.getLayerConfig().shape2d;\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'extrude',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Extrude',\n          shaderLocation: ShaderLocation.EXTRUDE,\n          buffer: {\n            // give the WebGL driver a hint that this buffer may change\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 3,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];\n            var extrudeIndex = attributeIdx % 4 * 3;\n            return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];\n          }\n        }\n      });\n\n      // point layer size;\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          shaderLocation: ShaderLocation.SIZE,\n          buffer: {\n            // give the WebGL driver a hint that this buffer may change\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature) {\n            var _feature$size = feature.size,\n              size = _feature$size === void 0 ? 5 : _feature$size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n\n      // point layer shape;\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'shape',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Shape',\n          shaderLocation: ShaderLocation.SHAPE,\n          buffer: {\n            // give the WebGL driver a hint that this buffer may change\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature) {\n            var _feature$shape = feature.shape,\n              shape = _feature$shape === void 0 ? 2 : _feature$shape;\n            var shapeIndex = shape2d.indexOf(shape);\n            return [shapeIndex];\n          }\n        }\n      });\n    }\n  }]);\n  return FillModel;\n}(BaseModel);\nexport { FillModel as default };","map":{"version":3,"names":["_asyncToGenerator","_classCallCheck","_createClass","_inherits","_possibleConstructorReturn","_getPrototypeOf","_regeneratorRuntime","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","AttributeType","gl","PointFillTriangulation","BaseModel","ShaderLocation","pointFillFrag","pointFillVert","SizeUnitType","FillModel","_BaseModel","_super","key","value","getCommonUniformsInfo","_ref","layer","getLayerConfig","_ref$strokeOpacity","strokeOpacity","_ref$strokeWidth","strokeWidth","blend","_ref$blur","blur","_ref$raisingHeight","raisingHeight","_ref$heightfixed","heightfixed","_ref$unit","unit","u_time","getAnimateUniforms","isNaN","commonOptions","u_blur_height_fixed","Number","u_stroke_width","u_additive","u_stroke_opacity","u_size_unit","u_animate","commonBufferInfo","getUniformsBufferInfo","_ref2","_ref2$animateOption","animateOption","enable","animateOption2Array","getLayerAnimateTime","getAttribute","styleAttributeService","createAttributesAndIndices","getEncodedData","_initModels","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","buildModels","stop","initModels","_buildModels","_callee2","_ref3","_ref3$animateOption","_this$getShaders","frag","vert","type","model","_callee2$","_context2","getShaders","triangulation","initUniformsBuffer","buildLayerModel","moduleName","vertexShader","fragmentShader","inject","getInject","depth","sent","option","speed","rings","registerBuiltinAttributes","shape2d","registerStyleAttribute","name","Attribute","descriptor","shaderLocation","EXTRUDE","buffer","usage","DYNAMIC_DRAW","data","FLOAT","size","update","feature","featureIdx","vertex","attributeIdx","extrude","extrudeIndex","SIZE","_feature$size","Array","isArray","SHAPE","_feature$shape","shape","shapeIndex","indexOf","default"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-layers/es/point/models/fill.js"],"sourcesContent":["import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { PointFillTriangulation } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { ShaderLocation } from \"../../core/CommonStyleAttribute\";\n/* babel-plugin-inline-import '../shaders/fill/fill_frag.glsl' */\nvar pointFillFrag = \"\\nlayout(std140) uniform commonUniforms {\\n  vec3 u_blur_height_fixed;\\n  float u_stroke_width;\\n  float u_additive;\\n  float u_stroke_opacity;\\n  float u_size_unit;\\n  float u_time;\\n  vec4 u_animate;\\n};\\n\\nin vec4 v_color;\\nin vec4 v_stroke;\\nin vec4 v_data;\\nin float v_radius;\\n\\n#pragma include \\\"scene_uniforms\\\"\\n#pragma include \\\"sdf_2d\\\"\\n#pragma include \\\"picking\\\"\\n\\nout vec4 outputColor;\\n\\nvoid main() {\\n  int shape = int(floor(v_data.w + 0.5));\\n  lowp float antialiasblur = v_data.z;\\n  float r = v_radius / (v_radius + u_stroke_width);\\n\\n  float outer_df;\\n  float inner_df;\\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\\n  if (shape == 0) {\\n    outer_df = sdCircle(v_data.xy, 1.0);\\n    inner_df = sdCircle(v_data.xy, r);\\n  } else if (shape == 1) {\\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\\n  } else if (shape == 2) {\\n    outer_df = sdBox(v_data.xy, vec2(1.));\\n    inner_df = sdBox(v_data.xy, vec2(r));\\n  } else if (shape == 3) {\\n    outer_df = sdPentagon(v_data.xy, 0.8);\\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\\n  } else if (shape == 4) {\\n    outer_df = sdHexagon(v_data.xy, 0.8);\\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\\n  } else if (shape == 5) {\\n    outer_df = sdOctogon(v_data.xy, 1.0);\\n    inner_df = sdOctogon(v_data.xy, r);\\n  } else if (shape == 6) {\\n    outer_df = sdHexagram(v_data.xy, 0.52);\\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\\n  } else if (shape == 7) {\\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\\n    inner_df = sdRhombus(v_data.xy, vec2(r));\\n  } else if (shape == 8) {\\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\\n  }\\n\\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\\n\\n  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\\n    antialiasblur,\\n    0.0,\\n    inner_df\\n  );\\n\\n  float PI = 3.14159;\\n  float N_RINGS = 3.0;\\n  float FREQ = 1.0;\\n\\n  if(u_stroke_width < 0.01) {\\n    outputColor = v_color;\\n  } else {\\n    outputColor = mix(v_color, v_stroke * u_stroke_opacity, color_t);\\n  }\\n  float intensity = 1.0;\\n  if(u_time!=-1.0){\\n    //wave\\u76F8\\u5173\\u903B\\u8F91\\n    float d = length(v_data.xy);\\n    if(d > 0.5) {\\n      discard;\\n    }\\n    intensity = clamp(cos(d * PI), 0.0, 1.0) * clamp(cos(2.0 * PI * (d * 2.0 * u_animate.z - u_animate.y * u_time)), 0.0, 1.0);\\n  }\\n\\n  if(u_additive > 0.0) {\\n    outputColor *= opacity_t;\\n    outputColor *= intensity;//wave\\n    outputColor = filterColorAlpha(outputColor, outputColor.a);\\n  } else {\\n    outputColor.a *= opacity_t;\\n    outputColor.a *= intensity;//wave \\n    outputColor = filterColor(outputColor);\\n  }\\n   // \\u4F5C\\u4E3A mask \\u6A21\\u677F\\u65F6\\u9700\\u8981\\u4E22\\u5F03\\u900F\\u660E\\u7684\\u50CF\\u7D20\\n  if(outputColor.a < 0.01) {\\n    discard;\\n  } \\n}\\n\";\n/* babel-plugin-inline-import '../shaders/fill/fill_vert.glsl' */\nvar pointFillVert = \"layout(location = 0) in vec3 a_Position;\\nlayout(location = 1) in vec4 a_Color;\\nlayout(location = 9) in float a_Size;\\nlayout(location = 10) in float a_Shape;\\nlayout(location = 11) in vec3 a_Extrude;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec3 u_blur_height_fixed;\\n  float u_stroke_width;\\n  float u_additive;\\n  float u_stroke_opacity;\\n  float u_size_unit;\\n  float u_time;\\n  vec4 u_animate;   \\n};\\n\\nout vec4 v_color;\\nout vec4 v_stroke;\\nout vec4 v_data;\\nout float v_radius;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"picking\\\"\\n#pragma include \\\"rotation_2d\\\"\\n\\nvoid main() {\\n  // \\u900F\\u660E\\u5EA6\\u8BA1\\u7B97\\n   v_stroke = stroke;  \\n  vec3 extrude = a_Extrude;\\n  float shape_type = a_Shape;\\n  /*\\n  *  setPickingSize \\u8BBE\\u7F6E\\u62FE\\u53D6\\u5927\\u5C0F\\n  *  u_meter2coord \\u5728\\u7B49\\u9762\\u79EF\\u5927\\u5C0F\\u7684\\u65F6\\u5019\\u8BBE\\u7F6E\\u5355\\u4F4D\\n  */\\n  float newSize = setPickingSize(a_Size);\\n  // float newSize = setPickingSize(a_Size) * 0.00001038445708445579;\\n\\n\\n\\n  // unpack color(vec2)\\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\\n\\n  if(u_size_unit == 1.0) {\\n    newSize = newSize  * u_PixelsPerMeter.z;\\n  }\\n\\n   v_radius = newSize;\\n\\n  // anti-alias\\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, u_blur_height_fixed.x);\\n\\n  vec2 offset = (extrude.xy * (newSize + u_stroke_width) + u_offsets);\\n  vec3 aPosition = a_Position;\\n\\n  offset = project_pixel(offset);\\n  offset = rotate_matrix(offset,rotation);\\n  \\n  // TODP: /abs(extrude.x) \\u662F\\u4E3A\\u4E86\\u517C\\u5BB9\\u5730\\u7403\\u6A21\\u5F0F\\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\\n\\n\\n  // vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\\n  vec4 project_pos = project_position(vec4(aPosition.xy, 0.0, 1.0));\\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\\n\\n  float raisingHeight = u_blur_height_fixed.y;\\n\\n  if(u_blur_height_fixed.z < 1.0) { // false\\n    raisingHeight = project_pixel(u_blur_height_fixed.y);\\n  } else {\\n     if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\\n      raisingHeight = u_blur_height_fixed.y * mapboxZoomScale;\\n    }\\n  }\\n  \\n  gl_Position = project_common_position_to_clipspace_v2(vec4(project_pos.xy + offset, raisingHeight, 1.0));\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nimport { SizeUnitType } from \"../../core/interface\";\nvar FillModel = /*#__PURE__*/function (_BaseModel) {\n  _inherits(FillModel, _BaseModel);\n  var _super = _createSuper(FillModel);\n  function FillModel() {\n    _classCallCheck(this, FillModel);\n    return _super.apply(this, arguments);\n  }\n  _createClass(FillModel, [{\n    key: \"getCommonUniformsInfo\",\n    value: function getCommonUniformsInfo() {\n      var _ref = this.layer.getLayerConfig(),\n        _ref$strokeOpacity = _ref.strokeOpacity,\n        strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,\n        _ref$strokeWidth = _ref.strokeWidth,\n        strokeWidth = _ref$strokeWidth === void 0 ? 0 : _ref$strokeWidth,\n        blend = _ref.blend,\n        _ref$blur = _ref.blur,\n        blur = _ref$blur === void 0 ? 0 : _ref$blur,\n        _ref$raisingHeight = _ref.raisingHeight,\n        raisingHeight = _ref$raisingHeight === void 0 ? 0 : _ref$raisingHeight,\n        _ref$heightfixed = _ref.heightfixed,\n        heightfixed = _ref$heightfixed === void 0 ? false : _ref$heightfixed,\n        _ref$unit = _ref.unit,\n        unit = _ref$unit === void 0 ? 'pixel' : _ref$unit;\n      var u_time = this.getAnimateUniforms().u_time;\n      if (isNaN(u_time)) {\n        u_time = -1.0;\n      }\n      var commonOptions = {\n        u_blur_height_fixed: [blur, Number(raisingHeight), Number(heightfixed)],\n        u_stroke_width: strokeWidth,\n        u_additive: blend === 'additive' ? 1.0 : 0.0,\n        u_stroke_opacity: strokeOpacity,\n        u_size_unit: SizeUnitType[unit],\n        u_time: u_time,\n        u_animate: this.getAnimateUniforms().u_animate\n      };\n      var commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n      return commonBufferInfo;\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      var _ref2 = this.layer.getLayerConfig(),\n        _ref2$animateOption = _ref2.animateOption,\n        animateOption = _ref2$animateOption === void 0 ? {\n          enable: false\n        } : _ref2$animateOption;\n      return {\n        u_animate: this.animateOption2Array(animateOption),\n        u_time: this.layer.getLayerAnimateTime()\n      };\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute() {\n      return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);\n    }\n  }, {\n    key: \"initModels\",\n    value: function () {\n      var _initModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.buildModels());\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function initModels() {\n        return _initModels.apply(this, arguments);\n      }\n      return initModels;\n    }()\n  }, {\n    key: \"buildModels\",\n    value: function () {\n      var _buildModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _ref3, _ref3$animateOption, animateOption, _this$getShaders, frag, vert, type, model;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _ref3 = this.layer.getLayerConfig(), _ref3$animateOption = _ref3.animateOption, animateOption = _ref3$animateOption === void 0 ? {\n                enable: false\n              } : _ref3$animateOption;\n              _this$getShaders = this.getShaders(animateOption), frag = _this$getShaders.frag, vert = _this$getShaders.vert, type = _this$getShaders.type;\n              this.layer.triangulation = PointFillTriangulation;\n              this.initUniformsBuffer();\n              _context2.next = 6;\n              return this.layer.buildLayerModel({\n                moduleName: type,\n                vertexShader: vert,\n                fragmentShader: frag,\n                inject: this.getInject(),\n                triangulation: PointFillTriangulation,\n                depth: {\n                  enable: false\n                }\n              });\n            case 6:\n              model = _context2.sent;\n              return _context2.abrupt(\"return\", [model]);\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function buildModels() {\n        return _buildModels.apply(this, arguments);\n      }\n      return buildModels;\n    }()\n    /**\n     * 根据 animateOption 的值返回对应的 shader 代码\n     * @returns\n     */\n  }, {\n    key: \"getShaders\",\n    value: function getShaders(animateOption) {\n      return {\n        frag: pointFillFrag,\n        vert: pointFillVert,\n        type: 'pointFill'\n      };\n    }\n\n    // overwrite baseModel func\n  }, {\n    key: \"animateOption2Array\",\n    value: function animateOption2Array(option) {\n      return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      // 注册 Style 参与数据映射的内置属性\n      var shape2d = this.layer.getLayerConfig().shape2d;\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'extrude',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Extrude',\n          shaderLocation: ShaderLocation.EXTRUDE,\n          buffer: {\n            // give the WebGL driver a hint that this buffer may change\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 3,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];\n            var extrudeIndex = attributeIdx % 4 * 3;\n            return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];\n          }\n        }\n      });\n\n      // point layer size;\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          shaderLocation: ShaderLocation.SIZE,\n          buffer: {\n            // give the WebGL driver a hint that this buffer may change\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature) {\n            var _feature$size = feature.size,\n              size = _feature$size === void 0 ? 5 : _feature$size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n\n      // point layer shape;\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'shape',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Shape',\n          shaderLocation: ShaderLocation.SHAPE,\n          buffer: {\n            // give the WebGL driver a hint that this buffer may change\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature) {\n            var _feature$shape = feature.shape,\n              shape = _feature$shape === void 0 ? 2 : _feature$shape;\n            var shapeIndex = shape2d.indexOf(shape);\n            return [shapeIndex];\n          }\n        }\n      });\n    }\n  }]);\n  return FillModel;\n}(BaseModel);\nexport { FillModel as default };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}