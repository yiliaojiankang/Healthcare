{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _tslib = require(\"tslib\");\nvar _floydWarshall = _interopRequireDefault(require(\"./floydWarshall\"));\nvar _gSpan = _interopRequireDefault(require(\"./gSpan/gSpan\"));\nvar _dijkstra = _interopRequireDefault(require(\"./dijkstra\"));\nvar _util = require(\"./util\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * 为 graphData 中每个节点生成邻居单元数组\n * @param graphData\n * @param spm\n * @param nodeLabelProp\n * @param k k-近邻\n */\nvar findKNeighborUnits = function findKNeighborUnits(graphData, spm, nodeLabelProp, k) {\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n  if (k === void 0) {\n    k = 2;\n  }\n  var units = [];\n  var nodes = graphData.nodes;\n  spm.forEach(function (row, i) {\n    units.push(findKNeighborUnit(nodes, row, i, nodeLabelProp, k));\n  });\n  return units;\n};\nvar findKNeighborUnit = function findKNeighborUnit(nodes, row, i, nodeLabelProp, k) {\n  var unitNodeIdxs = [i];\n  var neighbors = [];\n  var labelCountMap = {};\n  row.forEach(function (v, j) {\n    if (v <= k && i !== j) {\n      unitNodeIdxs.push(j);\n      neighbors.push(nodes[j]);\n      var label = nodes[j][nodeLabelProp];\n      if (!labelCountMap[label]) labelCountMap[label] = {\n        count: 1,\n        dists: [v]\n      };else {\n        labelCountMap[label].count++;\n        labelCountMap[label].dists.push(v);\n      }\n    }\n  });\n  // 将 labelCountMap 中的 dists 按照从小到大排序，方便后面使用\n  Object.keys(labelCountMap).forEach(function (label) {\n    labelCountMap[label].dists = labelCountMap[label].dists.sort(function (a, b) {\n      return a - b;\n    });\n  });\n  return {\n    nodeIdx: i,\n    nodeId: nodes[i].id,\n    nodeIdxs: unitNodeIdxs,\n    neighbors: neighbors,\n    neighborNum: unitNodeIdxs.length - 1,\n    nodeLabelCountMap: labelCountMap\n  };\n};\n/**\n * 随机寻找点对，满足距离小于 k\n * @param k 参数 k，表示 k-近邻\n * @param nodeNum 参数 length\n * @param maxNodePairNum 寻找点对的数量不超过 maxNodePairNum\n * @param spm 最短路径矩阵\n */\nvar findNodePairsRandomly = function findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm) {\n  // 每个节点需要随机找出的点对数\n  var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);\n  var nodePairMap = {};\n  var foundNodePairCount = 0;\n  // 遍历节点，为每个节点随机找出 nodePairNumEachNode 个点对，满足距离小于 k。找到的点对数量超过 maxNodePairNum 或所有节点遍历结束时终止\n  kNeighborUnits.forEach(function (unit, i) {\n    // 若未达到 nodePairNumEachNode，或循环次数小于最大循环次数(2 * nodeNum)，继续循环\n    var nodePairForICount = 0;\n    var outerLoopCount = 0;\n    var neighbors = unit.nodeIdxs; // the first one is the center node\n    var neighborNum = unit.neighborNum - 1;\n    while (nodePairForICount < nodePairNumEachNode) {\n      // 另一端节点在节点数组中的的 index\n      var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];\n      var innerLoopCount = 0;\n      // 若随机得到的另一端 idx 不符合条件，则继续 random。条件是不是同一个节点、这个点对没有被记录过、距离小于 k\n      while (nodePairMap[\"\".concat(i, \"-\").concat(oidx)] || nodePairMap[\"\".concat(oidx, \"-\").concat(i)]) {\n        oidx = Math.floor(Math.random() * nodeNum);\n        innerLoopCount++;\n        if (innerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n      }\n\n      if (innerLoopCount < 2 * nodeNum) {\n        // 未达到最大循环次数，说明找到了合适的另一端\n        nodePairMap[\"\".concat(i, \"-\").concat(oidx)] = {\n          start: i,\n          end: oidx,\n          distance: spm[i][oidx]\n        };\n        nodePairForICount++;\n        foundNodePairCount++;\n        // 如果当前找到的点对数量达到了上限，返回结果\n        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;\n      }\n      outerLoopCount++;\n      if (outerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n    }\n    // 这个节点没有找到足够 nodePairNumEachNode 的点对。更新 nodePairNumEachNode，让后续节点找更多的点对\n    if (nodePairForICount < nodePairNumEachNode) {\n      var gap = nodePairNumEachNode - nodePairForICount;\n      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i - 1);\n    }\n  });\n  return nodePairMap;\n};\n/**\n * 计算所有 nodePairMap 中节点对的相交邻居诱导子图\n * @param nodePairMap 节点对 map，key 为 node1.id-node2.id，value 为 { startNodeIdx, endNodeIdx, distance }\n * @param neighborUnits 每个节点的邻居元数组\n * @param graphData 原图数据\n * @param edgeMap 边的 map，方便检索\n * @param cachedInducedGraphMap 缓存的结果，下次进入该函数将继续更新该缓存，若 key 在缓存中存在则不需要重复计算\n */\nvar getIntersectNeighborInducedGraph = function getIntersectNeighborInducedGraph(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {\n  var nodes = graphData.nodes;\n  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};\n  Object.keys(nodePairMap).forEach(function (key) {\n    var _a, _b;\n    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;\n    cachedInducedGraphMap[key] = {\n      nodes: [],\n      edges: []\n    };\n    var pair = nodePairMap[key];\n    var startUnitNodeIds = (_a = neighborUnits[pair.start]) === null || _a === void 0 ? void 0 : _a.nodeIdxs;\n    var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;\n    if (!startUnitNodeIds || !endUnitNodeIds) return; // 不存在邻元，返回空图\n    var endSet = new Set(endUnitNodeIds);\n    var intersect = startUnitNodeIds.filter(function (x) {\n      return endSet.has(x);\n    }); // 可能会爆栈（在 1580 + 6 nodes full-connected 时出现）\n    if (!intersect || !intersect.length) return; // 没有交集，返回空图\n    var intersectIdMap = {};\n    var intersectLength = intersect.length;\n    for (var i = 0; i < intersectLength; i++) {\n      var node = nodes[intersect[i]];\n      cachedInducedGraphMap[key].nodes.push(node); // 将交集中的点加入诱导子图\n      intersectIdMap[node.id] = true;\n    }\n    // 遍历所有边数据，如果边的两端都在交集中，将该边加入诱导子图\n    graphData.edges.forEach(function (edge) {\n      if (intersectIdMap[edge.source] && intersectIdMap[edge.target]) cachedInducedGraphMap[key].edges.push(edge);\n    });\n  });\n  return cachedInducedGraphMap;\n};\n/**\n * 计算 strcutre 在 graph 上的匹配数量\n * @param graph 图数据\n * @param structure 目前支持只有两个节点一条边的最简单结构\n * @param nodeLabelProp 节点类型字段名\n * @param edgeLabelProp 边类型字段名\n */\nvar getMatchedCount = function getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp) {\n  var _a, _b;\n  var nodeMap = {};\n  graph.nodes.forEach(function (node) {\n    nodeMap[node.id] = node;\n  });\n  var count = 0;\n  if (!((_a = structure === null || structure === void 0 ? void 0 : structure.edges) === null || _a === void 0 ? void 0 : _a.length) || ((_b = structure === null || structure === void 0 ? void 0 : structure.nodes) === null || _b === void 0 ? void 0 : _b.length) < 2) return 0;\n  graph.edges.forEach(function (e) {\n    var sourceLabel = nodeMap[e.source][nodeLabelProp];\n    var targetLabel = nodeMap[e.target][nodeLabelProp];\n    var strNodeLabel1 = structure === null || structure === void 0 ? void 0 : structure.nodes[0][nodeLabelProp];\n    var strNodeLabel2 = structure === null || structure === void 0 ? void 0 : structure.nodes[1][nodeLabelProp];\n    var strEdgeLabel = structure === null || structure === void 0 ? void 0 : structure.edges[0][edgeLabelProp];\n    if (e[edgeLabelProp] !== strEdgeLabel) return;\n    if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {\n      count++;\n    }\n  });\n  return count;\n};\n/**\n * structures 中寻找最具有代表性的一个。这个结构是使得 matchedCountMap 的分组方式类内间距最小，类间间距最大\n * @param matchedCountMap 每个 structure 分类后的各图匹配数量，格式 { [strcture.idx]: { [interInducedGraphKey]: count } }\n * @param structureNum strcuture 个数，与 matchedCountMap.length 对应\n * @param structures\n */\nvar findRepresentStructure = function findRepresentStructure(matchedCountMap, structureNum, structures) {\n  var maxOffset = Infinity,\n    representClusterType = 0;\n  var _loop_1 = function _loop_1(i) {\n    // 一种分组的 map，key 是 intGraph 的 key，value 是 structures[i] 的匹配个数\n    var countMapI = matchedCountMap[i];\n    // 按照 value 为该组排序，生成 keys 的数组：\n    var sortedGraphKeys = Object.keys(countMapI).sort(function (a, b) {\n      return countMapI[a] - countMapI[b];\n    });\n    // 共 100 个 graphKeys，将 graphKeys 按顺序分为 groupNum 组\n    var groupNum = 10;\n    var clusters = []; // 总共有 groupNum 个项\n    sortedGraphKeys.forEach(function (key, j) {\n      if (!clusters[j % groupNum]) clusters[j % groupNum] = {\n        graphs: [],\n        totalCount: 0,\n        aveCount: 0\n      };\n      clusters[j % groupNum].graphs.push(key);\n      clusters[j % groupNum].totalCount += countMapI[key];\n    });\n    // 计算 cluster 与 cluster 之间的距离 innerDist，每个 cluster 内部的距离 intraDist\n    var aveIntraDist = 0; // 该类的类内平均值\n    var aveCounts = []; // 类内平均匹配数量，将用于计算类间距离\n    clusters.forEach(function (graphsInCluster) {\n      // 类内均值\n      var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;\n      graphsInCluster.aveCount = aveCount;\n      aveCounts.push(aveCount);\n      // 对于每类，计算类内间距平均值\n      var aveIntraPerCluster = 0;\n      var graphsNum = graphsInCluster.length;\n      graphsInCluster.graphs.forEach(function (graphKey1, j) {\n        var graph1Count = countMapI[graphKey1];\n        graphsInCluster.graphs.forEach(function (graphKey2, k) {\n          if (j === k) return;\n          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);\n        });\n      });\n      aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;\n      aveIntraDist += aveIntraPerCluster;\n    });\n    aveIntraDist /= clusters.length;\n    // 用类内均值计算类间距\n    var aveInterDist = 0; // 类间间距平均值\n    aveCounts.forEach(function (aveCount1, j) {\n      aveCounts.forEach(function (aveCount2, k) {\n        if (j === k) return;\n        aveInterDist += Math.abs(aveCount1 - aveCount2);\n      });\n      aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;\n    });\n    // 寻找 (类间间距均值-类内间距均值) 最大的一种分组方式（对应的 structure 就是最终要找的唯一 DS(G)）\n    var offset = aveInterDist - aveIntraDist;\n    if (maxOffset < offset) {\n      maxOffset = offset;\n      representClusterType = i;\n    }\n  };\n  for (var i = 0; i < structureNum; i++) {\n    _loop_1(i);\n  }\n  return {\n    structure: structures[representClusterType],\n    structureCountMap: matchedCountMap[representClusterType]\n  };\n};\nvar getNodeMaps = function getNodeMaps(nodes, nodeLabelProp) {\n  var nodeMap = {},\n    nodeLabelMap = {};\n  nodes.forEach(function (node, i) {\n    nodeMap[node.id] = {\n      idx: i,\n      node: node,\n      degree: 0,\n      inDegree: 0,\n      outDegree: 0\n    };\n    var label = node[nodeLabelProp];\n    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];\n    nodeLabelMap[label].push(node);\n  });\n  return {\n    nodeMap: nodeMap,\n    nodeLabelMap: nodeLabelMap\n  };\n};\nvar getEdgeMaps = function getEdgeMaps(edges, edgeLabelProp, nodeMap) {\n  var edgeMap = {},\n    edgeLabelMap = {};\n  edges.forEach(function (edge, i) {\n    edgeMap[\"\".concat(_util.uniqueId)] = {\n      idx: i,\n      edge: edge\n    };\n    var label = edge[edgeLabelProp];\n    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];\n    edgeLabelMap[label].push(edge);\n    var sourceNode = nodeMap[edge.source];\n    if (sourceNode) {\n      sourceNode.degree++;\n      sourceNode.outDegree++;\n    }\n    var targetNode = nodeMap[edge.target];\n    if (targetNode) {\n      targetNode.degree++;\n      targetNode.inDegree++;\n    }\n  });\n  return {\n    edgeMap: edgeMap,\n    edgeLabelMap: edgeLabelMap\n  };\n};\n/**\n * 输出最短路径的 map，key 为 sourceNode.id-targetNode.id，value 为这两个节点的最短路径长度\n * @param nodes\n * @param spm\n * @param directed\n */\nvar getSpmMap = function getSpmMap(nodes, spm, directed) {\n  var length = spm.length;\n  var map = {};\n  spm.forEach(function (row, i) {\n    var start = directed ? 0 : i + 1;\n    var iId = nodes[i].id;\n    for (var j = start; j < length; j++) {\n      if (i === j) continue;\n      var jId = nodes[j].id;\n      var dist = row[j];\n      map[\"\".concat(iId, \"-\").concat(jId)] = dist;\n      if (!directed) map[\"\".concat(jId, \"-\").concat(iId)] = dist;\n    }\n  });\n  return map;\n};\n/**\n * 计算一对节点（node1，node2）的 NDS 距离\n * @param graph 原图数据\n * @param node1\n * @param node2\n */\nvar getNDSDist = function getNDSDist(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {\n  var _a;\n  var key = \"\".concat(node1.id, \"-\").concat(node2.id);\n  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];\n  var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : undefined;\n  // 若没有缓存相交邻居诱导子图，计算\n  if (!interInducedGraph) {\n    var pairMap = (_a = {}, _a[key] = {\n      start: nodeMap[node1.id].idx,\n      end: nodeMap[node2.id].idx,\n      distance: spDist\n    }, _a);\n    cachedInterInducedGraph = getIntersectNeighborInducedGraph(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);\n    interInducedGraph = cachedInterInducedGraph[key];\n  }\n  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);\n};\n/**\n * 计算 pattern 上绩点的度数并存储到 minPatternNodeLabelDegreeMap\n */\nvar stashPatternNodeLabelDegreeMap = function stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap) {\n  var _a, _b, _c;\n  var minPatternNodeLabelDegree = (_a = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _a === void 0 ? void 0 : _a.degree;\n  var minPatternNodeLabelInDegree = (_b = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _b === void 0 ? void 0 : _b.inDegree;\n  var minPatternNodeLabelOutDegree = (_c = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _c === void 0 ? void 0 : _c.outDegree;\n  if (minPatternNodeLabelDegreeMap[neighborLabel] === undefined) {\n    minPatternNodeLabelDegree = Infinity;\n    minPatternNodeLabelInDegree = Infinity;\n    minPatternNodeLabelOutDegree = Infinity;\n    patternNodeLabelMap[neighborLabel].forEach(function (patternNodeWithLabel) {\n      var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;\n      if (minPatternNodeLabelDegree > patternNodeDegree) minPatternNodeLabelDegree = patternNodeDegree;\n      var patternNodeInDegree = patternNodeMap[patternNodeWithLabel.id].inDegree;\n      if (minPatternNodeLabelInDegree > patternNodeInDegree) minPatternNodeLabelInDegree = patternNodeInDegree;\n      var patternNodeOutDegree = patternNodeMap[patternNodeWithLabel.id].outDegree;\n      if (minPatternNodeLabelOutDegree > patternNodeOutDegree) minPatternNodeLabelOutDegree = patternNodeOutDegree;\n    });\n    minPatternNodeLabelDegreeMap[neighborLabel] = {\n      degree: minPatternNodeLabelDegree,\n      inDegree: minPatternNodeLabelInDegree,\n      outDegree: minPatternNodeLabelOutDegree\n    };\n  }\n  return {\n    minPatternNodeLabelDegree: minPatternNodeLabelDegree,\n    minPatternNodeLabelInDegree: minPatternNodeLabelInDegree,\n    minPatternNodeLabelOutDegree: minPatternNodeLabelOutDegree\n  };\n};\n/**\n * GADDI 模式匹配\n * @param graphData 原图数据\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\n * @param directed 是否计算有向图，默认 false\n * @param k 参数 k，表示 k-近邻\n * @param length 参数 length\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\n */\nvar GADDI = function GADDI(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\n  var _a;\n  if (directed === void 0) {\n    directed = false;\n  }\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n  if (edgeLabelProp === void 0) {\n    edgeLabelProp = 'cluster';\n  }\n  if (!graphData || !graphData.nodes) return;\n  // 分为三步：\n  // 0. 预计算：节点/边数，邻接矩阵、最短路径矩阵\n  // 1. 处理原图 graphData。再分为 1~5 小步\n  // 2. 匹配\n  // console.log(\"----- stage-pre: preprocessing -------\");\n  // -------- 第零步，预计算：节点/边数，邻接矩阵、最短路径矩阵-------\n  var nodeNum = graphData.nodes.length;\n  if (!nodeNum) return;\n  // console.log(\"----- stage-pre.1: calc shortest path matrix for graph -------\");\n  var spm = (0, _floydWarshall.default)(graphData, directed);\n  // console.log(\n  //   \"----- stage-pre.2: calc shortest path matrix for pattern -------\"\n  // );\n  var patternSpm = (0, _floydWarshall.default)(pattern, directed);\n  // console.log(\n  //   \"----- stage-pre.3: calc shortest path matrix map for graph -------\"\n  // );\n  var spmMap = getSpmMap(graphData.nodes, spm, directed);\n  // console.log(\n  //   \"----- stage-pre.4: calc shortest path matrix map for pattern -------\"\n  // );\n  var patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed);\n  // console.log(\"----- stage-pre.5: establish maps -------\");\n  // 节点的 map，以 id 为 id 映射，方便后续快速检索\n  var _b = getNodeMaps(graphData.nodes, nodeLabelProp),\n    nodeMap = _b.nodeMap,\n    nodeLabelMap = _b.nodeLabelMap;\n  var _c = getNodeMaps(pattern.nodes, nodeLabelProp),\n    patternNodeMap = _c.nodeMap,\n    patternNodeLabelMap = _c.nodeLabelMap;\n  // 计算节点度数\n  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);\n  var patternEdgeLabelMap = getEdgeMaps(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap;\n  // 若未指定 length，自动计算 pattern 半径（最短路径最大值）\n  var patternSpmSpread = [];\n  patternSpm === null || patternSpm === void 0 ? void 0 : patternSpm.forEach(function (row) {\n    patternSpmSpread = patternSpmSpread.concat(row);\n  });\n  if (!length) length = Math.max.apply(Math, (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], patternSpmSpread, false), [2], false));\n  if (!k) k = length;\n  // console.log(\"params\", directed, length, k);\n  // console.log(\"----- stage-pre.6: calc k neighbor units -------\");\n  // 计算每个节点的 k 邻元集合\n  var kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k);\n  var patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k);\n  // console.log(\n  //   \"----- stage0: going to processing graph and find intersect neighbor induced graphs -------\"\n  // );\n  // console.log(\"----- stage0.1: going to select random node pairs -------\");\n  // -------- 第一步，处理原图 graphData-------\n  // 1.1. 随机选择最多 100 个点对，满足距离小于 Length 和 k\n  // 当 graphData 少于 20 个节点，则不能找出 100 个点对，只找出不多于 n(n-1)/2 个点对\n  var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);\n  var nodePairsMap = findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm);\n  // console.log(\n  //   \"----- stage0.2: going to calculate intersect neighbor induced graphs -------\"\n  // );\n  // 1.2. 生成上面节点对的相应相交邻居诱导子图。格式为 {'beginNodeIdx-endNodeIdx': {nodes: [], edges: []}}\n  var intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData);\n  // 1.3. 使用 gSpan 算法（frequent graph mining）计算 ISIntG 的前 10 个频率最高的子结构（3-4条边）\n  var top = 10,\n    minSupport = 1,\n    minNodeNum = 1,\n    maxNodeNum = 4;\n  var params = {\n    graphs: intGMap,\n    nodeLabelProp: nodeLabelProp,\n    edgeLabelProp: edgeLabelProp,\n    minSupport: minSupport,\n    minNodeNum: minNodeNum,\n    maxNodeNum: maxNodeNum,\n    directed: directed\n  };\n  // console.log(\n  //   \"----- stage1: (gSpan) going to find frequent structure dsG -------\"\n  // );\n  // console.log(\"----- stage1.1: going to run gSpan -------\");\n  // 暂时假设生成的 sub structure 都只有一条边\n  var freStructures = (0, _gSpan.default)(params).slice(0, top);\n  // structureNum 可能小于 top\n  var structureNum = freStructures.length;\n  // 1.4. 计算上述 10 个子结构在 intGMap 中每个诱导子图的匹配个数\n  var matchedCountMap = [];\n  freStructures.forEach(function (structure, i) {\n    matchedCountMap[i] = {};\n    Object.keys(intGMap).forEach(function (key) {\n      var graph = intGMap[key];\n      var subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);\n      matchedCountMap[i][key] = subStructureCount;\n    });\n  });\n  // console.log(\n  //   \"----- stage1.1: going to find the most represent strucutre -------\"\n  // );\n  // 1.5. 对于每个子结构，根据匹配个数为 intGMap 中的诱导子图分组，生成 structureNum 种分组\n  // 计算每种分组的类间距和类内间距，找到类间距最大、类内间距最小的一种分组，这种分组对应的子结构被选为唯一代表性子结构 DS(G)\n  var _d = findRepresentStructure(matchedCountMap, structureNum, freStructures),\n    dsG = _d.structure,\n    ndsDist = _d.structureCountMap;\n  // -------- 第二步，匹配-------\n  // 2.1 找到从 Q 中的一个节点作为起始节点，寻找 G 中的匹配。这个其实节点的标签可以在 G 中找到最多的节点\n  var beginPNode = pattern.nodes[0],\n    candidates = [],\n    label = (_a = pattern.nodes[0]) === null || _a === void 0 ? void 0 : _a[nodeLabelProp],\n    maxNodeNumWithSameLabel = -Infinity;\n  pattern.nodes.forEach(function (node) {\n    var pLabel = node[nodeLabelProp];\n    var nodesWithSameLabel = nodeLabelMap[pLabel];\n    if ((nodesWithSameLabel === null || nodesWithSameLabel === void 0 ? void 0 : nodesWithSameLabel.length) > maxNodeNumWithSameLabel) {\n      maxNodeNumWithSameLabel = nodesWithSameLabel.length;\n      candidates = nodesWithSameLabel;\n      label = pLabel;\n      beginPNode = node;\n    }\n  });\n  // console.log(\"----- stage2: going to find candidates -------\");\n  // 全局缓存，避免重复计算\n  var minPatternNodeLabelDegreeMap = {}; // key 是 label，value 是该 label 节点的最小度数\n  var patternIntGraphMap = {},\n    patternNDSDist = {},\n    // key 为 node.id-node.id\n    patternNDSDistMap = {}; // key 为 node.id-label2，value nds距离值数组（按从大到小排序，无需关心具体对应哪个 node2）\n  // 2.2.2 对于 Q 中的另一个标签的 k 个节点，计算它们到 node 的最短路径以及 NDS 距离\n  var patternSpDist = {};\n  var patternSpDistBack = {};\n  Object.keys(patternNodeLabelMap).forEach(function (label2, j) {\n    patternSpDist[label2] = [];\n    if (directed) {\n      patternSpDistBack[label2] = [];\n    }\n    var maxDist = -Infinity;\n    var patternNodesWithLabel2 = patternNodeLabelMap[label2];\n    var patternNodePairMap = {};\n    patternNodesWithLabel2.forEach(function (nodeWithLabel2) {\n      var dist = patternSpmMap[\"\".concat(beginPNode.id, \"-\").concat(nodeWithLabel2.id)];\n      dist && patternSpDist[label2].push(dist);\n      if (maxDist < dist) maxDist = dist;\n      patternNodePairMap[\"\".concat(beginPNode.id, \"-\").concat(nodeWithLabel2.id)] = {\n        start: 0,\n        end: patternNodeMap[nodeWithLabel2.id].idx,\n        distance: dist\n      };\n      if (directed) {\n        var distBack = patternSpmMap[\"\".concat(nodeWithLabel2.id, \"-\").concat(beginPNode.id)];\n        distBack && patternSpDistBack[label2].push(distBack);\n      }\n    });\n    // spDist[label2] 按照从小到大排序\n    patternSpDist[label2] = patternSpDist[label2].sort(function (a, b) {\n      return a - b;\n    });\n    if (directed) patternSpDistBack[label2] = patternSpDistBack[label2].sort(function (a, b) {\n      return a - b;\n    });\n    // 计算 Q 中所有 label2 节点到 beginPNode 的 NDS 距离\n    // 所有 label2 节点到 beginPNode 的邻居相交诱导子图：\n    // key: node1.id-node2.id\n    patternIntGraphMap = getIntersectNeighborInducedGraph(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap);\n    // pattern 中 beginNode 到当前 label2 节点 的 NDS 距离（数组，无需关心具体对应到哪个节点）\n    var currentPatternNDSDistArray = [];\n    Object.keys(patternNodePairMap).forEach(function (key) {\n      if (patternNDSDist[key]) {\n        currentPatternNDSDistArray.push(patternNDSDist[key]);\n        return; // 缓存过则不需要再次计算\n      }\n\n      var patternIntGraph = patternIntGraphMap[key];\n      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);\n      currentPatternNDSDistArray.push(patternNDSDist[key]);\n    });\n    // 根据值为 currentPatternNDSDist 从大到小排序\n    currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function (a, b) {\n      return b - a;\n    });\n    patternNDSDistMap[\"\".concat(beginPNode.id, \"-\").concat(label2)] = currentPatternNDSDistArray;\n    if (label2 === label) return;\n    var candidatesNum = (candidates === null || candidates === void 0 ? void 0 : candidates.length) || 0;\n    var _loop_4 = function _loop_4(m) {\n      var cNode = candidates[m];\n      // prune1：若 candidates 中节点 cNode 的 kNeighborUnits 中标签为 label2 的节点个数少于 pattern 中 label2 个数，删去它\n      var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];\n      var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];\n      var patternLabel2Num = patternNodeLabelMap[label2].length;\n      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      }\n      // prune2：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点最短路径大于 patternSpDist[label2]，删去它\n      // (prune2 规则即：candidate 相关的最短路径的最大 spDist[label2].length 个，按照大小顺序依次和 patternSpDist[label2] 中的值比较，只要遇到一个是 G > Q 的，就删去这个 candidate)\n      var prune2Invalid = false;\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (graphNeighborUnitCountMap.dists[n] > patternSpDist[label2][n]) {\n          prune2Invalid = true;\n          break;\n        }\n      }\n      if (prune2Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      }\n      // prune3：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点 NDS 距离小于 patternNDSDist[beginNode.id-label2]，删去它\n      // TODO：prune3，currentPatternNDSDistArray 与 currentNDSDist 的比较\n      // 计算 G 中所有 label2 节点到 cNode 的 NDS 距离\n      // 所有 label2 节点到 cNode 的邻居相交诱导子图：\n      var cNodePairMap = {};\n      graphNeighborUnit.neighbors.forEach(function (neighborNode) {\n        var dist = spmMap[\"\".concat(cNode.id, \"-\").concat(neighborNode.id)];\n        cNodePairMap[\"\".concat(cNode.id, \"-\").concat(neighborNode.id)] = {\n          start: nodeMap[cNode.id].idx,\n          end: nodeMap[neighborNode.id].idx,\n          distance: dist\n        };\n      });\n      // 更新 intGMap\n      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap);\n      // candidate 到它周围 label2 节点的 NDS 距离, key 是 node.id-node.id\n      var currentNDSDistArray = [];\n      Object.keys(cNodePairMap).forEach(function (key) {\n        if (ndsDist[key]) {\n          currentNDSDistArray.push(ndsDist[key]);\n          return; // 缓存过则不需要再次计算\n        }\n\n        var intGraph = intGMap[key];\n        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);\n        currentNDSDistArray.push(ndsDist[key]);\n      });\n      // 根据值为 currentNDSDistArray 从大到小排序\n      currentNDSDistArray = currentNDSDistArray.sort(function (a, b) {\n        return b - a;\n      });\n      var prune3Invalid = false;\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (currentNDSDistArray[n] < currentPatternNDSDistArray[n]) {\n          prune3Invalid = true;\n          break;\n        }\n      }\n      if (prune3Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      }\n    };\n    for (var m = candidatesNum - 1; m >= 0; m--) {\n      _loop_4(m);\n    }\n  });\n  var candidateGraphs = [];\n  // console.log(\n  //   \"----- stage3: going to splice neighbors for each candidate graph -------\"\n  // );\n  // candidates 经过筛选后，以每个 candidate 为中心，生成 Length-neighbor 的邻居诱导子图\n  // 并在诱导子图中去除不可能在 Q 上找到匹配的点：在 Q 上不存在的 label，其他 label 到 candidate 的最大最短距离符合 Q、NDS 距离符合 Q\n  candidates === null || candidates === void 0 ? void 0 : candidates.forEach(function (candidate) {\n    var nodeIdx = nodeMap[candidate.id].idx;\n    var lengthNeighborUnit = findKNeighborUnit(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length);\n    var neighborNodes = lengthNeighborUnit.neighbors;\n    // 删除不可能找到匹配的邻居点\n    var neighborNum = neighborNodes.length;\n    var unmatched = false;\n    for (var i = neighborNum - 1; i >= 0; i--) {\n      // 如果通过裁剪，符合条件的节点数量已过少，说明不能匹配这个 candidate 相关的图\n      if (neighborNodes.length + 1 < pattern.nodes.length) {\n        unmatched = true;\n        return;\n      }\n      var neighborNode = neighborNodes[i];\n      var neighborLabel = neighborNode[nodeLabelProp];\n      // prune1: 若该邻居点的 label 不存在于 pattern 中，移除这个点\n      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n      // prune2: 若该邻居点到 candidate 的最短路径比和它有相同 label 的节点到 beginPNode 的最大最短路径长度长，移除这个点\n      // prune2.1: 如果没有这个标签到 beginPNode 的距离记录，说明 pattern 上（可能 beginPNode 是这个 label）没有其他这个 label 的节点\n      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n      var key = \"\".concat(candidate.id, \"-\").concat(neighborNode.id);\n      // prune2.2\n      var distToCandidate = spmMap[key];\n      var idx = patternSpDist[neighborLabel].length - 1;\n      var maxDistWithLabelInPattern = patternSpDist[neighborLabel][idx]; // patternSpDist[neighborLabel] 已经按照从小到大排序\n      if (distToCandidate > maxDistWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n      if (directed) {\n        var keyBack = \"\".concat(neighborNode.id, \"-\").concat(candidate.id);\n        var distFromCandidate = spmMap[keyBack];\n        idx = patternSpDistBack[neighborLabel].length - 1;\n        var maxBackDistWithLabelInPattern = patternSpDistBack[neighborLabel][idx];\n        if (distFromCandidate > maxBackDistWithLabelInPattern) {\n          neighborNodes.splice(i, 1);\n          continue;\n        }\n      }\n      // prune3: 若该邻居点到 candidate 的 NDS 距离比和它有相同 label 的节点到 beginPNode 的最小 NDS 距离小，移除这个点\n      var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);\n      var patternKey = \"\".concat(beginPNode.id, \"-\").concat(neighborLabel);\n      var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1]; // patternNDSDist[key] 一定存在\n      if (ndsToCandidate < minNdsWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n      // prune4: 若该邻居点的度数小于 pattern 同 label 节点最小度数，删去该点\n      var _a = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap),\n        minPatternNodeLabelDegree = _a.minPatternNodeLabelDegree,\n        minPatternNodeLabelInDegree = _a.minPatternNodeLabelInDegree,\n        minPatternNodeLabelOutDegree = _a.minPatternNodeLabelOutDegree;\n      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n    }\n    // 节点在个数上符合匹配（不少于 pattern 的节点个数），现在筛选相关边\n    if (!unmatched) {\n      candidateGraphs.push({\n        nodes: [candidate].concat(neighborNodes)\n      });\n    }\n  });\n  // console.log(\n  //   \"----- stage4: going to splice edges and neighbors for each candidate graph -------\"\n  // );\n  var undirectedLengthsToBeginPNode = (0, _dijkstra.default)(pattern, beginPNode.id, false).length;\n  var undirectedLengthsToBeginPNodeLabelMap = {};\n  if (directed) {\n    Object.keys(undirectedLengthsToBeginPNode).forEach(function (nodeId) {\n      var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];\n      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel]) undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];else undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);\n    });\n    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function (pLabel) {\n      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function (a, b) {\n        return a - b;\n      });\n    });\n  } else {\n    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;\n  }\n  // 现在 candidateGraphs 里面只有节点，进行边的筛选\n  var candidateGraphNum = candidateGraphs.length;\n  var _loop_2 = function _loop_2(i) {\n    var candidateGraph = candidateGraphs[i];\n    var candidate = candidateGraph.nodes[0];\n    var candidateNodeLabelCountMap = {};\n    var candidateNodeMap = {};\n    candidateGraph.nodes.forEach(function (node, q) {\n      candidateNodeMap[node.id] = {\n        idx: q,\n        node: node,\n        degree: 0,\n        inDegree: 0,\n        outDegree: 0\n      };\n      var cNodeLabel = node[nodeLabelProp];\n      if (!candidateNodeLabelCountMap[cNodeLabel]) candidateNodeLabelCountMap[cNodeLabel] = 1;else candidateNodeLabelCountMap[cNodeLabel]++;\n    });\n    // 根据 candidate 和 neighborNodes 中的节点生成 G 的诱导子图\n    // 即，将 graphData 上两端都在 candidateGraph.nodes 中的边放入 candidateEdges\n    var candidateEdges = [];\n    var edgeLabelCountMap = {};\n    graphData.edges.forEach(function (edge) {\n      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {\n        candidateEdges.push(edge);\n        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;else edgeLabelCountMap[edge[edgeLabelProp]]++;\n        candidateNodeMap[edge.source].degree++;\n        candidateNodeMap[edge.target].degree++;\n        candidateNodeMap[edge.source].outDegree++;\n        candidateNodeMap[edge.target].inDegree++;\n      }\n    });\n    // prune：若有一个 edgeLabel 在 candidateGraph 上的个数少于 pattern，去除该图\n    var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;\n    var prunedByEdgeLabel = false;\n    for (var e = 0; e < pattenrEdgeLabelNum; e++) {\n      var label_1 = Object.keys(patternEdgeLabelMap)[e];\n      if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {\n        prunedByEdgeLabel = true;\n        break;\n      }\n    }\n    if (prunedByEdgeLabel) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n    // 遍历 candidateEdges，进行边的筛选\n    var candidateEdgeNum = candidateEdges.length;\n    // prune：若边数过少，去除该图\n    if (candidateEdgeNum < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"break\";\n    }\n    var candidateGraphInvalid = false;\n    var _loop_5 = function _loop_5(e) {\n      var edge = candidateEdges[e];\n      var edgeLabel = edge[edgeLabelProp];\n      var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel];\n      // prune 1: 若边的 label 不存在于 pattern 边 label 中，去除该边\n      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {\n        edgeLabelCountMap[edgeLabel]--;\n        // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        candidateNodeMap[edge.source].outDegree--;\n        candidateNodeMap[edge.target].inDegree--;\n        return \"continue\";\n      }\n      // prune 2: 若边的 label +两端 label 的三元组关系不能在 pattern 中找到，去除该边\n      var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];\n      var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];\n      var edgeMatched = false;\n      patternEdgesWithLabel.forEach(function (patternEdge) {\n        var patternSource = patternNodeMap[patternEdge.source].node;\n        var patternTarget = patternNodeMap[patternEdge.target].node;\n        if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel) edgeMatched = true;\n        if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel) edgeMatched = true;\n      });\n      if (!edgeMatched) {\n        edgeLabelCountMap[edgeLabel]--;\n        // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        candidateNodeMap[edge.source].outDegree--;\n        candidateNodeMap[edge.target].inDegree--;\n        return \"continue\";\n      }\n    };\n    for (var e = candidateEdgeNum - 1; e >= 0; e--) {\n      var state_2 = _loop_5(e);\n      if (state_2 === \"break\") break;\n    }\n    // prune2: 删除边的过程中，发现边数过少/边 label 数过少时，去除该图\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n    candidateGraph.edges = candidateEdges;\n    var lengthsToCandidate = (0, _dijkstra.default)(candidateGraph, candidateGraph.nodes[0].id, false).length;\n    Object.keys(lengthsToCandidate).reverse().forEach(function (targetId) {\n      if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return;\n      // prune4: 通过上述裁剪，可能导致该邻居子图变为不连通。裁剪掉目前在这个邻居子图中和 candidate（第一个节点）不连通的节点\n      if (lengthsToCandidate[targetId] === Infinity) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n        return;\n      }\n      // prune5: 经过边裁剪后，可能又出现了最短路径过长的节点 （比 pattern 中同 label 的节点到 beginNode 最大最短距离远），删去这些节点\n      var nLabel = nodeMap[targetId].node[nodeLabelProp];\n      if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n      }\n    });\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n    var degreeChanged = true;\n    var loopCount = 0;\n    while (degreeChanged && !candidateGraphInvalid) {\n      degreeChanged = false;\n      // candidate 度数不足，删去该图\n      var condition = directed ? candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree || candidateNodeMap[candidate.id].inDegree < patternNodeMap[beginPNode.id].inDegree || candidateNodeMap[candidate.id].outDegree < patternNodeMap[beginPNode.id].outDegree : candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree;\n      if (condition) {\n        candidateGraphInvalid = true;\n        break;\n      }\n      // candidate label 个数不足，删去该图\n      if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {\n        candidateGraphInvalid = true;\n        break;\n      }\n      // prune6：去除度数过小的节点\n      var currentCandidateNodeNum = candidateGraph.nodes.length;\n      for (var o = currentCandidateNodeNum - 1; o >= 0; o--) {\n        var cgNode = candidateGraph.nodes[o];\n        var nodeDegree = candidateNodeMap[cgNode.id].degree;\n        var nodeInDegree = candidateNodeMap[cgNode.id].inDegree;\n        var nodeOutDegree = candidateNodeMap[cgNode.id].outDegree;\n        var cNodeLabel = cgNode[nodeLabelProp];\n        var _e = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, cNodeLabel, patternNodeMap, patternNodeLabelMap),\n          minPatternNodeLabelDegree = _e.minPatternNodeLabelDegree,\n          minPatternNodeLabelInDegree = _e.minPatternNodeLabelInDegree,\n          minPatternNodeLabelOutDegree = _e.minPatternNodeLabelOutDegree;\n        var deleteCondition = directed ? nodeDegree < minPatternNodeLabelDegree || nodeInDegree < minPatternNodeLabelInDegree || nodeOutDegree < minPatternNodeLabelOutDegree : nodeDegree < minPatternNodeLabelDegree;\n        if (deleteCondition) {\n          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--;\n          // 节点 label 个数不足\n          if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n          candidateGraph.nodes.splice(o, 1);\n          candidateNodeMap[cgNode.id] = undefined;\n          degreeChanged = true;\n        }\n      }\n      if (candidateGraphInvalid || !degreeChanged && loopCount !== 0) break;\n      // 经过 prune5 节点裁剪，删去端点已经不在 candidateGraph 中的边\n      candidateEdgeNum = candidateEdges.length;\n      for (var y = candidateEdgeNum - 1; y >= 0; y--) {\n        var cedge = candidateEdges[y];\n        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {\n          candidateEdges.splice(y, 1);\n          var edgeLabel = cedge[edgeLabelProp];\n          edgeLabelCountMap[edgeLabel]--;\n          if (candidateNodeMap[cedge.source]) {\n            candidateNodeMap[cedge.source].degree--;\n            candidateNodeMap[cedge.source].outDegree--;\n          }\n          if (candidateNodeMap[cedge.target]) {\n            candidateNodeMap[cedge.target].degree--;\n            candidateNodeMap[cedge.target].inDegree--;\n          }\n          // 边 label 数量不足\n          if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n          degreeChanged = true;\n        }\n      }\n      loopCount++;\n    }\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n    // prune: 若节点/边数过少，节点/边 label 过少，去掉这个图\n    if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n  };\n  for (var i = candidateGraphNum - 1; i >= 0; i--) {\n    var state_1 = _loop_2(i);\n    if (state_1 === \"break\") break;\n  }\n  // 此时已经生成的多个 candidateGraphs，可能有重复\n  // console.log(\n  //   \"----- stage5: going to splice dulplicated candidate graphs -------\"\n  // );\n  // 删去 candidateGraphs 中一模一样的子图，通过边的 node-node-edgeLabel 作为 key，这类边个数作为 value，进行匹配\n  var currentLength = candidateGraphs.length;\n  var _loop_3 = function _loop_3(i) {\n    var cg1 = candidateGraphs[i];\n    var cg1EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n    cg1.edges.forEach(function (edge) {\n      var key = \"\".concat(edge.source, \"-\").concat(edge.target, \"-\").concat(edge.label);\n      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;else cg1EdgeMap[key]++;\n    });\n    var _loop_6 = function _loop_6(j) {\n      var cg2 = candidateGraphs[j];\n      var cg2EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n      cg2.edges.forEach(function (edge) {\n        var key = \"\".concat(edge.source, \"-\").concat(edge.target, \"-\").concat(edge.label);\n        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;else cg2EdgeMap[key]++;\n      });\n      var same = true;\n      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {\n        same = false;\n      } else {\n        Object.keys(cg1EdgeMap).forEach(function (key) {\n          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;\n        });\n      }\n      if (same) {\n        candidateGraphs.splice(j, 1);\n      }\n    };\n    for (var j = currentLength - 1; j > i; j--) {\n      _loop_6(j);\n    }\n    currentLength = candidateGraphs.length;\n  };\n  for (var i = 0; i <= currentLength - 1; i++) {\n    _loop_3(i);\n  }\n  return candidateGraphs;\n};\nvar _default = GADDI;\nexports.default = _default;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","default","_tslib","_floydWarshall","_interopRequireDefault","_gSpan","_dijkstra","_util","obj","__esModule","findKNeighborUnits","graphData","spm","nodeLabelProp","k","units","nodes","forEach","row","i","push","findKNeighborUnit","unitNodeIdxs","neighbors","labelCountMap","v","j","label","count","dists","keys","sort","a","b","nodeIdx","nodeId","id","nodeIdxs","neighborNum","length","nodeLabelCountMap","findNodePairsRandomly","nodeNum","maxNodePairNum","kNeighborUnits","nodePairNumEachNode","Math","ceil","nodePairMap","foundNodePairCount","unit","nodePairForICount","outerLoopCount","oidx","floor","random","innerLoopCount","concat","start","end","distance","gap","getIntersectNeighborInducedGraph","neighborUnits","cachedInducedGraphMap","key","_a","_b","edges","pair","startUnitNodeIds","endUnitNodeIds","endSet","Set","intersect","filter","x","has","intersectIdMap","intersectLength","node","edge","source","target","getMatchedCount","graph","structure","edgeLabelProp","nodeMap","e","sourceLabel","targetLabel","strNodeLabel1","strNodeLabel2","strEdgeLabel","findRepresentStructure","matchedCountMap","structureNum","structures","maxOffset","Infinity","representClusterType","_loop_1","countMapI","sortedGraphKeys","groupNum","clusters","graphs","totalCount","aveCount","aveIntraDist","aveCounts","graphsInCluster","aveIntraPerCluster","graphsNum","graphKey1","graph1Count","graphKey2","abs","aveInterDist","aveCount1","aveCount2","offset","structureCountMap","getNodeMaps","nodeLabelMap","idx","degree","inDegree","outDegree","getEdgeMaps","edgeMap","edgeLabelMap","uniqueId","sourceNode","targetNode","getSpmMap","directed","map","iId","jId","dist","getNDSDist","node1","node2","spDist","cachedNDSMap","cachedInterInducedGraph","interInducedGraph","undefined","pairMap","stashPatternNodeLabelDegreeMap","minPatternNodeLabelDegreeMap","neighborLabel","patternNodeMap","patternNodeLabelMap","_c","minPatternNodeLabelDegree","minPatternNodeLabelInDegree","minPatternNodeLabelOutDegree","patternNodeWithLabel","patternNodeDegree","patternNodeInDegree","patternNodeOutDegree","GADDI","pattern","patternSpm","spmMap","patternSpmMap","patternEdgeLabelMap","patternSpmSpread","max","apply","__spreadArray","patternKNeighborUnits","min","nodePairsMap","intGMap","top","minSupport","minNodeNum","maxNodeNum","params","freStructures","slice","subStructureCount","_d","dsG","ndsDist","beginPNode","candidates","maxNodeNumWithSameLabel","pLabel","nodesWithSameLabel","patternIntGraphMap","patternNDSDist","patternNDSDistMap","patternSpDist","patternSpDistBack","label2","maxDist","patternNodesWithLabel2","patternNodePairMap","nodeWithLabel2","distBack","currentPatternNDSDistArray","patternIntGraph","candidatesNum","_loop_4","m","cNode","graphNeighborUnit","graphNeighborUnitCountMap","patternLabel2Num","splice","prune2Invalid","n","cNodePairMap","neighborNode","currentNDSDistArray","intGraph","prune3Invalid","candidateGraphs","candidate","lengthNeighborUnit","neighborNodes","unmatched","distToCandidate","maxDistWithLabelInPattern","keyBack","distFromCandidate","maxBackDistWithLabelInPattern","ndsToCandidate","patternKey","minNdsWithLabelInPattern","undirectedLengthsToBeginPNode","undirectedLengthsToBeginPNodeLabelMap","nodeLabel","candidateGraphNum","_loop_2","candidateGraph","candidateNodeLabelCountMap","candidateNodeMap","q","cNodeLabel","candidateEdges","edgeLabelCountMap","pattenrEdgeLabelNum","prunedByEdgeLabel","label_1","candidateEdgeNum","candidateGraphInvalid","_loop_5","edgeLabel","patternEdgesWithLabel","edgeMatched","patternEdge","patternSource","patternTarget","state_2","lengthsToCandidate","reverse","targetId","targetNodeLabel","indexOf","nLabel","degreeChanged","loopCount","condition","currentCandidateNodeNum","o","cgNode","nodeDegree","nodeInDegree","nodeOutDegree","_e","deleteCondition","y","cedge","state_1","currentLength","_loop_3","cg1","cg1EdgeMap","_loop_6","cg2","cg2EdgeMap","same","_default"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/algorithm/lib/gaddi.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _tslib = require(\"tslib\");\nvar _floydWarshall = _interopRequireDefault(require(\"./floydWarshall\"));\nvar _gSpan = _interopRequireDefault(require(\"./gSpan/gSpan\"));\nvar _dijkstra = _interopRequireDefault(require(\"./dijkstra\"));\nvar _util = require(\"./util\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * 为 graphData 中每个节点生成邻居单元数组\n * @param graphData\n * @param spm\n * @param nodeLabelProp\n * @param k k-近邻\n */\nvar findKNeighborUnits = function findKNeighborUnits(graphData, spm, nodeLabelProp, k) {\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n  if (k === void 0) {\n    k = 2;\n  }\n  var units = [];\n  var nodes = graphData.nodes;\n  spm.forEach(function (row, i) {\n    units.push(findKNeighborUnit(nodes, row, i, nodeLabelProp, k));\n  });\n  return units;\n};\nvar findKNeighborUnit = function findKNeighborUnit(nodes, row, i, nodeLabelProp, k) {\n  var unitNodeIdxs = [i];\n  var neighbors = [];\n  var labelCountMap = {};\n  row.forEach(function (v, j) {\n    if (v <= k && i !== j) {\n      unitNodeIdxs.push(j);\n      neighbors.push(nodes[j]);\n      var label = nodes[j][nodeLabelProp];\n      if (!labelCountMap[label]) labelCountMap[label] = {\n        count: 1,\n        dists: [v]\n      };else {\n        labelCountMap[label].count++;\n        labelCountMap[label].dists.push(v);\n      }\n    }\n  });\n  // 将 labelCountMap 中的 dists 按照从小到大排序，方便后面使用\n  Object.keys(labelCountMap).forEach(function (label) {\n    labelCountMap[label].dists = labelCountMap[label].dists.sort(function (a, b) {\n      return a - b;\n    });\n  });\n  return {\n    nodeIdx: i,\n    nodeId: nodes[i].id,\n    nodeIdxs: unitNodeIdxs,\n    neighbors: neighbors,\n    neighborNum: unitNodeIdxs.length - 1,\n    nodeLabelCountMap: labelCountMap\n  };\n};\n/**\n * 随机寻找点对，满足距离小于 k\n * @param k 参数 k，表示 k-近邻\n * @param nodeNum 参数 length\n * @param maxNodePairNum 寻找点对的数量不超过 maxNodePairNum\n * @param spm 最短路径矩阵\n */\nvar findNodePairsRandomly = function findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm) {\n  // 每个节点需要随机找出的点对数\n  var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);\n  var nodePairMap = {};\n  var foundNodePairCount = 0;\n  // 遍历节点，为每个节点随机找出 nodePairNumEachNode 个点对，满足距离小于 k。找到的点对数量超过 maxNodePairNum 或所有节点遍历结束时终止\n  kNeighborUnits.forEach(function (unit, i) {\n    // 若未达到 nodePairNumEachNode，或循环次数小于最大循环次数(2 * nodeNum)，继续循环\n    var nodePairForICount = 0;\n    var outerLoopCount = 0;\n    var neighbors = unit.nodeIdxs; // the first one is the center node\n    var neighborNum = unit.neighborNum - 1;\n    while (nodePairForICount < nodePairNumEachNode) {\n      // 另一端节点在节点数组中的的 index\n      var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];\n      var innerLoopCount = 0;\n      // 若随机得到的另一端 idx 不符合条件，则继续 random。条件是不是同一个节点、这个点对没有被记录过、距离小于 k\n      while (nodePairMap[\"\".concat(i, \"-\").concat(oidx)] || nodePairMap[\"\".concat(oidx, \"-\").concat(i)]) {\n        oidx = Math.floor(Math.random() * nodeNum);\n        innerLoopCount++;\n        if (innerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n      }\n\n      if (innerLoopCount < 2 * nodeNum) {\n        // 未达到最大循环次数，说明找到了合适的另一端\n        nodePairMap[\"\".concat(i, \"-\").concat(oidx)] = {\n          start: i,\n          end: oidx,\n          distance: spm[i][oidx]\n        };\n        nodePairForICount++;\n        foundNodePairCount++;\n        // 如果当前找到的点对数量达到了上限，返回结果\n        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;\n      }\n      outerLoopCount++;\n      if (outerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n    }\n    // 这个节点没有找到足够 nodePairNumEachNode 的点对。更新 nodePairNumEachNode，让后续节点找更多的点对\n    if (nodePairForICount < nodePairNumEachNode) {\n      var gap = nodePairNumEachNode - nodePairForICount;\n      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i - 1);\n    }\n  });\n  return nodePairMap;\n};\n/**\n * 计算所有 nodePairMap 中节点对的相交邻居诱导子图\n * @param nodePairMap 节点对 map，key 为 node1.id-node2.id，value 为 { startNodeIdx, endNodeIdx, distance }\n * @param neighborUnits 每个节点的邻居元数组\n * @param graphData 原图数据\n * @param edgeMap 边的 map，方便检索\n * @param cachedInducedGraphMap 缓存的结果，下次进入该函数将继续更新该缓存，若 key 在缓存中存在则不需要重复计算\n */\nvar getIntersectNeighborInducedGraph = function getIntersectNeighborInducedGraph(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {\n  var nodes = graphData.nodes;\n  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};\n  Object.keys(nodePairMap).forEach(function (key) {\n    var _a, _b;\n    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;\n    cachedInducedGraphMap[key] = {\n      nodes: [],\n      edges: []\n    };\n    var pair = nodePairMap[key];\n    var startUnitNodeIds = (_a = neighborUnits[pair.start]) === null || _a === void 0 ? void 0 : _a.nodeIdxs;\n    var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;\n    if (!startUnitNodeIds || !endUnitNodeIds) return; // 不存在邻元，返回空图\n    var endSet = new Set(endUnitNodeIds);\n    var intersect = startUnitNodeIds.filter(function (x) {\n      return endSet.has(x);\n    }); // 可能会爆栈（在 1580 + 6 nodes full-connected 时出现）\n    if (!intersect || !intersect.length) return; // 没有交集，返回空图\n    var intersectIdMap = {};\n    var intersectLength = intersect.length;\n    for (var i = 0; i < intersectLength; i++) {\n      var node = nodes[intersect[i]];\n      cachedInducedGraphMap[key].nodes.push(node); // 将交集中的点加入诱导子图\n      intersectIdMap[node.id] = true;\n    }\n    // 遍历所有边数据，如果边的两端都在交集中，将该边加入诱导子图\n    graphData.edges.forEach(function (edge) {\n      if (intersectIdMap[edge.source] && intersectIdMap[edge.target]) cachedInducedGraphMap[key].edges.push(edge);\n    });\n  });\n  return cachedInducedGraphMap;\n};\n/**\n * 计算 strcutre 在 graph 上的匹配数量\n * @param graph 图数据\n * @param structure 目前支持只有两个节点一条边的最简单结构\n * @param nodeLabelProp 节点类型字段名\n * @param edgeLabelProp 边类型字段名\n */\nvar getMatchedCount = function getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp) {\n  var _a, _b;\n  var nodeMap = {};\n  graph.nodes.forEach(function (node) {\n    nodeMap[node.id] = node;\n  });\n  var count = 0;\n  if (!((_a = structure === null || structure === void 0 ? void 0 : structure.edges) === null || _a === void 0 ? void 0 : _a.length) || ((_b = structure === null || structure === void 0 ? void 0 : structure.nodes) === null || _b === void 0 ? void 0 : _b.length) < 2) return 0;\n  graph.edges.forEach(function (e) {\n    var sourceLabel = nodeMap[e.source][nodeLabelProp];\n    var targetLabel = nodeMap[e.target][nodeLabelProp];\n    var strNodeLabel1 = structure === null || structure === void 0 ? void 0 : structure.nodes[0][nodeLabelProp];\n    var strNodeLabel2 = structure === null || structure === void 0 ? void 0 : structure.nodes[1][nodeLabelProp];\n    var strEdgeLabel = structure === null || structure === void 0 ? void 0 : structure.edges[0][edgeLabelProp];\n    if (e[edgeLabelProp] !== strEdgeLabel) return;\n    if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {\n      count++;\n    }\n  });\n  return count;\n};\n/**\n * structures 中寻找最具有代表性的一个。这个结构是使得 matchedCountMap 的分组方式类内间距最小，类间间距最大\n * @param matchedCountMap 每个 structure 分类后的各图匹配数量，格式 { [strcture.idx]: { [interInducedGraphKey]: count } }\n * @param structureNum strcuture 个数，与 matchedCountMap.length 对应\n * @param structures\n */\nvar findRepresentStructure = function findRepresentStructure(matchedCountMap, structureNum, structures) {\n  var maxOffset = Infinity,\n    representClusterType = 0;\n  var _loop_1 = function _loop_1(i) {\n    // 一种分组的 map，key 是 intGraph 的 key，value 是 structures[i] 的匹配个数\n    var countMapI = matchedCountMap[i];\n    // 按照 value 为该组排序，生成 keys 的数组：\n    var sortedGraphKeys = Object.keys(countMapI).sort(function (a, b) {\n      return countMapI[a] - countMapI[b];\n    });\n    // 共 100 个 graphKeys，将 graphKeys 按顺序分为 groupNum 组\n    var groupNum = 10;\n    var clusters = []; // 总共有 groupNum 个项\n    sortedGraphKeys.forEach(function (key, j) {\n      if (!clusters[j % groupNum]) clusters[j % groupNum] = {\n        graphs: [],\n        totalCount: 0,\n        aveCount: 0\n      };\n      clusters[j % groupNum].graphs.push(key);\n      clusters[j % groupNum].totalCount += countMapI[key];\n    });\n    // 计算 cluster 与 cluster 之间的距离 innerDist，每个 cluster 内部的距离 intraDist\n    var aveIntraDist = 0; // 该类的类内平均值\n    var aveCounts = []; // 类内平均匹配数量，将用于计算类间距离\n    clusters.forEach(function (graphsInCluster) {\n      // 类内均值\n      var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;\n      graphsInCluster.aveCount = aveCount;\n      aveCounts.push(aveCount);\n      // 对于每类，计算类内间距平均值\n      var aveIntraPerCluster = 0;\n      var graphsNum = graphsInCluster.length;\n      graphsInCluster.graphs.forEach(function (graphKey1, j) {\n        var graph1Count = countMapI[graphKey1];\n        graphsInCluster.graphs.forEach(function (graphKey2, k) {\n          if (j === k) return;\n          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);\n        });\n      });\n      aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;\n      aveIntraDist += aveIntraPerCluster;\n    });\n    aveIntraDist /= clusters.length;\n    // 用类内均值计算类间距\n    var aveInterDist = 0; // 类间间距平均值\n    aveCounts.forEach(function (aveCount1, j) {\n      aveCounts.forEach(function (aveCount2, k) {\n        if (j === k) return;\n        aveInterDist += Math.abs(aveCount1 - aveCount2);\n      });\n      aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;\n    });\n    // 寻找 (类间间距均值-类内间距均值) 最大的一种分组方式（对应的 structure 就是最终要找的唯一 DS(G)）\n    var offset = aveInterDist - aveIntraDist;\n    if (maxOffset < offset) {\n      maxOffset = offset;\n      representClusterType = i;\n    }\n  };\n  for (var i = 0; i < structureNum; i++) {\n    _loop_1(i);\n  }\n  return {\n    structure: structures[representClusterType],\n    structureCountMap: matchedCountMap[representClusterType]\n  };\n};\nvar getNodeMaps = function getNodeMaps(nodes, nodeLabelProp) {\n  var nodeMap = {},\n    nodeLabelMap = {};\n  nodes.forEach(function (node, i) {\n    nodeMap[node.id] = {\n      idx: i,\n      node: node,\n      degree: 0,\n      inDegree: 0,\n      outDegree: 0\n    };\n    var label = node[nodeLabelProp];\n    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];\n    nodeLabelMap[label].push(node);\n  });\n  return {\n    nodeMap: nodeMap,\n    nodeLabelMap: nodeLabelMap\n  };\n};\nvar getEdgeMaps = function getEdgeMaps(edges, edgeLabelProp, nodeMap) {\n  var edgeMap = {},\n    edgeLabelMap = {};\n  edges.forEach(function (edge, i) {\n    edgeMap[\"\".concat(_util.uniqueId)] = {\n      idx: i,\n      edge: edge\n    };\n    var label = edge[edgeLabelProp];\n    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];\n    edgeLabelMap[label].push(edge);\n    var sourceNode = nodeMap[edge.source];\n    if (sourceNode) {\n      sourceNode.degree++;\n      sourceNode.outDegree++;\n    }\n    var targetNode = nodeMap[edge.target];\n    if (targetNode) {\n      targetNode.degree++;\n      targetNode.inDegree++;\n    }\n  });\n  return {\n    edgeMap: edgeMap,\n    edgeLabelMap: edgeLabelMap\n  };\n};\n/**\n * 输出最短路径的 map，key 为 sourceNode.id-targetNode.id，value 为这两个节点的最短路径长度\n * @param nodes\n * @param spm\n * @param directed\n */\nvar getSpmMap = function getSpmMap(nodes, spm, directed) {\n  var length = spm.length;\n  var map = {};\n  spm.forEach(function (row, i) {\n    var start = directed ? 0 : i + 1;\n    var iId = nodes[i].id;\n    for (var j = start; j < length; j++) {\n      if (i === j) continue;\n      var jId = nodes[j].id;\n      var dist = row[j];\n      map[\"\".concat(iId, \"-\").concat(jId)] = dist;\n      if (!directed) map[\"\".concat(jId, \"-\").concat(iId)] = dist;\n    }\n  });\n  return map;\n};\n/**\n * 计算一对节点（node1，node2）的 NDS 距离\n * @param graph 原图数据\n * @param node1\n * @param node2\n */\nvar getNDSDist = function getNDSDist(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {\n  var _a;\n  var key = \"\".concat(node1.id, \"-\").concat(node2.id);\n  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];\n  var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : undefined;\n  // 若没有缓存相交邻居诱导子图，计算\n  if (!interInducedGraph) {\n    var pairMap = (_a = {}, _a[key] = {\n      start: nodeMap[node1.id].idx,\n      end: nodeMap[node2.id].idx,\n      distance: spDist\n    }, _a);\n    cachedInterInducedGraph = getIntersectNeighborInducedGraph(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);\n    interInducedGraph = cachedInterInducedGraph[key];\n  }\n  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);\n};\n/**\n * 计算 pattern 上绩点的度数并存储到 minPatternNodeLabelDegreeMap\n */\nvar stashPatternNodeLabelDegreeMap = function stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap) {\n  var _a, _b, _c;\n  var minPatternNodeLabelDegree = (_a = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _a === void 0 ? void 0 : _a.degree;\n  var minPatternNodeLabelInDegree = (_b = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _b === void 0 ? void 0 : _b.inDegree;\n  var minPatternNodeLabelOutDegree = (_c = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _c === void 0 ? void 0 : _c.outDegree;\n  if (minPatternNodeLabelDegreeMap[neighborLabel] === undefined) {\n    minPatternNodeLabelDegree = Infinity;\n    minPatternNodeLabelInDegree = Infinity;\n    minPatternNodeLabelOutDegree = Infinity;\n    patternNodeLabelMap[neighborLabel].forEach(function (patternNodeWithLabel) {\n      var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;\n      if (minPatternNodeLabelDegree > patternNodeDegree) minPatternNodeLabelDegree = patternNodeDegree;\n      var patternNodeInDegree = patternNodeMap[patternNodeWithLabel.id].inDegree;\n      if (minPatternNodeLabelInDegree > patternNodeInDegree) minPatternNodeLabelInDegree = patternNodeInDegree;\n      var patternNodeOutDegree = patternNodeMap[patternNodeWithLabel.id].outDegree;\n      if (minPatternNodeLabelOutDegree > patternNodeOutDegree) minPatternNodeLabelOutDegree = patternNodeOutDegree;\n    });\n    minPatternNodeLabelDegreeMap[neighborLabel] = {\n      degree: minPatternNodeLabelDegree,\n      inDegree: minPatternNodeLabelInDegree,\n      outDegree: minPatternNodeLabelOutDegree\n    };\n  }\n  return {\n    minPatternNodeLabelDegree: minPatternNodeLabelDegree,\n    minPatternNodeLabelInDegree: minPatternNodeLabelInDegree,\n    minPatternNodeLabelOutDegree: minPatternNodeLabelOutDegree\n  };\n};\n/**\n * GADDI 模式匹配\n * @param graphData 原图数据\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\n * @param directed 是否计算有向图，默认 false\n * @param k 参数 k，表示 k-近邻\n * @param length 参数 length\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\n */\nvar GADDI = function GADDI(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\n  var _a;\n  if (directed === void 0) {\n    directed = false;\n  }\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n  if (edgeLabelProp === void 0) {\n    edgeLabelProp = 'cluster';\n  }\n  if (!graphData || !graphData.nodes) return;\n  // 分为三步：\n  // 0. 预计算：节点/边数，邻接矩阵、最短路径矩阵\n  // 1. 处理原图 graphData。再分为 1~5 小步\n  // 2. 匹配\n  // console.log(\"----- stage-pre: preprocessing -------\");\n  // -------- 第零步，预计算：节点/边数，邻接矩阵、最短路径矩阵-------\n  var nodeNum = graphData.nodes.length;\n  if (!nodeNum) return;\n  // console.log(\"----- stage-pre.1: calc shortest path matrix for graph -------\");\n  var spm = (0, _floydWarshall.default)(graphData, directed);\n  // console.log(\n  //   \"----- stage-pre.2: calc shortest path matrix for pattern -------\"\n  // );\n  var patternSpm = (0, _floydWarshall.default)(pattern, directed);\n  // console.log(\n  //   \"----- stage-pre.3: calc shortest path matrix map for graph -------\"\n  // );\n  var spmMap = getSpmMap(graphData.nodes, spm, directed);\n  // console.log(\n  //   \"----- stage-pre.4: calc shortest path matrix map for pattern -------\"\n  // );\n  var patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed);\n  // console.log(\"----- stage-pre.5: establish maps -------\");\n  // 节点的 map，以 id 为 id 映射，方便后续快速检索\n  var _b = getNodeMaps(graphData.nodes, nodeLabelProp),\n    nodeMap = _b.nodeMap,\n    nodeLabelMap = _b.nodeLabelMap;\n  var _c = getNodeMaps(pattern.nodes, nodeLabelProp),\n    patternNodeMap = _c.nodeMap,\n    patternNodeLabelMap = _c.nodeLabelMap;\n  // 计算节点度数\n  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);\n  var patternEdgeLabelMap = getEdgeMaps(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap;\n  // 若未指定 length，自动计算 pattern 半径（最短路径最大值）\n  var patternSpmSpread = [];\n  patternSpm === null || patternSpm === void 0 ? void 0 : patternSpm.forEach(function (row) {\n    patternSpmSpread = patternSpmSpread.concat(row);\n  });\n  if (!length) length = Math.max.apply(Math, (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], patternSpmSpread, false), [2], false));\n  if (!k) k = length;\n  // console.log(\"params\", directed, length, k);\n  // console.log(\"----- stage-pre.6: calc k neighbor units -------\");\n  // 计算每个节点的 k 邻元集合\n  var kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k);\n  var patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k);\n  // console.log(\n  //   \"----- stage0: going to processing graph and find intersect neighbor induced graphs -------\"\n  // );\n  // console.log(\"----- stage0.1: going to select random node pairs -------\");\n  // -------- 第一步，处理原图 graphData-------\n  // 1.1. 随机选择最多 100 个点对，满足距离小于 Length 和 k\n  // 当 graphData 少于 20 个节点，则不能找出 100 个点对，只找出不多于 n(n-1)/2 个点对\n  var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);\n  var nodePairsMap = findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm);\n  // console.log(\n  //   \"----- stage0.2: going to calculate intersect neighbor induced graphs -------\"\n  // );\n  // 1.2. 生成上面节点对的相应相交邻居诱导子图。格式为 {'beginNodeIdx-endNodeIdx': {nodes: [], edges: []}}\n  var intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData);\n  // 1.3. 使用 gSpan 算法（frequent graph mining）计算 ISIntG 的前 10 个频率最高的子结构（3-4条边）\n  var top = 10,\n    minSupport = 1,\n    minNodeNum = 1,\n    maxNodeNum = 4;\n  var params = {\n    graphs: intGMap,\n    nodeLabelProp: nodeLabelProp,\n    edgeLabelProp: edgeLabelProp,\n    minSupport: minSupport,\n    minNodeNum: minNodeNum,\n    maxNodeNum: maxNodeNum,\n    directed: directed\n  };\n  // console.log(\n  //   \"----- stage1: (gSpan) going to find frequent structure dsG -------\"\n  // );\n  // console.log(\"----- stage1.1: going to run gSpan -------\");\n  // 暂时假设生成的 sub structure 都只有一条边\n  var freStructures = (0, _gSpan.default)(params).slice(0, top);\n  // structureNum 可能小于 top\n  var structureNum = freStructures.length;\n  // 1.4. 计算上述 10 个子结构在 intGMap 中每个诱导子图的匹配个数\n  var matchedCountMap = [];\n  freStructures.forEach(function (structure, i) {\n    matchedCountMap[i] = {};\n    Object.keys(intGMap).forEach(function (key) {\n      var graph = intGMap[key];\n      var subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);\n      matchedCountMap[i][key] = subStructureCount;\n    });\n  });\n  // console.log(\n  //   \"----- stage1.1: going to find the most represent strucutre -------\"\n  // );\n  // 1.5. 对于每个子结构，根据匹配个数为 intGMap 中的诱导子图分组，生成 structureNum 种分组\n  // 计算每种分组的类间距和类内间距，找到类间距最大、类内间距最小的一种分组，这种分组对应的子结构被选为唯一代表性子结构 DS(G)\n  var _d = findRepresentStructure(matchedCountMap, structureNum, freStructures),\n    dsG = _d.structure,\n    ndsDist = _d.structureCountMap;\n  // -------- 第二步，匹配-------\n  // 2.1 找到从 Q 中的一个节点作为起始节点，寻找 G 中的匹配。这个其实节点的标签可以在 G 中找到最多的节点\n  var beginPNode = pattern.nodes[0],\n    candidates = [],\n    label = (_a = pattern.nodes[0]) === null || _a === void 0 ? void 0 : _a[nodeLabelProp],\n    maxNodeNumWithSameLabel = -Infinity;\n  pattern.nodes.forEach(function (node) {\n    var pLabel = node[nodeLabelProp];\n    var nodesWithSameLabel = nodeLabelMap[pLabel];\n    if ((nodesWithSameLabel === null || nodesWithSameLabel === void 0 ? void 0 : nodesWithSameLabel.length) > maxNodeNumWithSameLabel) {\n      maxNodeNumWithSameLabel = nodesWithSameLabel.length;\n      candidates = nodesWithSameLabel;\n      label = pLabel;\n      beginPNode = node;\n    }\n  });\n  // console.log(\"----- stage2: going to find candidates -------\");\n  // 全局缓存，避免重复计算\n  var minPatternNodeLabelDegreeMap = {}; // key 是 label，value 是该 label 节点的最小度数\n  var patternIntGraphMap = {},\n    patternNDSDist = {},\n    // key 为 node.id-node.id\n    patternNDSDistMap = {}; // key 为 node.id-label2，value nds距离值数组（按从大到小排序，无需关心具体对应哪个 node2）\n  // 2.2.2 对于 Q 中的另一个标签的 k 个节点，计算它们到 node 的最短路径以及 NDS 距离\n  var patternSpDist = {};\n  var patternSpDistBack = {};\n  Object.keys(patternNodeLabelMap).forEach(function (label2, j) {\n    patternSpDist[label2] = [];\n    if (directed) {\n      patternSpDistBack[label2] = [];\n    }\n    var maxDist = -Infinity;\n    var patternNodesWithLabel2 = patternNodeLabelMap[label2];\n    var patternNodePairMap = {};\n    patternNodesWithLabel2.forEach(function (nodeWithLabel2) {\n      var dist = patternSpmMap[\"\".concat(beginPNode.id, \"-\").concat(nodeWithLabel2.id)];\n      dist && patternSpDist[label2].push(dist);\n      if (maxDist < dist) maxDist = dist;\n      patternNodePairMap[\"\".concat(beginPNode.id, \"-\").concat(nodeWithLabel2.id)] = {\n        start: 0,\n        end: patternNodeMap[nodeWithLabel2.id].idx,\n        distance: dist\n      };\n      if (directed) {\n        var distBack = patternSpmMap[\"\".concat(nodeWithLabel2.id, \"-\").concat(beginPNode.id)];\n        distBack && patternSpDistBack[label2].push(distBack);\n      }\n    });\n    // spDist[label2] 按照从小到大排序\n    patternSpDist[label2] = patternSpDist[label2].sort(function (a, b) {\n      return a - b;\n    });\n    if (directed) patternSpDistBack[label2] = patternSpDistBack[label2].sort(function (a, b) {\n      return a - b;\n    });\n    // 计算 Q 中所有 label2 节点到 beginPNode 的 NDS 距离\n    // 所有 label2 节点到 beginPNode 的邻居相交诱导子图：\n    // key: node1.id-node2.id\n    patternIntGraphMap = getIntersectNeighborInducedGraph(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap);\n    // pattern 中 beginNode 到当前 label2 节点 的 NDS 距离（数组，无需关心具体对应到哪个节点）\n    var currentPatternNDSDistArray = [];\n    Object.keys(patternNodePairMap).forEach(function (key) {\n      if (patternNDSDist[key]) {\n        currentPatternNDSDistArray.push(patternNDSDist[key]);\n        return; // 缓存过则不需要再次计算\n      }\n\n      var patternIntGraph = patternIntGraphMap[key];\n      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);\n      currentPatternNDSDistArray.push(patternNDSDist[key]);\n    });\n    // 根据值为 currentPatternNDSDist 从大到小排序\n    currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function (a, b) {\n      return b - a;\n    });\n    patternNDSDistMap[\"\".concat(beginPNode.id, \"-\").concat(label2)] = currentPatternNDSDistArray;\n    if (label2 === label) return;\n    var candidatesNum = (candidates === null || candidates === void 0 ? void 0 : candidates.length) || 0;\n    var _loop_4 = function _loop_4(m) {\n      var cNode = candidates[m];\n      // prune1：若 candidates 中节点 cNode 的 kNeighborUnits 中标签为 label2 的节点个数少于 pattern 中 label2 个数，删去它\n      var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];\n      var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];\n      var patternLabel2Num = patternNodeLabelMap[label2].length;\n      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      }\n      // prune2：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点最短路径大于 patternSpDist[label2]，删去它\n      // (prune2 规则即：candidate 相关的最短路径的最大 spDist[label2].length 个，按照大小顺序依次和 patternSpDist[label2] 中的值比较，只要遇到一个是 G > Q 的，就删去这个 candidate)\n      var prune2Invalid = false;\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (graphNeighborUnitCountMap.dists[n] > patternSpDist[label2][n]) {\n          prune2Invalid = true;\n          break;\n        }\n      }\n      if (prune2Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      }\n      // prune3：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点 NDS 距离小于 patternNDSDist[beginNode.id-label2]，删去它\n      // TODO：prune3，currentPatternNDSDistArray 与 currentNDSDist 的比较\n      // 计算 G 中所有 label2 节点到 cNode 的 NDS 距离\n      // 所有 label2 节点到 cNode 的邻居相交诱导子图：\n      var cNodePairMap = {};\n      graphNeighborUnit.neighbors.forEach(function (neighborNode) {\n        var dist = spmMap[\"\".concat(cNode.id, \"-\").concat(neighborNode.id)];\n        cNodePairMap[\"\".concat(cNode.id, \"-\").concat(neighborNode.id)] = {\n          start: nodeMap[cNode.id].idx,\n          end: nodeMap[neighborNode.id].idx,\n          distance: dist\n        };\n      });\n      // 更新 intGMap\n      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap);\n      // candidate 到它周围 label2 节点的 NDS 距离, key 是 node.id-node.id\n      var currentNDSDistArray = [];\n      Object.keys(cNodePairMap).forEach(function (key) {\n        if (ndsDist[key]) {\n          currentNDSDistArray.push(ndsDist[key]);\n          return; // 缓存过则不需要再次计算\n        }\n\n        var intGraph = intGMap[key];\n        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);\n        currentNDSDistArray.push(ndsDist[key]);\n      });\n      // 根据值为 currentNDSDistArray 从大到小排序\n      currentNDSDistArray = currentNDSDistArray.sort(function (a, b) {\n        return b - a;\n      });\n      var prune3Invalid = false;\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (currentNDSDistArray[n] < currentPatternNDSDistArray[n]) {\n          prune3Invalid = true;\n          break;\n        }\n      }\n      if (prune3Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      }\n    };\n    for (var m = candidatesNum - 1; m >= 0; m--) {\n      _loop_4(m);\n    }\n  });\n  var candidateGraphs = [];\n  // console.log(\n  //   \"----- stage3: going to splice neighbors for each candidate graph -------\"\n  // );\n  // candidates 经过筛选后，以每个 candidate 为中心，生成 Length-neighbor 的邻居诱导子图\n  // 并在诱导子图中去除不可能在 Q 上找到匹配的点：在 Q 上不存在的 label，其他 label 到 candidate 的最大最短距离符合 Q、NDS 距离符合 Q\n  candidates === null || candidates === void 0 ? void 0 : candidates.forEach(function (candidate) {\n    var nodeIdx = nodeMap[candidate.id].idx;\n    var lengthNeighborUnit = findKNeighborUnit(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length);\n    var neighborNodes = lengthNeighborUnit.neighbors;\n    // 删除不可能找到匹配的邻居点\n    var neighborNum = neighborNodes.length;\n    var unmatched = false;\n    for (var i = neighborNum - 1; i >= 0; i--) {\n      // 如果通过裁剪，符合条件的节点数量已过少，说明不能匹配这个 candidate 相关的图\n      if (neighborNodes.length + 1 < pattern.nodes.length) {\n        unmatched = true;\n        return;\n      }\n      var neighborNode = neighborNodes[i];\n      var neighborLabel = neighborNode[nodeLabelProp];\n      // prune1: 若该邻居点的 label 不存在于 pattern 中，移除这个点\n      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n      // prune2: 若该邻居点到 candidate 的最短路径比和它有相同 label 的节点到 beginPNode 的最大最短路径长度长，移除这个点\n      // prune2.1: 如果没有这个标签到 beginPNode 的距离记录，说明 pattern 上（可能 beginPNode 是这个 label）没有其他这个 label 的节点\n      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n      var key = \"\".concat(candidate.id, \"-\").concat(neighborNode.id);\n      // prune2.2\n      var distToCandidate = spmMap[key];\n      var idx = patternSpDist[neighborLabel].length - 1;\n      var maxDistWithLabelInPattern = patternSpDist[neighborLabel][idx]; // patternSpDist[neighborLabel] 已经按照从小到大排序\n      if (distToCandidate > maxDistWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n      if (directed) {\n        var keyBack = \"\".concat(neighborNode.id, \"-\").concat(candidate.id);\n        var distFromCandidate = spmMap[keyBack];\n        idx = patternSpDistBack[neighborLabel].length - 1;\n        var maxBackDistWithLabelInPattern = patternSpDistBack[neighborLabel][idx];\n        if (distFromCandidate > maxBackDistWithLabelInPattern) {\n          neighborNodes.splice(i, 1);\n          continue;\n        }\n      }\n      // prune3: 若该邻居点到 candidate 的 NDS 距离比和它有相同 label 的节点到 beginPNode 的最小 NDS 距离小，移除这个点\n      var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);\n      var patternKey = \"\".concat(beginPNode.id, \"-\").concat(neighborLabel);\n      var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1]; // patternNDSDist[key] 一定存在\n      if (ndsToCandidate < minNdsWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n      // prune4: 若该邻居点的度数小于 pattern 同 label 节点最小度数，删去该点\n      var _a = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap),\n        minPatternNodeLabelDegree = _a.minPatternNodeLabelDegree,\n        minPatternNodeLabelInDegree = _a.minPatternNodeLabelInDegree,\n        minPatternNodeLabelOutDegree = _a.minPatternNodeLabelOutDegree;\n      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n    }\n    // 节点在个数上符合匹配（不少于 pattern 的节点个数），现在筛选相关边\n    if (!unmatched) {\n      candidateGraphs.push({\n        nodes: [candidate].concat(neighborNodes)\n      });\n    }\n  });\n  // console.log(\n  //   \"----- stage4: going to splice edges and neighbors for each candidate graph -------\"\n  // );\n  var undirectedLengthsToBeginPNode = (0, _dijkstra.default)(pattern, beginPNode.id, false).length;\n  var undirectedLengthsToBeginPNodeLabelMap = {};\n  if (directed) {\n    Object.keys(undirectedLengthsToBeginPNode).forEach(function (nodeId) {\n      var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];\n      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel]) undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];else undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);\n    });\n    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function (pLabel) {\n      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function (a, b) {\n        return a - b;\n      });\n    });\n  } else {\n    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;\n  }\n  // 现在 candidateGraphs 里面只有节点，进行边的筛选\n  var candidateGraphNum = candidateGraphs.length;\n  var _loop_2 = function _loop_2(i) {\n    var candidateGraph = candidateGraphs[i];\n    var candidate = candidateGraph.nodes[0];\n    var candidateNodeLabelCountMap = {};\n    var candidateNodeMap = {};\n    candidateGraph.nodes.forEach(function (node, q) {\n      candidateNodeMap[node.id] = {\n        idx: q,\n        node: node,\n        degree: 0,\n        inDegree: 0,\n        outDegree: 0\n      };\n      var cNodeLabel = node[nodeLabelProp];\n      if (!candidateNodeLabelCountMap[cNodeLabel]) candidateNodeLabelCountMap[cNodeLabel] = 1;else candidateNodeLabelCountMap[cNodeLabel]++;\n    });\n    // 根据 candidate 和 neighborNodes 中的节点生成 G 的诱导子图\n    // 即，将 graphData 上两端都在 candidateGraph.nodes 中的边放入 candidateEdges\n    var candidateEdges = [];\n    var edgeLabelCountMap = {};\n    graphData.edges.forEach(function (edge) {\n      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {\n        candidateEdges.push(edge);\n        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;else edgeLabelCountMap[edge[edgeLabelProp]]++;\n        candidateNodeMap[edge.source].degree++;\n        candidateNodeMap[edge.target].degree++;\n        candidateNodeMap[edge.source].outDegree++;\n        candidateNodeMap[edge.target].inDegree++;\n      }\n    });\n    // prune：若有一个 edgeLabel 在 candidateGraph 上的个数少于 pattern，去除该图\n    var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;\n    var prunedByEdgeLabel = false;\n    for (var e = 0; e < pattenrEdgeLabelNum; e++) {\n      var label_1 = Object.keys(patternEdgeLabelMap)[e];\n      if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {\n        prunedByEdgeLabel = true;\n        break;\n      }\n    }\n    if (prunedByEdgeLabel) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n    // 遍历 candidateEdges，进行边的筛选\n    var candidateEdgeNum = candidateEdges.length;\n    // prune：若边数过少，去除该图\n    if (candidateEdgeNum < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"break\";\n    }\n    var candidateGraphInvalid = false;\n    var _loop_5 = function _loop_5(e) {\n      var edge = candidateEdges[e];\n      var edgeLabel = edge[edgeLabelProp];\n      var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel];\n      // prune 1: 若边的 label 不存在于 pattern 边 label 中，去除该边\n      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {\n        edgeLabelCountMap[edgeLabel]--;\n        // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        candidateNodeMap[edge.source].outDegree--;\n        candidateNodeMap[edge.target].inDegree--;\n        return \"continue\";\n      }\n      // prune 2: 若边的 label +两端 label 的三元组关系不能在 pattern 中找到，去除该边\n      var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];\n      var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];\n      var edgeMatched = false;\n      patternEdgesWithLabel.forEach(function (patternEdge) {\n        var patternSource = patternNodeMap[patternEdge.source].node;\n        var patternTarget = patternNodeMap[patternEdge.target].node;\n        if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel) edgeMatched = true;\n        if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel) edgeMatched = true;\n      });\n      if (!edgeMatched) {\n        edgeLabelCountMap[edgeLabel]--;\n        // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        candidateNodeMap[edge.source].outDegree--;\n        candidateNodeMap[edge.target].inDegree--;\n        return \"continue\";\n      }\n    };\n    for (var e = candidateEdgeNum - 1; e >= 0; e--) {\n      var state_2 = _loop_5(e);\n      if (state_2 === \"break\") break;\n    }\n    // prune2: 删除边的过程中，发现边数过少/边 label 数过少时，去除该图\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n    candidateGraph.edges = candidateEdges;\n    var lengthsToCandidate = (0, _dijkstra.default)(candidateGraph, candidateGraph.nodes[0].id, false).length;\n    Object.keys(lengthsToCandidate).reverse().forEach(function (targetId) {\n      if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return;\n      // prune4: 通过上述裁剪，可能导致该邻居子图变为不连通。裁剪掉目前在这个邻居子图中和 candidate（第一个节点）不连通的节点\n      if (lengthsToCandidate[targetId] === Infinity) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n        return;\n      }\n      // prune5: 经过边裁剪后，可能又出现了最短路径过长的节点 （比 pattern 中同 label 的节点到 beginNode 最大最短距离远），删去这些节点\n      var nLabel = nodeMap[targetId].node[nodeLabelProp];\n      if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n      }\n    });\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n    var degreeChanged = true;\n    var loopCount = 0;\n    while (degreeChanged && !candidateGraphInvalid) {\n      degreeChanged = false;\n      // candidate 度数不足，删去该图\n      var condition = directed ? candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree || candidateNodeMap[candidate.id].inDegree < patternNodeMap[beginPNode.id].inDegree || candidateNodeMap[candidate.id].outDegree < patternNodeMap[beginPNode.id].outDegree : candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree;\n      if (condition) {\n        candidateGraphInvalid = true;\n        break;\n      }\n      // candidate label 个数不足，删去该图\n      if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {\n        candidateGraphInvalid = true;\n        break;\n      }\n      // prune6：去除度数过小的节点\n      var currentCandidateNodeNum = candidateGraph.nodes.length;\n      for (var o = currentCandidateNodeNum - 1; o >= 0; o--) {\n        var cgNode = candidateGraph.nodes[o];\n        var nodeDegree = candidateNodeMap[cgNode.id].degree;\n        var nodeInDegree = candidateNodeMap[cgNode.id].inDegree;\n        var nodeOutDegree = candidateNodeMap[cgNode.id].outDegree;\n        var cNodeLabel = cgNode[nodeLabelProp];\n        var _e = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, cNodeLabel, patternNodeMap, patternNodeLabelMap),\n          minPatternNodeLabelDegree = _e.minPatternNodeLabelDegree,\n          minPatternNodeLabelInDegree = _e.minPatternNodeLabelInDegree,\n          minPatternNodeLabelOutDegree = _e.minPatternNodeLabelOutDegree;\n        var deleteCondition = directed ? nodeDegree < minPatternNodeLabelDegree || nodeInDegree < minPatternNodeLabelInDegree || nodeOutDegree < minPatternNodeLabelOutDegree : nodeDegree < minPatternNodeLabelDegree;\n        if (deleteCondition) {\n          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--;\n          // 节点 label 个数不足\n          if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n          candidateGraph.nodes.splice(o, 1);\n          candidateNodeMap[cgNode.id] = undefined;\n          degreeChanged = true;\n        }\n      }\n      if (candidateGraphInvalid || !degreeChanged && loopCount !== 0) break;\n      // 经过 prune5 节点裁剪，删去端点已经不在 candidateGraph 中的边\n      candidateEdgeNum = candidateEdges.length;\n      for (var y = candidateEdgeNum - 1; y >= 0; y--) {\n        var cedge = candidateEdges[y];\n        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {\n          candidateEdges.splice(y, 1);\n          var edgeLabel = cedge[edgeLabelProp];\n          edgeLabelCountMap[edgeLabel]--;\n          if (candidateNodeMap[cedge.source]) {\n            candidateNodeMap[cedge.source].degree--;\n            candidateNodeMap[cedge.source].outDegree--;\n          }\n          if (candidateNodeMap[cedge.target]) {\n            candidateNodeMap[cedge.target].degree--;\n            candidateNodeMap[cedge.target].inDegree--;\n          }\n          // 边 label 数量不足\n          if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n          degreeChanged = true;\n        }\n      }\n      loopCount++;\n    }\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n    // prune: 若节点/边数过少，节点/边 label 过少，去掉这个图\n    if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n  };\n  for (var i = candidateGraphNum - 1; i >= 0; i--) {\n    var state_1 = _loop_2(i);\n    if (state_1 === \"break\") break;\n  }\n  // 此时已经生成的多个 candidateGraphs，可能有重复\n  // console.log(\n  //   \"----- stage5: going to splice dulplicated candidate graphs -------\"\n  // );\n  // 删去 candidateGraphs 中一模一样的子图，通过边的 node-node-edgeLabel 作为 key，这类边个数作为 value，进行匹配\n  var currentLength = candidateGraphs.length;\n  var _loop_3 = function _loop_3(i) {\n    var cg1 = candidateGraphs[i];\n    var cg1EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n    cg1.edges.forEach(function (edge) {\n      var key = \"\".concat(edge.source, \"-\").concat(edge.target, \"-\").concat(edge.label);\n      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;else cg1EdgeMap[key]++;\n    });\n    var _loop_6 = function _loop_6(j) {\n      var cg2 = candidateGraphs[j];\n      var cg2EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n      cg2.edges.forEach(function (edge) {\n        var key = \"\".concat(edge.source, \"-\").concat(edge.target, \"-\").concat(edge.label);\n        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;else cg2EdgeMap[key]++;\n      });\n      var same = true;\n      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {\n        same = false;\n      } else {\n        Object.keys(cg1EdgeMap).forEach(function (key) {\n          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;\n        });\n      }\n      if (same) {\n        candidateGraphs.splice(j, 1);\n      }\n    };\n    for (var j = currentLength - 1; j > i; j--) {\n      _loop_6(j);\n    }\n    currentLength = candidateGraphs.length;\n  };\n  for (var i = 0; i <= currentLength - 1; i++) {\n    _loop_3(i);\n  }\n  return candidateGraphs;\n};\nvar _default = GADDI;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}