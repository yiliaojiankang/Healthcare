{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * 通过配置不同的 costFunc, distFunc, constraints 可以得到不同效果的 router\n * generalRouter: 不限制搜索时的移动方向，避开障碍即可\n * orthogonal: 线必须沿着竖直或水平方向（4个方向）\n * octolinearRouter: 线沿着竖直、水平、对角线方向（8个方向）\n */\nimport { Util } from '@antv/g6-core';\nimport { deepMix } from '@antv/util';\nimport { getExpandedBBox, getExpandedBBoxPoint, getPolylinePoints, simplifyPolyline, isSegmentCrossingBBox, SortedArray } from './polyline-util';\nvar manhattanDist = function manhattanDist(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\nvar eucliDist = function eucliDist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\nvar straightPath = function straightPath(start, end) {\n  // console.warn('fallbackRoute: straight path');\n  return [start, end];\n};\nvar simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {\n  return simplifyPolyline(getPolylinePoints(start, end, startNode, endNode, cfg.offset));\n};\n// getPolylinePoints\nvar defaultCfg = {\n  offset: 20,\n  maxAllowedDirectionChange: Math.PI / 2,\n  maximumLoops: 2000,\n  gridSize: 10,\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: -1\n  } // top\n  ],\n\n  get penalties() {\n    return {\n      0: 0,\n      45: this.gridSize / 2,\n      90: this.gridSize / 2\n    };\n  },\n  distFunc: manhattanDist,\n  fallbackRoute: simplePolyline\n};\nexport var octolinearCfg = {\n  maxAllowedDirectionChange: Math.PI / 4,\n  // 8 个方向: 上下左右 + 45度斜线方向\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: 1,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: -1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }, {\n    stepX: 1,\n    stepY: -1\n  }],\n  distFunc: eucliDist,\n  fallbackRoute: straightPath\n};\nvar pos2GridIx = function pos2GridIx(pos, gridSize) {\n  var gridIx = Math.round(Math.abs(pos / gridSize));\n  var sign = pos < 0 ? -1 : 1;\n  return gridIx < 0 ? 0 : sign * gridIx;\n};\nvar getObstacleMap = function getObstacleMap(items, gridSize, offset) {\n  var map = {};\n  items.forEach(function (item) {\n    // create-edge 时，当边类型为 polyline 时 endNode 为 null\n    if (!item) return;\n    var bbox = getExpandedBBox(item.getBBox(), offset);\n    for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {\n      for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {\n        map[\"\".concat(x, \"|||\").concat(y)] = true;\n      }\n    }\n  });\n  return map;\n};\n/**\n * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）\n * @param p1 PolyPoint\n * @param p2 PolyPoint\n */\nvar getDirectionAngle = function getDirectionAngle(p1, p2) {\n  var deltaX = p2.x - p1.x;\n  var deltaY = p2.y - p1.y;\n  if (deltaX || deltaY) {\n    return Math.atan2(deltaY, deltaX);\n  }\n  return 0;\n};\n/**\n * 方向角的改变，取小于180度角\n * @param angle1\n * @param angle2\n */\nvar getAngleDiff = function getAngleDiff(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange;\n  // return directionChange > 180 ? 360 - directionChange : directionChange;\n};\n// Path finder //\nvar estimateCost = function estimateCost(from, endPoints, distFunc) {\n  var min = Infinity;\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = distFunc(from, endPoints[i]);\n    if (cost < min) {\n      min = cost;\n    }\n  }\n  return min;\n};\n// 计算考虑 offset 后的 BBox 上的连接点\nvar getBoxPoints = function getBoxPoints(point,\n// 被 gridSize 格式化后的位置（anchorPoint）\noriPoint,\n// 未被 gridSize 格式化的位置（anchorPoint）\nnode,\n// 原始节点，用于获取 bbox\nanotherPoint,\n// 另一端被 gridSize 格式化后的位置\ncfg) {\n  var points = [];\n  // create-edge 生成边的过程中，endNode 为 null\n  if (!node) {\n    return [point];\n  }\n  var directions = cfg.directions,\n    offset = cfg.offset;\n  var bbox = node.getBBox();\n  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;\n  var expandBBox = getExpandedBBox(bbox, offset);\n  for (var i in expandBBox) {\n    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);\n  }\n  if (isInside) {\n    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点\n    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n      var dir = directions_1[_i];\n      var bounds = [[{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }]];\n      for (var i = 0; i < 4; i++) {\n        var boundLine = bounds[i];\n        var insterctP_1 = Util.getLineIntersect(point, {\n          x: point.x + dir.stepX * expandBBox.width,\n          y: point.y + dir.stepY * expandBBox.height\n        }, boundLine[0], boundLine[1]);\n        if (insterctP_1 && !isSegmentCrossingBBox(point, insterctP_1, bbox)) {\n          insterctP_1.id = \"\".concat(insterctP_1.x, \"|||\").concat(insterctP_1.y);\n          points.push(insterctP_1);\n        }\n      }\n    }\n    return points;\n  }\n  // 如果 anchorPoint 在节点上，只有一个可选方向\n  var insterctP = getExpandedBBoxPoint(expandBBox, point, anotherPoint);\n  insterctP.id = \"\".concat(insterctP.x, \"|||\").concat(insterctP.y);\n  return [insterctP];\n};\nvar getDirectionChange = function getDirectionChange(current, neighbor, cameFrom, scaleStartPoint) {\n  var directionAngle = getDirectionAngle(current, neighbor);\n  var currentCameFrom = cameFrom[current.id];\n  if (!currentCameFrom) {\n    var startAngle = getDirectionAngle(scaleStartPoint, current);\n    return getAngleDiff(startAngle, directionAngle);\n  }\n  var prevDirectionAngle = getDirectionAngle({\n    x: currentCameFrom.x,\n    y: currentCameFrom.y\n  }, current);\n  return getAngleDiff(prevDirectionAngle, directionAngle);\n};\nvar getControlPoints = function getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize) {\n  var controlPoints = [endPoint];\n  var pointZero = endPoint;\n  var currentId = current.id;\n  var currentX = current.x;\n  var currentY = current.y;\n  var lastPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  };\n  if (getDirectionChange(lastPoint, scaleEndPoint, cameFrom, scaleStartPoint)) {\n    pointZero = {\n      x: scaleEndPoint.x === endPoint.x ? endPoint.x : lastPoint.x * gridSize,\n      y: scaleEndPoint.y === endPoint.y ? endPoint.y : lastPoint.y * gridSize\n    };\n    controlPoints.unshift(pointZero);\n  }\n  var currentCameFrom = cameFrom[currentId];\n  while (currentCameFrom && currentCameFrom.id !== currentId) {\n    var point = {\n      x: currentX,\n      y: currentY,\n      id: currentId\n    };\n    var prePoint = {\n      x: currentCameFrom.x,\n      y: currentCameFrom.y,\n      id: currentCameFrom.id\n    };\n    var directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);\n    if (directionChange) {\n      pointZero = {\n        x: prePoint.x === point.x ? pointZero.x : prePoint.x * gridSize,\n        y: prePoint.y === point.y ? pointZero.y : prePoint.y * gridSize\n      };\n      controlPoints.unshift(pointZero);\n    }\n    currentId = prePoint.id;\n    currentX = prePoint.x;\n    currentY = prePoint.y;\n    currentCameFrom = cameFrom[currentId];\n  }\n  // 和startNode对齐\n  controlPoints[0].x = currentX === scaleStartPoint.x ? startPoint.x : pointZero.x;\n  controlPoints[0].y = currentY === scaleStartPoint.y ? startPoint.y : pointZero.y;\n  controlPoints.unshift(startPoint);\n  return controlPoints;\n};\nexport var pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {\n  if (isNaN(startPoint.x) || isNaN(endPoint.x)) return [];\n  var cfg = deepMix(defaultCfg, routerCfg);\n  cfg.obstacles = cfg.obstacles || [];\n  var penalties = cfg.penalties,\n    gridSize = cfg.gridSize;\n  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), gridSize, cfg.offset);\n  var scaleStartPoint = {\n    x: pos2GridIx(startPoint.x, gridSize),\n    y: pos2GridIx(startPoint.y, gridSize)\n  };\n  var scaleEndPoint = {\n    x: pos2GridIx(endPoint.x, gridSize),\n    y: pos2GridIx(endPoint.y, gridSize)\n  };\n  startPoint.id = \"\".concat(scaleStartPoint.x, \"|||\").concat(scaleStartPoint.y);\n  endPoint.id = \"\".concat(scaleEndPoint.x, \"|||\").concat(scaleEndPoint.y);\n  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);\n  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);\n  startPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  endPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  var openSet = {};\n  var closedSet = {};\n  var cameFrom = {};\n  // 从起点到当前点已产生的 cost, default: Infinity\n  var gScore = {};\n  // 起点经过当前点到达终点预估的 cost, default: Infinity\n  var fScore = {};\n  var sortedOpenSet = new SortedArray();\n  // initialize\n  for (var i = 0; i < startPoints.length; i++) {\n    var firstStep = startPoints[i];\n    openSet[firstStep.id] = firstStep;\n    gScore[firstStep.id] = 0;\n    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);\n    sortedOpenSet.add({\n      id: firstStep.id,\n      value: fScore[firstStep.id]\n    });\n  }\n  var remainLoops = cfg.maximumLoops;\n  var current, direction, neighbor, neighborCost, costFromStart, directionChange;\n  var curCost = Infinity;\n  var endPointMap = {};\n  endPoints.forEach(function (point) {\n    endPointMap[\"\".concat(point.x, \"|||\").concat(point.y)] = true;\n  });\n  Object.keys(openSet).forEach(function (key) {\n    var id = openSet[key].id;\n    if (fScore[id] <= curCost) {\n      curCost = fScore[id];\n      current = openSet[id];\n    }\n  });\n  while (Object.keys(openSet).length > 0 && remainLoops > 0) {\n    var minId = sortedOpenSet.minId((remainLoops + 1) % 30 === 0);\n    if (minId) {\n      current = openSet[minId];\n    } else {\n      break;\n    }\n    // 如果 fScore 最小的点就是终点\n    if (endPointMap[\"\".concat(current.x, \"|||\").concat(current.y)]) {\n      return getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize);\n    }\n    delete openSet[current.id];\n    sortedOpenSet.remove(current.id);\n    closedSet[current.id] = true;\n    // 获取符合条件的下一步的候选连接点\n    // 沿候选方向走一步\n    for (var i = 0; i < cfg.directions.length; i++) {\n      direction = cfg.directions[i];\n      var neighborId = \"\".concat(Math.round(current.x) + direction.stepX, \"|||\").concat(Math.round(current.y) + direction.stepY);\n      neighbor = {\n        x: current.x + direction.stepX,\n        y: current.y + direction.stepY,\n        id: neighborId\n      };\n      if (closedSet[neighborId]) continue;\n      directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);\n      if (directionChange > cfg.maxAllowedDirectionChange) continue;\n      if (map[neighborId]) continue; // 如果交叉则跳过\n      // 将候选点加入 openSet, 并计算每个候选点的 cost\n      if (!openSet[neighborId]) {\n        openSet[neighborId] = neighbor;\n      }\n      var directionPenalties = penalties[directionChange];\n      neighborCost = cfg.distFunc(current, neighbor) + (isNaN(directionPenalties) ? gridSize : directionPenalties);\n      costFromStart = gScore[current.id] + neighborCost;\n      var neighborGScore = gScore[neighborId];\n      if (neighborGScore && costFromStart >= neighborGScore) {\n        continue;\n      }\n      cameFrom[neighborId] = current;\n      gScore[neighborId] = costFromStart;\n      fScore[neighborId] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);\n      sortedOpenSet.add({\n        id: neighborId,\n        value: fScore[neighborId]\n      });\n    }\n    remainLoops -= 1;\n  }\n  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);\n};","map":{"version":3,"names":["Util","deepMix","getExpandedBBox","getExpandedBBoxPoint","getPolylinePoints","simplifyPolyline","isSegmentCrossingBBox","SortedArray","manhattanDist","p1","p2","Math","abs","x","y","eucliDist","sqrt","pow","straightPath","start","end","simplePolyline","startNode","endNode","cfg","offset","defaultCfg","maxAllowedDirectionChange","PI","maximumLoops","gridSize","directions","stepX","stepY","penalties","distFunc","fallbackRoute","octolinearCfg","pos2GridIx","pos","gridIx","round","sign","getObstacleMap","items","map","forEach","item","bbox","getBBox","minX","maxX","minY","maxY","concat","getDirectionAngle","deltaX","deltaY","atan2","getAngleDiff","angle1","angle2","directionChange","estimateCost","from","endPoints","min","Infinity","i","len","length","cost","getBoxPoints","point","oriPoint","node","anotherPoint","points","isInside","expandBBox","_i","directions_1","dir","bounds","boundLine","insterctP_1","getLineIntersect","width","height","id","push","insterctP","getDirectionChange","current","neighbor","cameFrom","scaleStartPoint","directionAngle","currentCameFrom","startAngle","prevDirectionAngle","getControlPoints","endPoint","startPoint","scaleEndPoint","controlPoints","pointZero","currentId","currentX","currentY","lastPoint","unshift","prePoint","pathFinder","routerCfg","isNaN","obstacles","startPoints","openSet","closedSet","gScore","fScore","sortedOpenSet","firstStep","add","value","remainLoops","direction","neighborCost","costFromStart","curCost","endPointMap","Object","keys","key","minId","remove","neighborId","directionPenalties","neighborGScore"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/g6-element/es/edges/router.js"],"sourcesContent":["/**\n * 通过配置不同的 costFunc, distFunc, constraints 可以得到不同效果的 router\n * generalRouter: 不限制搜索时的移动方向，避开障碍即可\n * orthogonal: 线必须沿着竖直或水平方向（4个方向）\n * octolinearRouter: 线沿着竖直、水平、对角线方向（8个方向）\n */\nimport { Util } from '@antv/g6-core';\nimport { deepMix } from '@antv/util';\nimport { getExpandedBBox, getExpandedBBoxPoint, getPolylinePoints, simplifyPolyline, isSegmentCrossingBBox, SortedArray } from './polyline-util';\nvar manhattanDist = function manhattanDist(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\nvar eucliDist = function eucliDist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\nvar straightPath = function straightPath(start, end) {\n  // console.warn('fallbackRoute: straight path');\n  return [start, end];\n};\nvar simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {\n  return simplifyPolyline(getPolylinePoints(start, end, startNode, endNode, cfg.offset));\n};\n// getPolylinePoints\nvar defaultCfg = {\n  offset: 20,\n  maxAllowedDirectionChange: Math.PI / 2,\n  maximumLoops: 2000,\n  gridSize: 10,\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: -1\n  } // top\n  ],\n\n  get penalties() {\n    return {\n      0: 0,\n      45: this.gridSize / 2,\n      90: this.gridSize / 2\n    };\n  },\n  distFunc: manhattanDist,\n  fallbackRoute: simplePolyline\n};\nexport var octolinearCfg = {\n  maxAllowedDirectionChange: Math.PI / 4,\n  // 8 个方向: 上下左右 + 45度斜线方向\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: 1,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: -1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }, {\n    stepX: 1,\n    stepY: -1\n  }],\n  distFunc: eucliDist,\n  fallbackRoute: straightPath\n};\nvar pos2GridIx = function pos2GridIx(pos, gridSize) {\n  var gridIx = Math.round(Math.abs(pos / gridSize));\n  var sign = pos < 0 ? -1 : 1;\n  return gridIx < 0 ? 0 : sign * gridIx;\n};\nvar getObstacleMap = function getObstacleMap(items, gridSize, offset) {\n  var map = {};\n  items.forEach(function (item) {\n    // create-edge 时，当边类型为 polyline 时 endNode 为 null\n    if (!item) return;\n    var bbox = getExpandedBBox(item.getBBox(), offset);\n    for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {\n      for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {\n        map[\"\".concat(x, \"|||\").concat(y)] = true;\n      }\n    }\n  });\n  return map;\n};\n/**\n * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）\n * @param p1 PolyPoint\n * @param p2 PolyPoint\n */\nvar getDirectionAngle = function getDirectionAngle(p1, p2) {\n  var deltaX = p2.x - p1.x;\n  var deltaY = p2.y - p1.y;\n  if (deltaX || deltaY) {\n    return Math.atan2(deltaY, deltaX);\n  }\n  return 0;\n};\n/**\n * 方向角的改变，取小于180度角\n * @param angle1\n * @param angle2\n */\nvar getAngleDiff = function getAngleDiff(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange;\n  // return directionChange > 180 ? 360 - directionChange : directionChange;\n};\n// Path finder //\nvar estimateCost = function estimateCost(from, endPoints, distFunc) {\n  var min = Infinity;\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = distFunc(from, endPoints[i]);\n    if (cost < min) {\n      min = cost;\n    }\n  }\n  return min;\n};\n// 计算考虑 offset 后的 BBox 上的连接点\nvar getBoxPoints = function getBoxPoints(point,\n// 被 gridSize 格式化后的位置（anchorPoint）\noriPoint,\n// 未被 gridSize 格式化的位置（anchorPoint）\nnode,\n// 原始节点，用于获取 bbox\nanotherPoint,\n// 另一端被 gridSize 格式化后的位置\ncfg) {\n  var points = [];\n  // create-edge 生成边的过程中，endNode 为 null\n  if (!node) {\n    return [point];\n  }\n  var directions = cfg.directions,\n    offset = cfg.offset;\n  var bbox = node.getBBox();\n  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;\n  var expandBBox = getExpandedBBox(bbox, offset);\n  for (var i in expandBBox) {\n    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);\n  }\n  if (isInside) {\n    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点\n    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n      var dir = directions_1[_i];\n      var bounds = [[{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }]];\n      for (var i = 0; i < 4; i++) {\n        var boundLine = bounds[i];\n        var insterctP_1 = Util.getLineIntersect(point, {\n          x: point.x + dir.stepX * expandBBox.width,\n          y: point.y + dir.stepY * expandBBox.height\n        }, boundLine[0], boundLine[1]);\n        if (insterctP_1 && !isSegmentCrossingBBox(point, insterctP_1, bbox)) {\n          insterctP_1.id = \"\".concat(insterctP_1.x, \"|||\").concat(insterctP_1.y);\n          points.push(insterctP_1);\n        }\n      }\n    }\n    return points;\n  }\n  // 如果 anchorPoint 在节点上，只有一个可选方向\n  var insterctP = getExpandedBBoxPoint(expandBBox, point, anotherPoint);\n  insterctP.id = \"\".concat(insterctP.x, \"|||\").concat(insterctP.y);\n  return [insterctP];\n};\nvar getDirectionChange = function getDirectionChange(current, neighbor, cameFrom, scaleStartPoint) {\n  var directionAngle = getDirectionAngle(current, neighbor);\n  var currentCameFrom = cameFrom[current.id];\n  if (!currentCameFrom) {\n    var startAngle = getDirectionAngle(scaleStartPoint, current);\n    return getAngleDiff(startAngle, directionAngle);\n  }\n  var prevDirectionAngle = getDirectionAngle({\n    x: currentCameFrom.x,\n    y: currentCameFrom.y\n  }, current);\n  return getAngleDiff(prevDirectionAngle, directionAngle);\n};\nvar getControlPoints = function getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize) {\n  var controlPoints = [endPoint];\n  var pointZero = endPoint;\n  var currentId = current.id;\n  var currentX = current.x;\n  var currentY = current.y;\n  var lastPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  };\n  if (getDirectionChange(lastPoint, scaleEndPoint, cameFrom, scaleStartPoint)) {\n    pointZero = {\n      x: scaleEndPoint.x === endPoint.x ? endPoint.x : lastPoint.x * gridSize,\n      y: scaleEndPoint.y === endPoint.y ? endPoint.y : lastPoint.y * gridSize\n    };\n    controlPoints.unshift(pointZero);\n  }\n  var currentCameFrom = cameFrom[currentId];\n  while (currentCameFrom && currentCameFrom.id !== currentId) {\n    var point = {\n      x: currentX,\n      y: currentY,\n      id: currentId\n    };\n    var prePoint = {\n      x: currentCameFrom.x,\n      y: currentCameFrom.y,\n      id: currentCameFrom.id\n    };\n    var directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);\n    if (directionChange) {\n      pointZero = {\n        x: prePoint.x === point.x ? pointZero.x : prePoint.x * gridSize,\n        y: prePoint.y === point.y ? pointZero.y : prePoint.y * gridSize\n      };\n      controlPoints.unshift(pointZero);\n    }\n    currentId = prePoint.id;\n    currentX = prePoint.x;\n    currentY = prePoint.y;\n    currentCameFrom = cameFrom[currentId];\n  }\n  // 和startNode对齐\n  controlPoints[0].x = currentX === scaleStartPoint.x ? startPoint.x : pointZero.x;\n  controlPoints[0].y = currentY === scaleStartPoint.y ? startPoint.y : pointZero.y;\n  controlPoints.unshift(startPoint);\n  return controlPoints;\n};\nexport var pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {\n  if (isNaN(startPoint.x) || isNaN(endPoint.x)) return [];\n  var cfg = deepMix(defaultCfg, routerCfg);\n  cfg.obstacles = cfg.obstacles || [];\n  var penalties = cfg.penalties,\n    gridSize = cfg.gridSize;\n  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), gridSize, cfg.offset);\n  var scaleStartPoint = {\n    x: pos2GridIx(startPoint.x, gridSize),\n    y: pos2GridIx(startPoint.y, gridSize)\n  };\n  var scaleEndPoint = {\n    x: pos2GridIx(endPoint.x, gridSize),\n    y: pos2GridIx(endPoint.y, gridSize)\n  };\n  startPoint.id = \"\".concat(scaleStartPoint.x, \"|||\").concat(scaleStartPoint.y);\n  endPoint.id = \"\".concat(scaleEndPoint.x, \"|||\").concat(scaleEndPoint.y);\n  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);\n  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);\n  startPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  endPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  var openSet = {};\n  var closedSet = {};\n  var cameFrom = {};\n  // 从起点到当前点已产生的 cost, default: Infinity\n  var gScore = {};\n  // 起点经过当前点到达终点预估的 cost, default: Infinity\n  var fScore = {};\n  var sortedOpenSet = new SortedArray();\n  // initialize\n  for (var i = 0; i < startPoints.length; i++) {\n    var firstStep = startPoints[i];\n    openSet[firstStep.id] = firstStep;\n    gScore[firstStep.id] = 0;\n    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);\n    sortedOpenSet.add({\n      id: firstStep.id,\n      value: fScore[firstStep.id]\n    });\n  }\n  var remainLoops = cfg.maximumLoops;\n  var current, direction, neighbor, neighborCost, costFromStart, directionChange;\n  var curCost = Infinity;\n  var endPointMap = {};\n  endPoints.forEach(function (point) {\n    endPointMap[\"\".concat(point.x, \"|||\").concat(point.y)] = true;\n  });\n  Object.keys(openSet).forEach(function (key) {\n    var id = openSet[key].id;\n    if (fScore[id] <= curCost) {\n      curCost = fScore[id];\n      current = openSet[id];\n    }\n  });\n  while (Object.keys(openSet).length > 0 && remainLoops > 0) {\n    var minId = sortedOpenSet.minId((remainLoops + 1) % 30 === 0);\n    if (minId) {\n      current = openSet[minId];\n    } else {\n      break;\n    }\n    // 如果 fScore 最小的点就是终点\n    if (endPointMap[\"\".concat(current.x, \"|||\").concat(current.y)]) {\n      return getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize);\n    }\n    delete openSet[current.id];\n    sortedOpenSet.remove(current.id);\n    closedSet[current.id] = true;\n    // 获取符合条件的下一步的候选连接点\n    // 沿候选方向走一步\n    for (var i = 0; i < cfg.directions.length; i++) {\n      direction = cfg.directions[i];\n      var neighborId = \"\".concat(Math.round(current.x) + direction.stepX, \"|||\").concat(Math.round(current.y) + direction.stepY);\n      neighbor = {\n        x: current.x + direction.stepX,\n        y: current.y + direction.stepY,\n        id: neighborId\n      };\n      if (closedSet[neighborId]) continue;\n      directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);\n      if (directionChange > cfg.maxAllowedDirectionChange) continue;\n      if (map[neighborId]) continue; // 如果交叉则跳过\n      // 将候选点加入 openSet, 并计算每个候选点的 cost\n      if (!openSet[neighborId]) {\n        openSet[neighborId] = neighbor;\n      }\n      var directionPenalties = penalties[directionChange];\n      neighborCost = cfg.distFunc(current, neighbor) + (isNaN(directionPenalties) ? gridSize : directionPenalties);\n      costFromStart = gScore[current.id] + neighborCost;\n      var neighborGScore = gScore[neighborId];\n      if (neighborGScore && costFromStart >= neighborGScore) {\n        continue;\n      }\n      cameFrom[neighborId] = current;\n      gScore[neighborId] = costFromStart;\n      fScore[neighborId] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);\n      sortedOpenSet.add({\n        id: neighborId,\n        value: fScore[neighborId]\n      });\n    }\n    remainLoops -= 1;\n  }\n  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}