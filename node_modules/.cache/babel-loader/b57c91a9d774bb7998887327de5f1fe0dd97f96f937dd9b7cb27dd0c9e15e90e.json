{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { lodashUtil, rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { polygonTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/ocean/ocean_frag.glsl' */\nvar ocean_frag = \"\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_watercolor;\\n  vec4 u_watercolor2;\\n  float u_time;\\n};\\n\\nin vec2 v_uv;\\nin float v_opacity;\\nout vec4 outputColor;\\n\\nfloat coast2water_fadedepth = 0.10;\\nfloat large_waveheight      = .750; // change to adjust the \\\"heavy\\\" waves\\nfloat large_wavesize        = 3.4;  // factor to adjust the large wave size\\nfloat small_waveheight      = 0.6;  // change to adjust the small random waves\\nfloat small_wavesize        = 0.5;   // factor to ajust the small wave size\\nfloat water_softlight_fact  = 15.;  // range [1..200] (should be << smaller than glossy-fact)\\nfloat water_glossylight_fact= 120.; // range [1..200]\\nfloat particle_amount       = 70.;\\n\\nvec3 water_specularcolor    = vec3(1.3, 1.3, 0.9);    // specular Color (RGB) of the water-highlights\\n#define light                 vec3(-0., sin(u_time*0.5)*.5 + .35, 2.8) // position of the sun\\n\\nuniform sampler2D u_texture1;\\nuniform sampler2D u_texture2;\\nuniform sampler2D u_texture3;\\n\\n  \\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*43758.5453123);\\n}\\n\\n// 2d noise function\\nfloat noise1( in vec2 x ) {\\n  vec2 p  = floor(x);\\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\\n  float n = p.x + p.y*57.0;\\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\\n}\\n\\nfloat noise(vec2 p) {\\n    return texture(SAMPLER_2D(u_texture2),p*vec2(1./256.)).x;\\n}\\n\\nvec4 highness(vec2 p) {\\n    vec4 t = texture(SAMPLER_2D(u_texture1),fract(p));\\n    float clipped = -2.0-smoothstep(3.,10.,t.a)*6.9-smoothstep(10.,100.,t.a)*89.9-smoothstep(0.,10000.,t.a)*10000.0;\\n    return clamp(t, 0.0,3.0)+clamp(t/3.0-1.0, 0.0,1.0)+clamp(t/16.0-1.0, 0.0,1.0);\\n}\\n\\nfloat height_map( vec2 p ) {\\n    vec4 height=highness(p);\\n    /*\\n    height = -0.5+\\n        0.5*smoothstep(-100.,0.,-height)+\\n        2.75*smoothstep(0.,2.,height)+\\n        1.75*smoothstep(2.,4.,height)+\\n        2.75*smoothstep(4.,16.,height)+\\n        1.5*smoothstep(16.,1000.,height);\\n    */\\n\\n    mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );\\n    //p = p*6.;\\n    float f = 0.6000*noise1( p ); p = m*p*1.1*6.;\\n    f += 0.2500*noise( p ); p = m*p*1.32;\\n    f += 0.1666*noise( p ); p = m*p*1.11;\\n    f += 0.0834*noise( p ); p = m*p*1.12;\\n    f += 0.0634*noise( p ); p = m*p*1.13;\\n    f += 0.0444*noise( p ); p = m*p*1.14;\\n    f += 0.0274*noise( p ); p = m*p*1.15;\\n    f += 0.0134*noise( p ); p = m*p*1.16;\\n    f += 0.0104*noise( p ); p = m*p*1.17;\\n    f += 0.0084*noise( p );\\n    f = .25*f+dot(height,vec4(-.03125,-.125,.25,.25))*.5;\\n        const float FLAT_LEVEL = 0.92525;\\n        //f = f*0.25+height*0.75;\\n    if (f<FLAT_LEVEL)\\n        f = f;\\n    else\\n        f = pow((f-FLAT_LEVEL)/(1.-FLAT_LEVEL), 2.)*(1.-FLAT_LEVEL)*2.0+FLAT_LEVEL; // makes a smooth coast-increase\\n    return clamp(f, 0., 10.);\\n}\\n\\nvec3 plasma_quintic( float x ) {\\n    x = clamp( x, 0.0, 1.0);\\n    vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\\n    vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\\n    return vec3(\\n        dot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),\\n        dot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),\\n        dot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) );\\n}\\n\\nvec4 color(vec2 p){\\n    vec4 c1 = vec4(1.7,1.6,.9,1);\\n    vec4 c2 = vec4(.2,.94,.1,1);\\n    vec4 c3 = vec4(.3,.2,.0,1);\\n    vec4 c4 = vec4(.99,.99,1.6,1);\\n    vec4 v = highness(p);\\n    float los = smoothstep(0.1,1.1,v.b);\\n    float his = smoothstep(3.5,6.5,v.b);\\n    float ces = smoothstep(1.,5.,v.a);\\n    vec4 lo = mix(c1,c2,los);\\n    vec4 hi = mix(c3,c4,his);\\n    vec4 ce = mix(lo,hi,ces);\\n\\n    return vec4(plasma_quintic(ces),1).ragb;\\n}\\n\\nvec3 terrain_map( vec2 p )\\n{\\n  return color(p).rgb*0.75+0.25*vec3(0.7, .55, .4)+texture(SAMPLER_2D(u_texture3), fract(p*5.)).rgb*.5; // test-terrain is simply 'sandstone'\\n}\\n\\nconst mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );\\n\\nfloat water_map( vec2 p, float height ) {\\n    vec2 p2 = p*large_wavesize;\\n    vec2 shift1 = 0.001*vec2( u_time*160.0*2.0, u_time*120.0*2.0 );\\n    vec2 shift2 = 0.001*vec2( u_time*190.0*2.0, -u_time*130.0*2.0 );\\n\\n    // coarse crossing 'ocean' waves...\\n    float f = 0.6000*noise( p );\\n    f += 0.2500*noise( p*m );\\n    f += 0.1666*noise( p*m*m );\\n    float wave = sin(p2.x*0.622+p2.y*0.622+shift2.x*4.269)*large_waveheight*f*height*height ;\\n\\n    p *= small_wavesize;\\n    f = 0.;\\n    float amp = 1.0, s = .5;\\n    for (int i=0; i<9; i++)\\n    { p = m*p*.947; f -= amp*abs(sin((noise( p+shift1*s )-.5)*2.)); amp = amp*.59; s*=-1.329; }\\n    \\n    return wave+f*small_waveheight;\\n}\\n\\nfloat nautic(vec2 p) {\\n    p *= 18.;\\n    float f = 0.;\\n    float amp = 1.0, s = .5;\\n    for (int i=0; i<3; i++)\\n    { p = m*p*1.2; f += amp*abs(smoothstep(0., 1., noise( p+u_time*s ))-.5); amp = amp*.5; s*=-1.227; }\\n    return pow(1.-f, 5.);\\n}\\n\\nfloat particles(vec2 p) {\\n    p *= 200.;\\n    float f = 0.;\\n    float amp = 1.0, s = 1.5;\\n    for (int i=0; i<3; i++)\\n    { p = m*p*1.2; f += amp*noise( p+u_time*s ); amp = amp*.5; s*=-1.227; }\\n    return pow(f*.35, 7.)*particle_amount;\\n}\\n\\nfloat test_shadow( vec2 xy, float height) {\\n    vec3 r0 = vec3(xy, height);\\n    vec3 rd = normalize( light - r0 );\\n    \\n    float hit = 1.0;\\n    float t   = 0.001;\\n    for (int j=1; j<25; j++)\\n    {\\n        vec3 p = r0 + t*rd;\\n        float h = height_map( p.xy );\\n        float height_diff = p.z - h;\\n        if (height_diff<0.0)\\n        {\\n            return 0.0;\\n        }\\n        t += 0.01+height_diff*.02;\\n        hit = min(hit, 2.*height_diff/t); // soft shaddow   \\n    }\\n    return hit;\\n}\\n\\nvec3 CalcTerrain(vec2 uv, float height) {\\n    vec3 col = terrain_map( uv );\\n    vec2 iResolution = vec2(512.);\\n    float h1 = height_map(uv-vec2(0., 0.5)/ iResolution.xy);\\n    float h2 = height_map(uv+vec2(0., 0.5)/ iResolution.xy);\\n    float h3 = height_map(uv-vec2(0.5, 0.)/ iResolution.xy);\\n    float h4 = height_map(uv+vec2(0.5, 0.)/ iResolution.xy);\\n    vec3 norm = normalize(vec3(h3-h4, h1-h2, 1.));\\n    vec3 r0 = vec3(uv, height);\\n    vec3 rd = normalize( light - r0 );\\n    float grad = dot(norm, rd);\\n    col *= grad+pow(grad, 8.);\\n    float terrainshade = test_shadow( uv, height );\\n    col = mix(col*.25, col, terrainshade);\\n    return col;\\n}\\n\\n\\nvoid main() {\\n  vec3 watercolor = u_watercolor.rgb;\\n  vec3 watercolor2 = u_watercolor2.rgb;\\n  vec2 uv = v_uv;\\n  float WATER_LEVEL = 0.84; // Water level (range: 0.0 - 2.0)\\n  float deepwater_fadedepth   = 0.4 + coast2water_fadedepth;\\n  float height = height_map( uv );\\n  vec3 col;\\n\\n    float waveheight = clamp(WATER_LEVEL*3.-1.5, 0., 1.);\\n    float level = WATER_LEVEL + .2*water_map(uv*15. + vec2(u_time*.1), waveheight);\\n    if (height > level)\\n    {\\n        col = CalcTerrain(uv, height);\\n    }\\n    if (height <= level)\\n    {\\n        vec2 dif = vec2(.0, .01);\\n        vec2 pos = uv*15. + vec2(u_time*.01);\\n        float h1 = water_map(pos-dif,waveheight);\\n        float h2 = water_map(pos+dif,waveheight);\\n        float h3 = water_map(pos-dif.yx,waveheight);\\n        float h4 = water_map(pos+dif.yx,waveheight);\\n        vec3 normwater = normalize(vec3(h3-h4, h1-h2, .125)); // norm-vector of the 'bumpy' water-plane\\n        uv += normwater.xy*.002*(level-height);\\n        \\n        col = CalcTerrain(uv, height);\\n\\n        float coastfade = clamp((level-height)/coast2water_fadedepth, 0., 1.);\\n        float coastfade2= clamp((level-height)/deepwater_fadedepth, 0., 1.);\\n        float intensity = col.r*.2126+col.g*.7152+col.b*.0722;\\n        watercolor = mix(watercolor*intensity, watercolor2, smoothstep(0., 1., coastfade2));\\n\\n        vec3 r0 = vec3(uv, WATER_LEVEL);\\n        vec3 rd = normalize( light - r0 ); // ray-direction to the light from water-position\\n        float grad     = dot(normwater, rd); // dot-product of norm-vector and light-direction\\n        float specular = pow(grad, water_softlight_fact);  // used for soft highlights                          \\n        float specular2= pow(grad, water_glossylight_fact); // used for glossy highlights\\n        float gradpos  = dot(vec3(0., 0., 1.), rd);\\n        float specular1= smoothstep(0., 1., pow(gradpos, 5.));  // used for diffusity (some darker corona around light's specular reflections...)                          \\n        float watershade  = test_shadow( uv, level );\\n        watercolor *= 2.2+watershade;\\n        watercolor += (.2+.8*watershade) * ((grad-1.0)*.5+specular) * .25;\\n        watercolor /= (1.+specular1*1.25);\\n        watercolor += watershade*specular2*water_specularcolor;\\n        watercolor += watershade*coastfade*(1.-coastfade2)*(vec3(.5, .6, .7)*nautic(uv)+vec3(1., 1., 1.)*particles(uv));\\n        \\n        col = mix(col, watercolor, coastfade);\\n    }\\n    \\n  outputColor = vec4(col, v_opacity);  \\n}\\n\";\n/* babel-plugin-inline-import '../shaders/ocean/ocean_vert.glsl' */\nvar ocean_vert = \"layout(location = 0) in vec3 a_Position;\\nlayout(location = 14) in vec2 a_uv;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_watercolor;\\n  vec4 u_watercolor2;\\n  float u_time;\\n};\\n\\n\\nout vec2 v_uv;\\nout float v_opacity;\\n\\n#pragma include \\\"projection\\\"\\n\\nvoid main() {\\n  v_uv = a_uv;\\n  v_opacity = opacity;\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n  gl_Position = project_common_position_to_clipspace_v2(vec4(project_pos.xyz, 1.0));\\n}\\n\\n\";\nimport { ShaderLocation } from \"../../core/CommonStyleAttribute\";\nvar isNumber = lodashUtil.isNumber;\nvar OceanModel = /*#__PURE__*/function (_BaseModel) {\n  _inherits(OceanModel, _BaseModel);\n  var _super = _createSuper(OceanModel);\n  function OceanModel() {\n    _classCallCheck(this, OceanModel);\n    return _super.apply(this, arguments);\n  }\n  _createClass(OceanModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var commoninfo = this.getCommonUniformsInfo();\n      var attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n      this.updateStyleUnifoms();\n      return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n    }\n  }, {\n    key: \"getCommonUniformsInfo\",\n    value: function getCommonUniformsInfo() {\n      var _ref = this.layer.getLayerConfig(),\n        _ref$watercolor = _ref.watercolor,\n        watercolor = _ref$watercolor === void 0 ? '#6D99A8' : _ref$watercolor,\n        _ref$watercolor2 = _ref.watercolor2,\n        watercolor2 = _ref$watercolor2 === void 0 ? '#0F121C' : _ref$watercolor2;\n      var commonOptions = {\n        u_watercolor: rgb2arr(watercolor),\n        u_watercolor2: rgb2arr(watercolor2),\n        u_time: this.layer.getLayerAnimateTime(),\n        u_texture1: this.texture1,\n        u_texture2: this.texture2,\n        u_texture3: this.texture3\n      };\n\n      // u_opacity: isNumber(opacity) ? opacity : 1.0,\n      this.textures = [this.texture1, this.texture2, this.texture3];\n      var commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n      return commonBufferInfo;\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      return {\n        u_time: this.layer.getLayerAnimateTime()\n      };\n    }\n  }, {\n    key: \"initModels\",\n    value: function () {\n      var _initModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.loadTexture();\n              return _context.abrupt(\"return\", this.buildModels());\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function initModels() {\n        return _initModels.apply(this, arguments);\n      }\n      return initModels;\n    }()\n  }, {\n    key: \"buildModels\",\n    value: function () {\n      var _buildModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var model;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.initUniformsBuffer();\n              _context2.next = 3;\n              return this.layer.buildLayerModel({\n                moduleName: 'polygonOcean',\n                vertexShader: ocean_vert,\n                fragmentShader: ocean_frag,\n                inject: this.getInject(),\n                triangulation: polygonTriangulation,\n                primitive: gl.TRIANGLES,\n                depth: {\n                  enable: false\n                }\n              });\n            case 3:\n              model = _context2.sent;\n              return _context2.abrupt(\"return\", [model]);\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function buildModels() {\n        return _buildModels.apply(this, arguments);\n      }\n      return buildModels;\n    }()\n  }, {\n    key: \"clearModels\",\n    value: function clearModels() {\n      var _this$texture, _this$texture2, _this$texture3;\n      (_this$texture = this.texture1) === null || _this$texture === void 0 || _this$texture.destroy();\n      (_this$texture2 = this.texture2) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n      (_this$texture3 = this.texture3) === null || _this$texture3 === void 0 || _this$texture3.destroy();\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      var bbox = this.layer.getSource().extent;\n      var _bbox = _slicedToArray(bbox, 4),\n        minLng = _bbox[0],\n        minLat = _bbox[1],\n        maxLng = _bbox[2],\n        maxLat = _bbox[3];\n      var lngLen = maxLng - minLng;\n      var latLen = maxLat - minLat;\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'oceanUv',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_uv',\n          shaderLocation: ShaderLocation.UV,\n          buffer: {\n            // give the WebGL driver a hint that this buffer may change\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 2,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var v = feature.version === 'GAODE2.x' ? feature.originCoordinates[0][attributeIdx] : vertex;\n            var _v = _slicedToArray(v, 2),\n              lng = _v[0],\n              lat = _v[1];\n            return [(lng - minLng) / lngLen, (lat - minLat) / latLen];\n          }\n        }\n      });\n    }\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture() {\n      var _this = this;\n      var createTexture2D = this.rendererService.createTexture2D;\n      var defaultTextureOptions = {\n        height: 0,\n        width: 0\n      };\n      // 默认索引为 undefined，所以单独赋值\n      this.texture1 = createTexture2D(defaultTextureOptions);\n      this.texture2 = createTexture2D(defaultTextureOptions);\n      this.texture3 = createTexture2D(defaultTextureOptions);\n\n      // 加载完 image 后单独给 texture f赋值\n      initImage(function (images) {\n        _this.texture1 = initTex(images[0]);\n        _this.texture2 = initTex(images[1]);\n        _this.texture3 = initTex(images[2]);\n        _this.layerService.reRender();\n      });\n      function initImage(callback) {\n        var loadedCount = 0;\n        var loadedImages = [];\n        var images = ['https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ', 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*MJ22QbpuCzIAAAAAAAAAAAAAARQnAQ', 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*-z2HSIVDsHIAAAAAAAAAAAAAARQnAQ'];\n        images.map(function (imgSrc) {\n          var image = new Image();\n          image.crossOrigin = '';\n          image.src = imgSrc;\n          loadedImages.push(image);\n          image.onload = function () {\n            loadedCount++;\n            if (loadedCount === 3) {\n              callback(loadedImages);\n            }\n          };\n        });\n      }\n      function initTex(image) {\n        return createTexture2D({\n          data: image,\n          width: image.width,\n          height: image.height,\n          wrapS: gl.MIRRORED_REPEAT,\n          wrapT: gl.MIRRORED_REPEAT,\n          min: gl.LINEAR,\n          mag: gl.LINEAR\n        });\n      }\n    }\n  }]);\n  return OceanModel;\n}(BaseModel);\nexport { OceanModel as default };","map":{"version":3,"names":["_slicedToArray","_asyncToGenerator","_objectSpread","_classCallCheck","_createClass","_inherits","_possibleConstructorReturn","_getPrototypeOf","_regeneratorRuntime","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","AttributeType","gl","lodashUtil","rgb2arr","BaseModel","polygonTriangulation","ocean_frag","ocean_vert","ShaderLocation","isNumber","OceanModel","_BaseModel","_super","key","value","getUninforms","commoninfo","getCommonUniformsInfo","attributeInfo","getUniformsBufferInfo","getStyleAttribute","updateStyleUnifoms","uniformsOption","_ref","layer","getLayerConfig","_ref$watercolor","watercolor","_ref$watercolor2","watercolor2","commonOptions","u_watercolor","u_watercolor2","u_time","getLayerAnimateTime","u_texture1","texture1","u_texture2","texture2","u_texture3","texture3","textures","commonBufferInfo","getAnimateUniforms","_initModels","mark","_callee","wrap","_callee$","_context","prev","next","loadTexture","abrupt","buildModels","stop","initModels","_buildModels","_callee2","model","_callee2$","_context2","initUniformsBuffer","buildLayerModel","moduleName","vertexShader","fragmentShader","inject","getInject","triangulation","primitive","TRIANGLES","depth","enable","sent","clearModels","_this$texture","_this$texture2","_this$texture3","destroy","registerBuiltinAttributes","bbox","getSource","extent","_bbox","minLng","minLat","maxLng","maxLat","lngLen","latLen","styleAttributeService","registerStyleAttribute","name","type","Attribute","descriptor","shaderLocation","UV","buffer","usage","STATIC_DRAW","data","FLOAT","size","update","feature","featureIdx","vertex","attributeIdx","v","version","originCoordinates","_v","lng","lat","_this","createTexture2D","rendererService","defaultTextureOptions","height","width","initImage","images","initTex","layerService","reRender","callback","loadedCount","loadedImages","map","imgSrc","image","Image","crossOrigin","src","push","onload","wrapS","MIRRORED_REPEAT","wrapT","min","LINEAR","mag","default"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-layers/es/polygon/models/ocean.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { lodashUtil, rgb2arr } from '@antv/l7-utils';\nimport BaseModel from \"../../core/BaseModel\";\nimport { polygonTriangulation } from \"../../core/triangulation\";\n/* babel-plugin-inline-import '../shaders/ocean/ocean_frag.glsl' */\nvar ocean_frag = \"\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_watercolor;\\n  vec4 u_watercolor2;\\n  float u_time;\\n};\\n\\nin vec2 v_uv;\\nin float v_opacity;\\nout vec4 outputColor;\\n\\nfloat coast2water_fadedepth = 0.10;\\nfloat large_waveheight      = .750; // change to adjust the \\\"heavy\\\" waves\\nfloat large_wavesize        = 3.4;  // factor to adjust the large wave size\\nfloat small_waveheight      = 0.6;  // change to adjust the small random waves\\nfloat small_wavesize        = 0.5;   // factor to ajust the small wave size\\nfloat water_softlight_fact  = 15.;  // range [1..200] (should be << smaller than glossy-fact)\\nfloat water_glossylight_fact= 120.; // range [1..200]\\nfloat particle_amount       = 70.;\\n\\nvec3 water_specularcolor    = vec3(1.3, 1.3, 0.9);    // specular Color (RGB) of the water-highlights\\n#define light                 vec3(-0., sin(u_time*0.5)*.5 + .35, 2.8) // position of the sun\\n\\nuniform sampler2D u_texture1;\\nuniform sampler2D u_texture2;\\nuniform sampler2D u_texture3;\\n\\n  \\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*43758.5453123);\\n}\\n\\n// 2d noise function\\nfloat noise1( in vec2 x ) {\\n  vec2 p  = floor(x);\\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\\n  float n = p.x + p.y*57.0;\\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\\n}\\n\\nfloat noise(vec2 p) {\\n    return texture(SAMPLER_2D(u_texture2),p*vec2(1./256.)).x;\\n}\\n\\nvec4 highness(vec2 p) {\\n    vec4 t = texture(SAMPLER_2D(u_texture1),fract(p));\\n    float clipped = -2.0-smoothstep(3.,10.,t.a)*6.9-smoothstep(10.,100.,t.a)*89.9-smoothstep(0.,10000.,t.a)*10000.0;\\n    return clamp(t, 0.0,3.0)+clamp(t/3.0-1.0, 0.0,1.0)+clamp(t/16.0-1.0, 0.0,1.0);\\n}\\n\\nfloat height_map( vec2 p ) {\\n    vec4 height=highness(p);\\n    /*\\n    height = -0.5+\\n        0.5*smoothstep(-100.,0.,-height)+\\n        2.75*smoothstep(0.,2.,height)+\\n        1.75*smoothstep(2.,4.,height)+\\n        2.75*smoothstep(4.,16.,height)+\\n        1.5*smoothstep(16.,1000.,height);\\n    */\\n\\n    mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );\\n    //p = p*6.;\\n    float f = 0.6000*noise1( p ); p = m*p*1.1*6.;\\n    f += 0.2500*noise( p ); p = m*p*1.32;\\n    f += 0.1666*noise( p ); p = m*p*1.11;\\n    f += 0.0834*noise( p ); p = m*p*1.12;\\n    f += 0.0634*noise( p ); p = m*p*1.13;\\n    f += 0.0444*noise( p ); p = m*p*1.14;\\n    f += 0.0274*noise( p ); p = m*p*1.15;\\n    f += 0.0134*noise( p ); p = m*p*1.16;\\n    f += 0.0104*noise( p ); p = m*p*1.17;\\n    f += 0.0084*noise( p );\\n    f = .25*f+dot(height,vec4(-.03125,-.125,.25,.25))*.5;\\n        const float FLAT_LEVEL = 0.92525;\\n        //f = f*0.25+height*0.75;\\n    if (f<FLAT_LEVEL)\\n        f = f;\\n    else\\n        f = pow((f-FLAT_LEVEL)/(1.-FLAT_LEVEL), 2.)*(1.-FLAT_LEVEL)*2.0+FLAT_LEVEL; // makes a smooth coast-increase\\n    return clamp(f, 0., 10.);\\n}\\n\\nvec3 plasma_quintic( float x ) {\\n    x = clamp( x, 0.0, 1.0);\\n    vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\\n    vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\\n    return vec3(\\n        dot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),\\n        dot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),\\n        dot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) );\\n}\\n\\nvec4 color(vec2 p){\\n    vec4 c1 = vec4(1.7,1.6,.9,1);\\n    vec4 c2 = vec4(.2,.94,.1,1);\\n    vec4 c3 = vec4(.3,.2,.0,1);\\n    vec4 c4 = vec4(.99,.99,1.6,1);\\n    vec4 v = highness(p);\\n    float los = smoothstep(0.1,1.1,v.b);\\n    float his = smoothstep(3.5,6.5,v.b);\\n    float ces = smoothstep(1.,5.,v.a);\\n    vec4 lo = mix(c1,c2,los);\\n    vec4 hi = mix(c3,c4,his);\\n    vec4 ce = mix(lo,hi,ces);\\n\\n    return vec4(plasma_quintic(ces),1).ragb;\\n}\\n\\nvec3 terrain_map( vec2 p )\\n{\\n  return color(p).rgb*0.75+0.25*vec3(0.7, .55, .4)+texture(SAMPLER_2D(u_texture3), fract(p*5.)).rgb*.5; // test-terrain is simply 'sandstone'\\n}\\n\\nconst mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );\\n\\nfloat water_map( vec2 p, float height ) {\\n    vec2 p2 = p*large_wavesize;\\n    vec2 shift1 = 0.001*vec2( u_time*160.0*2.0, u_time*120.0*2.0 );\\n    vec2 shift2 = 0.001*vec2( u_time*190.0*2.0, -u_time*130.0*2.0 );\\n\\n    // coarse crossing 'ocean' waves...\\n    float f = 0.6000*noise( p );\\n    f += 0.2500*noise( p*m );\\n    f += 0.1666*noise( p*m*m );\\n    float wave = sin(p2.x*0.622+p2.y*0.622+shift2.x*4.269)*large_waveheight*f*height*height ;\\n\\n    p *= small_wavesize;\\n    f = 0.;\\n    float amp = 1.0, s = .5;\\n    for (int i=0; i<9; i++)\\n    { p = m*p*.947; f -= amp*abs(sin((noise( p+shift1*s )-.5)*2.)); amp = amp*.59; s*=-1.329; }\\n    \\n    return wave+f*small_waveheight;\\n}\\n\\nfloat nautic(vec2 p) {\\n    p *= 18.;\\n    float f = 0.;\\n    float amp = 1.0, s = .5;\\n    for (int i=0; i<3; i++)\\n    { p = m*p*1.2; f += amp*abs(smoothstep(0., 1., noise( p+u_time*s ))-.5); amp = amp*.5; s*=-1.227; }\\n    return pow(1.-f, 5.);\\n}\\n\\nfloat particles(vec2 p) {\\n    p *= 200.;\\n    float f = 0.;\\n    float amp = 1.0, s = 1.5;\\n    for (int i=0; i<3; i++)\\n    { p = m*p*1.2; f += amp*noise( p+u_time*s ); amp = amp*.5; s*=-1.227; }\\n    return pow(f*.35, 7.)*particle_amount;\\n}\\n\\nfloat test_shadow( vec2 xy, float height) {\\n    vec3 r0 = vec3(xy, height);\\n    vec3 rd = normalize( light - r0 );\\n    \\n    float hit = 1.0;\\n    float t   = 0.001;\\n    for (int j=1; j<25; j++)\\n    {\\n        vec3 p = r0 + t*rd;\\n        float h = height_map( p.xy );\\n        float height_diff = p.z - h;\\n        if (height_diff<0.0)\\n        {\\n            return 0.0;\\n        }\\n        t += 0.01+height_diff*.02;\\n        hit = min(hit, 2.*height_diff/t); // soft shaddow   \\n    }\\n    return hit;\\n}\\n\\nvec3 CalcTerrain(vec2 uv, float height) {\\n    vec3 col = terrain_map( uv );\\n    vec2 iResolution = vec2(512.);\\n    float h1 = height_map(uv-vec2(0., 0.5)/ iResolution.xy);\\n    float h2 = height_map(uv+vec2(0., 0.5)/ iResolution.xy);\\n    float h3 = height_map(uv-vec2(0.5, 0.)/ iResolution.xy);\\n    float h4 = height_map(uv+vec2(0.5, 0.)/ iResolution.xy);\\n    vec3 norm = normalize(vec3(h3-h4, h1-h2, 1.));\\n    vec3 r0 = vec3(uv, height);\\n    vec3 rd = normalize( light - r0 );\\n    float grad = dot(norm, rd);\\n    col *= grad+pow(grad, 8.);\\n    float terrainshade = test_shadow( uv, height );\\n    col = mix(col*.25, col, terrainshade);\\n    return col;\\n}\\n\\n\\nvoid main() {\\n  vec3 watercolor = u_watercolor.rgb;\\n  vec3 watercolor2 = u_watercolor2.rgb;\\n  vec2 uv = v_uv;\\n  float WATER_LEVEL = 0.84; // Water level (range: 0.0 - 2.0)\\n  float deepwater_fadedepth   = 0.4 + coast2water_fadedepth;\\n  float height = height_map( uv );\\n  vec3 col;\\n\\n    float waveheight = clamp(WATER_LEVEL*3.-1.5, 0., 1.);\\n    float level = WATER_LEVEL + .2*water_map(uv*15. + vec2(u_time*.1), waveheight);\\n    if (height > level)\\n    {\\n        col = CalcTerrain(uv, height);\\n    }\\n    if (height <= level)\\n    {\\n        vec2 dif = vec2(.0, .01);\\n        vec2 pos = uv*15. + vec2(u_time*.01);\\n        float h1 = water_map(pos-dif,waveheight);\\n        float h2 = water_map(pos+dif,waveheight);\\n        float h3 = water_map(pos-dif.yx,waveheight);\\n        float h4 = water_map(pos+dif.yx,waveheight);\\n        vec3 normwater = normalize(vec3(h3-h4, h1-h2, .125)); // norm-vector of the 'bumpy' water-plane\\n        uv += normwater.xy*.002*(level-height);\\n        \\n        col = CalcTerrain(uv, height);\\n\\n        float coastfade = clamp((level-height)/coast2water_fadedepth, 0., 1.);\\n        float coastfade2= clamp((level-height)/deepwater_fadedepth, 0., 1.);\\n        float intensity = col.r*.2126+col.g*.7152+col.b*.0722;\\n        watercolor = mix(watercolor*intensity, watercolor2, smoothstep(0., 1., coastfade2));\\n\\n        vec3 r0 = vec3(uv, WATER_LEVEL);\\n        vec3 rd = normalize( light - r0 ); // ray-direction to the light from water-position\\n        float grad     = dot(normwater, rd); // dot-product of norm-vector and light-direction\\n        float specular = pow(grad, water_softlight_fact);  // used for soft highlights                          \\n        float specular2= pow(grad, water_glossylight_fact); // used for glossy highlights\\n        float gradpos  = dot(vec3(0., 0., 1.), rd);\\n        float specular1= smoothstep(0., 1., pow(gradpos, 5.));  // used for diffusity (some darker corona around light's specular reflections...)                          \\n        float watershade  = test_shadow( uv, level );\\n        watercolor *= 2.2+watershade;\\n        watercolor += (.2+.8*watershade) * ((grad-1.0)*.5+specular) * .25;\\n        watercolor /= (1.+specular1*1.25);\\n        watercolor += watershade*specular2*water_specularcolor;\\n        watercolor += watershade*coastfade*(1.-coastfade2)*(vec3(.5, .6, .7)*nautic(uv)+vec3(1., 1., 1.)*particles(uv));\\n        \\n        col = mix(col, watercolor, coastfade);\\n    }\\n    \\n  outputColor = vec4(col, v_opacity);  \\n}\\n\";\n/* babel-plugin-inline-import '../shaders/ocean/ocean_vert.glsl' */\nvar ocean_vert = \"layout(location = 0) in vec3 a_Position;\\nlayout(location = 14) in vec2 a_uv;\\n\\nlayout(std140) uniform commonUniforms {\\n  vec4 u_watercolor;\\n  vec4 u_watercolor2;\\n  float u_time;\\n};\\n\\n\\nout vec2 v_uv;\\nout float v_opacity;\\n\\n#pragma include \\\"projection\\\"\\n\\nvoid main() {\\n  v_uv = a_uv;\\n  v_opacity = opacity;\\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\\n  gl_Position = project_common_position_to_clipspace_v2(vec4(project_pos.xyz, 1.0));\\n}\\n\\n\";\nimport { ShaderLocation } from \"../../core/CommonStyleAttribute\";\nvar isNumber = lodashUtil.isNumber;\nvar OceanModel = /*#__PURE__*/function (_BaseModel) {\n  _inherits(OceanModel, _BaseModel);\n  var _super = _createSuper(OceanModel);\n  function OceanModel() {\n    _classCallCheck(this, OceanModel);\n    return _super.apply(this, arguments);\n  }\n  _createClass(OceanModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var commoninfo = this.getCommonUniformsInfo();\n      var attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());\n      this.updateStyleUnifoms();\n      return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);\n    }\n  }, {\n    key: \"getCommonUniformsInfo\",\n    value: function getCommonUniformsInfo() {\n      var _ref = this.layer.getLayerConfig(),\n        _ref$watercolor = _ref.watercolor,\n        watercolor = _ref$watercolor === void 0 ? '#6D99A8' : _ref$watercolor,\n        _ref$watercolor2 = _ref.watercolor2,\n        watercolor2 = _ref$watercolor2 === void 0 ? '#0F121C' : _ref$watercolor2;\n      var commonOptions = {\n        u_watercolor: rgb2arr(watercolor),\n        u_watercolor2: rgb2arr(watercolor2),\n        u_time: this.layer.getLayerAnimateTime(),\n        u_texture1: this.texture1,\n        u_texture2: this.texture2,\n        u_texture3: this.texture3\n      };\n\n      // u_opacity: isNumber(opacity) ? opacity : 1.0,\n      this.textures = [this.texture1, this.texture2, this.texture3];\n      var commonBufferInfo = this.getUniformsBufferInfo(commonOptions);\n      return commonBufferInfo;\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      return {\n        u_time: this.layer.getLayerAnimateTime()\n      };\n    }\n  }, {\n    key: \"initModels\",\n    value: function () {\n      var _initModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.loadTexture();\n              return _context.abrupt(\"return\", this.buildModels());\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function initModels() {\n        return _initModels.apply(this, arguments);\n      }\n      return initModels;\n    }()\n  }, {\n    key: \"buildModels\",\n    value: function () {\n      var _buildModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var model;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.initUniformsBuffer();\n              _context2.next = 3;\n              return this.layer.buildLayerModel({\n                moduleName: 'polygonOcean',\n                vertexShader: ocean_vert,\n                fragmentShader: ocean_frag,\n                inject: this.getInject(),\n                triangulation: polygonTriangulation,\n                primitive: gl.TRIANGLES,\n                depth: {\n                  enable: false\n                }\n              });\n            case 3:\n              model = _context2.sent;\n              return _context2.abrupt(\"return\", [model]);\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function buildModels() {\n        return _buildModels.apply(this, arguments);\n      }\n      return buildModels;\n    }()\n  }, {\n    key: \"clearModels\",\n    value: function clearModels() {\n      var _this$texture, _this$texture2, _this$texture3;\n      (_this$texture = this.texture1) === null || _this$texture === void 0 || _this$texture.destroy();\n      (_this$texture2 = this.texture2) === null || _this$texture2 === void 0 || _this$texture2.destroy();\n      (_this$texture3 = this.texture3) === null || _this$texture3 === void 0 || _this$texture3.destroy();\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      var bbox = this.layer.getSource().extent;\n      var _bbox = _slicedToArray(bbox, 4),\n        minLng = _bbox[0],\n        minLat = _bbox[1],\n        maxLng = _bbox[2],\n        maxLat = _bbox[3];\n      var lngLen = maxLng - minLng;\n      var latLen = maxLat - minLat;\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'oceanUv',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_uv',\n          shaderLocation: ShaderLocation.UV,\n          buffer: {\n            // give the WebGL driver a hint that this buffer may change\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 2,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var v = feature.version === 'GAODE2.x' ? feature.originCoordinates[0][attributeIdx] : vertex;\n            var _v = _slicedToArray(v, 2),\n              lng = _v[0],\n              lat = _v[1];\n            return [(lng - minLng) / lngLen, (lat - minLat) / latLen];\n          }\n        }\n      });\n    }\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture() {\n      var _this = this;\n      var createTexture2D = this.rendererService.createTexture2D;\n      var defaultTextureOptions = {\n        height: 0,\n        width: 0\n      };\n      // 默认索引为 undefined，所以单独赋值\n      this.texture1 = createTexture2D(defaultTextureOptions);\n      this.texture2 = createTexture2D(defaultTextureOptions);\n      this.texture3 = createTexture2D(defaultTextureOptions);\n\n      // 加载完 image 后单独给 texture f赋值\n      initImage(function (images) {\n        _this.texture1 = initTex(images[0]);\n        _this.texture2 = initTex(images[1]);\n        _this.texture3 = initTex(images[2]);\n        _this.layerService.reRender();\n      });\n      function initImage(callback) {\n        var loadedCount = 0;\n        var loadedImages = [];\n        var images = ['https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ', 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*MJ22QbpuCzIAAAAAAAAAAAAAARQnAQ', 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*-z2HSIVDsHIAAAAAAAAAAAAAARQnAQ'];\n        images.map(function (imgSrc) {\n          var image = new Image();\n          image.crossOrigin = '';\n          image.src = imgSrc;\n          loadedImages.push(image);\n          image.onload = function () {\n            loadedCount++;\n            if (loadedCount === 3) {\n              callback(loadedImages);\n            }\n          };\n        });\n      }\n      function initTex(image) {\n        return createTexture2D({\n          data: image,\n          width: image.width,\n          height: image.height,\n          wrapS: gl.MIRRORED_REPEAT,\n          wrapT: gl.MIRRORED_REPEAT,\n          min: gl.LINEAR,\n          mag: gl.LINEAR\n        });\n      }\n    }\n  }]);\n  return OceanModel;\n}(BaseModel);\nexport { OceanModel as default };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}