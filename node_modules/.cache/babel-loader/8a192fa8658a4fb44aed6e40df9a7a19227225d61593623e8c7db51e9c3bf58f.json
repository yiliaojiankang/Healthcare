{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __extends } from \"tslib\";\nimport { each, isNil, isNumber } from '@antv/util';\nimport { distance, getCircleIntersectByPoint, getEllipseIntersectByPoint, getRectIntersectByPoint } from '../util/math';\nimport Item from './item';\nvar CACHE_ANCHOR_POINTS = 'anchorPointsCache';\nvar CACHE_BBOX = 'bboxCache';\nvar Node = /** @class */function (_super) {\n  __extends(Node, _super);\n  function Node() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Node.prototype.getNearestPoint = function (points, curPoint) {\n    var index = 0;\n    var nearestPoint = points[0];\n    var minDistance = distance(points[0], curPoint);\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      var dis = distance(point, curPoint);\n      if (dis < minDistance) {\n        nearestPoint = point;\n        minDistance = dis;\n        index = i;\n      }\n    }\n    nearestPoint.anchorIndex = index;\n    return nearestPoint;\n  };\n  Node.prototype.getDefaultCfg = function () {\n    return {\n      type: 'node',\n      edges: []\n    };\n  };\n  /**\n   * 获取从节点关联的所有边\n   */\n  Node.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取所有的入边\n   */\n  Node.prototype.getInEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('target') === self;\n    });\n  };\n  /**\n   * 获取所有的出边\n   */\n  Node.prototype.getOutEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('source') === self;\n    });\n  };\n  /**\n   * 获取节点的邻居节点\n   *\n   * @returns {INode[]}\n   * @memberof Node\n   */\n  Node.prototype.getNeighbors = function (type) {\n    var _this = this;\n    var edges = this.get('edges');\n    if (type === 'target') {\n      // 当前节点为 source，它所指向的目标节点\n      var neighborsConverter_1 = function neighborsConverter_1(edge) {\n        return edge.getSource() === _this;\n      };\n      return edges.filter(neighborsConverter_1).map(function (edge) {\n        return edge.getTarget();\n      });\n    }\n    if (type === 'source') {\n      // 当前节点为 target，它所指向的源节点\n      var neighborsConverter_2 = function neighborsConverter_2(edge) {\n        return edge.getTarget() === _this;\n      };\n      return edges.filter(neighborsConverter_2).map(function (edge) {\n        return edge.getSource();\n      });\n    }\n    // 若未指定 type ，则返回所有邻居\n    var neighborsConverter = function neighborsConverter(edge) {\n      return edge.getSource() === _this ? edge.getTarget() : edge.getSource();\n    };\n    return edges.map(neighborsConverter);\n  };\n  /**\n   * 根据锚点的索引获取连接点\n   * @param  {Number} index 索引\n   */\n  Node.prototype.getLinkPointByAnchor = function (index) {\n    var anchorPoints = this.getAnchorPoints();\n    return anchorPoints[index];\n  };\n  /**\n   * 获取连接点\n   * @param point\n   */\n  Node.prototype.getLinkPoint = function (point) {\n    var keyShape = this.get('keyShape');\n    var type = keyShape.get('type');\n    var itemType = this.get('type');\n    var centerX;\n    var centerY;\n    var bbox = this.getBBox();\n    if (itemType === 'combo') {\n      centerX = bbox.centerX || (bbox.maxX + bbox.minX) / 2;\n      centerY = bbox.centerY || (bbox.maxY + bbox.minY) / 2;\n    } else {\n      centerX = bbox.centerX;\n      centerY = bbox.centerY;\n    }\n    var anchorPoints = this.getAnchorPoints();\n    var intersectPoint;\n    switch (type) {\n      case 'circle':\n        intersectPoint = getCircleIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          r: bbox.width / 2\n        }, point);\n        break;\n      case 'ellipse':\n        intersectPoint = getEllipseIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          rx: bbox.width / 2,\n          ry: bbox.height / 2\n        }, point);\n        break;\n      default:\n        intersectPoint = getRectIntersectByPoint(bbox, point);\n    }\n    var linkPoint = intersectPoint;\n    // 如果存在锚点，则使用交点计算最近的锚点\n    if (anchorPoints.length) {\n      if (!linkPoint) {\n        // 如果计算不出交点\n        linkPoint = point;\n      }\n      linkPoint = this.getNearestPoint(anchorPoints, linkPoint);\n    }\n    if (!linkPoint) {\n      // 如果最终依然没法找到锚点和连接点，直接返回中心点\n      linkPoint = {\n        x: centerX,\n        y: centerY\n      };\n    }\n    return linkPoint;\n  };\n  /**\n   * 获取锚点的定义\n   * @return {array} anchorPoints\n   */\n  Node.prototype.getAnchorPoints = function () {\n    var anchorPoints = this.get(CACHE_ANCHOR_POINTS);\n    if (!anchorPoints) {\n      anchorPoints = [];\n      var shapeFactory = this.get('shapeFactory');\n      var bbox_1 = this.getBBox();\n      var model = this.get('model');\n      var shapeCfg = this.getShapeCfg(model);\n      var type = model.type;\n      var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];\n      each(points, function (pointArr, index) {\n        var point = {\n          x: bbox_1.minX + pointArr[0] * bbox_1.width,\n          y: bbox_1.minY + pointArr[1] * bbox_1.height,\n          anchorIndex: index\n        };\n        anchorPoints.push(point);\n      });\n      this.set(CACHE_ANCHOR_POINTS, anchorPoints);\n    }\n    return anchorPoints;\n  };\n  /**\n   * add edge\n   * @param edge Edge instance\n   */\n  Node.prototype.addEdge = function (edge) {\n    this.get('edges').push(edge);\n  };\n  /**\n   * 锁定节点\n   */\n  Node.prototype.lock = function () {\n    this.set('locked', true);\n  };\n  /**\n   * 解锁锁定的节点\n   */\n  Node.prototype.unlock = function () {\n    this.set('locked', false);\n  };\n  Node.prototype.hasLocked = function () {\n    return this.get('locked');\n  };\n  /**\n   * 移除边\n   * @param {Edge} edge 边\n   */\n  Node.prototype.removeEdge = function (edge) {\n    var edges = this.getEdges();\n    var index = edges.indexOf(edge);\n    if (index > -1) edges.splice(index, 1);\n  };\n  Node.prototype.clearCache = function () {\n    this.set(CACHE_BBOX, null); // 清理缓存的 bbox\n    this.set(CACHE_ANCHOR_POINTS, null);\n  };\n  /**\n   * 判断更新的种类，move 表示仅移动，bbox 表示大小有变化，style 表示仅与大小无关的参数变化\n   * @param cfg 节点数据模型\n   */\n  Node.prototype.getUpdateType = function (cfg) {\n    var _a, _b, _c, _d, _e;\n    if (!cfg) return undefined;\n    var existX = !isNil(cfg.x);\n    var existY = !isNil(cfg.y);\n    var keys = Object.keys(cfg);\n    // 仅有一个字段，包含 x 或者 包含 y\n    // 两个字段，同时有 x，同时有 y\n    if (keys.length === 1 && (existX || existY) || keys.length === 2 && existX && existY) return 'move';\n    if (isNumber(cfg.x) || isNumber(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size || (cfg === null || cfg === void 0 ? void 0 : cfg.style) && (((_a = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _a === void 0 ? void 0 : _a.r) || ((_b = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _b === void 0 ? void 0 : _b.width) || ((_c = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _d === void 0 ? void 0 : _d.rx) || ((_e = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _e === void 0 ? void 0 : _e.ry))) return 'bbox|label';\n    var updateLabel = keys.includes('label') || keys.includes('labelCfg');\n    return updateLabel ? 'style|label' : 'style';\n  };\n  Node.prototype.setState = function (state, value) {\n    var _this = this;\n    if (this.optimize) {\n      _super.prototype.setState.call(this, state, value);\n      return;\n    }\n    this.runWithBBoxAffected(function () {\n      return _super.prototype.setState.call(_this, state, value);\n    });\n  };\n  Node.prototype.clearStates = function (states) {\n    var _this = this;\n    if (this.optimize) {\n      _super.prototype.clearStates.call(this, states);\n      return;\n    }\n    this.runWithBBoxAffected(function () {\n      return _super.prototype.clearStates.call(_this, states);\n    });\n  };\n  Node.prototype.runWithBBoxAffected = function (fn) {\n    var bboxAffectedStyleKeys = ['r', 'width', 'height', 'rx', 'ry', 'lineWidth'];\n    var beforeAttrs = this.getKeyShape().attr();\n    var bboxAffectedStyleBefore = {};\n    Object.keys(this.getKeyShape().attr()).forEach(function (key) {\n      if (bboxAffectedStyleKeys.includes(key)) bboxAffectedStyleBefore[key] = beforeAttrs[key];\n    });\n    fn();\n    // if the state styles affect the bbox, the bbox cache should be cleared to get correct edge connecting points\n    var afterAttrs = this.getKeyShape().attr();\n    for (var i = 0; i < bboxAffectedStyleKeys.length; i++) {\n      var key = bboxAffectedStyleKeys[i];\n      if (afterAttrs[key] !== bboxAffectedStyleBefore[key]) {\n        this.clearCache();\n        this.getEdges().forEach(function (edge) {\n          return edge.refresh();\n        });\n        break;\n      }\n    }\n  };\n  return Node;\n}(Item);\nexport default Node;","map":{"version":3,"names":["__extends","each","isNil","isNumber","distance","getCircleIntersectByPoint","getEllipseIntersectByPoint","getRectIntersectByPoint","Item","CACHE_ANCHOR_POINTS","CACHE_BBOX","Node","_super","apply","arguments","prototype","getNearestPoint","points","curPoint","index","nearestPoint","minDistance","i","length","point","dis","anchorIndex","getDefaultCfg","type","edges","getEdges","get","getInEdges","self","filter","edge","getOutEdges","getNeighbors","_this","neighborsConverter_1","getSource","map","getTarget","neighborsConverter_2","neighborsConverter","getLinkPointByAnchor","anchorPoints","getAnchorPoints","getLinkPoint","keyShape","itemType","centerX","centerY","bbox","getBBox","maxX","minX","maxY","minY","intersectPoint","x","y","r","width","rx","ry","height","linkPoint","shapeFactory","bbox_1","model","shapeCfg","getShapeCfg","pointArr","push","set","addEdge","lock","unlock","hasLocked","removeEdge","indexOf","splice","clearCache","getUpdateType","cfg","_a","_b","_c","_d","_e","undefined","existX","existY","keys","Object","size","style","updateLabel","includes","setState","state","value","optimize","call","runWithBBoxAffected","clearStates","states","fn","bboxAffectedStyleKeys","beforeAttrs","getKeyShape","attr","bboxAffectedStyleBefore","forEach","key","afterAttrs","refresh"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/g6-core/es/item/node.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport { each, isNil, isNumber } from '@antv/util';\nimport { distance, getCircleIntersectByPoint, getEllipseIntersectByPoint, getRectIntersectByPoint } from '../util/math';\nimport Item from './item';\nvar CACHE_ANCHOR_POINTS = 'anchorPointsCache';\nvar CACHE_BBOX = 'bboxCache';\nvar Node = /** @class */function (_super) {\n  __extends(Node, _super);\n  function Node() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Node.prototype.getNearestPoint = function (points, curPoint) {\n    var index = 0;\n    var nearestPoint = points[0];\n    var minDistance = distance(points[0], curPoint);\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      var dis = distance(point, curPoint);\n      if (dis < minDistance) {\n        nearestPoint = point;\n        minDistance = dis;\n        index = i;\n      }\n    }\n    nearestPoint.anchorIndex = index;\n    return nearestPoint;\n  };\n  Node.prototype.getDefaultCfg = function () {\n    return {\n      type: 'node',\n      edges: []\n    };\n  };\n  /**\n   * 获取从节点关联的所有边\n   */\n  Node.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取所有的入边\n   */\n  Node.prototype.getInEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('target') === self;\n    });\n  };\n  /**\n   * 获取所有的出边\n   */\n  Node.prototype.getOutEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('source') === self;\n    });\n  };\n  /**\n   * 获取节点的邻居节点\n   *\n   * @returns {INode[]}\n   * @memberof Node\n   */\n  Node.prototype.getNeighbors = function (type) {\n    var _this = this;\n    var edges = this.get('edges');\n    if (type === 'target') {\n      // 当前节点为 source，它所指向的目标节点\n      var neighborsConverter_1 = function neighborsConverter_1(edge) {\n        return edge.getSource() === _this;\n      };\n      return edges.filter(neighborsConverter_1).map(function (edge) {\n        return edge.getTarget();\n      });\n    }\n    if (type === 'source') {\n      // 当前节点为 target，它所指向的源节点\n      var neighborsConverter_2 = function neighborsConverter_2(edge) {\n        return edge.getTarget() === _this;\n      };\n      return edges.filter(neighborsConverter_2).map(function (edge) {\n        return edge.getSource();\n      });\n    }\n    // 若未指定 type ，则返回所有邻居\n    var neighborsConverter = function neighborsConverter(edge) {\n      return edge.getSource() === _this ? edge.getTarget() : edge.getSource();\n    };\n    return edges.map(neighborsConverter);\n  };\n  /**\n   * 根据锚点的索引获取连接点\n   * @param  {Number} index 索引\n   */\n  Node.prototype.getLinkPointByAnchor = function (index) {\n    var anchorPoints = this.getAnchorPoints();\n    return anchorPoints[index];\n  };\n  /**\n   * 获取连接点\n   * @param point\n   */\n  Node.prototype.getLinkPoint = function (point) {\n    var keyShape = this.get('keyShape');\n    var type = keyShape.get('type');\n    var itemType = this.get('type');\n    var centerX;\n    var centerY;\n    var bbox = this.getBBox();\n    if (itemType === 'combo') {\n      centerX = bbox.centerX || (bbox.maxX + bbox.minX) / 2;\n      centerY = bbox.centerY || (bbox.maxY + bbox.minY) / 2;\n    } else {\n      centerX = bbox.centerX;\n      centerY = bbox.centerY;\n    }\n    var anchorPoints = this.getAnchorPoints();\n    var intersectPoint;\n    switch (type) {\n      case 'circle':\n        intersectPoint = getCircleIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          r: bbox.width / 2\n        }, point);\n        break;\n      case 'ellipse':\n        intersectPoint = getEllipseIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          rx: bbox.width / 2,\n          ry: bbox.height / 2\n        }, point);\n        break;\n      default:\n        intersectPoint = getRectIntersectByPoint(bbox, point);\n    }\n    var linkPoint = intersectPoint;\n    // 如果存在锚点，则使用交点计算最近的锚点\n    if (anchorPoints.length) {\n      if (!linkPoint) {\n        // 如果计算不出交点\n        linkPoint = point;\n      }\n      linkPoint = this.getNearestPoint(anchorPoints, linkPoint);\n    }\n    if (!linkPoint) {\n      // 如果最终依然没法找到锚点和连接点，直接返回中心点\n      linkPoint = {\n        x: centerX,\n        y: centerY\n      };\n    }\n    return linkPoint;\n  };\n  /**\n   * 获取锚点的定义\n   * @return {array} anchorPoints\n   */\n  Node.prototype.getAnchorPoints = function () {\n    var anchorPoints = this.get(CACHE_ANCHOR_POINTS);\n    if (!anchorPoints) {\n      anchorPoints = [];\n      var shapeFactory = this.get('shapeFactory');\n      var bbox_1 = this.getBBox();\n      var model = this.get('model');\n      var shapeCfg = this.getShapeCfg(model);\n      var type = model.type;\n      var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];\n      each(points, function (pointArr, index) {\n        var point = {\n          x: bbox_1.minX + pointArr[0] * bbox_1.width,\n          y: bbox_1.minY + pointArr[1] * bbox_1.height,\n          anchorIndex: index\n        };\n        anchorPoints.push(point);\n      });\n      this.set(CACHE_ANCHOR_POINTS, anchorPoints);\n    }\n    return anchorPoints;\n  };\n  /**\n   * add edge\n   * @param edge Edge instance\n   */\n  Node.prototype.addEdge = function (edge) {\n    this.get('edges').push(edge);\n  };\n  /**\n   * 锁定节点\n   */\n  Node.prototype.lock = function () {\n    this.set('locked', true);\n  };\n  /**\n   * 解锁锁定的节点\n   */\n  Node.prototype.unlock = function () {\n    this.set('locked', false);\n  };\n  Node.prototype.hasLocked = function () {\n    return this.get('locked');\n  };\n  /**\n   * 移除边\n   * @param {Edge} edge 边\n   */\n  Node.prototype.removeEdge = function (edge) {\n    var edges = this.getEdges();\n    var index = edges.indexOf(edge);\n    if (index > -1) edges.splice(index, 1);\n  };\n  Node.prototype.clearCache = function () {\n    this.set(CACHE_BBOX, null); // 清理缓存的 bbox\n    this.set(CACHE_ANCHOR_POINTS, null);\n  };\n  /**\n   * 判断更新的种类，move 表示仅移动，bbox 表示大小有变化，style 表示仅与大小无关的参数变化\n   * @param cfg 节点数据模型\n   */\n  Node.prototype.getUpdateType = function (cfg) {\n    var _a, _b, _c, _d, _e;\n    if (!cfg) return undefined;\n    var existX = !isNil(cfg.x);\n    var existY = !isNil(cfg.y);\n    var keys = Object.keys(cfg);\n    // 仅有一个字段，包含 x 或者 包含 y\n    // 两个字段，同时有 x，同时有 y\n    if (keys.length === 1 && (existX || existY) || keys.length === 2 && existX && existY) return 'move';\n    if (isNumber(cfg.x) || isNumber(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size || (cfg === null || cfg === void 0 ? void 0 : cfg.style) && (((_a = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _a === void 0 ? void 0 : _a.r) || ((_b = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _b === void 0 ? void 0 : _b.width) || ((_c = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _d === void 0 ? void 0 : _d.rx) || ((_e = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _e === void 0 ? void 0 : _e.ry))) return 'bbox|label';\n    var updateLabel = keys.includes('label') || keys.includes('labelCfg');\n    return updateLabel ? 'style|label' : 'style';\n  };\n  Node.prototype.setState = function (state, value) {\n    var _this = this;\n    if (this.optimize) {\n      _super.prototype.setState.call(this, state, value);\n      return;\n    }\n    this.runWithBBoxAffected(function () {\n      return _super.prototype.setState.call(_this, state, value);\n    });\n  };\n  Node.prototype.clearStates = function (states) {\n    var _this = this;\n    if (this.optimize) {\n      _super.prototype.clearStates.call(this, states);\n      return;\n    }\n    this.runWithBBoxAffected(function () {\n      return _super.prototype.clearStates.call(_this, states);\n    });\n  };\n  Node.prototype.runWithBBoxAffected = function (fn) {\n    var bboxAffectedStyleKeys = ['r', 'width', 'height', 'rx', 'ry', 'lineWidth'];\n    var beforeAttrs = this.getKeyShape().attr();\n    var bboxAffectedStyleBefore = {};\n    Object.keys(this.getKeyShape().attr()).forEach(function (key) {\n      if (bboxAffectedStyleKeys.includes(key)) bboxAffectedStyleBefore[key] = beforeAttrs[key];\n    });\n    fn();\n    // if the state styles affect the bbox, the bbox cache should be cleared to get correct edge connecting points\n    var afterAttrs = this.getKeyShape().attr();\n    for (var i = 0; i < bboxAffectedStyleKeys.length; i++) {\n      var key = bboxAffectedStyleKeys[i];\n      if (afterAttrs[key] !== bboxAffectedStyleBefore[key]) {\n        this.clearCache();\n        this.getEdges().forEach(function (edge) {\n          return edge.refresh();\n        });\n        break;\n      }\n    }\n  };\n  return Node;\n}(Item);\nexport default Node;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}