{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nexport var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n    y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var map = {};\n  var pointsLength = points.length;\n  for (var i = pointsLength - 1; i >= 0; i--) {\n    var p = points[i];\n    p.id = \"\".concat(p.x, \"|||\").concat(p.y);\n    if (!map[p.id]) {\n      map[p.id] = p;\n      result.push(p);\n    }\n  }\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  return filterConnectPoints(points);\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width || bbox.height) {\n    return {\n      centerX: bbox.centerX,\n      centerY: bbox.centerY,\n      minX: bbox.minX - offset,\n      minY: bbox.minY - offset,\n      maxX: bbox.maxX + offset,\n      maxY: bbox.maxY + offset,\n      height: bbox.height + 2 * offset,\n      width: bbox.width + 2 * offset\n    };\n  }\n  // when it is a point\n  return bbox;\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  if (dx === 0 && dy === 0) return 0;\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox,\n// 将原来节点 bbox 扩展了 offset 后的 bbox，且被 gridSize 格式化\npoint,\n// 被 gridSize 格式化后的位置（anchorPoint）\nanotherPoint) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n  if (isHorizontal === 0) {\n    // 说明锚点是节点中心，linkCenter: true。需要根据两个节点的相对关系决定方向\n    var x = bbox.centerX;\n    var y = bbox.centerY;\n    if (anotherPoint.y < point.y) {\n      // 另一端在左上/右上方时，总是从上方走\n      y = bbox.minY;\n    } else if (anotherPoint.x > point.x) {\n      // 另一端在右下方，往右边走\n      x = bbox.maxX;\n    } else if (anotherPoint.x < point.x) {\n      // 另一端在左下方，往左边走\n      x = bbox.minX;\n    } else if (anotherPoint.x === point.x) {\n      // 另一段在正下方，往下走\n      y = bbox.maxY;\n    }\n    return {\n      x: x,\n      y: y\n    };\n  }\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  return [{\n    x: bbox.minX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }, {\n    x: bbox.minX,\n    y: bbox.maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n    y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nexport var reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n  pathPoints.unshift(pointById[currentId]);\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var v1x = p2.x - p0.x;\n  var v1y = p2.y - p0.y;\n  var v2x = p3.x - p0.x;\n  var v2y = p3.y - p0.y;\n  var v3x = p2.x - p1.x;\n  var v3y = p2.y - p1.y;\n  var v4x = p3.x - p1.x;\n  var v4y = p3.y - p1.y;\n  var pd1 = v1x * v2y - v1y * v2x;\n  var pd2 = v3x * v4y - v3y * v4x;\n  var pd3 = v1x * v3y - v1y * v3x;\n  var pd4 = v2x * v4y - v2y * v4x;\n  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width || bbox.height) {\n    var _a = getPointsFromBBox(bbox),\n      pa = _a[0],\n      pb = _a[1],\n      pc = _a[2],\n      pd = _a[3];\n    return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n  }\n  return false;\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p === point) return;\n    if (p.x === point.x || p.y === point.y) {\n      if (isSegmentCrossingBBox(p, point, bbox1) || isSegmentCrossingBBox(p, point, bbox2)) return;\n      neighbors.push(p);\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  var _a;\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = (_a = {}, _a[start.id] = start, _a);\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n  var fScore = {}; // all default values are Infinity\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var sortedOpenSet = new SortedArray();\n  sortedOpenSet.add({\n    id: start.id,\n    value: fScore[start.id]\n  });\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n  var current;\n  while (Object.keys(openSet).length) {\n    var minId = sortedOpenSet.minId(false);\n    if (minId) {\n      current = openSet[minId];\n    } else {\n      break;\n    }\n    // 若 openSet 中 fScore 最小的点就是终点\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return pathPoints;\n    }\n    delete openSet[current.id];\n    sortedOpenSet.remove(current.id);\n    closedSet.push(current);\n    var neighborPoints = getNeighborPoints(points, current, sBBox, tBBox);\n    var iterateNeighbors = function iterateNeighbors(items) {\n      items.forEach(function (neighbor) {\n        if (closedSet.indexOf(neighbor) !== -1) {\n          return;\n        }\n        var neighborId = neighbor.id;\n        if (!openSet[neighborId]) {\n          openSet[neighborId] = neighbor;\n        }\n        var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n        if (gScore[neighborId] && tentativeGScore >= gScore[neighborId]) {\n          sortedOpenSet.add({\n            id: neighborId,\n            value: fScore[neighborId]\n          });\n          return;\n        }\n        cameFrom[neighborId] = current.id;\n        gScore[neighborId] = tentativeGScore;\n        fScore[neighborId] = gScore[neighborId] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n        sortedOpenSet.add({\n          id: neighborId,\n          value: fScore[neighborId]\n        });\n      });\n    };\n    iterateNeighbors(neighborPoints);\n  }\n  // throw new Error('Cannot find path');\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n  if (d0 < r) {\n    r = d0;\n  }\n  if (d1 < r) {\n    r = d1;\n  }\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\".concat(startPoint.x, \" \").concat(startPoint.y));\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n          ps = _a[0],\n          pt = _a[1];\n        pathSegments.push(\"L\".concat(ps.x, \" \").concat(ps.y));\n        pathSegments.push(\"Q\".concat(p1.x, \" \").concat(p1.y, \" \").concat(pt.x, \" \").concat(pt.y));\n        pathSegments.push(\"L\".concat(pt.x, \" \").concat(pt.y));\n      } else {\n        pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sKeyShapeBBox = sNode.getKeyShape().getBBox();\n    if (sKeyShapeBBox) {\n      var _a = sNode.getModel(),\n        sx = _a.x,\n        sy = _a.y;\n      sBBox = {\n        x: sx,\n        y: sy,\n        width: sKeyShapeBBox.width,\n        height: sKeyShapeBBox.height,\n        minX: sKeyShapeBBox.minX + sx,\n        maxX: sKeyShapeBBox.maxX + sx,\n        minY: sKeyShapeBBox.minY + sy,\n        maxY: sKeyShapeBBox.maxY + sy\n      };\n      sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n      sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n    } else {\n      sBBox = getBBoxFromPoint(start);\n    }\n  } else {\n    sBBox = sNode && sNode.getBBox();\n  }\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tKeyShapeBBox = tNode.getKeyShape().getBBox();\n    if (tKeyShapeBBox) {\n      var _b = tNode.getModel(),\n        tx = _b.x,\n        ty = _b.y;\n      tBBox = {\n        x: tx,\n        y: ty,\n        width: tKeyShapeBBox.width,\n        height: tKeyShapeBBox.height,\n        minX: tKeyShapeBBox.minX + tx,\n        maxX: tKeyShapeBBox.maxX + tx,\n        minY: tKeyShapeBBox.minY + ty,\n        maxY: tKeyShapeBBox.maxY + ty\n      };\n      tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n      tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n    } else {\n      tBBox = getBBoxFromPoint(end);\n    }\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  }\n  // if (isBBoxesOverlapping(sBBox, tBBox)) {\n  //   // source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset);\n  // if (isBBoxesOverlapping(sxBBox, txBBox)) {\n  //   // the expanded bounding boxes of source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n  var sPoint = getExpandedBBoxPoint(sxBBox, start, end);\n  var tPoint = getExpandedBBoxPoint(txBBox, end, start);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n      connectPoints.push(p);\n    }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint);\n  // filter out dulplicated points in connectPoints\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};\n/**\n * 去除连续同 x 不同 y 的中间点；去除连续同 y 不同 x 的中间点\n * @param points 坐标集合 { x: number, y: number, id: string }[]\n * @returns\n */\nexport var removeRedundantPoint = function removeRedundantPoint(points) {\n  if (!(points === null || points === void 0 ? void 0 : points.length)) return points;\n  var beginPoint = points[points.length - 1];\n  var current = {\n    x: beginPoint.x,\n    y: beginPoint.y\n  };\n  var continueSameX = [beginPoint];\n  var continueSameY = [beginPoint];\n  for (var i = points.length - 2; i >= 0; i--) {\n    var point = points[i];\n    if (point.x === current.x) {\n      continueSameX.push(point);\n    } else {\n      continueSameX = [point];\n      current.x = point.x;\n    }\n    if (point.y === current.y) {\n      continueSameY.push(point);\n    } else {\n      continueSameY = [point];\n      current.y = point.y;\n    }\n    if (continueSameX.length > 2) {\n      var removeIdx = points.indexOf(continueSameX[1]);\n      if (removeIdx > -1) points.splice(removeIdx, 1);\n      continue;\n    }\n    if (continueSameY.length > 2) {\n      var removeIdx = points.indexOf(continueSameY[1]);\n      if (removeIdx > -1) points.splice(removeIdx, 1);\n    }\n  }\n  return points;\n};\n/**\n * sorted array ascendly\n * add new item to proper index when calling add\n */\nvar SortedArray = /** @class */function () {\n  function SortedArray() {\n    this.arr = [];\n    this.map = {};\n    this.arr = [];\n    this.map = {};\n  }\n  SortedArray.prototype._innerAdd = function (item, length) {\n    var idxRange = [0, length - 1];\n    while (idxRange[1] - idxRange[0] > 1) {\n      var midIdx = Math.floor((idxRange[0] + idxRange[1]) / 2);\n      if (this.arr[midIdx].value > item.value) {\n        idxRange[1] = midIdx;\n      } else if (this.arr[midIdx].value < item.value) {\n        idxRange[0] = midIdx;\n      } else {\n        this.arr.splice(midIdx, 0, item);\n        this.map[item.id] = true;\n        return;\n      }\n    }\n    this.arr.splice(idxRange[1], 0, item);\n    this.map[item.id] = true;\n  };\n  SortedArray.prototype.add = function (item) {\n    // 已经存在，先移除\n    delete this.map[item.id];\n    var length = this.arr.length;\n    if (!length) {\n      this.arr.push(item);\n      this.map[item.id] = true;\n      return;\n    }\n    // 比最后一个大，加入尾部\n    if (this.arr[length - 1].value < item.value) {\n      this.arr.push(item);\n      this.map[item.id] = true;\n      return;\n    }\n    this._innerAdd(item, length);\n  };\n  // only remove from the map to avoid cost\n  // clear the invalid (not in the map) item when calling minId(true)\n  SortedArray.prototype.remove = function (id) {\n    if (!this.map[id]) return;\n    delete this.map[id];\n  };\n  SortedArray.prototype._clearAndGetMinId = function () {\n    var res;\n    for (var i = this.arr.length - 1; i >= 0; i--) {\n      if (this.map[this.arr[i].id]) res = this.arr[i].id;else this.arr.splice(i, 1);\n    }\n    return res;\n  };\n  SortedArray.prototype._findFirstId = function () {\n    while (this.arr.length) {\n      var first = this.arr.shift();\n      if (this.map[first.id]) return first.id;\n    }\n  };\n  SortedArray.prototype.minId = function (clear) {\n    if (clear) {\n      return this._clearAndGetMinId();\n    } else {\n      return this._findFirstId();\n    }\n  };\n  return SortedArray;\n}();\nexport { SortedArray };","map":{"version":3,"names":["getBBoxFromPoint","point","x","y","centerX","centerY","minX","minY","maxX","maxY","height","width","getBBoxFromPoints","points","xs","ys","forEach","p","push","Math","min","apply","max","isBBoxesOverlapping","b1","b2","abs","filterConnectPoints","result","map","pointsLength","length","i","id","concat","simplifyPolyline","getSimplePolyline","sPoint","tPoint","getExpandedBBox","bbox","offset","isHorizontalPort","port","dx","dy","getExpandedBBoxPoint","anotherPoint","isHorizontal","mergeBBox","getPointsFromBBox","isPointOutsideBBox","getBBoxXCrossPoints","getBBoxYCrossPoints","getBBoxCrossPointsByPoint","distance","p1","p2","_costByPoints","heuristicCostEstimate","ps","pt","source","target","reconstructPath","pathPoints","pointById","cameFrom","currentId","iterator","unshift","removeFrom","arr","item","index","indexOf","splice","isSegmentsIntersected","p0","p3","v1x","v1y","v2x","v2y","v3x","v3y","v4x","v4y","pd1","pd2","pd3","pd4","isSegmentCrossingBBox","_a","pa","pb","pc","pd","getNeighborPoints","bbox1","bbox2","neighbors","pathFinder","start","goal","sBBox","tBBox","os","ot","closedSet","openSet","gScore","fScore","sortedOpenSet","SortedArray","add","value","current","Object","keys","minId","remove","neighborPoints","iterateNeighbors","items","neighbor","neighborId","tentativeGScore","isBending","getBorderRadiusPoints","r","d0","d1","getPathWithBorderRadiusByPolyline","borderRadius","pathSegments","startPoint","join","getPolylinePoints","end","sNode","tNode","getType","sKeyShapeBBox","getKeyShape","getBBox","getModel","sx","sy","tKeyShapeBBox","_b","tx","ty","sxBBox","txBBox","lineBBox","sMixBBox","tMixBBox","connectPoints","centerPoint","filter","removeRedundantPoint","beginPoint","continueSameX","continueSameY","removeIdx","prototype","_innerAdd","idxRange","midIdx","floor","_clearAndGetMinId","res","_findFirstId","first","shift","clear"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/g6-element/es/edges/polyline-util.js"],"sourcesContent":["export var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n    y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var map = {};\n  var pointsLength = points.length;\n  for (var i = pointsLength - 1; i >= 0; i--) {\n    var p = points[i];\n    p.id = \"\".concat(p.x, \"|||\").concat(p.y);\n    if (!map[p.id]) {\n      map[p.id] = p;\n      result.push(p);\n    }\n  }\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  return filterConnectPoints(points);\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width || bbox.height) {\n    return {\n      centerX: bbox.centerX,\n      centerY: bbox.centerY,\n      minX: bbox.minX - offset,\n      minY: bbox.minY - offset,\n      maxX: bbox.maxX + offset,\n      maxY: bbox.maxY + offset,\n      height: bbox.height + 2 * offset,\n      width: bbox.width + 2 * offset\n    };\n  }\n  // when it is a point\n  return bbox;\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  if (dx === 0 && dy === 0) return 0;\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox,\n// 将原来节点 bbox 扩展了 offset 后的 bbox，且被 gridSize 格式化\npoint,\n// 被 gridSize 格式化后的位置（anchorPoint）\nanotherPoint) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n  if (isHorizontal === 0) {\n    // 说明锚点是节点中心，linkCenter: true。需要根据两个节点的相对关系决定方向\n    var x = bbox.centerX;\n    var y = bbox.centerY;\n    if (anotherPoint.y < point.y) {\n      // 另一端在左上/右上方时，总是从上方走\n      y = bbox.minY;\n    } else if (anotherPoint.x > point.x) {\n      // 另一端在右下方，往右边走\n      x = bbox.maxX;\n    } else if (anotherPoint.x < point.x) {\n      // 另一端在左下方，往左边走\n      x = bbox.minX;\n    } else if (anotherPoint.x === point.x) {\n      // 另一段在正下方，往下走\n      y = bbox.maxY;\n    }\n    return {\n      x: x,\n      y: y\n    };\n  }\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  return [{\n    x: bbox.minX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }, {\n    x: bbox.minX,\n    y: bbox.maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n    y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nexport var reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n  pathPoints.unshift(pointById[currentId]);\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var v1x = p2.x - p0.x;\n  var v1y = p2.y - p0.y;\n  var v2x = p3.x - p0.x;\n  var v2y = p3.y - p0.y;\n  var v3x = p2.x - p1.x;\n  var v3y = p2.y - p1.y;\n  var v4x = p3.x - p1.x;\n  var v4y = p3.y - p1.y;\n  var pd1 = v1x * v2y - v1y * v2x;\n  var pd2 = v3x * v4y - v3y * v4x;\n  var pd3 = v1x * v3y - v1y * v3x;\n  var pd4 = v2x * v4y - v2y * v4x;\n  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width || bbox.height) {\n    var _a = getPointsFromBBox(bbox),\n      pa = _a[0],\n      pb = _a[1],\n      pc = _a[2],\n      pd = _a[3];\n    return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n  }\n  return false;\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p === point) return;\n    if (p.x === point.x || p.y === point.y) {\n      if (isSegmentCrossingBBox(p, point, bbox1) || isSegmentCrossingBBox(p, point, bbox2)) return;\n      neighbors.push(p);\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  var _a;\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = (_a = {}, _a[start.id] = start, _a);\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n  var fScore = {}; // all default values are Infinity\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var sortedOpenSet = new SortedArray();\n  sortedOpenSet.add({\n    id: start.id,\n    value: fScore[start.id]\n  });\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n  var current;\n  while (Object.keys(openSet).length) {\n    var minId = sortedOpenSet.minId(false);\n    if (minId) {\n      current = openSet[minId];\n    } else {\n      break;\n    }\n    // 若 openSet 中 fScore 最小的点就是终点\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return pathPoints;\n    }\n    delete openSet[current.id];\n    sortedOpenSet.remove(current.id);\n    closedSet.push(current);\n    var neighborPoints = getNeighborPoints(points, current, sBBox, tBBox);\n    var iterateNeighbors = function iterateNeighbors(items) {\n      items.forEach(function (neighbor) {\n        if (closedSet.indexOf(neighbor) !== -1) {\n          return;\n        }\n        var neighborId = neighbor.id;\n        if (!openSet[neighborId]) {\n          openSet[neighborId] = neighbor;\n        }\n        var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n        if (gScore[neighborId] && tentativeGScore >= gScore[neighborId]) {\n          sortedOpenSet.add({\n            id: neighborId,\n            value: fScore[neighborId]\n          });\n          return;\n        }\n        cameFrom[neighborId] = current.id;\n        gScore[neighborId] = tentativeGScore;\n        fScore[neighborId] = gScore[neighborId] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n        sortedOpenSet.add({\n          id: neighborId,\n          value: fScore[neighborId]\n        });\n      });\n    };\n    iterateNeighbors(neighborPoints);\n  }\n  // throw new Error('Cannot find path');\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n  if (d0 < r) {\n    r = d0;\n  }\n  if (d1 < r) {\n    r = d1;\n  }\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\".concat(startPoint.x, \" \").concat(startPoint.y));\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n          ps = _a[0],\n          pt = _a[1];\n        pathSegments.push(\"L\".concat(ps.x, \" \").concat(ps.y));\n        pathSegments.push(\"Q\".concat(p1.x, \" \").concat(p1.y, \" \").concat(pt.x, \" \").concat(pt.y));\n        pathSegments.push(\"L\".concat(pt.x, \" \").concat(pt.y));\n      } else {\n        pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sKeyShapeBBox = sNode.getKeyShape().getBBox();\n    if (sKeyShapeBBox) {\n      var _a = sNode.getModel(),\n        sx = _a.x,\n        sy = _a.y;\n      sBBox = {\n        x: sx,\n        y: sy,\n        width: sKeyShapeBBox.width,\n        height: sKeyShapeBBox.height,\n        minX: sKeyShapeBBox.minX + sx,\n        maxX: sKeyShapeBBox.maxX + sx,\n        minY: sKeyShapeBBox.minY + sy,\n        maxY: sKeyShapeBBox.maxY + sy\n      };\n      sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n      sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n    } else {\n      sBBox = getBBoxFromPoint(start);\n    }\n  } else {\n    sBBox = sNode && sNode.getBBox();\n  }\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tKeyShapeBBox = tNode.getKeyShape().getBBox();\n    if (tKeyShapeBBox) {\n      var _b = tNode.getModel(),\n        tx = _b.x,\n        ty = _b.y;\n      tBBox = {\n        x: tx,\n        y: ty,\n        width: tKeyShapeBBox.width,\n        height: tKeyShapeBBox.height,\n        minX: tKeyShapeBBox.minX + tx,\n        maxX: tKeyShapeBBox.maxX + tx,\n        minY: tKeyShapeBBox.minY + ty,\n        maxY: tKeyShapeBBox.maxY + ty\n      };\n      tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n      tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n    } else {\n      tBBox = getBBoxFromPoint(end);\n    }\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  }\n  // if (isBBoxesOverlapping(sBBox, tBBox)) {\n  //   // source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset);\n  // if (isBBoxesOverlapping(sxBBox, txBBox)) {\n  //   // the expanded bounding boxes of source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n  var sPoint = getExpandedBBoxPoint(sxBBox, start, end);\n  var tPoint = getExpandedBBoxPoint(txBBox, end, start);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n      connectPoints.push(p);\n    }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint);\n  // filter out dulplicated points in connectPoints\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};\n/**\n * 去除连续同 x 不同 y 的中间点；去除连续同 y 不同 x 的中间点\n * @param points 坐标集合 { x: number, y: number, id: string }[]\n * @returns\n */\nexport var removeRedundantPoint = function removeRedundantPoint(points) {\n  if (!(points === null || points === void 0 ? void 0 : points.length)) return points;\n  var beginPoint = points[points.length - 1];\n  var current = {\n    x: beginPoint.x,\n    y: beginPoint.y\n  };\n  var continueSameX = [beginPoint];\n  var continueSameY = [beginPoint];\n  for (var i = points.length - 2; i >= 0; i--) {\n    var point = points[i];\n    if (point.x === current.x) {\n      continueSameX.push(point);\n    } else {\n      continueSameX = [point];\n      current.x = point.x;\n    }\n    if (point.y === current.y) {\n      continueSameY.push(point);\n    } else {\n      continueSameY = [point];\n      current.y = point.y;\n    }\n    if (continueSameX.length > 2) {\n      var removeIdx = points.indexOf(continueSameX[1]);\n      if (removeIdx > -1) points.splice(removeIdx, 1);\n      continue;\n    }\n    if (continueSameY.length > 2) {\n      var removeIdx = points.indexOf(continueSameY[1]);\n      if (removeIdx > -1) points.splice(removeIdx, 1);\n    }\n  }\n  return points;\n};\n/**\n * sorted array ascendly\n * add new item to proper index when calling add\n */\nvar SortedArray = /** @class */function () {\n  function SortedArray() {\n    this.arr = [];\n    this.map = {};\n    this.arr = [];\n    this.map = {};\n  }\n  SortedArray.prototype._innerAdd = function (item, length) {\n    var idxRange = [0, length - 1];\n    while (idxRange[1] - idxRange[0] > 1) {\n      var midIdx = Math.floor((idxRange[0] + idxRange[1]) / 2);\n      if (this.arr[midIdx].value > item.value) {\n        idxRange[1] = midIdx;\n      } else if (this.arr[midIdx].value < item.value) {\n        idxRange[0] = midIdx;\n      } else {\n        this.arr.splice(midIdx, 0, item);\n        this.map[item.id] = true;\n        return;\n      }\n    }\n    this.arr.splice(idxRange[1], 0, item);\n    this.map[item.id] = true;\n  };\n  SortedArray.prototype.add = function (item) {\n    // 已经存在，先移除\n    delete this.map[item.id];\n    var length = this.arr.length;\n    if (!length) {\n      this.arr.push(item);\n      this.map[item.id] = true;\n      return;\n    }\n    // 比最后一个大，加入尾部\n    if (this.arr[length - 1].value < item.value) {\n      this.arr.push(item);\n      this.map[item.id] = true;\n      return;\n    }\n    this._innerAdd(item, length);\n  };\n  // only remove from the map to avoid cost\n  // clear the invalid (not in the map) item when calling minId(true)\n  SortedArray.prototype.remove = function (id) {\n    if (!this.map[id]) return;\n    delete this.map[id];\n  };\n  SortedArray.prototype._clearAndGetMinId = function () {\n    var res;\n    for (var i = this.arr.length - 1; i >= 0; i--) {\n      if (this.map[this.arr[i].id]) res = this.arr[i].id;else this.arr.splice(i, 1);\n    }\n    return res;\n  };\n  SortedArray.prototype._findFirstId = function () {\n    while (this.arr.length) {\n      var first = this.arr.shift();\n      if (this.map[first.id]) return first.id;\n    }\n  };\n  SortedArray.prototype.minId = function (clear) {\n    if (clear) {\n      return this._clearAndGetMinId();\n    } else {\n      return this._findFirstId();\n    }\n  };\n  return SortedArray;\n}();\nexport { SortedArray };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}