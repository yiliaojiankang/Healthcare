{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nvar DEFAULT_CONFIG = {\n  tileSize: 256,\n  minZoom: 0,\n  maxZoom: Infinity,\n  zoomOffset: 0\n};\nvar getVectorTile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tile) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", new Promise(function (resolve) {\n            var _tile$bounds = _slicedToArray(tile.bounds, 4),\n              minLng = _tile$bounds[0],\n              minLat = _tile$bounds[1],\n              maxLng = _tile$bounds[2],\n              maxLat = _tile$bounds[3];\n            // minLng/maxLat ---- maxLng/maxLat\n            // |                    |\n            // |                    |\n            // |                    |\n            // minLng/minLat --- maxLng/minLat\n\n            var vectorTile = {\n              layers: {\n                // Tip: fixed SourceLayer Name\n                testTile: {\n                  features: [{\n                    type: 'Feature',\n                    properties: {\n                      key: tile.x + '/' + tile.y + '/' + tile.z,\n                      x: (minLng + maxLng) / 2,\n                      y: (minLat + maxLat) / 2\n                    },\n                    geometry: {\n                      type: 'LineString',\n                      coordinates: [[maxLng, maxLat], [maxLng, minLat], [minLng, minLat], [minLng, minLat]]\n                    }\n                  }]\n                }\n              }\n            };\n            resolve(vectorTile);\n          }));\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function getVectorTile(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport default function mapboxVectorTile(data, cfg) {\n  var getTileData = function getTileData(tile) {\n    return getVectorTile(tile);\n  };\n  var tilesetOptions = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CONFIG), cfg), {}, {\n    getTileData: getTileData\n  });\n  return {\n    data: data,\n    dataArray: [],\n    tilesetOptions: tilesetOptions,\n    isTile: true\n  };\n}","map":{"version":3,"names":["_objectSpread","_slicedToArray","_asyncToGenerator","_regeneratorRuntime","DEFAULT_CONFIG","tileSize","minZoom","maxZoom","Infinity","zoomOffset","getVectorTile","_ref","mark","_callee","tile","wrap","_callee$","_context","prev","next","abrupt","Promise","resolve","_tile$bounds","bounds","minLng","minLat","maxLng","maxLat","vectorTile","layers","testTile","features","type","properties","key","x","y","z","geometry","coordinates","stop","_x","apply","arguments","mapboxVectorTile","data","cfg","getTileData","tilesetOptions","dataArray","isTile"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-source/es/parser/testTile.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nvar DEFAULT_CONFIG = {\n  tileSize: 256,\n  minZoom: 0,\n  maxZoom: Infinity,\n  zoomOffset: 0\n};\nvar getVectorTile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tile) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", new Promise(function (resolve) {\n            var _tile$bounds = _slicedToArray(tile.bounds, 4),\n              minLng = _tile$bounds[0],\n              minLat = _tile$bounds[1],\n              maxLng = _tile$bounds[2],\n              maxLat = _tile$bounds[3];\n            // minLng/maxLat ---- maxLng/maxLat\n            // |                    |\n            // |                    |\n            // |                    |\n            // minLng/minLat --- maxLng/minLat\n\n            var vectorTile = {\n              layers: {\n                // Tip: fixed SourceLayer Name\n                testTile: {\n                  features: [{\n                    type: 'Feature',\n                    properties: {\n                      key: tile.x + '/' + tile.y + '/' + tile.z,\n                      x: (minLng + maxLng) / 2,\n                      y: (minLat + maxLat) / 2\n                    },\n                    geometry: {\n                      type: 'LineString',\n                      coordinates: [[maxLng, maxLat], [maxLng, minLat], [minLng, minLat], [minLng, minLat]]\n                    }\n                  }]\n                }\n              }\n            };\n            resolve(vectorTile);\n          }));\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function getVectorTile(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport default function mapboxVectorTile(data, cfg) {\n  var getTileData = function getTileData(tile) {\n    return getVectorTile(tile);\n  };\n  var tilesetOptions = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CONFIG), cfg), {}, {\n    getTileData: getTileData\n  });\n  return {\n    data: data,\n    dataArray: [],\n    tilesetOptions: tilesetOptions,\n    isTile: true\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}