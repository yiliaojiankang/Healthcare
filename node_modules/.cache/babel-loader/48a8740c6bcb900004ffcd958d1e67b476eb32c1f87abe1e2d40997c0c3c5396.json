{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _tslib = require(\"tslib\");\nvar _util = require(\"@antv/util\");\nvar _util2 = require(\"./util\");\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n  return minNode;\n};\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n    var relatedEdges = [];\n    if (directed) relatedEdges = (0, _util2.getOutEdgesNodeId)(minNodeId, edges);else relatedEdges = (0, _util2.getEdgesByNodeId)(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n  prevs[source] = [source];\n  // 每个节点存可能存在多条最短路径\n  var paths = {};\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  }\n  // 兼容之前单路径\n  var path = {};\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\nvar _default = dijkstra;\nexports.default = _default;\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n  var paths = [];\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if ((0, _util.isArray)(prePath)) paths.push((0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], prePath, true), [target], false));else paths.push([prePath, target]);\n    }\n  }\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}","map":{"version":3,"names":["require","Object","defineProperty","exports","value","default","_tslib","_util","_util2","minVertex","D","nodes","marks","minDis","Infinity","minNode","i","length","nodeId","id","dijkstra","graphData","source","directed","weightPropertyName","_a","_b","edges","nodeIds","prevs","forEach","node","push","nodeNum","_loop_1","minNodeId","relatedEdges","getOutEdgesNodeId","getEdgesByNodeId","edge","edgeTarget","target","edgeSource","w","weight","paths","findAllPaths","path","allPath","_default","foundPaths","_i","prev","prevPaths","prevPaths_1","prePath","isArray","__spreadArray"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/algorithm/lib/dijkstra.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _tslib = require(\"tslib\");\nvar _util = require(\"@antv/util\");\nvar _util2 = require(\"./util\");\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n  return minNode;\n};\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n    var relatedEdges = [];\n    if (directed) relatedEdges = (0, _util2.getOutEdgesNodeId)(minNodeId, edges);else relatedEdges = (0, _util2.getEdgesByNodeId)(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n  prevs[source] = [source];\n  // 每个节点存可能存在多条最短路径\n  var paths = {};\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  }\n  // 兼容之前单路径\n  var path = {};\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\nvar _default = dijkstra;\nexports.default = _default;\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n  var paths = [];\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if ((0, _util.isArray)(prePath)) paths.push((0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], prePath, true), [target], false));else paths.push([prePath, target]);\n    }\n  }\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}