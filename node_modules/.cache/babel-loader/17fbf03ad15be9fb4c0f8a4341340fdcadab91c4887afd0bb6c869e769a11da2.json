{"ast":null,"code":"import { Event as GEvent } from '../dependents';\n/**\n * @todo Whether it can(or necessary to) keep consistent with the structure of G.Event or directly use the structure of G.Event\n * G2 事件的事件包装类，基于 G.Event\n */\nvar Event = /** @class */function () {\n  function Event(view, gEvent, data) {\n    this.view = view;\n    this.gEvent = gEvent;\n    this.data = data;\n    this.type = gEvent.type;\n  }\n  /**\n   * 非交互产生的事件\n   * @param view\n   * @param type\n   * @param data\n   */\n  Event.fromData = function (view, type, data) {\n    return new Event(view, new GEvent(type, {}), data);\n  };\n  Object.defineProperty(Event.prototype, \"target\", {\n    // below props are proxy props of G.event convenient\n    /** the real trigger shape of the event */\n    get: function () {\n      // @todo G 中事件定义为 object 不正确，这里先 ignore\n      // @ts-ignore\n      return this.gEvent.target;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Event.prototype, \"event\", {\n    /** 获取对应的 dom 原生时间 */\n    get: function () {\n      return this.gEvent.originalEvent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Event.prototype, \"x\", {\n    /** x 画布坐标 */\n    get: function () {\n      return this.gEvent.x;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Event.prototype, \"y\", {\n    /** y 画布坐标 */\n    get: function () {\n      return this.gEvent.y;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Event.prototype, \"clientX\", {\n    /** x 窗口坐标 */\n    get: function () {\n      return this.gEvent.clientX;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Event.prototype, \"clientY\", {\n    /** y 窗口坐标 */\n    get: function () {\n      return this.gEvent.clientY;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  // end for proxy events\n  /**\n   * event string\n   * @returns string\n   */\n  Event.prototype.toString = function () {\n    return \"[Event (type=\".concat(this.type, \")]\");\n  };\n  /**\n   * clone a new event with same attributes\n   * @returns [[Event]]\n   */\n  Event.prototype.clone = function () {\n    return new Event(this.view, this.gEvent, this.data);\n  };\n  return Event;\n}();\nexport default Event;","map":{"version":3,"names":["Event","GEvent","view","gEvent","data","type","fromData","Object","defineProperty","prototype","get","target","originalEvent","x","y","clientX","clientY","toString","concat","clone"],"sources":["../../src/chart/event.ts"],"sourcesContent":["import { Event as GEvent, IShape } from '../dependents';\nimport { Datum } from '../interface';\nimport View from './view';\n\n/**\n * @todo Whether it can(or necessary to) keep consistent with the structure of G.Event or directly use the structure of G.Event\n * G2 事件的事件包装类，基于 G.Event\n */\nexport default class Event {\n  /** 当前 target 归属的 view 实例 */\n  public view: View;\n  /** 被包装的原生 G 事件 */\n  public gEvent: GEvent;\n  /** 原始数据 */\n  public data?: Datum;\n  /** 事件类型 */\n  public type: string;\n\n  constructor(view: View, gEvent: GEvent, data?: Datum) {\n    this.view = view;\n    this.gEvent = gEvent;\n    this.data = data;\n    this.type = gEvent.type;\n  }\n\n  /**\n   * 非交互产生的事件\n   * @param view\n   * @param type\n   * @param data\n   */\n  public static fromData(view: View, type: string, data: Datum) {\n    return new Event(view, new GEvent(type, {}), data);\n  }\n\n  // below props are proxy props of G.event convenient\n\n  /** the real trigger shape of the event */\n  public get target(): IShape {\n    // @todo G 中事件定义为 object 不正确，这里先 ignore\n    // @ts-ignore\n    return this.gEvent.target;\n  }\n\n  /** 获取对应的 dom 原生时间 */\n  public get event(): any {\n    return this.gEvent.originalEvent;\n  }\n\n  /** x 画布坐标 */\n  public get x(): number {\n    return this.gEvent.x;\n  }\n\n  /** y 画布坐标 */\n  public get y(): number {\n    return this.gEvent.y;\n  }\n\n  /** x 窗口坐标 */\n  public get clientX(): number {\n    return this.gEvent.clientX;\n  }\n\n  /** y 窗口坐标 */\n  public get clientY(): number {\n    return this.gEvent.clientY;\n  }\n  // end for proxy events\n\n  /**\n   * event string\n   * @returns string\n   */\n  public toString(): string {\n    return `[Event (type=${this.type})]`;\n  }\n\n  /**\n   * clone a new event with same attributes\n   * @returns [[Event]]\n   */\n  public clone(): Event {\n    return new Event(this.view, this.gEvent, this.data);\n  }\n}\n"],"mappings":"AAAA,SAASA,KAAK,IAAIC,MAAM,QAAgB,eAAe;AAIvD;;;;AAIA,IAAAD,KAAA;EAUE,SAAAA,MAAYE,IAAU,EAAEC,MAAc,EAAEC,IAAY;IAClD,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,IAAI,GAAGF,MAAM,CAACE,IAAI;EACzB;EAEA;;;;;;EAMcL,KAAA,CAAAM,QAAQ,GAAtB,UAAuBJ,IAAU,EAAEG,IAAY,EAAED,IAAW;IAC1D,OAAO,IAAIJ,KAAK,CAACE,IAAI,EAAE,IAAID,MAAM,CAACI,IAAI,EAAE,EAAE,CAAC,EAAED,IAAI,CAAC;EACpD,CAAC;EAKDG,MAAA,CAAAC,cAAA,CAAWR,KAAA,CAAAS,SAAA,UAAM;IAHjB;IAEA;SACA,SAAAC,CAAA;MACE;MACA;MACA,OAAO,IAAI,CAACP,MAAM,CAACQ,MAAM;IAC3B,CAAC;;;;EAGDJ,MAAA,CAAAC,cAAA,CAAWR,KAAA,CAAAS,SAAA,SAAK;IADhB;SACA,SAAAC,CAAA;MACE,OAAO,IAAI,CAACP,MAAM,CAACS,aAAa;IAClC,CAAC;;;;EAGDL,MAAA,CAAAC,cAAA,CAAWR,KAAA,CAAAS,SAAA,KAAC;IADZ;SACA,SAAAC,CAAA;MACE,OAAO,IAAI,CAACP,MAAM,CAACU,CAAC;IACtB,CAAC;;;;EAGDN,MAAA,CAAAC,cAAA,CAAWR,KAAA,CAAAS,SAAA,KAAC;IADZ;SACA,SAAAC,CAAA;MACE,OAAO,IAAI,CAACP,MAAM,CAACW,CAAC;IACtB,CAAC;;;;EAGDP,MAAA,CAAAC,cAAA,CAAWR,KAAA,CAAAS,SAAA,WAAO;IADlB;SACA,SAAAC,CAAA;MACE,OAAO,IAAI,CAACP,MAAM,CAACY,OAAO;IAC5B,CAAC;;;;EAGDR,MAAA,CAAAC,cAAA,CAAWR,KAAA,CAAAS,SAAA,WAAO;IADlB;SACA,SAAAC,CAAA;MACE,OAAO,IAAI,CAACP,MAAM,CAACa,OAAO;IAC5B,CAAC;;;;EACD;EAEA;;;;EAIOhB,KAAA,CAAAS,SAAA,CAAAQ,QAAQ,GAAf;IACE,OAAO,gBAAAC,MAAA,CAAgB,IAAI,CAACb,IAAI,OAAI;EACtC,CAAC;EAED;;;;EAIOL,KAAA,CAAAS,SAAA,CAAAU,KAAK,GAAZ;IACE,OAAO,IAAInB,KAAK,CAAC,IAAI,CAACE,IAAI,EAAE,IAAI,CAACC,MAAM,EAAE,IAAI,CAACC,IAAI,CAAC;EACrD,CAAC;EACH,OAAAJ,KAAC;AAAD,CAAC,CA7ED"},"metadata":{},"sourceType":"module","externalDependencies":[]}