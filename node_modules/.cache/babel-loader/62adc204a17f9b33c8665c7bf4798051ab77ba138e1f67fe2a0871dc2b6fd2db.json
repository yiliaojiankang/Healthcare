{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isString, isNumber, isArray } from '@antv/util';\nimport { G6GraphEvent } from '../interface/behavior';\nexport var uniqueId = function uniqueId(type) {\n  return \"\".concat(type, \"-\").concat(Math.random()).concat(Date.now());\n};\n/**\n * turn padding into [top, right, bottom, right]\n * @param  {Number|Array} padding input padding\n * @return {array} output\n */\nexport var formatPadding = function formatPadding(padding) {\n  if (isArray(padding)) {\n    switch (padding.length) {\n      case 4:\n        return padding;\n      case 3:\n        padding.push(padding[1]);\n        return padding;\n      case 2:\n        return padding.concat(padding);\n      case 1:\n        return [padding[0], padding[0], padding[0], padding[0]];\n      default:\n        return [0, 0, 0, 0];\n    }\n  }\n  if (isNumber(padding)) {\n    return [padding, padding, padding, padding];\n  } else if (isString(padding)) {\n    var intPadding = parseInt(padding, 10);\n    return [intPadding, intPadding, intPadding, intPadding];\n  }\n  return [0, 0, 0, 0];\n};\n/**\n * clone event\n * @param e\n */\nexport var cloneEvent = function cloneEvent(e) {\n  var event = new G6GraphEvent(e.type, e);\n  event.clientX = e.clientX;\n  event.clientY = e.clientY;\n  event.x = e.x;\n  event.y = e.y;\n  event.target = e.target;\n  event.currentTarget = e.currentTarget;\n  event.bubbles = true;\n  event.item = e.item;\n  return event;\n};\n/**\n * 判断 viewport 是否改变，通过和单位矩阵对比\n * @param matrix Viewport 的 Matrix\n */\nexport var isViewportChanged = function isViewportChanged(matrix) {\n  // matrix 为 null， 则说明没有变化\n  if (!matrix) {\n    return false;\n  }\n  var MATRIX_LEN = 9;\n  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  for (var i = 0; i < MATRIX_LEN; i++) {\n    if (matrix[i] !== ORIGIN_MATRIX[i]) {\n      return true;\n    }\n  }\n  return false;\n};\nexport var isNaN = function isNaN(input) {\n  return Number.isNaN(Number(input));\n};\n/**\n * 计算一组 Item 的 BBox\n * @param items 选中的一组Item，可以是 node 或 combo\n */\nexport var calculationItemsBBox = function calculationItemsBBox(items) {\n  var minx = Infinity;\n  var maxx = -Infinity;\n  var miny = Infinity;\n  var maxy = -Infinity;\n  // 获取已节点的所有最大最小x y值\n  for (var i = 0; i < items.length; i++) {\n    var element = items[i];\n    var bbox = element.getBBox();\n    var minX = bbox.minX,\n      minY = bbox.minY,\n      maxX = bbox.maxX,\n      maxY = bbox.maxY;\n    if (minX < minx) {\n      minx = minX;\n    }\n    if (minY < miny) {\n      miny = minY;\n    }\n    if (maxX > maxx) {\n      maxx = maxX;\n    }\n    if (maxY > maxy) {\n      maxy = maxY;\n    }\n  }\n  var x = Math.floor(minx);\n  var y = Math.floor(miny);\n  var width = Math.ceil(maxx) - Math.floor(minx);\n  var height = Math.ceil(maxy) - Math.floor(miny);\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    minX: minx,\n    minY: miny,\n    maxX: maxx,\n    maxY: maxy\n  };\n};\n/**\n * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠\n * 文档: https://g6.antv.antgroup.com/en/api/Util\n * @param edges 边数据集合\n * @param offsetDiff 相邻两边的 offset 之差\n * @param multiEdgeType\n * @param singleEdgeType\n * @param loopEdgeType\n */\nexport var processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {\n  if (offsetDiff === void 0) {\n    offsetDiff = 15;\n  }\n  if (multiEdgeType === void 0) {\n    multiEdgeType = 'quadratic';\n  }\n  if (singleEdgeType === void 0) {\n    singleEdgeType = undefined;\n  }\n  if (loopEdgeType === void 0) {\n    loopEdgeType = undefined;\n  }\n  var len = edges.length;\n  var cod = offsetDiff * 2;\n  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n  var edgeMap = {};\n  var tags = [];\n  var reverses = {};\n  for (var i = 0; i < len; i++) {\n    var edge = edges[i];\n    var source = edge.source,\n      target = edge.target;\n    var sourceTarget = \"\".concat(source, \"-\").concat(target);\n    if (tags[i]) continue;\n    if (!edgeMap[sourceTarget]) {\n      edgeMap[sourceTarget] = [];\n    }\n    tags[i] = true;\n    edgeMap[sourceTarget].push(edge);\n    for (var j = 0; j < len; j++) {\n      if (i === j) continue;\n      var sedge = edges[j];\n      var src = sedge.source;\n      var dst = sedge.target;\n      // 两个节点之间共同的边\n      // 第一条的source = 第二条的target\n      // 第一条的target = 第二条的source\n      if (!tags[j]) {\n        if (source === dst && target === src) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n          reverses[\"\".concat(src, \"|\").concat(dst, \"|\").concat(edgeMap[sourceTarget].length - 1)] = true;\n        } else if (source === src && target === dst) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n        }\n      }\n    }\n  }\n  for (var key in edgeMap) {\n    var arcEdges = edgeMap[key];\n    var length_1 = arcEdges.length;\n    for (var k = 0; k < length_1; k++) {\n      var current = arcEdges[k];\n      if (current.source === current.target) {\n        if (loopEdgeType) current.type = loopEdgeType;\n        // 超过8条自环边，则需要重新处理\n        current.loopCfg = {\n          position: loopPosition[k % 8],\n          dist: Math.floor(k / 8) * 20 + 50\n        };\n        continue;\n      }\n      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {\n        current.type = singleEdgeType;\n        continue;\n      }\n      current.type = multiEdgeType;\n      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[\"\".concat(current.source, \"|\").concat(current.target, \"|\").concat(k)] ? -1 : 1);\n      if (length_1 % 2 === 1) {\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n      } else {\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n      }\n    }\n  }\n  return edges;\n};","map":{"version":3,"names":["isString","isNumber","isArray","G6GraphEvent","uniqueId","type","concat","Math","random","Date","now","formatPadding","padding","length","push","intPadding","parseInt","cloneEvent","e","event","clientX","clientY","x","y","target","currentTarget","bubbles","item","isViewportChanged","matrix","MATRIX_LEN","ORIGIN_MATRIX","i","isNaN","input","Number","calculationItemsBBox","items","minx","Infinity","maxx","miny","maxy","element","bbox","getBBox","minX","minY","maxX","maxY","floor","width","ceil","height","processParallelEdges","edges","offsetDiff","multiEdgeType","singleEdgeType","loopEdgeType","undefined","len","cod","loopPosition","edgeMap","tags","reverses","edge","source","sourceTarget","j","sedge","src","dst","key","arcEdges","length_1","k","current","loopCfg","position","dist","sign","curveOffset"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/g6-core/es/util/base.js"],"sourcesContent":["import { isString, isNumber, isArray } from '@antv/util';\nimport { G6GraphEvent } from '../interface/behavior';\nexport var uniqueId = function uniqueId(type) {\n  return \"\".concat(type, \"-\").concat(Math.random()).concat(Date.now());\n};\n/**\n * turn padding into [top, right, bottom, right]\n * @param  {Number|Array} padding input padding\n * @return {array} output\n */\nexport var formatPadding = function formatPadding(padding) {\n  if (isArray(padding)) {\n    switch (padding.length) {\n      case 4:\n        return padding;\n      case 3:\n        padding.push(padding[1]);\n        return padding;\n      case 2:\n        return padding.concat(padding);\n      case 1:\n        return [padding[0], padding[0], padding[0], padding[0]];\n      default:\n        return [0, 0, 0, 0];\n    }\n  }\n  if (isNumber(padding)) {\n    return [padding, padding, padding, padding];\n  } else if (isString(padding)) {\n    var intPadding = parseInt(padding, 10);\n    return [intPadding, intPadding, intPadding, intPadding];\n  }\n  return [0, 0, 0, 0];\n};\n/**\n * clone event\n * @param e\n */\nexport var cloneEvent = function cloneEvent(e) {\n  var event = new G6GraphEvent(e.type, e);\n  event.clientX = e.clientX;\n  event.clientY = e.clientY;\n  event.x = e.x;\n  event.y = e.y;\n  event.target = e.target;\n  event.currentTarget = e.currentTarget;\n  event.bubbles = true;\n  event.item = e.item;\n  return event;\n};\n/**\n * 判断 viewport 是否改变，通过和单位矩阵对比\n * @param matrix Viewport 的 Matrix\n */\nexport var isViewportChanged = function isViewportChanged(matrix) {\n  // matrix 为 null， 则说明没有变化\n  if (!matrix) {\n    return false;\n  }\n  var MATRIX_LEN = 9;\n  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  for (var i = 0; i < MATRIX_LEN; i++) {\n    if (matrix[i] !== ORIGIN_MATRIX[i]) {\n      return true;\n    }\n  }\n  return false;\n};\nexport var isNaN = function isNaN(input) {\n  return Number.isNaN(Number(input));\n};\n/**\n * 计算一组 Item 的 BBox\n * @param items 选中的一组Item，可以是 node 或 combo\n */\nexport var calculationItemsBBox = function calculationItemsBBox(items) {\n  var minx = Infinity;\n  var maxx = -Infinity;\n  var miny = Infinity;\n  var maxy = -Infinity;\n  // 获取已节点的所有最大最小x y值\n  for (var i = 0; i < items.length; i++) {\n    var element = items[i];\n    var bbox = element.getBBox();\n    var minX = bbox.minX,\n      minY = bbox.minY,\n      maxX = bbox.maxX,\n      maxY = bbox.maxY;\n    if (minX < minx) {\n      minx = minX;\n    }\n    if (minY < miny) {\n      miny = minY;\n    }\n    if (maxX > maxx) {\n      maxx = maxX;\n    }\n    if (maxY > maxy) {\n      maxy = maxY;\n    }\n  }\n  var x = Math.floor(minx);\n  var y = Math.floor(miny);\n  var width = Math.ceil(maxx) - Math.floor(minx);\n  var height = Math.ceil(maxy) - Math.floor(miny);\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    minX: minx,\n    minY: miny,\n    maxX: maxx,\n    maxY: maxy\n  };\n};\n/**\n * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠\n * 文档: https://g6.antv.antgroup.com/en/api/Util\n * @param edges 边数据集合\n * @param offsetDiff 相邻两边的 offset 之差\n * @param multiEdgeType\n * @param singleEdgeType\n * @param loopEdgeType\n */\nexport var processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {\n  if (offsetDiff === void 0) {\n    offsetDiff = 15;\n  }\n  if (multiEdgeType === void 0) {\n    multiEdgeType = 'quadratic';\n  }\n  if (singleEdgeType === void 0) {\n    singleEdgeType = undefined;\n  }\n  if (loopEdgeType === void 0) {\n    loopEdgeType = undefined;\n  }\n  var len = edges.length;\n  var cod = offsetDiff * 2;\n  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n  var edgeMap = {};\n  var tags = [];\n  var reverses = {};\n  for (var i = 0; i < len; i++) {\n    var edge = edges[i];\n    var source = edge.source,\n      target = edge.target;\n    var sourceTarget = \"\".concat(source, \"-\").concat(target);\n    if (tags[i]) continue;\n    if (!edgeMap[sourceTarget]) {\n      edgeMap[sourceTarget] = [];\n    }\n    tags[i] = true;\n    edgeMap[sourceTarget].push(edge);\n    for (var j = 0; j < len; j++) {\n      if (i === j) continue;\n      var sedge = edges[j];\n      var src = sedge.source;\n      var dst = sedge.target;\n      // 两个节点之间共同的边\n      // 第一条的source = 第二条的target\n      // 第一条的target = 第二条的source\n      if (!tags[j]) {\n        if (source === dst && target === src) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n          reverses[\"\".concat(src, \"|\").concat(dst, \"|\").concat(edgeMap[sourceTarget].length - 1)] = true;\n        } else if (source === src && target === dst) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n        }\n      }\n    }\n  }\n  for (var key in edgeMap) {\n    var arcEdges = edgeMap[key];\n    var length_1 = arcEdges.length;\n    for (var k = 0; k < length_1; k++) {\n      var current = arcEdges[k];\n      if (current.source === current.target) {\n        if (loopEdgeType) current.type = loopEdgeType;\n        // 超过8条自环边，则需要重新处理\n        current.loopCfg = {\n          position: loopPosition[k % 8],\n          dist: Math.floor(k / 8) * 20 + 50\n        };\n        continue;\n      }\n      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {\n        current.type = singleEdgeType;\n        continue;\n      }\n      current.type = multiEdgeType;\n      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[\"\".concat(current.source, \"|\").concat(current.target, \"|\").concat(k)] ? -1 : 1);\n      if (length_1 % 2 === 1) {\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n      } else {\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n      }\n    }\n  }\n  return edges;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}