{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nmodule.exports = TinySDF;\nmodule.exports.default = TinySDF;\nvar INF = 1e20;\nfunction TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {\n  this.fontSize = fontSize || 24;\n  this.buffer = buffer === undefined ? 3 : buffer;\n  this.cutoff = cutoff || 0.25;\n  this.fontFamily = fontFamily || 'sans-serif';\n  this.fontWeight = fontWeight || 'normal';\n  this.radius = radius || 8;\n\n  // For backwards compatibility, we honor the implicit contract that the\n  // size of the returned bitmap will be fontSize + buffer * 2\n  var size = this.size = this.fontSize + this.buffer * 2;\n  // Glyphs may be slightly larger than their fontSize. The canvas already\n  // has buffer space, but create extra buffer space in the output grid for the\n  // \"halo\" to extend into (if metric extraction is enabled)\n  var gridSize = size + this.buffer * 2;\n  this.canvas = document.createElement('canvas');\n  this.canvas.width = this.canvas.height = size;\n  this.ctx = this.canvas.getContext('2d');\n  this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;\n  this.ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment\n  this.ctx.fillStyle = 'black';\n\n  // temporary arrays for the distance transform\n  this.gridOuter = new Float64Array(gridSize * gridSize);\n  this.gridInner = new Float64Array(gridSize * gridSize);\n  this.f = new Float64Array(gridSize);\n  this.z = new Float64Array(gridSize + 1);\n  this.v = new Uint16Array(gridSize);\n  this.useMetrics = this.ctx.measureText('A').actualBoundingBoxLeft !== undefined;\n\n  // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852\n  this.middle = Math.round(size / 2 * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));\n}\nfunction prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {\n  // Initialize grids outside the glyph range to alpha 0\n  gridOuter.fill(INF, 0, width * height);\n  gridInner.fill(0, 0, width * height);\n  var offset = (width - glyphWidth) / 2; // This is zero if we're not extracting metrics\n\n  for (var y = 0; y < glyphHeight; y++) {\n    for (var x = 0; x < glyphWidth; x++) {\n      var j = (y + offset) * width + x + offset;\n      var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n      if (a === 1) {\n        gridOuter[j] = 0;\n        gridInner[j] = INF;\n      } else if (a === 0) {\n        gridOuter[j] = INF;\n        gridInner[j] = 0;\n      } else {\n        var b = Math.max(0, 0.5 - a);\n        var c = Math.max(0, a - 0.5);\n        gridOuter[j] = b * b;\n        gridInner[j] = c * c;\n      }\n    }\n  }\n}\nfunction extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {\n  for (var i = 0; i < width * height; i++) {\n    var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n    alphaChannel[i] = Math.round(255 - 255 * (d / radius + cutoff));\n  }\n}\nTinySDF.prototype._draw = function (char, getMetrics) {\n  var textMetrics = this.ctx.measureText(char);\n  // Older browsers only expose the glyph width\n  // This is enough for basic layout with all glyphs using the same fixed size\n  var advance = textMetrics.width;\n  var doubleBuffer = 2 * this.buffer;\n  var width, glyphWidth, height, glyphHeight, top;\n  var imgTop, imgLeft, baselinePosition;\n  // If the browser supports bounding box metrics, we can generate a smaller\n  // SDF. This is a significant performance win.\n  if (getMetrics && this.useMetrics) {\n    // The integer/pixel part of the top alignment is encoded in metrics.top\n    // The remainder is implicitly encoded in the rasterization\n    top = Math.floor(textMetrics.actualBoundingBoxAscent);\n    baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);\n    imgTop = this.buffer;\n    imgLeft = this.buffer;\n\n    // If the glyph overflows the canvas size, it will be clipped at the\n    // bottom/right\n    glyphWidth = Math.min(this.size, Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft));\n    glyphHeight = Math.min(this.size - imgTop, Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent));\n    width = glyphWidth + doubleBuffer;\n    height = glyphHeight + doubleBuffer;\n    this.ctx.textBaseline = 'alphabetic';\n  } else {\n    width = glyphWidth = this.size;\n    height = glyphHeight = this.size;\n    // 19 points is an approximation of the \"cap height\" ascent from alphabetic\n    // baseline (even though actual drawing is from middle baseline, we can\n    // use the approximation because every glyph fills the em box)\n    top = 19 * this.fontSize / 24;\n    imgTop = imgLeft = 0;\n    baselinePosition = this.middle;\n    this.ctx.textBaseline = 'middle';\n  }\n  var imgData;\n  if (glyphWidth && glyphHeight) {\n    this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);\n    this.ctx.fillText(char, this.buffer, baselinePosition);\n    imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);\n  }\n  var alphaChannel = new Uint8ClampedArray(width * height);\n  prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);\n  edt(this.gridOuter, width, height, this.f, this.v, this.z);\n  edt(this.gridInner, width, height, this.f, this.v, this.z);\n  extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);\n  return {\n    data: alphaChannel,\n    metrics: {\n      width: glyphWidth,\n      height: glyphHeight,\n      sdfWidth: width,\n      sdfHeight: height,\n      top: top,\n      left: 0,\n      advance: advance\n    }\n  };\n};\nTinySDF.prototype.draw = function (char) {\n  return this._draw(char, false).data;\n};\nTinySDF.prototype.drawWithMetrics = function (char) {\n  return this._draw(char, true);\n};\n\n// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\nfunction edt(data, width, height, f, v, z) {\n  for (var x = 0; x < width; x++) edt1d(data, x, width, height, f, v, z);\n  for (var y = 0; y < height; y++) edt1d(data, y * width, 1, width, f, v, z);\n}\n\n// 1D squared distance transform\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n  var q, k, s, r;\n  v[0] = 0;\n  z[0] = -INF;\n  z[1] = INF;\n  for (q = 0; q < length; q++) f[q] = grid[offset + q * stride];\n  for (q = 1, k = 0, s = 0; q < length; q++) {\n    do {\n      r = v[k];\n      s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;\n    } while (s <= z[k] && --k > -1);\n    k++;\n    v[k] = q;\n    z[k] = s;\n    z[k + 1] = INF;\n  }\n  for (q = 0, k = 0; q < length; q++) {\n    while (z[k + 1] < q) k++;\n    r = v[k];\n    grid[offset + q * stride] = f[r] + (q - r) * (q - r);\n  }\n}","map":{"version":3,"names":["require","module","exports","TinySDF","default","INF","fontSize","buffer","radius","cutoff","fontFamily","fontWeight","undefined","size","gridSize","canvas","document","createElement","width","height","ctx","getContext","font","textAlign","fillStyle","gridOuter","Float64Array","gridInner","f","z","v","Uint16Array","useMetrics","measureText","actualBoundingBoxLeft","middle","Math","round","navigator","userAgent","indexOf","prepareGrids","imgData","glyphWidth","glyphHeight","fill","offset","y","x","j","a","data","b","max","c","extractAlpha","alphaChannel","i","d","sqrt","prototype","_draw","char","getMetrics","textMetrics","advance","doubleBuffer","top","imgTop","imgLeft","baselinePosition","floor","actualBoundingBoxAscent","ceil","min","actualBoundingBoxRight","actualBoundingBoxDescent","textBaseline","clearRect","fillText","getImageData","Uint8ClampedArray","edt","metrics","sdfWidth","sdfHeight","left","draw","drawWithMetrics","edt1d","grid","stride","length","q","k","s","r"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@mapbox/tiny-sdf/index.js"],"sourcesContent":["'use strict';\n\nmodule.exports = TinySDF;\nmodule.exports.default = TinySDF;\n\nvar INF = 1e20;\n\nfunction TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {\n    this.fontSize = fontSize || 24;\n    this.buffer = buffer === undefined ? 3 : buffer;\n    this.cutoff = cutoff || 0.25;\n    this.fontFamily = fontFamily || 'sans-serif';\n    this.fontWeight = fontWeight || 'normal';\n    this.radius = radius || 8;\n\n    // For backwards compatibility, we honor the implicit contract that the\n    // size of the returned bitmap will be fontSize + buffer * 2\n    var size = this.size = this.fontSize + this.buffer * 2;\n    // Glyphs may be slightly larger than their fontSize. The canvas already\n    // has buffer space, but create extra buffer space in the output grid for the\n    // \"halo\" to extend into (if metric extraction is enabled)\n    var gridSize = size + this.buffer * 2;\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = this.canvas.height = size;\n\n    this.ctx = this.canvas.getContext('2d');\n    this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;\n\n    this.ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment\n    this.ctx.fillStyle = 'black';\n\n    // temporary arrays for the distance transform\n    this.gridOuter = new Float64Array(gridSize * gridSize);\n    this.gridInner = new Float64Array(gridSize * gridSize);\n    this.f = new Float64Array(gridSize);\n    this.z = new Float64Array(gridSize + 1);\n    this.v = new Uint16Array(gridSize);\n\n    this.useMetrics = this.ctx.measureText('A').actualBoundingBoxLeft !== undefined;\n\n    // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852\n    this.middle = Math.round((size / 2) * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));\n}\n\nfunction prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {\n    // Initialize grids outside the glyph range to alpha 0\n    gridOuter.fill(INF, 0, width * height);\n    gridInner.fill(0, 0, width * height);\n\n    var offset = (width - glyphWidth) / 2; // This is zero if we're not extracting metrics\n\n    for (var y = 0; y < glyphHeight; y++) {\n        for (var x = 0; x < glyphWidth; x++) {\n            var j = (y + offset) * width + x + offset;\n            var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n            if (a === 1) {\n                gridOuter[j] = 0;\n                gridInner[j] = INF;\n            } else if (a === 0) {\n                gridOuter[j] = INF;\n                gridInner[j] = 0;\n            } else {\n                var b = Math.max(0, 0.5 - a);\n                var c = Math.max(0, a - 0.5);\n                gridOuter[j] = b * b;\n                gridInner[j] = c * c;\n            }\n        }\n    }\n}\n\nfunction extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {\n    for (var i = 0; i < width * height; i++) {\n        var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n        alphaChannel[i] = Math.round(255 - 255 * (d / radius + cutoff));\n    }\n}\n\nTinySDF.prototype._draw = function (char, getMetrics) {\n    var textMetrics = this.ctx.measureText(char);\n    // Older browsers only expose the glyph width\n    // This is enough for basic layout with all glyphs using the same fixed size\n    var advance = textMetrics.width;\n\n    var doubleBuffer = 2 * this.buffer;\n    var width, glyphWidth, height, glyphHeight, top;\n\n    var imgTop, imgLeft, baselinePosition;\n    // If the browser supports bounding box metrics, we can generate a smaller\n    // SDF. This is a significant performance win.\n    if (getMetrics && this.useMetrics) {\n        // The integer/pixel part of the top alignment is encoded in metrics.top\n        // The remainder is implicitly encoded in the rasterization\n        top = Math.floor(textMetrics.actualBoundingBoxAscent);\n        baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);\n        imgTop = this.buffer;\n        imgLeft = this.buffer;\n\n        // If the glyph overflows the canvas size, it will be clipped at the\n        // bottom/right\n        glyphWidth = Math.min(this.size,\n            Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft));\n        glyphHeight = Math.min(this.size - imgTop,\n            Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent));\n\n        width = glyphWidth + doubleBuffer;\n        height = glyphHeight + doubleBuffer;\n        this.ctx.textBaseline = 'alphabetic';\n    } else {\n        width = glyphWidth = this.size;\n        height = glyphHeight = this.size;\n        // 19 points is an approximation of the \"cap height\" ascent from alphabetic\n        // baseline (even though actual drawing is from middle baseline, we can\n        // use the approximation because every glyph fills the em box)\n        top = 19 * this.fontSize / 24;\n        imgTop = imgLeft = 0;\n        baselinePosition = this.middle;\n        this.ctx.textBaseline = 'middle';\n    }\n\n    var imgData;\n    if (glyphWidth && glyphHeight) {\n        this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);\n        this.ctx.fillText(char, this.buffer, baselinePosition);\n        imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);\n    }\n\n    var alphaChannel = new Uint8ClampedArray(width * height);\n\n    prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);\n\n    edt(this.gridOuter, width, height, this.f, this.v, this.z);\n    edt(this.gridInner, width, height, this.f, this.v, this.z);\n\n    extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);\n\n    return {\n        data: alphaChannel,\n        metrics: {\n            width: glyphWidth,\n            height: glyphHeight,\n            sdfWidth: width,\n            sdfHeight: height,\n            top: top,\n            left: 0,\n            advance: advance\n        }\n    };\n};\n\nTinySDF.prototype.draw = function (char) {\n    return this._draw(char, false).data;\n};\n\nTinySDF.prototype.drawWithMetrics = function (char) {\n    return this._draw(char, true);\n};\n\n// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\nfunction edt(data, width, height, f, v, z) {\n    for (var x = 0; x < width; x++) edt1d(data, x, width, height, f, v, z);\n    for (var y = 0; y < height; y++) edt1d(data, y * width, 1, width, f, v, z);\n}\n\n// 1D squared distance transform\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n    var q, k, s, r;\n    v[0] = 0;\n    z[0] = -INF;\n    z[1] = INF;\n\n    for (q = 0; q < length; q++) f[q] = grid[offset + q * stride];\n\n    for (q = 1, k = 0, s = 0; q < length; q++) {\n        do {\n            r = v[k];\n            s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;\n        } while (s <= z[k] && --k > -1);\n\n        k++;\n        v[k] = q;\n        z[k] = s;\n        z[k + 1] = INF;\n    }\n\n    for (q = 0, k = 0; q < length; q++) {\n        while (z[k + 1] < q) k++;\n        r = v[k];\n        grid[offset + q * stride] = f[r] + (q - r) * (q - r);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}