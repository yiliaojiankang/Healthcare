{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\nvar _util = require(\"./util\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\n  if (directed === void 0) {\n    directed = false;\n  }\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  }\n  // the origin data\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var clusters = {};\n  var nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach(function (node, i) {\n    var cid = (0, _util.uniqueId)();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  });\n  // the adjacent matrix of calNodes inside clusters\n  var adjMatrix = (0, _adjacentMatrix.default)(graphData, directed);\n  // the sum of each row in adjacent matrix\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  var neighbors = {};\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n  var iter = 0;\n  var _loop_1 = function _loop_1() {\n    var changed = false;\n    nodes.forEach(function (node) {\n      var neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\n        var neighborWeight = neighbors[node.id][neighborId];\n        var neighborNode = nodeMap[neighborId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      });\n      // find the cluster with max weight\n      var maxWeight = -Infinity;\n      var bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(function (clusterId) {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true;\n        // remove from origin cluster\n        var selfCluster = clusters[node.clusterId];\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n        // move the node to the best cluster\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) return \"break\";\n    iter++;\n  };\n  while (iter < maxIteration) {\n    var state_1 = _loop_1();\n    if (state_1 === \"break\") break;\n  }\n  // delete the empty clusters\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  });\n  // get the cluster edges\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n      target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\nvar _default = labelPropagation;\nexports.default = _default;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","default","_adjacentMatrix","_interopRequireDefault","_util","obj","__esModule","labelPropagation","graphData","directed","weightPropertyName","maxIteration","_a","nodes","_b","edges","clusters","nodeMap","forEach","node","i","cid","uniqueId","clusterId","id","idx","adjMatrix","ks","neighbors","row","k","iid","entry","j","jid","push","iter","_loop_1","changed","neighborClusters","keys","neighborId","neighborWeight","neighborNode","neighborClusterId","maxWeight","Infinity","bestClusterIds","length","selfClusterIdx","indexOf","splice","selfCluster","nodeInSelfClusterIdx","randomIdx","Math","floor","random","bestCluster","state_1","cluster","clusterEdges","clusterEdgeMap","edge","source","target","weight","sourceClusterId","targetClusterId","newEdgeId","concat","count","newEdge","clustersArray","_default"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/algorithm/lib/label-propagation.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\nvar _util = require(\"./util\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\n  if (directed === void 0) {\n    directed = false;\n  }\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  }\n  // the origin data\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var clusters = {};\n  var nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach(function (node, i) {\n    var cid = (0, _util.uniqueId)();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  });\n  // the adjacent matrix of calNodes inside clusters\n  var adjMatrix = (0, _adjacentMatrix.default)(graphData, directed);\n  // the sum of each row in adjacent matrix\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  var neighbors = {};\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n  var iter = 0;\n  var _loop_1 = function _loop_1() {\n    var changed = false;\n    nodes.forEach(function (node) {\n      var neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\n        var neighborWeight = neighbors[node.id][neighborId];\n        var neighborNode = nodeMap[neighborId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      });\n      // find the cluster with max weight\n      var maxWeight = -Infinity;\n      var bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(function (clusterId) {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true;\n        // remove from origin cluster\n        var selfCluster = clusters[node.clusterId];\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n        // move the node to the best cluster\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) return \"break\";\n    iter++;\n  };\n  while (iter < maxIteration) {\n    var state_1 = _loop_1();\n    if (state_1 === \"break\") break;\n  }\n  // delete the empty clusters\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  });\n  // get the cluster edges\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n      target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\nvar _default = labelPropagation;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}