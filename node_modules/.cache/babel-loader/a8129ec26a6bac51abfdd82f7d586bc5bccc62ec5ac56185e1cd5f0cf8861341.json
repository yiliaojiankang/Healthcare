{"ast":null,"code":"/**\n * @file utils of label\n */\nimport { isNil, isNumber, some } from '@antv/util';\nimport { rotate } from '../../../util/transform';\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\nexport function findLabelTextShape(label) {\n  return label.find(function (el) {\n    return el.get('type') === 'text';\n  });\n}\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\nexport function getLabelBackgroundInfo(labelGroup, labelItem, padding) {\n  if (padding === void 0) {\n    padding = [0, 0, 0, 0];\n  }\n  var content = labelGroup && labelGroup.getChildren()[0];\n  if (content) {\n    var labelShape = content.clone();\n    // revert rotate\n    if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {\n      rotate(labelShape, -labelItem.rotate);\n    }\n    // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n    var _a = labelShape.getCanvasBBox(),\n      x = _a.x,\n      y = _a.y,\n      width = _a.width,\n      height = _a.height;\n    labelShape.destroy();\n    var boxPadding = padding;\n    if (isNil(boxPadding)) {\n      boxPadding = [2, 2, 2, 2];\n    } else if (isNumber(boxPadding)) {\n      boxPadding = new Array(4).fill(boxPadding);\n    }\n    return {\n      x: x - boxPadding[3],\n      y: y - boxPadding[0],\n      width: width + boxPadding[1] + boxPadding[3],\n      height: height + boxPadding[0] + boxPadding[2],\n      rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0\n    };\n  }\n  return {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    rotation: 0\n  };\n}\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nexport function getOverlapArea(a, b, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n  return xOverlap * yOverlap;\n}\n/** 检测是否和已布局的堆叠 */\nexport function checkShapeOverlap(cur, dones) {\n  var box = cur.getBBox();\n  return some(dones, function (done) {\n    var target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}","map":{"version":3,"names":["isNil","isNumber","some","rotate","findLabelTextShape","label","find","el","get","getLabelBackgroundInfo","labelGroup","labelItem","padding","content","getChildren","labelShape","clone","_a","getCanvasBBox","x","y","width","height","destroy","boxPadding","Array","fill","rotation","getOverlapArea","a","b","margin","xOverlap","Math","max","min","yOverlap","checkShapeOverlap","cur","dones","box","getBBox","done","target"],"sources":["../../../../src/geometry/label/util/index.ts"],"sourcesContent":["/**\n * @file utils of label\n */\n\nimport { isNil, isNumber, some } from '@antv/util';\nimport { IElement, IGroup, BBox } from '../../../dependents';\nimport { rotate } from '../../../util/transform';\n\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\nexport function findLabelTextShape(label: IGroup): IElement {\n  return label.find((el) => el.get('type') === 'text');\n}\n\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\nexport function getLabelBackgroundInfo(\n  labelGroup: IGroup,\n  labelItem: { rotate?: number;[key: string]: any },\n  padding: number | number[] = [0, 0, 0, 0]\n): { x: number; y: number; width: number; height: number; rotation: number } {\n  const content = labelGroup && labelGroup.getChildren()[0];\n  if (content) {\n    const labelShape = content.clone();\n\n    // revert rotate\n    if (labelItem?.rotate) {\n      rotate(labelShape as IGroup, -labelItem.rotate);\n    }\n\n    // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n    const { x, y, width, height } = labelShape.getCanvasBBox();\n\n    labelShape.destroy();\n\n    let boxPadding = padding;\n    if (isNil(boxPadding)) {\n      boxPadding = [2, 2, 2, 2];\n    } else if (isNumber(boxPadding)) {\n      boxPadding = new Array(4).fill(boxPadding);\n    }\n\n    return {\n      x: x - boxPadding[3],\n      y: y - boxPadding[0],\n      width: width + boxPadding[1] + boxPadding[3],\n      height: height + boxPadding[0] + boxPadding[2],\n      rotation: labelItem?.rotate || 0,\n    };\n  }\n\n  return { x: 0, y: 0, width: 0, height: 0, rotation: 0 };\n}\n\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nexport function getOverlapArea(a: BBox, b: BBox, margin = 0) {\n  const xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  const yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n\n  return xOverlap * yOverlap;\n}\n\n/** 检测是否和已布局的堆叠 */\nexport function checkShapeOverlap(cur: IElement, dones: IElement[]) {\n  const box = cur.getBBox();\n  return some(dones, (done) => {\n    const target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}