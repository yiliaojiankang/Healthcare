{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.feasibleTreeWithLayer = exports.feasibleTree = void 0;\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"../util\");\nvar graph_1 = require(\"../../graph\");\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nvar feasibleTree = function (g) {\n  var t = new graph_1.Graph({\n    directed: false\n  });\n  // Choose arbitrary node from which to start our tree\n  var start = g.nodes()[0];\n  var size = g.nodeCount();\n  t.setNode(start, {});\n  var edge;\n  var delta;\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? (0, util_1.slack)(g, edge) : -(0, util_1.slack)(g, edge);\n    shiftRanks(t, g, delta);\n  }\n  return t;\n};\nexports.feasibleTree = feasibleTree;\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nvar tightTree = function (t, g) {\n  var dfs = function (v) {\n    g.nodeEdges(v).forEach(function (e) {\n      var edgeV = e.v;\n      var w = v === edgeV ? e.w : edgeV;\n      if (!t.hasNode(w) && !(0, util_1.slack)(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nvar feasibleTreeWithLayer = function (g) {\n  var t = new graph_1.Graph({\n    directed: false\n  });\n  // Choose arbitrary node from which to start our tree\n  var start = g.nodes()[0];\n  var size = g.nodes().filter(function (n) {\n    return !!g.node(n);\n  }).length;\n  t.setNode(start, {});\n  var edge;\n  var delta;\n  while (tightTreeWithLayer(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? (0, util_1.slack)(g, edge) : -(0, util_1.slack)(g, edge);\n    shiftRanks(t, g, delta);\n  }\n  return t;\n};\nexports.feasibleTreeWithLayer = feasibleTreeWithLayer;\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nvar tightTreeWithLayer = function (t, g) {\n  var dfs = function (v) {\n    var _a;\n    (_a = g.nodeEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n      var edgeV = e.v;\n      var w = v === edgeV ? e.w : edgeV;\n      // 对于指定layer的，直接加入tight-tree，不参与调整\n      if (!t.hasNode(w) && (g.node(w).layer !== undefined || !(0, util_1.slack)(g, e))) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nvar findMinSlackEdge = function (t, g) {\n  return (0, util_2.minBy)(g.edges(), function (e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return (0, util_1.slack)(g, e);\n    }\n    return Infinity;\n  });\n};\nvar shiftRanks = function (t, g, delta) {\n  t.nodes().forEach(function (v) {\n    if (!g.node(v).rank) g.node(v).rank = 0;\n    g.node(v).rank += delta;\n  });\n};\nexports.default = {\n  feasibleTree: feasibleTree,\n  feasibleTreeWithLayer: feasibleTreeWithLayer\n};","map":{"version":3,"names":["util_1","require","util_2","graph_1","feasibleTree","g","t","Graph","directed","start","nodes","size","nodeCount","setNode","edge","delta","tightTree","findMinSlackEdge","hasNode","v","slack","shiftRanks","exports","dfs","nodeEdges","forEach","e","edgeV","w","setEdge","feasibleTreeWithLayer","filter","n","node","length","tightTreeWithLayer","_a","layer","undefined","minBy","edges","Infinity","rank","default"],"sources":["../../../../../src/layout/dagre/src/rank/feasible-tree.ts"],"sourcesContent":[null],"mappings":";;;;;;AAAA,IAAAA,MAAA,GAAAC,OAAA;AACA,IAAAC,MAAA,GAAAD,OAAA;AACA,IAAAE,OAAA,GAAAF,OAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,IAAMG,YAAY,GAAG,SAAAA,CAACC,CAAQ;EAC5B,IAAMC,CAAC,GAAG,IAAIH,OAAA,CAAAI,KAAK,CAAC;IAAEC,QAAQ,EAAE;EAAK,CAAE,CAAC;EAExC;EACA,IAAMC,KAAK,GAAGJ,CAAC,CAACK,KAAK,EAAE,CAAC,CAAC,CAAC;EAC1B,IAAMC,IAAI,GAAGN,CAAC,CAACO,SAAS,EAAE;EAC1BN,CAAC,CAACO,OAAO,CAACJ,KAAK,EAAE,EAAE,CAAC;EAEpB,IAAIK,IAAS;EACb,IAAIC,KAAa;EACjB,OAAOC,SAAS,CAACV,CAAC,EAAED,CAAC,CAAC,GAAGM,IAAI,EAAE;IAC7BG,IAAI,GAAGG,gBAAgB,CAACX,CAAC,EAAED,CAAC,CAAC;IAC7BU,KAAK,GAAGT,CAAC,CAACY,OAAO,CAACJ,IAAI,CAACK,CAAC,CAAC,GAAG,IAAAnB,MAAA,CAAAoB,KAAK,EAACf,CAAC,EAAES,IAAI,CAAC,GAAG,CAAC,IAAAd,MAAA,CAAAoB,KAAK,EAACf,CAAC,EAAES,IAAI,CAAC;IAC5DO,UAAU,CAACf,CAAC,EAAED,CAAC,EAAEU,KAAK,CAAC;;EAGzB,OAAOT,CAAC;AACV,CAAC;AA+GCgB,OAAA,CAAAlB,YAAA,GAAAA,YAAA;AA7GF;;;;AAIA,IAAMY,SAAS,GAAG,SAAAA,CAACV,CAAQ,EAAED,CAAQ;EACnC,IAAMkB,GAAG,GAAG,SAAAA,CAACJ,CAAS;IACpBd,CAAC,CAACmB,SAAS,CAACL,CAAC,CAAE,CAACM,OAAO,CAAC,UAACC,CAAC;MACxB,IAAMC,KAAK,GAAGD,CAAC,CAACP,CAAC;MACjB,IAAMS,CAAC,GAAIT,CAAC,KAAKQ,KAAK,GAAID,CAAC,CAACE,CAAC,GAAGD,KAAK;MACrC,IAAI,CAACrB,CAAC,CAACY,OAAO,CAACU,CAAC,CAAC,IAAI,CAAC,IAAA5B,MAAA,CAAAoB,KAAK,EAACf,CAAC,EAAEqB,CAAC,CAAC,EAAE;QACjCpB,CAAC,CAACO,OAAO,CAACe,CAAC,EAAE,EAAE,CAAC;QAChBtB,CAAC,CAACuB,OAAO,CAACV,CAAC,EAAES,CAAC,EAAE,EAAE,CAAC;QACnBL,GAAG,CAACK,CAAC,CAAC;;IAEV,CAAC,CAAC;EACJ,CAAC;EAEDtB,CAAC,CAACI,KAAK,EAAE,CAACe,OAAO,CAACF,GAAG,CAAC;EACtB,OAAOjB,CAAC,CAACM,SAAS,EAAE;AACtB,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,IAAMkB,qBAAqB,GAAG,SAAAA,CAACzB,CAAQ;EACrC,IAAMC,CAAC,GAAG,IAAIH,OAAA,CAAAI,KAAK,CAAC;IAAEC,QAAQ,EAAE;EAAK,CAAE,CAAQ;EAE/C;EACA,IAAMC,KAAK,GAAGJ,CAAC,CAACK,KAAK,EAAE,CAAC,CAAC,CAAC;EAC1B,IAAMC,IAAI,GAAGN,CAAC,CAACK,KAAK,EAAE,CAACqB,MAAM,CAAC,UAACC,CAAC;IAAK,QAAC,CAAC3B,CAAC,CAAC4B,IAAI,CAACD,CAAC,CAAC;EAAX,CAAW,CAAC,CAACE,MAAM;EACxD5B,CAAC,CAACO,OAAO,CAACJ,KAAK,EAAE,EAAE,CAAC;EAEpB,IAAIK,IAAS;EACb,IAAIC,KAAa;EACjB,OAAOoB,kBAAkB,CAAC7B,CAAC,EAAED,CAAC,CAAE,GAAGM,IAAI,EAAE;IACvCG,IAAI,GAAGG,gBAAgB,CAACX,CAAC,EAAED,CAAC,CAAC;IAC7BU,KAAK,GAAGT,CAAC,CAACY,OAAO,CAACJ,IAAI,CAACK,CAAC,CAAC,GAAG,IAAAnB,MAAA,CAAAoB,KAAK,EAACf,CAAC,EAAES,IAAI,CAAC,GAAG,CAAC,IAAAd,MAAA,CAAAoB,KAAK,EAACf,CAAC,EAAES,IAAI,CAAC;IAC5DO,UAAU,CAACf,CAAC,EAAED,CAAC,EAAEU,KAAK,CAAC;;EAGzB,OAAOT,CAAC;AACV,CAAC;AA+CCgB,OAAA,CAAAQ,qBAAA,GAAAA,qBAAA;AA5CF;;;;AAIA,IAAMK,kBAAkB,GAAG,SAAAA,CAAC7B,CAAQ,EAAED,CAAQ;EAC5C,IAAMkB,GAAG,GAAG,SAAAA,CAACJ,CAAS;;IACpB,CAAAiB,EAAA,GAAA/B,CAAC,CAACmB,SAAS,CAACL,CAAC,CAAC,cAAAiB,EAAA,uBAAAA,EAAA,CAAEX,OAAO,CAAC,UAACC,CAAC;MACxB,IAAMC,KAAK,GAAGD,CAAC,CAACP,CAAC;MACjB,IAAMS,CAAC,GAAIT,CAAC,KAAKQ,KAAK,GAAID,CAAC,CAACE,CAAC,GAAGD,KAAK;MACrC;MACA,IAAI,CAACrB,CAAC,CAACY,OAAO,CAACU,CAAC,CAAC,KAAKvB,CAAC,CAAC4B,IAAI,CAACL,CAAC,CAAE,CAACS,KAAK,KAAKC,SAAS,IAAI,CAAC,IAAAtC,MAAA,CAAAoB,KAAK,EAACf,CAAC,EAAEqB,CAAC,CAAC,CAAC,EAAE;QACrEpB,CAAC,CAACO,OAAO,CAACe,CAAC,EAAE,EAAE,CAAC;QAChBtB,CAAC,CAACuB,OAAO,CAACV,CAAC,EAAES,CAAC,EAAE,EAAE,CAAC;QACnBL,GAAG,CAACK,CAAC,CAAC;;IAEV,CAAC,CAAC;EACJ,CAAC;EAEDtB,CAAC,CAACI,KAAK,EAAE,CAACe,OAAO,CAACF,GAAG,CAAC;EACtB,OAAOjB,CAAC,CAACM,SAAS,EAAE;AACtB,CAAC;AAED;;;;AAIA,IAAMK,gBAAgB,GAAG,SAAAA,CAACX,CAAQ,EAAED,CAAQ;EAC1C,OAAO,IAAAH,MAAA,CAAAqC,KAAK,EAAClC,CAAC,CAACmC,KAAK,EAAE,EAAE,UAACd,CAAM;IAC7B,IAAIpB,CAAC,CAACY,OAAO,CAACQ,CAAC,CAACP,CAAC,CAAC,KAAKb,CAAC,CAACY,OAAO,CAACQ,CAAC,CAACE,CAAC,CAAC,EAAE;MACrC,OAAO,IAAA5B,MAAA,CAAAoB,KAAK,EAACf,CAAC,EAAEqB,CAAC,CAAC;;IAEpB,OAAOe,QAAQ;EACjB,CAAC,CAAC;AACJ,CAAC;AAED,IAAMpB,UAAU,GAAG,SAAAA,CAACf,CAAQ,EAAED,CAAQ,EAAEU,KAAa;EACnDT,CAAC,CAACI,KAAK,EAAE,CAACe,OAAO,CAAC,UAACN,CAAS;IAC1B,IAAI,CAACd,CAAC,CAAC4B,IAAI,CAACd,CAAC,CAAE,CAACuB,IAAI,EAAErC,CAAC,CAAC4B,IAAI,CAACd,CAAC,CAAE,CAACuB,IAAI,GAAG,CAAC;IACxCrC,CAAC,CAAC4B,IAAI,CAACd,CAAC,CAAE,CAACuB,IAAe,IAAI3B,KAAK;EACtC,CAAC,CAAC;AACJ,CAAC;AAODO,OAAA,CAAAqB,OAAA,GAAe;EACbvC,YAAY,EAAAA,YAAA;EACZ0B,qBAAqB,EAAAA;CACtB"},"metadata":{},"sourceType":"script","externalDependencies":[]}