{"ast":null,"code":"/**\n * 碰撞检测算法\n */\nexport function antiCollision(items, labelHeight, plotRange) {\n  var labels = items.filter(function (item) {\n    return !item.invisible;\n  });\n  // sorted by y, mutable\n  labels.sort(function (a, b) {\n    return a.y - b.y;\n  });\n  // adjust y position of labels to avoid overlapping\n  var overlapping = true;\n  var startY = plotRange.minY;\n  var endY = plotRange.maxY;\n  var totalHeight = Math.abs(startY - endY);\n  var i;\n  var maxY = 0;\n  var minY = Number.MIN_VALUE;\n  var boxes = labels.map(function (label) {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n    if (label.y < minY) {\n      minY = label.y;\n    }\n    return {\n      content: label.content,\n      size: labelHeight,\n      targets: [label.y - startY],\n      pos: null\n    };\n  });\n  minY -= startY;\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach(function (box) {\n      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      box.pos = Math.max(0, box.pos);\n    });\n    // detect overlapping and join boxes\n    overlapping = false;\n    i = boxes.length;\n    while (i--) {\n      if (i > 0) {\n        var previousBox = boxes[i - 1];\n        var box = boxes[i];\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets);\n          // overflow, shift up\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n          boxes.splice(i, 1); // removing box\n          overlapping = true;\n        }\n      }\n    }\n  }\n  i = 0;\n  // step 4: normalize y and adjust x\n  boxes.forEach(function (b) {\n    var posInCompositeBox = startY + labelHeight / 2; // middle of the label\n    b.targets.forEach(function () {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n}","map":{"version":3,"names":["antiCollision","items","labelHeight","plotRange","labels","filter","item","invisible","sort","a","b","y","overlapping","startY","minY","endY","maxY","totalHeight","Math","abs","i","Number","MIN_VALUE","boxes","map","label","content","size","targets","pos","forEach","box","target","min","apply","max","length","previousBox","concat","splice","posInCompositeBox"],"sources":["../../../../../src/geometry/label/layout/pie/util.ts"],"sourcesContent":["import { PolarLabelItem } from '../../interface';\n\n/**\n * 碰撞检测算法\n */\nexport function antiCollision(\n  items: PolarLabelItem[],\n  labelHeight: number,\n  plotRange: { minY: number; maxY: number; minX: number; maxX: number }\n) {\n  const labels = items.filter((item) => !item.invisible);\n\n  // sorted by y, mutable\n  labels.sort((a, b) => a.y - b.y);\n  // adjust y position of labels to avoid overlapping\n  let overlapping = true;\n  const startY = plotRange.minY;\n  const endY = plotRange.maxY;\n  let totalHeight = Math.abs(startY - endY);\n  let i;\n\n  let maxY = 0;\n  let minY = Number.MIN_VALUE;\n  const boxes = labels.map((label) => {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n    if (label.y < minY) {\n      minY = label.y;\n    }\n    return {\n      content: label.content,\n      size: labelHeight,\n      targets: [label.y - startY],\n      pos: null,\n    };\n  });\n\n  minY -= startY;\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach((box) => {\n      const target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      box.pos = Math.max(0, box.pos);\n    });\n\n    // detect overlapping and join boxes\n    overlapping = false;\n    i = boxes.length;\n    while (i--) {\n      if (i > 0) {\n        const previousBox = boxes[i - 1];\n        const box = boxes[i];\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets);\n\n          // overflow, shift up\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n          boxes.splice(i, 1); // removing box\n          overlapping = true;\n        }\n      }\n    }\n  }\n\n  i = 0;\n  // step 4: normalize y and adjust x\n  boxes.forEach((b) => {\n    let posInCompositeBox = startY + labelHeight / 2; // middle of the label\n    b.targets.forEach(() => {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}