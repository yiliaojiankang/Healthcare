{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getConnectedComponents;\nexports.detectStrongConnectComponents = exports.detectConnectedComponents = void 0;\nvar _util = require(\"./util\");\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\nvar detectConnectedComponents = function detectConnectedComponents(graphData) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    var neighbors = (0, _util.getNeighbors)(node.id, edges);\n    var _loop_1 = function _loop_1(i) {\n      var neighbor = neighbors[i];\n      if (!visited[neighbor]) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === neighbor;\n        });\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    };\n    for (var i = 0; i < neighbors.length; ++i) {\n      _loop_1(i);\n    }\n  };\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n      allComponents.push(component);\n    }\n  }\n  return allComponents;\n};\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\nexports.detectConnectedComponents = detectConnectedComponents;\nvar detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true;\n    // 考虑每个邻接点\n    var neighbors = (0, _util.getNeighbors)(node.id, edges, 'target').filter(function (n) {\n      return nodes.map(function (node) {\n        return node.id;\n      }).indexOf(n) > -1;\n    });\n    var _loop_2 = function _loop_2(i) {\n      var targetNodeID = neighbors[i];\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === targetNodeID;\n        });\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n        // tree edge\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    };\n    for (var i = 0; i < neighbors.length; i++) {\n      _loop_2(i);\n    }\n    // If node is a root node, generate an SCC\n    if (lowLink[node.id] === indices[node.id]) {\n      var component = [];\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n  return allComponents;\n};\nexports.detectStrongConnectComponents = detectStrongConnectComponents;\nfunction getConnectedComponents(graphData, directed) {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}","map":{"version":3,"names":["require","Object","defineProperty","exports","value","default","getConnectedComponents","detectStrongConnectComponents","detectConnectedComponents","_util","graphData","_a","nodes","_b","edges","allComponents","visited","nodeStack","getComponent","node","push","id","neighbors","getNeighbors","_loop_1","i","neighbor","targetNode","filter","length","component","pop","inStack","indices","lowLink","index","n","map","indexOf","_loop_2","targetNodeID","Math","min","tmpNode","_i","nodes_1","directed"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/algorithm/lib/connected-component.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getConnectedComponents;\nexports.detectStrongConnectComponents = exports.detectConnectedComponents = void 0;\nvar _util = require(\"./util\");\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\nvar detectConnectedComponents = function detectConnectedComponents(graphData) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    var neighbors = (0, _util.getNeighbors)(node.id, edges);\n    var _loop_1 = function _loop_1(i) {\n      var neighbor = neighbors[i];\n      if (!visited[neighbor]) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === neighbor;\n        });\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    };\n    for (var i = 0; i < neighbors.length; ++i) {\n      _loop_1(i);\n    }\n  };\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n      allComponents.push(component);\n    }\n  }\n  return allComponents;\n};\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\nexports.detectConnectedComponents = detectConnectedComponents;\nvar detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true;\n    // 考虑每个邻接点\n    var neighbors = (0, _util.getNeighbors)(node.id, edges, 'target').filter(function (n) {\n      return nodes.map(function (node) {\n        return node.id;\n      }).indexOf(n) > -1;\n    });\n    var _loop_2 = function _loop_2(i) {\n      var targetNodeID = neighbors[i];\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === targetNodeID;\n        });\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n        // tree edge\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    };\n    for (var i = 0; i < neighbors.length; i++) {\n      _loop_2(i);\n    }\n    // If node is a root node, generate an SCC\n    if (lowLink[node.id] === indices[node.id]) {\n      var component = [];\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n  return allComponents;\n};\nexports.detectStrongConnectComponents = detectStrongConnectComponents;\nfunction getConnectedComponents(graphData, directed) {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}