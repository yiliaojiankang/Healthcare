{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { squareDist, pointLineSquareDist, itemIntersectByLine, getPointsCenter, fractionToLine, isPointsOverlap, pointRectSquareDist, Line, isPointInPolygon } from '../../util/math';\nvar defaultOps = {\n  maxRoutingIterations: 100,\n  maxMarchingIterations: 100,\n  pixelGroupSize: 2,\n  edgeR0: 10,\n  edgeR1: 10,\n  nodeR0: 5,\n  nodeR1: 10,\n  morphBuffer: 5,\n  threshold: 0.001,\n  skip: 16,\n  nodeInfluenceFactor: 1,\n  edgeInfluenceFactor: 1,\n  negativeNodeInfluenceFactor: -0.5\n};\n/**\n * Marching square algorithm for traching the contour of a pixel group\n * https://www.emanueleferonato.com/2013/03/01/using-marching-squares-algorithm-to-trace-the-contour-of-an-image/\n * @param potentialArea\n * @param threshold\n */\nfunction MarchingSquares(contour, potentialArea, threshold) {\n  var marched = false;\n  var getVal = function getVal(x, y) {\n    return potentialArea.cells[x + y * potentialArea.width];\n  };\n  var getState = function getState(x, y) {\n    var squareVal = 0;\n    if (getVal(x - 1, y - 1) >= threshold) {\n      squareVal += 1;\n    }\n    if (getVal(x, y - 1) > threshold) {\n      squareVal += 2;\n    }\n    if (getVal(x - 1, y) > threshold) {\n      squareVal += 4;\n    }\n    if (getVal(x, y) > threshold) {\n      squareVal += 8;\n    }\n    return squareVal;\n  };\n  var doMarch = function doMarch(xPos, yPos) {\n    var x = xPos;\n    var y = yPos;\n    var prevX;\n    var prevY;\n    for (var i = 0; i < potentialArea.width * potentialArea.height; i++) {\n      prevX = x;\n      prevY = y;\n      if (contour.findIndex(function (item) {\n        return item.x === x && item.y === y;\n      }) > -1) {\n        if (contour[0].x !== x || contour[0].y !== y) {\n          // encountered a loop but haven't returned to start: change direction using conditionals and continue back to start\n        } else {\n          return true;\n        }\n      } else {\n        contour.push({\n          x: x,\n          y: y\n        });\n      }\n      var state = getState(x, y);\n      // assign the move direction according to state of the square\n      switch (state) {\n        case -1:\n          console.warn('Marched out of bounds');\n          return true;\n        case 0:\n        case 3:\n        case 2:\n        case 7:\n          x++; // go right\n          break;\n        case 12:\n        case 14:\n        case 4:\n          x--; // go left\n          break;\n        case 6:\n          // go left if come from up else go right\n          if (prevX === 0) {\n            if (prevY === -1) {\n              x -= 1;\n            } else {\n              x += 1;\n            }\n          }\n          break;\n        case 1:\n        case 13:\n        case 5:\n          y--; // go up\n          break;\n        case 9:\n          // go up if come from right else go down\n          if (prevX === 1) {\n            if (prevY === 0) {\n              y -= 1;\n            } else {\n              y += 1;\n            }\n          }\n          break;\n        case 10:\n        case 8:\n        case 11:\n          y++; // go down\n          break;\n        default:\n          console.warn(\"Marching squares invalid state: \".concat(state));\n          return true;\n      }\n    }\n  };\n  this.march = function () {\n    for (var x = 0; x < potentialArea.width && !marched; x += 1) {\n      for (var y = 0; y < potentialArea.height && !marched; y += 1) {\n        if (getVal(x, y) > threshold && getState(x, y) !== 15) {\n          marched = doMarch(x, y);\n        }\n      }\n    }\n    return marched;\n  };\n}\n/**\n * Space partition & assign value to each cell\n * @param points\n */\nvar initGridCells = function initGridCells(width, height, pixelGroupSize) {\n  var scaleWidth = Math.ceil(width / pixelGroupSize);\n  var scaleHeight = Math.ceil(height / pixelGroupSize);\n  var gridCells = new Float32Array(Math.max(0, scaleWidth * scaleHeight)).fill(0);\n  return {\n    cells: gridCells,\n    width: scaleWidth,\n    height: scaleHeight\n  };\n};\n/**\n * Find the optimal already visited member to item;\n   Optimal: minimize cost(j) = distance(i,j) ∗ countObstacles(i,j)\n * @param item\n * @param visited\n */\nvar pickBestNeighbor = function pickBestNeighbor(item, visited, nonMembers) {\n  var closestNeighbour = null;\n  var minCost = Number.POSITIVE_INFINITY;\n  visited.forEach(function (neighbourItem) {\n    var itemP = {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n    var neighbourItemP = {\n      x: neighbourItem.getModel().x,\n      y: neighbourItem.getModel().y\n    };\n    var dist = squareDist(itemP, neighbourItemP);\n    var directLine = new Line(itemP.x, itemP.y, neighbourItemP.x, neighbourItemP.y);\n    var numberObstacles = nonMembers.reduce(function (count, _item) {\n      if (fractionToLine(_item, directLine) > 0) {\n        return count + 1;\n      }\n      return count;\n    }, 0);\n    if (dist * Math.pow(numberObstacles + 1, 2) < minCost) {\n      closestNeighbour = neighbourItem;\n      minCost = dist * Math.pow(numberObstacles + 1, 2);\n    }\n  });\n  return closestNeighbour;\n};\n/**\n * 返回和线相交的item中，离边的起点最近的item\n * @param items\n * @param line\n */\nvar getIntersectItem = function getIntersectItem(items, line) {\n  var minDistance = Number.POSITIVE_INFINITY;\n  var closestItem = null;\n  items.forEach(function (item) {\n    var distance = fractionToLine(item, line);\n    // find closest intersection\n    if (distance >= 0 && distance < minDistance) {\n      closestItem = item;\n      minDistance = distance;\n    }\n  });\n  return closestItem;\n};\n/**\n * Modify the directLine and Route virtual edges around obstacles\n */\nvar computeRoute = function computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {\n  var checkedLines = [];\n  var linesToCheck = [];\n  linesToCheck.push(directLine);\n  var hasIntersection = true;\n  var iterations = 0;\n  var pointExists = function pointExists(point, lines) {\n    var flag = false;\n    lines.forEach(function (line) {\n      if (flag) return;\n      if (isPointsOverlap(point, {\n        x: line.x1,\n        y: line.y1\n      }) || isPointsOverlap(point, {\n        x: line.x2,\n        y: line.y2\n      })) {\n        flag = true;\n      }\n    });\n    return flag;\n  };\n  var isPointInNonMembers = function isPointInNonMembers(point, _nonMembers) {\n    for (var _i = 0, _nonMembers_1 = _nonMembers; _i < _nonMembers_1.length; _i++) {\n      var item = _nonMembers_1[_i];\n      var bbox = item.getBBox();\n      var itemContour = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x, bbox.y + bbox.height], [bbox.x + bbox.width, bbox.y + bbox.height]];\n      if (isPointInPolygon(itemContour, point.x, point.y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  // outer loop end when no more intersections or out of iterations\n  while (hasIntersection && iterations < maxRoutingIterations) {\n    hasIntersection = false;\n    var _loop_1 = function _loop_1() {\n      var line = linesToCheck.pop();\n      var closestItem = getIntersectItem(nonMembers, line);\n      if (closestItem) {\n        var _a = itemIntersectByLine(closestItem, line),\n          intersections_1 = _a[0],\n          countIntersections = _a[1];\n        // if line passes through item\n        if (countIntersections === 2) {\n          var testReroute = function testReroute(isFirst) {\n            var tempMorphBuffer = morphBuffer;\n            var virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);\n            // test the virtualNode already exists\n            var exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n            var pointInside = isPointInNonMembers(virtualNode, nonMembers);\n            while (!exist && pointInside && tempMorphBuffer >= 1) {\n              // try a smaller buffer\n              tempMorphBuffer /= 1.5;\n              virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);\n              exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n              pointInside = isPointInNonMembers(virtualNode, nonMembers);\n            }\n            // 第二次route时不要求pointInside\n            if (virtualNode && !exist && (!isFirst || !pointInside)) {\n              // add 2 rerouted lines to check\n              linesToCheck.push(new Line(line.x1, line.y1, virtualNode.x, virtualNode.y));\n              linesToCheck.push(new Line(virtualNode.x, virtualNode.y, line.x2, line.y2));\n              hasIntersection = true;\n            }\n          };\n          testReroute(true);\n          if (!hasIntersection) {\n            // if we didn't find a valid point around the first corner, try the second\n            testReroute(false);\n          }\n        }\n      }\n      // no intersection found, mark this line as completed\n      if (!hasIntersection) {\n        checkedLines.push(line);\n      }\n      iterations += 1;\n    };\n    // inner loop end when out of lines or found an intersection\n    while (!hasIntersection && linesToCheck.length) {\n      _loop_1();\n    }\n  }\n  // 加入剩余的线\n  while (linesToCheck.length) {\n    checkedLines.push(linesToCheck.pop());\n  }\n  return checkedLines;\n};\n/**\n *  Connect item with visited members using direct line or virtual edges\n */\nfunction getRoute(item, nonMembers, visited, maxRoutingIterations, morphBuffer) {\n  var optimalNeighbor = pickBestNeighbor(item, visited, nonMembers);\n  if (optimalNeighbor === null) {\n    return [];\n  }\n  //  merge the consecutive lines\n  var mergeLines = function mergeLines(checkedLines) {\n    var finalRoute = [];\n    while (checkedLines.length > 0) {\n      var line1 = checkedLines.pop();\n      if (checkedLines.length === 0) {\n        finalRoute.push(line1);\n        break;\n      }\n      var line2 = checkedLines.pop();\n      var mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);\n      var closestItem = getIntersectItem(nonMembers, mergeLine);\n      // merge most recent line and previous line\n      if (!closestItem) {\n        checkedLines.push(mergeLine);\n      } else {\n        finalRoute.push(line1);\n        checkedLines.push(line2);\n      }\n    }\n    return finalRoute;\n  };\n  var directLine = new Line(item.getModel().x, item.getModel().y, optimalNeighbor.getModel().x, optimalNeighbor.getModel().y);\n  var checkedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);\n  var finalRoute = mergeLines(checkedLines);\n  return finalRoute;\n}\n/**\n * Calculate the counter that includes the  selected items and exclues the non-selected items\n * @param graph\n * @param members\n * @param nonMembers\n * @param options\n */\nexport var genBubbleSet = function genBubbleSet(members, nonMembers, ops) {\n  // eslint-disable-next-line no-redeclare\n  var options = Object.assign(defaultOps, ops);\n  var centroid = getPointsCenter(members.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  }));\n  // 按照到中心距离远近排序\n  members = members.sort(function (a, b) {\n    return squareDist({\n      x: a.getModel().x,\n      y: a.getModel().y\n    }, centroid) - squareDist({\n      x: b.getModel().x,\n      y: b.getModel().y\n    }, centroid);\n  });\n  var visited = [];\n  var virtualEdges = [];\n  members.forEach(function (item) {\n    var lines = getRoute(item, nonMembers, visited, options.maxRoutingIterations, options.morphBuffer);\n    lines.forEach(function (l) {\n      virtualEdges.push(l);\n    });\n    visited.push(item);\n  });\n  // 由于edge也可以作为member和nonMember传入，暂时不考虑把edges作为参数传入genBubbleSet\n  // edges && edges.forEach(e => {\n  //   virtualEdges.push(new Line(e.getSource().getModel().x, e.getSource().getModel().y, e.getTarget().getModel().x, e.getTarget().getModel().y));\n  // });\n  var activeRegion = getActiveRregion(members, virtualEdges, options.nodeR0);\n  var potentialArea = initGridCells(activeRegion.width, activeRegion.height, options.pixelGroupSize);\n  // Use march squares to generate contour\n  var contour = [];\n  var hull = [];\n  for (var iterations = 0; iterations < options.maxMarchingIterations; iterations++) {\n    fillPotentialArea(members, nonMembers, virtualEdges, activeRegion, potentialArea, options);\n    contour = [];\n    hull = [];\n    if (!new MarchingSquares(contour, potentialArea, options.threshold).march()) continue;\n    var marchedPath = contour.map(function (point) {\n      return {\n        x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX),\n        y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY)\n      };\n    });\n    // const marchedPath = marchingSquares(potentialArea, options.threshold).map(point => ({ x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX), y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY) }))\n    if (marchedPath) {\n      var size = marchedPath.length;\n      if (options.skip > 1) {\n        size = Math.floor(marchedPath.length / options.skip);\n        // if we reduced too much (fewer than three points in reduced surface) reduce skip and try again\n        while (size < 3 && options.skip > 1) {\n          options.skip -= 1;\n          size = Math.floor(marchedPath.length / options.skip);\n        }\n      }\n      // copy hull values\n      for (var i = 0, j = 0; j < size; j += 1, i += options.skip) {\n        hull.push({\n          x: marchedPath[i].x,\n          y: marchedPath[i].y\n        });\n      }\n    }\n    var isContourValid = function isContourValid() {\n      for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n        var item = members_1[_i];\n        var hullPoints = hull.map(function (point) {\n          return [point.x, point.y];\n        });\n        if (!isPointInPolygon(hullPoints, item.getBBox().centerX, item.getBBox().centerY)) return false;\n      }\n      // 不强制要求所有nonMembers都没有包含在内\n      // for (const item of nonMembers) {\n      //   if (isPointInPolygon({ x: item.getBBox().centerX, y: item.getBBox().centerY }, contour)) return false\n      // }\n      return true;\n    };\n    if (hull && isContourValid()) {\n      return hull;\n    }\n    // update parameters for next iteration\n    options.threshold *= 0.9;\n    if (iterations <= options.maxMarchingIterations * 0.5) {\n      options.memberInfluenceFactor *= 1.2;\n      options.edgeInfluenceFactor *= 1.2;\n    } else if (options.nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {\n      // after half the iterations, start increasing positive energy and lowering the threshold\n      options.nonMemberInfluenceFactor *= 0.8;\n    } else {\n      break;\n    }\n  }\n  return hull;\n};\n/**\n * unionboundingbox\n * @param members\n * @param edges\n */\nfunction getActiveRregion(members, edges, offset) {\n  var activeRegion = {\n    minX: Number.POSITIVE_INFINITY,\n    minY: Number.POSITIVE_INFINITY,\n    maxX: Number.NEGATIVE_INFINITY,\n    maxY: Number.NEGATIVE_INFINITY,\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n  };\n  var bboxes = [];\n  members.forEach(function (item) {\n    bboxes.push(item.getBBox());\n  });\n  edges.forEach(function (l) {\n    bboxes.push(l.getBBox());\n  });\n  for (var _i = 0, bboxes_1 = bboxes; _i < bboxes_1.length; _i++) {\n    var bbox = bboxes_1[_i];\n    activeRegion.minX = (bbox.minX < activeRegion.minX ? bbox.minX : activeRegion.minX) - offset;\n    activeRegion.minY = (bbox.minY < activeRegion.minY ? bbox.minY : activeRegion.minY) - offset;\n    activeRegion.maxX = (bbox.maxX > activeRegion.maxX ? bbox.maxX : activeRegion.maxX) + offset;\n    activeRegion.maxY = (bbox.maxY > activeRegion.maxY ? bbox.maxY : activeRegion.maxY) + offset;\n  }\n  activeRegion.width = activeRegion.maxX - activeRegion.minX;\n  activeRegion.height = activeRegion.maxY - activeRegion.minY;\n  activeRegion.x = activeRegion.minX;\n  activeRegion.y = activeRegion.minY;\n  return activeRegion;\n}\nfunction fillPotentialArea(members, nonMembers, edges, activeRegion, potentialArea, options) {\n  function pos2GridIx(x, offset) {\n    var gridIx = Math.floor((x - offset) / options.pixelGroupSize);\n    return gridIx < 0 ? 0 : gridIx;\n  }\n  function gridIx2Pos(x, offset) {\n    return x * options.pixelGroupSize + offset;\n  }\n  // using inverse a for numerical stability\n  var nodeInfA = (options.nodeR0 - options.nodeR1) * (options.nodeR0 - options.nodeR1);\n  var edgeInfA = (options.edgeR0 - options.edgeR1) * (options.edgeR0 - options.edgeR1);\n  var getAffectedRegion = function getAffectedRegion(bbox, thresholdR) {\n    var startX = Math.min(pos2GridIx(bbox.minX, thresholdR + activeRegion.minX), potentialArea.width);\n    var startY = Math.min(pos2GridIx(bbox.minY, thresholdR + activeRegion.minY), potentialArea.height);\n    var endX = Math.min(pos2GridIx(bbox.maxX, -thresholdR + activeRegion.minX), potentialArea.width);\n    var endY = Math.min(pos2GridIx(bbox.maxY, -thresholdR + activeRegion.minY), potentialArea.height);\n    return [startX, startY, endX, endY];\n  };\n  var addItemInfluence = function addItemInfluence(item, influenceFactor) {\n    var bbox = item.getBBox();\n    var _a = getAffectedRegion(bbox, options.nodeR1),\n      startX = _a[0],\n      startY = _a[1],\n      endX = _a[2],\n      endY = _a[3];\n    // calculate item influence for each cell\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var distanceSq = pointRectSquareDist({\n          x: tempX,\n          y: tempY\n        }, {\n          x: bbox.minX,\n          y: bbox.minY,\n          width: bbox.width,\n          height: bbox.height\n        });\n        if (distanceSq < Math.pow(options.nodeR1, 2)) {\n          var dr = Math.sqrt(distanceSq) - options.nodeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * dr * dr;\n        }\n      }\n    }\n  };\n  var addEdgeInfluence = function addEdgeInfluence(line, influenceFactor) {\n    var bbox = line.getBBox();\n    var _a = getAffectedRegion(bbox, options.edgeR1),\n      startX = _a[0],\n      startY = _a[1],\n      endX = _a[2],\n      endY = _a[3];\n    // for every point in active part of potentialArea, calculate distance to nearest point on line and add influence\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea.cells[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var minDistanceSq = pointLineSquareDist({\n          x: tempX,\n          y: tempY\n        }, line);\n        // only influence if less than r1\n        if (minDistanceSq < Math.pow(options.edgeR1, 2)) {\n          var mdr = Math.sqrt(minDistanceSq) - options.edgeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * mdr * mdr;\n        }\n      }\n    }\n  };\n  if (options.nodeInfluenceFactor) {\n    members.forEach(function (item) {\n      addItemInfluence(item, options.nodeInfluenceFactor / nodeInfA);\n    });\n  }\n  if (options.edgeInfluenceFactor) {\n    edges.forEach(function (edge) {\n      addEdgeInfluence(edge, options.edgeInfluenceFactor / edgeInfA);\n    });\n  }\n  if (options.negativeNodeInfluenceFactor) {\n    nonMembers.forEach(function (item) {\n      addItemInfluence(item, options.negativeNodeInfluenceFactor / nodeInfA);\n    });\n  }\n}\nfunction rerouteLine(item, buffer, intersections, wrapNormal) {\n  var bbox = item.getBBox();\n  var topIntersect = intersections[0],\n    leftIntersect = intersections[1],\n    bottomIntersect = intersections[2],\n    rightIntersect = intersections[3];\n  var cornerPos = {\n    topLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.minY - buffer\n    },\n    topRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.minY - buffer\n    },\n    bottomLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.maxY + buffer\n    },\n    bottomRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.maxY + buffer\n    }\n  };\n  var totalArea = bbox.height * bbox.width;\n  function calcHalfArea(intersect1, intersect2) {\n    return bbox.width * ((intersect1.y - bbox.minY + (intersect2.y - bbox.minY)) * 0.5);\n  }\n  // 根据线和boundingbox相交的情况，确定control point的位置\n  if (leftIntersect) {\n    // 相交区域有三角形\n    if (topIntersect) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n    // 相交区域分成上下两个梯形，比较面积\n    var topArea = calcHalfArea(leftIntersect, rightIntersect);\n    if (topArea < totalArea * 0.5) {\n      if (leftIntersect.y > rightIntersect.y) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    }\n    if (leftIntersect.y < rightIntersect.y) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n    return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  }\n  if (rightIntersect) {\n    if (topIntersect) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  }\n  // 相交区域分成左右两个梯形\n  var leftArea = calcHalfArea(topIntersect, bottomIntersect);\n  if (leftArea < totalArea * 0.5) {\n    if (topIntersect.x > bottomIntersect.x) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n  }\n  if (topIntersect.x < bottomIntersect.x) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n  return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n}","map":{"version":3,"names":["squareDist","pointLineSquareDist","itemIntersectByLine","getPointsCenter","fractionToLine","isPointsOverlap","pointRectSquareDist","Line","isPointInPolygon","defaultOps","maxRoutingIterations","maxMarchingIterations","pixelGroupSize","edgeR0","edgeR1","nodeR0","nodeR1","morphBuffer","threshold","skip","nodeInfluenceFactor","edgeInfluenceFactor","negativeNodeInfluenceFactor","MarchingSquares","contour","potentialArea","marched","getVal","x","y","cells","width","getState","squareVal","doMarch","xPos","yPos","prevX","prevY","i","height","findIndex","item","push","state","console","warn","concat","march","initGridCells","scaleWidth","Math","ceil","scaleHeight","gridCells","Float32Array","max","fill","pickBestNeighbor","visited","nonMembers","closestNeighbour","minCost","Number","POSITIVE_INFINITY","forEach","neighbourItem","itemP","getModel","neighbourItemP","dist","directLine","numberObstacles","reduce","count","_item","pow","getIntersectItem","items","line","minDistance","closestItem","distance","computeRoute","checkedLines","linesToCheck","hasIntersection","iterations","pointExists","point","lines","flag","x1","y1","x2","y2","isPointInNonMembers","_nonMembers","_i","_nonMembers_1","length","bbox","getBBox","itemContour","_loop_1","pop","_a","intersections_1","countIntersections","testReroute","isFirst","tempMorphBuffer","virtualNode","rerouteLine","exist","pointInside","getRoute","optimalNeighbor","mergeLines","finalRoute","line1","line2","mergeLine","genBubbleSet","members","ops","options","Object","assign","centroid","map","sort","a","b","virtualEdges","l","activeRegion","getActiveRregion","hull","fillPotentialArea","marchedPath","round","minX","minY","size","floor","j","isContourValid","members_1","hullPoints","centerX","centerY","memberInfluenceFactor","nonMemberInfluenceFactor","edges","offset","maxX","NEGATIVE_INFINITY","maxY","bboxes","bboxes_1","pos2GridIx","gridIx","gridIx2Pos","nodeInfA","edgeInfA","getAffectedRegion","thresholdR","startX","min","startY","endX","endY","addItemInfluence","influenceFactor","tempX","tempY","distanceSq","dr","sqrt","addEdgeInfluence","minDistanceSq","mdr","edge","buffer","intersections","wrapNormal","topIntersect","leftIntersect","bottomIntersect","rightIntersect","cornerPos","topLeft","topRight","bottomLeft","bottomRight","totalArea","calcHalfArea","intersect1","intersect2","topArea","leftArea"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/g6-core/es/element/hull/bubbleset.js"],"sourcesContent":["import { squareDist, pointLineSquareDist, itemIntersectByLine, getPointsCenter, fractionToLine, isPointsOverlap, pointRectSquareDist, Line, isPointInPolygon } from '../../util/math';\nvar defaultOps = {\n  maxRoutingIterations: 100,\n  maxMarchingIterations: 100,\n  pixelGroupSize: 2,\n  edgeR0: 10,\n  edgeR1: 10,\n  nodeR0: 5,\n  nodeR1: 10,\n  morphBuffer: 5,\n  threshold: 0.001,\n  skip: 16,\n  nodeInfluenceFactor: 1,\n  edgeInfluenceFactor: 1,\n  negativeNodeInfluenceFactor: -0.5\n};\n/**\n * Marching square algorithm for traching the contour of a pixel group\n * https://www.emanueleferonato.com/2013/03/01/using-marching-squares-algorithm-to-trace-the-contour-of-an-image/\n * @param potentialArea\n * @param threshold\n */\nfunction MarchingSquares(contour, potentialArea, threshold) {\n  var marched = false;\n  var getVal = function getVal(x, y) {\n    return potentialArea.cells[x + y * potentialArea.width];\n  };\n  var getState = function getState(x, y) {\n    var squareVal = 0;\n    if (getVal(x - 1, y - 1) >= threshold) {\n      squareVal += 1;\n    }\n    if (getVal(x, y - 1) > threshold) {\n      squareVal += 2;\n    }\n    if (getVal(x - 1, y) > threshold) {\n      squareVal += 4;\n    }\n    if (getVal(x, y) > threshold) {\n      squareVal += 8;\n    }\n    return squareVal;\n  };\n  var doMarch = function doMarch(xPos, yPos) {\n    var x = xPos;\n    var y = yPos;\n    var prevX;\n    var prevY;\n    for (var i = 0; i < potentialArea.width * potentialArea.height; i++) {\n      prevX = x;\n      prevY = y;\n      if (contour.findIndex(function (item) {\n        return item.x === x && item.y === y;\n      }) > -1) {\n        if (contour[0].x !== x || contour[0].y !== y) {\n          // encountered a loop but haven't returned to start: change direction using conditionals and continue back to start\n        } else {\n          return true;\n        }\n      } else {\n        contour.push({\n          x: x,\n          y: y\n        });\n      }\n      var state = getState(x, y);\n      // assign the move direction according to state of the square\n      switch (state) {\n        case -1:\n          console.warn('Marched out of bounds');\n          return true;\n        case 0:\n        case 3:\n        case 2:\n        case 7:\n          x++; // go right\n          break;\n        case 12:\n        case 14:\n        case 4:\n          x--; // go left\n          break;\n        case 6:\n          // go left if come from up else go right\n          if (prevX === 0) {\n            if (prevY === -1) {\n              x -= 1;\n            } else {\n              x += 1;\n            }\n          }\n          break;\n        case 1:\n        case 13:\n        case 5:\n          y--; // go up\n          break;\n        case 9:\n          // go up if come from right else go down\n          if (prevX === 1) {\n            if (prevY === 0) {\n              y -= 1;\n            } else {\n              y += 1;\n            }\n          }\n          break;\n        case 10:\n        case 8:\n        case 11:\n          y++; // go down\n          break;\n        default:\n          console.warn(\"Marching squares invalid state: \".concat(state));\n          return true;\n      }\n    }\n  };\n  this.march = function () {\n    for (var x = 0; x < potentialArea.width && !marched; x += 1) {\n      for (var y = 0; y < potentialArea.height && !marched; y += 1) {\n        if (getVal(x, y) > threshold && getState(x, y) !== 15) {\n          marched = doMarch(x, y);\n        }\n      }\n    }\n    return marched;\n  };\n}\n/**\n * Space partition & assign value to each cell\n * @param points\n */\nvar initGridCells = function initGridCells(width, height, pixelGroupSize) {\n  var scaleWidth = Math.ceil(width / pixelGroupSize);\n  var scaleHeight = Math.ceil(height / pixelGroupSize);\n  var gridCells = new Float32Array(Math.max(0, scaleWidth * scaleHeight)).fill(0);\n  return {\n    cells: gridCells,\n    width: scaleWidth,\n    height: scaleHeight\n  };\n};\n/**\n * Find the optimal already visited member to item;\n   Optimal: minimize cost(j) = distance(i,j) ∗ countObstacles(i,j)\n * @param item\n * @param visited\n */\nvar pickBestNeighbor = function pickBestNeighbor(item, visited, nonMembers) {\n  var closestNeighbour = null;\n  var minCost = Number.POSITIVE_INFINITY;\n  visited.forEach(function (neighbourItem) {\n    var itemP = {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n    var neighbourItemP = {\n      x: neighbourItem.getModel().x,\n      y: neighbourItem.getModel().y\n    };\n    var dist = squareDist(itemP, neighbourItemP);\n    var directLine = new Line(itemP.x, itemP.y, neighbourItemP.x, neighbourItemP.y);\n    var numberObstacles = nonMembers.reduce(function (count, _item) {\n      if (fractionToLine(_item, directLine) > 0) {\n        return count + 1;\n      }\n      return count;\n    }, 0);\n    if (dist * Math.pow(numberObstacles + 1, 2) < minCost) {\n      closestNeighbour = neighbourItem;\n      minCost = dist * Math.pow(numberObstacles + 1, 2);\n    }\n  });\n  return closestNeighbour;\n};\n/**\n * 返回和线相交的item中，离边的起点最近的item\n * @param items\n * @param line\n */\nvar getIntersectItem = function getIntersectItem(items, line) {\n  var minDistance = Number.POSITIVE_INFINITY;\n  var closestItem = null;\n  items.forEach(function (item) {\n    var distance = fractionToLine(item, line);\n    // find closest intersection\n    if (distance >= 0 && distance < minDistance) {\n      closestItem = item;\n      minDistance = distance;\n    }\n  });\n  return closestItem;\n};\n/**\n * Modify the directLine and Route virtual edges around obstacles\n */\nvar computeRoute = function computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {\n  var checkedLines = [];\n  var linesToCheck = [];\n  linesToCheck.push(directLine);\n  var hasIntersection = true;\n  var iterations = 0;\n  var pointExists = function pointExists(point, lines) {\n    var flag = false;\n    lines.forEach(function (line) {\n      if (flag) return;\n      if (isPointsOverlap(point, {\n        x: line.x1,\n        y: line.y1\n      }) || isPointsOverlap(point, {\n        x: line.x2,\n        y: line.y2\n      })) {\n        flag = true;\n      }\n    });\n    return flag;\n  };\n  var isPointInNonMembers = function isPointInNonMembers(point, _nonMembers) {\n    for (var _i = 0, _nonMembers_1 = _nonMembers; _i < _nonMembers_1.length; _i++) {\n      var item = _nonMembers_1[_i];\n      var bbox = item.getBBox();\n      var itemContour = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x, bbox.y + bbox.height], [bbox.x + bbox.width, bbox.y + bbox.height]];\n      if (isPointInPolygon(itemContour, point.x, point.y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  // outer loop end when no more intersections or out of iterations\n  while (hasIntersection && iterations < maxRoutingIterations) {\n    hasIntersection = false;\n    var _loop_1 = function _loop_1() {\n      var line = linesToCheck.pop();\n      var closestItem = getIntersectItem(nonMembers, line);\n      if (closestItem) {\n        var _a = itemIntersectByLine(closestItem, line),\n          intersections_1 = _a[0],\n          countIntersections = _a[1];\n        // if line passes through item\n        if (countIntersections === 2) {\n          var testReroute = function testReroute(isFirst) {\n            var tempMorphBuffer = morphBuffer;\n            var virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);\n            // test the virtualNode already exists\n            var exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n            var pointInside = isPointInNonMembers(virtualNode, nonMembers);\n            while (!exist && pointInside && tempMorphBuffer >= 1) {\n              // try a smaller buffer\n              tempMorphBuffer /= 1.5;\n              virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);\n              exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n              pointInside = isPointInNonMembers(virtualNode, nonMembers);\n            }\n            // 第二次route时不要求pointInside\n            if (virtualNode && !exist && (!isFirst || !pointInside)) {\n              // add 2 rerouted lines to check\n              linesToCheck.push(new Line(line.x1, line.y1, virtualNode.x, virtualNode.y));\n              linesToCheck.push(new Line(virtualNode.x, virtualNode.y, line.x2, line.y2));\n              hasIntersection = true;\n            }\n          };\n          testReroute(true);\n          if (!hasIntersection) {\n            // if we didn't find a valid point around the first corner, try the second\n            testReroute(false);\n          }\n        }\n      }\n      // no intersection found, mark this line as completed\n      if (!hasIntersection) {\n        checkedLines.push(line);\n      }\n      iterations += 1;\n    };\n    // inner loop end when out of lines or found an intersection\n    while (!hasIntersection && linesToCheck.length) {\n      _loop_1();\n    }\n  }\n  // 加入剩余的线\n  while (linesToCheck.length) {\n    checkedLines.push(linesToCheck.pop());\n  }\n  return checkedLines;\n};\n/**\n *  Connect item with visited members using direct line or virtual edges\n */\nfunction getRoute(item, nonMembers, visited, maxRoutingIterations, morphBuffer) {\n  var optimalNeighbor = pickBestNeighbor(item, visited, nonMembers);\n  if (optimalNeighbor === null) {\n    return [];\n  }\n  //  merge the consecutive lines\n  var mergeLines = function mergeLines(checkedLines) {\n    var finalRoute = [];\n    while (checkedLines.length > 0) {\n      var line1 = checkedLines.pop();\n      if (checkedLines.length === 0) {\n        finalRoute.push(line1);\n        break;\n      }\n      var line2 = checkedLines.pop();\n      var mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);\n      var closestItem = getIntersectItem(nonMembers, mergeLine);\n      // merge most recent line and previous line\n      if (!closestItem) {\n        checkedLines.push(mergeLine);\n      } else {\n        finalRoute.push(line1);\n        checkedLines.push(line2);\n      }\n    }\n    return finalRoute;\n  };\n  var directLine = new Line(item.getModel().x, item.getModel().y, optimalNeighbor.getModel().x, optimalNeighbor.getModel().y);\n  var checkedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);\n  var finalRoute = mergeLines(checkedLines);\n  return finalRoute;\n}\n/**\n * Calculate the counter that includes the  selected items and exclues the non-selected items\n * @param graph\n * @param members\n * @param nonMembers\n * @param options\n */\nexport var genBubbleSet = function genBubbleSet(members, nonMembers, ops) {\n  // eslint-disable-next-line no-redeclare\n  var options = Object.assign(defaultOps, ops);\n  var centroid = getPointsCenter(members.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  }));\n  // 按照到中心距离远近排序\n  members = members.sort(function (a, b) {\n    return squareDist({\n      x: a.getModel().x,\n      y: a.getModel().y\n    }, centroid) - squareDist({\n      x: b.getModel().x,\n      y: b.getModel().y\n    }, centroid);\n  });\n  var visited = [];\n  var virtualEdges = [];\n  members.forEach(function (item) {\n    var lines = getRoute(item, nonMembers, visited, options.maxRoutingIterations, options.morphBuffer);\n    lines.forEach(function (l) {\n      virtualEdges.push(l);\n    });\n    visited.push(item);\n  });\n  // 由于edge也可以作为member和nonMember传入，暂时不考虑把edges作为参数传入genBubbleSet\n  // edges && edges.forEach(e => {\n  //   virtualEdges.push(new Line(e.getSource().getModel().x, e.getSource().getModel().y, e.getTarget().getModel().x, e.getTarget().getModel().y));\n  // });\n  var activeRegion = getActiveRregion(members, virtualEdges, options.nodeR0);\n  var potentialArea = initGridCells(activeRegion.width, activeRegion.height, options.pixelGroupSize);\n  // Use march squares to generate contour\n  var contour = [];\n  var hull = [];\n  for (var iterations = 0; iterations < options.maxMarchingIterations; iterations++) {\n    fillPotentialArea(members, nonMembers, virtualEdges, activeRegion, potentialArea, options);\n    contour = [];\n    hull = [];\n    if (!new MarchingSquares(contour, potentialArea, options.threshold).march()) continue;\n    var marchedPath = contour.map(function (point) {\n      return {\n        x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX),\n        y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY)\n      };\n    });\n    // const marchedPath = marchingSquares(potentialArea, options.threshold).map(point => ({ x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX), y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY) }))\n    if (marchedPath) {\n      var size = marchedPath.length;\n      if (options.skip > 1) {\n        size = Math.floor(marchedPath.length / options.skip);\n        // if we reduced too much (fewer than three points in reduced surface) reduce skip and try again\n        while (size < 3 && options.skip > 1) {\n          options.skip -= 1;\n          size = Math.floor(marchedPath.length / options.skip);\n        }\n      }\n      // copy hull values\n      for (var i = 0, j = 0; j < size; j += 1, i += options.skip) {\n        hull.push({\n          x: marchedPath[i].x,\n          y: marchedPath[i].y\n        });\n      }\n    }\n    var isContourValid = function isContourValid() {\n      for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n        var item = members_1[_i];\n        var hullPoints = hull.map(function (point) {\n          return [point.x, point.y];\n        });\n        if (!isPointInPolygon(hullPoints, item.getBBox().centerX, item.getBBox().centerY)) return false;\n      }\n      // 不强制要求所有nonMembers都没有包含在内\n      // for (const item of nonMembers) {\n      //   if (isPointInPolygon({ x: item.getBBox().centerX, y: item.getBBox().centerY }, contour)) return false\n      // }\n      return true;\n    };\n    if (hull && isContourValid()) {\n      return hull;\n    }\n    // update parameters for next iteration\n    options.threshold *= 0.9;\n    if (iterations <= options.maxMarchingIterations * 0.5) {\n      options.memberInfluenceFactor *= 1.2;\n      options.edgeInfluenceFactor *= 1.2;\n    } else if (options.nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {\n      // after half the iterations, start increasing positive energy and lowering the threshold\n      options.nonMemberInfluenceFactor *= 0.8;\n    } else {\n      break;\n    }\n  }\n  return hull;\n};\n/**\n * unionboundingbox\n * @param members\n * @param edges\n */\nfunction getActiveRregion(members, edges, offset) {\n  var activeRegion = {\n    minX: Number.POSITIVE_INFINITY,\n    minY: Number.POSITIVE_INFINITY,\n    maxX: Number.NEGATIVE_INFINITY,\n    maxY: Number.NEGATIVE_INFINITY,\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n  };\n  var bboxes = [];\n  members.forEach(function (item) {\n    bboxes.push(item.getBBox());\n  });\n  edges.forEach(function (l) {\n    bboxes.push(l.getBBox());\n  });\n  for (var _i = 0, bboxes_1 = bboxes; _i < bboxes_1.length; _i++) {\n    var bbox = bboxes_1[_i];\n    activeRegion.minX = (bbox.minX < activeRegion.minX ? bbox.minX : activeRegion.minX) - offset;\n    activeRegion.minY = (bbox.minY < activeRegion.minY ? bbox.minY : activeRegion.minY) - offset;\n    activeRegion.maxX = (bbox.maxX > activeRegion.maxX ? bbox.maxX : activeRegion.maxX) + offset;\n    activeRegion.maxY = (bbox.maxY > activeRegion.maxY ? bbox.maxY : activeRegion.maxY) + offset;\n  }\n  activeRegion.width = activeRegion.maxX - activeRegion.minX;\n  activeRegion.height = activeRegion.maxY - activeRegion.minY;\n  activeRegion.x = activeRegion.minX;\n  activeRegion.y = activeRegion.minY;\n  return activeRegion;\n}\nfunction fillPotentialArea(members, nonMembers, edges, activeRegion, potentialArea, options) {\n  function pos2GridIx(x, offset) {\n    var gridIx = Math.floor((x - offset) / options.pixelGroupSize);\n    return gridIx < 0 ? 0 : gridIx;\n  }\n  function gridIx2Pos(x, offset) {\n    return x * options.pixelGroupSize + offset;\n  }\n  // using inverse a for numerical stability\n  var nodeInfA = (options.nodeR0 - options.nodeR1) * (options.nodeR0 - options.nodeR1);\n  var edgeInfA = (options.edgeR0 - options.edgeR1) * (options.edgeR0 - options.edgeR1);\n  var getAffectedRegion = function getAffectedRegion(bbox, thresholdR) {\n    var startX = Math.min(pos2GridIx(bbox.minX, thresholdR + activeRegion.minX), potentialArea.width);\n    var startY = Math.min(pos2GridIx(bbox.minY, thresholdR + activeRegion.minY), potentialArea.height);\n    var endX = Math.min(pos2GridIx(bbox.maxX, -thresholdR + activeRegion.minX), potentialArea.width);\n    var endY = Math.min(pos2GridIx(bbox.maxY, -thresholdR + activeRegion.minY), potentialArea.height);\n    return [startX, startY, endX, endY];\n  };\n  var addItemInfluence = function addItemInfluence(item, influenceFactor) {\n    var bbox = item.getBBox();\n    var _a = getAffectedRegion(bbox, options.nodeR1),\n      startX = _a[0],\n      startY = _a[1],\n      endX = _a[2],\n      endY = _a[3];\n    // calculate item influence for each cell\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var distanceSq = pointRectSquareDist({\n          x: tempX,\n          y: tempY\n        }, {\n          x: bbox.minX,\n          y: bbox.minY,\n          width: bbox.width,\n          height: bbox.height\n        });\n        if (distanceSq < Math.pow(options.nodeR1, 2)) {\n          var dr = Math.sqrt(distanceSq) - options.nodeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * dr * dr;\n        }\n      }\n    }\n  };\n  var addEdgeInfluence = function addEdgeInfluence(line, influenceFactor) {\n    var bbox = line.getBBox();\n    var _a = getAffectedRegion(bbox, options.edgeR1),\n      startX = _a[0],\n      startY = _a[1],\n      endX = _a[2],\n      endY = _a[3];\n    // for every point in active part of potentialArea, calculate distance to nearest point on line and add influence\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea.cells[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var minDistanceSq = pointLineSquareDist({\n          x: tempX,\n          y: tempY\n        }, line);\n        // only influence if less than r1\n        if (minDistanceSq < Math.pow(options.edgeR1, 2)) {\n          var mdr = Math.sqrt(minDistanceSq) - options.edgeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * mdr * mdr;\n        }\n      }\n    }\n  };\n  if (options.nodeInfluenceFactor) {\n    members.forEach(function (item) {\n      addItemInfluence(item, options.nodeInfluenceFactor / nodeInfA);\n    });\n  }\n  if (options.edgeInfluenceFactor) {\n    edges.forEach(function (edge) {\n      addEdgeInfluence(edge, options.edgeInfluenceFactor / edgeInfA);\n    });\n  }\n  if (options.negativeNodeInfluenceFactor) {\n    nonMembers.forEach(function (item) {\n      addItemInfluence(item, options.negativeNodeInfluenceFactor / nodeInfA);\n    });\n  }\n}\nfunction rerouteLine(item, buffer, intersections, wrapNormal) {\n  var bbox = item.getBBox();\n  var topIntersect = intersections[0],\n    leftIntersect = intersections[1],\n    bottomIntersect = intersections[2],\n    rightIntersect = intersections[3];\n  var cornerPos = {\n    topLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.minY - buffer\n    },\n    topRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.minY - buffer\n    },\n    bottomLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.maxY + buffer\n    },\n    bottomRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.maxY + buffer\n    }\n  };\n  var totalArea = bbox.height * bbox.width;\n  function calcHalfArea(intersect1, intersect2) {\n    return bbox.width * ((intersect1.y - bbox.minY + (intersect2.y - bbox.minY)) * 0.5);\n  }\n  // 根据线和boundingbox相交的情况，确定control point的位置\n  if (leftIntersect) {\n    // 相交区域有三角形\n    if (topIntersect) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n    // 相交区域分成上下两个梯形，比较面积\n    var topArea = calcHalfArea(leftIntersect, rightIntersect);\n    if (topArea < totalArea * 0.5) {\n      if (leftIntersect.y > rightIntersect.y) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    }\n    if (leftIntersect.y < rightIntersect.y) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n    return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  }\n  if (rightIntersect) {\n    if (topIntersect) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  }\n  // 相交区域分成左右两个梯形\n  var leftArea = calcHalfArea(topIntersect, bottomIntersect);\n  if (leftArea < totalArea * 0.5) {\n    if (topIntersect.x > bottomIntersect.x) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n  }\n  if (topIntersect.x < bottomIntersect.x) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n  return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}