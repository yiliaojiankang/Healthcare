{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport Base from '../base';\nfunction getEucliDis(pointA, pointB, eps) {\n  var vx = pointA.x - pointB.x;\n  var vy = pointA.y - pointB.y;\n  if (!eps || Math.abs(vx) > eps || Math.abs(vy) > eps) {\n    return Math.sqrt(vx * vx + vy * vy);\n  }\n  return eps;\n}\nfunction getDotProduct(ei, ej) {\n  return ei.x * ej.x + ei.y * ej.y;\n}\nfunction projectPointToEdge(p, e) {\n  var k = (e.source.y - e.target.y) / (e.source.x - e.target.x);\n  var x = (k * k * e.source.x + k * (p.y - e.source.y) + p.x) / (k * k + 1);\n  var y = k * (x - e.source.x) + e.source.y;\n  return {\n    x: x,\n    y: y\n  };\n}\nvar Bundling = /** @class */function (_super) {\n  __extends(Bundling, _super);\n  function Bundling(config) {\n    return _super.call(this, config) || this;\n  }\n  Bundling.prototype.getDefaultCfgs = function () {\n    return {\n      edgeBundles: [],\n      edgePoints: [],\n      K: 0.1,\n      lambda: 0.1,\n      divisions: 1,\n      divRate: 2,\n      cycles: 6,\n      iterations: 90,\n      iterRate: 0.6666667,\n      bundleThreshold: 0.6,\n      eps: 1e-6,\n      onLayoutEnd: function onLayoutEnd() {},\n      onTick: function onTick() {}\n    };\n  };\n  Bundling.prototype.init = function () {\n    var graph = this.get('graph');\n    var onTick = this.get('onTick');\n    var tick = function tick() {\n      if (onTick) {\n        onTick();\n      }\n      graph.refreshPositions();\n    };\n    this.set('tick', tick);\n  };\n  Bundling.prototype.bundling = function (data) {\n    var self = this;\n    self.set('data', data);\n    // 如果正在布局，忽略布局请求\n    if (self.isTicking()) {\n      return;\n    }\n    var edges = data.edges || [];\n    var nodes = data.nodes || [];\n    var nodeIdMap = {};\n    var error = false;\n    nodes.forEach(function (node) {\n      if (node.x === null || !node.y === null || node.x === undefined || !node.y === undefined) {\n        error = true;\n      }\n      nodeIdMap[node.id] = node;\n    });\n    if (error) throw new Error('please layout the graph or assign x and y for nodes first');\n    self.set('nodeIdMap', nodeIdMap);\n    // subdivide each edges\n    var divisions = self.get('divisions');\n    var divRate = self.get('divRate');\n    var edgePoints = self.divideEdges(divisions);\n    self.set('edgePoints', edgePoints);\n    // compute the bundles\n    var edgeBundles = self.getEdgeBundles();\n    self.set('edgeBundles', edgeBundles);\n    // iterations\n    var C = self.get('cycles');\n    var iterations = self.get('iterations');\n    var iterRate = self.get('iterRate');\n    var lambda = self.get('lambda');\n    for (var i = 0; i < C; i++) {\n      var _loop_1 = function _loop_1(j) {\n        var forces = [];\n        edges.forEach(function (e, k) {\n          if (e.source === e.target) return;\n          var source = nodeIdMap[e.source];\n          var target = nodeIdMap[e.target];\n          forces[k] = self.getEdgeForces({\n            source: source,\n            target: target\n          }, k, divisions, lambda);\n          for (var p = 0; p < divisions + 1; p++) {\n            edgePoints[k][p].x += forces[k][p].x;\n            edgePoints[k][p].y += forces[k][p].y;\n          }\n        });\n      };\n      for (var j = 0; j < iterations; j++) {\n        _loop_1(j);\n      }\n      // parameters for nex cycle\n      lambda = lambda / 2;\n      divisions *= divRate;\n      iterations *= iterRate;\n      edgePoints = self.divideEdges(divisions);\n      self.set('edgePoints', edgePoints);\n    }\n    // change the edges according to edgePoints\n    edges.forEach(function (e, i) {\n      if (e.source === e.target) return;\n      e.type = 'polyline';\n      e.controlPoints = edgePoints[i].slice(1, edgePoints[i].length - 1);\n    });\n    var graph = self.get('graph');\n    graph.refresh();\n  };\n  Bundling.prototype.updateBundling = function (cfg) {\n    var self = this;\n    var data = cfg.data;\n    if (data) {\n      self.set('data', data);\n    }\n    if (self.get('ticking')) {\n      self.set('ticking', false);\n    }\n    Object.keys(cfg).forEach(function (key) {\n      self.set(key, cfg[key]);\n    });\n    if (cfg.onTick) {\n      var graph_1 = this.get('graph');\n      self.set('tick', function () {\n        cfg.onTick();\n        graph_1.refresh();\n      });\n    }\n    self.bundling(data);\n  };\n  Bundling.prototype.divideEdges = function (divisions) {\n    var self = this;\n    var edges = self.get('data').edges;\n    var nodeIdMap = self.get('nodeIdMap');\n    var edgePoints = self.get('edgePoints');\n    if (!edgePoints || edgePoints === undefined) edgePoints = [];\n    edges.forEach(function (edge, i) {\n      var _a;\n      if (!edgePoints[i] || edgePoints[i] === undefined) {\n        edgePoints[i] = [];\n      }\n      var source = nodeIdMap[edge.source];\n      var target = nodeIdMap[edge.target];\n      if (divisions === 1) {\n        edgePoints[i].push({\n          x: source.x,\n          y: source.y\n        }); // source\n        edgePoints[i].push({\n          x: 0.5 * (source.x + target.x),\n          y: 0.5 * (source.y + target.y)\n        }); // mid\n        edgePoints[i].push({\n          x: target.x,\n          y: target.y\n        }); // target\n      } else {\n        var edgeLength = 0;\n        if (!((_a = edgePoints[i]) === null || _a === void 0 ? void 0 : _a.length)) {\n          // it is a straight line\n          edgeLength = getEucliDis({\n            x: source.x,\n            y: source.y\n          }, {\n            x: target.x,\n            y: target.y\n          });\n        } else {\n          edgeLength = self.getEdgeLength(edgePoints[i]);\n        }\n        var divisionLength_1 = edgeLength / (divisions + 1);\n        var currentDivisonLength_1 = divisionLength_1;\n        var newEdgePoints_1 = [{\n          x: source.x,\n          y: source.y\n        }]; // source\n        edgePoints[i].forEach(function (ep, j) {\n          if (j === 0) return;\n          var oriDivisionLength = getEucliDis(ep, edgePoints[i][j - 1]);\n          while (oriDivisionLength > currentDivisonLength_1) {\n            var ratio = currentDivisonLength_1 / oriDivisionLength;\n            var edgePoint = {\n              x: edgePoints[i][j - 1].x,\n              y: edgePoints[i][j - 1].y\n            };\n            edgePoint.x += ratio * (ep.x - edgePoints[i][j - 1].x);\n            edgePoint.y += ratio * (ep.y - edgePoints[i][j - 1].y);\n            newEdgePoints_1.push(edgePoint);\n            oriDivisionLength -= currentDivisonLength_1;\n            currentDivisonLength_1 = divisionLength_1;\n          }\n          currentDivisonLength_1 -= oriDivisionLength;\n        });\n        newEdgePoints_1.push({\n          x: target.x,\n          y: target.y\n        }); // target\n        edgePoints[i] = newEdgePoints_1;\n      }\n    });\n    return edgePoints;\n  };\n  /**\n   * 计算边的长度\n   * @param points\n   */\n  Bundling.prototype.getEdgeLength = function (points) {\n    var length = 0;\n    points.forEach(function (p, i) {\n      if (i === 0) return;\n      length += getEucliDis(p, points[i - 1]);\n    });\n    return length;\n  };\n  Bundling.prototype.getEdgeBundles = function () {\n    var self = this;\n    var data = self.get('data');\n    var edges = data.edges || [];\n    var bundleThreshold = self.get('bundleThreshold');\n    var nodeIdMap = self.get('nodeIdMap');\n    var edgeBundles = self.get('edgeBundles');\n    if (!edgeBundles) edgeBundles = [];\n    edges.forEach(function (e, i) {\n      if (!edgeBundles[i] || edgeBundles[i] === undefined) {\n        edgeBundles[i] = [];\n      }\n    });\n    edges.forEach(function (ei, i) {\n      var iSource = nodeIdMap[ei.source];\n      var iTarget = nodeIdMap[ei.target];\n      edges.forEach(function (ej, j) {\n        if (j <= i) return;\n        var jSource = nodeIdMap[ej.source];\n        var jTarget = nodeIdMap[ej.target];\n        var score = self.getBundleScore({\n          source: iSource,\n          target: iTarget\n        }, {\n          source: jSource,\n          target: jTarget\n        });\n        if (score >= bundleThreshold) {\n          edgeBundles[i].push(j);\n          edgeBundles[j].push(i);\n        }\n      });\n    });\n    return edgeBundles;\n  };\n  Bundling.prototype.getBundleScore = function (ei, ej) {\n    var self = this;\n    ei.vx = ei.target.x - ei.source.x;\n    ei.vy = ei.target.y - ei.source.y;\n    ej.vx = ej.target.x - ej.source.x;\n    ej.vy = ej.target.y - ej.source.y;\n    ei.length = getEucliDis({\n      x: ei.source.x,\n      y: ei.source.y\n    }, {\n      x: ei.target.x,\n      y: ei.target.y\n    });\n    ej.length = getEucliDis({\n      x: ej.source.x,\n      y: ej.source.y\n    }, {\n      x: ej.target.x,\n      y: ej.target.y\n    });\n    // angle score\n    var aScore = self.getAngleScore(ei, ej);\n    // scale score\n    var sScore = self.getScaleScore(ei, ej);\n    // position score\n    var pScore = self.getPositionScore(ei, ej);\n    // visibility socre\n    var vScore = self.getVisibilityScore(ei, ej);\n    return aScore * sScore * pScore * vScore;\n  };\n  Bundling.prototype.getAngleScore = function (ei, ej) {\n    var dotProduct = getDotProduct({\n      x: ei.vx,\n      y: ei.vy\n    }, {\n      x: ej.vx,\n      y: ej.vy\n    });\n    return dotProduct / (ei.length * ej.length);\n  };\n  Bundling.prototype.getScaleScore = function (ei, ej) {\n    var aLength = (ei.length + ej.length) / 2;\n    var score = 2 / (aLength / Math.min(ei.length, ej.length) + Math.max(ei.length, ej.length) / aLength);\n    return score;\n  };\n  Bundling.prototype.getPositionScore = function (ei, ej) {\n    var aLength = (ei.length + ej.length) / 2;\n    var iMid = {\n      x: (ei.source.x + ei.target.x) / 2,\n      y: (ei.source.y + ei.target.y) / 2\n    };\n    var jMid = {\n      x: (ej.source.x + ej.target.x) / 2,\n      y: (ej.source.y + ej.target.y) / 2\n    };\n    var distance = getEucliDis(iMid, jMid);\n    return aLength / (aLength + distance);\n  };\n  Bundling.prototype.getVisibilityScore = function (ei, ej) {\n    var vij = this.getEdgeVisibility(ei, ej);\n    var vji = this.getEdgeVisibility(ej, ei);\n    return vij < vji ? vij : vji;\n  };\n  Bundling.prototype.getEdgeVisibility = function (ei, ej) {\n    var ps = projectPointToEdge(ej.source, ei);\n    var pt = projectPointToEdge(ej.target, ei);\n    var pMid = {\n      x: (ps.x + pt.x) / 2,\n      y: (ps.y + pt.y) / 2\n    };\n    var iMid = {\n      x: (ei.source.x + ei.target.x) / 2,\n      y: (ei.source.y + ei.target.y) / 2\n    };\n    return Math.max(0, 1 - 2 * getEucliDis(pMid, iMid) / getEucliDis(ps, pt));\n  };\n  Bundling.prototype.getEdgeForces = function (e, eidx, divisions, lambda) {\n    var self = this;\n    var edgePoints = self.get('edgePoints');\n    var K = self.get('K');\n    var kp = K / (getEucliDis(e.source, e.target) * (divisions + 1));\n    var edgePointForces = [{\n      x: 0,\n      y: 0\n    }];\n    for (var i = 1; i < divisions; i++) {\n      var force = {\n        x: 0,\n        y: 0\n      };\n      var spring = self.getSpringForce({\n        pre: edgePoints[eidx][i - 1],\n        cur: edgePoints[eidx][i],\n        next: edgePoints[eidx][i + 1]\n      }, kp);\n      var electrostatic = self.getElectrostaticForce(i, eidx);\n      force.x = lambda * (spring.x + electrostatic.x);\n      force.y = lambda * (spring.y + electrostatic.y);\n      edgePointForces.push(force);\n    }\n    edgePointForces.push({\n      x: 0,\n      y: 0\n    });\n    return edgePointForces;\n  };\n  Bundling.prototype.getSpringForce = function (divisions, kp) {\n    var x = divisions.pre.x + divisions.next.x - 2 * divisions.cur.x;\n    var y = divisions.pre.y + divisions.next.y - 2 * divisions.cur.y;\n    x *= kp;\n    y *= kp;\n    return {\n      x: x,\n      y: y\n    };\n  };\n  Bundling.prototype.getElectrostaticForce = function (pidx, eidx) {\n    var self = this;\n    var eps = self.get('eps');\n    var edgeBundles = self.get('edgeBundles');\n    var edgePoints = self.get('edgePoints');\n    var edgeBundle = edgeBundles[eidx];\n    var resForce = {\n      x: 0,\n      y: 0\n    };\n    edgeBundle.forEach(function (eb) {\n      var force = {\n        x: edgePoints[eb][pidx].x - edgePoints[eidx][pidx].x,\n        y: edgePoints[eb][pidx].y - edgePoints[eidx][pidx].y\n      };\n      if (Math.abs(force.x) > eps || Math.abs(force.y) > eps) {\n        var length_1 = getEucliDis(edgePoints[eb][pidx], edgePoints[eidx][pidx]);\n        var diff = 1 / length_1;\n        resForce.x += force.x * diff;\n        resForce.y += force.y * diff;\n      }\n    });\n    return resForce;\n  };\n  Bundling.prototype.isTicking = function () {\n    return this.get('ticking');\n  };\n  Bundling.prototype.getSimulation = function () {\n    return this.get('forceSimulation');\n  };\n  Bundling.prototype.destroy = function () {\n    if (this.get('ticking')) {\n      this.getSimulation().stop();\n    }\n    _super.prototype.destroy.call(this);\n  };\n  return Bundling;\n}(Base);\nexport default Bundling;","map":{"version":3,"names":["__extends","_extendStatics","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","Base","getEucliDis","pointA","pointB","eps","vx","x","vy","y","Math","abs","sqrt","getDotProduct","ei","ej","projectPointToEdge","e","k","source","target","Bundling","_super","config","getDefaultCfgs","edgeBundles","edgePoints","K","lambda","divisions","divRate","cycles","iterations","iterRate","bundleThreshold","onLayoutEnd","onTick","init","graph","get","tick","refreshPositions","set","bundling","data","self","isTicking","edges","nodes","nodeIdMap","error","forEach","node","undefined","id","Error","divideEdges","getEdgeBundles","C","i","_loop_1","j","forces","getEdgeForces","type","controlPoints","slice","length","refresh","updateBundling","cfg","keys","key","graph_1","edge","_a","push","edgeLength","getEdgeLength","divisionLength_1","currentDivisonLength_1","newEdgePoints_1","ep","oriDivisionLength","ratio","edgePoint","points","iSource","iTarget","jSource","jTarget","score","getBundleScore","aScore","getAngleScore","sScore","getScaleScore","pScore","getPositionScore","vScore","getVisibilityScore","dotProduct","aLength","min","max","iMid","jMid","distance","vij","getEdgeVisibility","vji","ps","pt","pMid","eidx","kp","edgePointForces","force","spring","getSpringForce","pre","cur","next","electrostatic","getElectrostaticForce","pidx","edgeBundle","resForce","eb","length_1","diff","getSimulation","destroy","stop"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/g6-plugin/es/bundling/index.js"],"sourcesContent":["var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport Base from '../base';\nfunction getEucliDis(pointA, pointB, eps) {\n  var vx = pointA.x - pointB.x;\n  var vy = pointA.y - pointB.y;\n  if (!eps || Math.abs(vx) > eps || Math.abs(vy) > eps) {\n    return Math.sqrt(vx * vx + vy * vy);\n  }\n  return eps;\n}\nfunction getDotProduct(ei, ej) {\n  return ei.x * ej.x + ei.y * ej.y;\n}\nfunction projectPointToEdge(p, e) {\n  var k = (e.source.y - e.target.y) / (e.source.x - e.target.x);\n  var x = (k * k * e.source.x + k * (p.y - e.source.y) + p.x) / (k * k + 1);\n  var y = k * (x - e.source.x) + e.source.y;\n  return {\n    x: x,\n    y: y\n  };\n}\nvar Bundling = /** @class */function (_super) {\n  __extends(Bundling, _super);\n  function Bundling(config) {\n    return _super.call(this, config) || this;\n  }\n  Bundling.prototype.getDefaultCfgs = function () {\n    return {\n      edgeBundles: [],\n      edgePoints: [],\n      K: 0.1,\n      lambda: 0.1,\n      divisions: 1,\n      divRate: 2,\n      cycles: 6,\n      iterations: 90,\n      iterRate: 0.6666667,\n      bundleThreshold: 0.6,\n      eps: 1e-6,\n      onLayoutEnd: function onLayoutEnd() {},\n      onTick: function onTick() {}\n    };\n  };\n  Bundling.prototype.init = function () {\n    var graph = this.get('graph');\n    var onTick = this.get('onTick');\n    var tick = function tick() {\n      if (onTick) {\n        onTick();\n      }\n      graph.refreshPositions();\n    };\n    this.set('tick', tick);\n  };\n  Bundling.prototype.bundling = function (data) {\n    var self = this;\n    self.set('data', data);\n    // 如果正在布局，忽略布局请求\n    if (self.isTicking()) {\n      return;\n    }\n    var edges = data.edges || [];\n    var nodes = data.nodes || [];\n    var nodeIdMap = {};\n    var error = false;\n    nodes.forEach(function (node) {\n      if (node.x === null || !node.y === null || node.x === undefined || !node.y === undefined) {\n        error = true;\n      }\n      nodeIdMap[node.id] = node;\n    });\n    if (error) throw new Error('please layout the graph or assign x and y for nodes first');\n    self.set('nodeIdMap', nodeIdMap);\n    // subdivide each edges\n    var divisions = self.get('divisions');\n    var divRate = self.get('divRate');\n    var edgePoints = self.divideEdges(divisions);\n    self.set('edgePoints', edgePoints);\n    // compute the bundles\n    var edgeBundles = self.getEdgeBundles();\n    self.set('edgeBundles', edgeBundles);\n    // iterations\n    var C = self.get('cycles');\n    var iterations = self.get('iterations');\n    var iterRate = self.get('iterRate');\n    var lambda = self.get('lambda');\n    for (var i = 0; i < C; i++) {\n      var _loop_1 = function _loop_1(j) {\n        var forces = [];\n        edges.forEach(function (e, k) {\n          if (e.source === e.target) return;\n          var source = nodeIdMap[e.source];\n          var target = nodeIdMap[e.target];\n          forces[k] = self.getEdgeForces({\n            source: source,\n            target: target\n          }, k, divisions, lambda);\n          for (var p = 0; p < divisions + 1; p++) {\n            edgePoints[k][p].x += forces[k][p].x;\n            edgePoints[k][p].y += forces[k][p].y;\n          }\n        });\n      };\n      for (var j = 0; j < iterations; j++) {\n        _loop_1(j);\n      }\n      // parameters for nex cycle\n      lambda = lambda / 2;\n      divisions *= divRate;\n      iterations *= iterRate;\n      edgePoints = self.divideEdges(divisions);\n      self.set('edgePoints', edgePoints);\n    }\n    // change the edges according to edgePoints\n    edges.forEach(function (e, i) {\n      if (e.source === e.target) return;\n      e.type = 'polyline';\n      e.controlPoints = edgePoints[i].slice(1, edgePoints[i].length - 1);\n    });\n    var graph = self.get('graph');\n    graph.refresh();\n  };\n  Bundling.prototype.updateBundling = function (cfg) {\n    var self = this;\n    var data = cfg.data;\n    if (data) {\n      self.set('data', data);\n    }\n    if (self.get('ticking')) {\n      self.set('ticking', false);\n    }\n    Object.keys(cfg).forEach(function (key) {\n      self.set(key, cfg[key]);\n    });\n    if (cfg.onTick) {\n      var graph_1 = this.get('graph');\n      self.set('tick', function () {\n        cfg.onTick();\n        graph_1.refresh();\n      });\n    }\n    self.bundling(data);\n  };\n  Bundling.prototype.divideEdges = function (divisions) {\n    var self = this;\n    var edges = self.get('data').edges;\n    var nodeIdMap = self.get('nodeIdMap');\n    var edgePoints = self.get('edgePoints');\n    if (!edgePoints || edgePoints === undefined) edgePoints = [];\n    edges.forEach(function (edge, i) {\n      var _a;\n      if (!edgePoints[i] || edgePoints[i] === undefined) {\n        edgePoints[i] = [];\n      }\n      var source = nodeIdMap[edge.source];\n      var target = nodeIdMap[edge.target];\n      if (divisions === 1) {\n        edgePoints[i].push({\n          x: source.x,\n          y: source.y\n        }); // source\n        edgePoints[i].push({\n          x: 0.5 * (source.x + target.x),\n          y: 0.5 * (source.y + target.y)\n        }); // mid\n        edgePoints[i].push({\n          x: target.x,\n          y: target.y\n        }); // target\n      } else {\n        var edgeLength = 0;\n        if (!((_a = edgePoints[i]) === null || _a === void 0 ? void 0 : _a.length)) {\n          // it is a straight line\n          edgeLength = getEucliDis({\n            x: source.x,\n            y: source.y\n          }, {\n            x: target.x,\n            y: target.y\n          });\n        } else {\n          edgeLength = self.getEdgeLength(edgePoints[i]);\n        }\n        var divisionLength_1 = edgeLength / (divisions + 1);\n        var currentDivisonLength_1 = divisionLength_1;\n        var newEdgePoints_1 = [{\n          x: source.x,\n          y: source.y\n        }]; // source\n        edgePoints[i].forEach(function (ep, j) {\n          if (j === 0) return;\n          var oriDivisionLength = getEucliDis(ep, edgePoints[i][j - 1]);\n          while (oriDivisionLength > currentDivisonLength_1) {\n            var ratio = currentDivisonLength_1 / oriDivisionLength;\n            var edgePoint = {\n              x: edgePoints[i][j - 1].x,\n              y: edgePoints[i][j - 1].y\n            };\n            edgePoint.x += ratio * (ep.x - edgePoints[i][j - 1].x);\n            edgePoint.y += ratio * (ep.y - edgePoints[i][j - 1].y);\n            newEdgePoints_1.push(edgePoint);\n            oriDivisionLength -= currentDivisonLength_1;\n            currentDivisonLength_1 = divisionLength_1;\n          }\n          currentDivisonLength_1 -= oriDivisionLength;\n        });\n        newEdgePoints_1.push({\n          x: target.x,\n          y: target.y\n        }); // target\n        edgePoints[i] = newEdgePoints_1;\n      }\n    });\n    return edgePoints;\n  };\n  /**\n   * 计算边的长度\n   * @param points\n   */\n  Bundling.prototype.getEdgeLength = function (points) {\n    var length = 0;\n    points.forEach(function (p, i) {\n      if (i === 0) return;\n      length += getEucliDis(p, points[i - 1]);\n    });\n    return length;\n  };\n  Bundling.prototype.getEdgeBundles = function () {\n    var self = this;\n    var data = self.get('data');\n    var edges = data.edges || [];\n    var bundleThreshold = self.get('bundleThreshold');\n    var nodeIdMap = self.get('nodeIdMap');\n    var edgeBundles = self.get('edgeBundles');\n    if (!edgeBundles) edgeBundles = [];\n    edges.forEach(function (e, i) {\n      if (!edgeBundles[i] || edgeBundles[i] === undefined) {\n        edgeBundles[i] = [];\n      }\n    });\n    edges.forEach(function (ei, i) {\n      var iSource = nodeIdMap[ei.source];\n      var iTarget = nodeIdMap[ei.target];\n      edges.forEach(function (ej, j) {\n        if (j <= i) return;\n        var jSource = nodeIdMap[ej.source];\n        var jTarget = nodeIdMap[ej.target];\n        var score = self.getBundleScore({\n          source: iSource,\n          target: iTarget\n        }, {\n          source: jSource,\n          target: jTarget\n        });\n        if (score >= bundleThreshold) {\n          edgeBundles[i].push(j);\n          edgeBundles[j].push(i);\n        }\n      });\n    });\n    return edgeBundles;\n  };\n  Bundling.prototype.getBundleScore = function (ei, ej) {\n    var self = this;\n    ei.vx = ei.target.x - ei.source.x;\n    ei.vy = ei.target.y - ei.source.y;\n    ej.vx = ej.target.x - ej.source.x;\n    ej.vy = ej.target.y - ej.source.y;\n    ei.length = getEucliDis({\n      x: ei.source.x,\n      y: ei.source.y\n    }, {\n      x: ei.target.x,\n      y: ei.target.y\n    });\n    ej.length = getEucliDis({\n      x: ej.source.x,\n      y: ej.source.y\n    }, {\n      x: ej.target.x,\n      y: ej.target.y\n    });\n    // angle score\n    var aScore = self.getAngleScore(ei, ej);\n    // scale score\n    var sScore = self.getScaleScore(ei, ej);\n    // position score\n    var pScore = self.getPositionScore(ei, ej);\n    // visibility socre\n    var vScore = self.getVisibilityScore(ei, ej);\n    return aScore * sScore * pScore * vScore;\n  };\n  Bundling.prototype.getAngleScore = function (ei, ej) {\n    var dotProduct = getDotProduct({\n      x: ei.vx,\n      y: ei.vy\n    }, {\n      x: ej.vx,\n      y: ej.vy\n    });\n    return dotProduct / (ei.length * ej.length);\n  };\n  Bundling.prototype.getScaleScore = function (ei, ej) {\n    var aLength = (ei.length + ej.length) / 2;\n    var score = 2 / (aLength / Math.min(ei.length, ej.length) + Math.max(ei.length, ej.length) / aLength);\n    return score;\n  };\n  Bundling.prototype.getPositionScore = function (ei, ej) {\n    var aLength = (ei.length + ej.length) / 2;\n    var iMid = {\n      x: (ei.source.x + ei.target.x) / 2,\n      y: (ei.source.y + ei.target.y) / 2\n    };\n    var jMid = {\n      x: (ej.source.x + ej.target.x) / 2,\n      y: (ej.source.y + ej.target.y) / 2\n    };\n    var distance = getEucliDis(iMid, jMid);\n    return aLength / (aLength + distance);\n  };\n  Bundling.prototype.getVisibilityScore = function (ei, ej) {\n    var vij = this.getEdgeVisibility(ei, ej);\n    var vji = this.getEdgeVisibility(ej, ei);\n    return vij < vji ? vij : vji;\n  };\n  Bundling.prototype.getEdgeVisibility = function (ei, ej) {\n    var ps = projectPointToEdge(ej.source, ei);\n    var pt = projectPointToEdge(ej.target, ei);\n    var pMid = {\n      x: (ps.x + pt.x) / 2,\n      y: (ps.y + pt.y) / 2\n    };\n    var iMid = {\n      x: (ei.source.x + ei.target.x) / 2,\n      y: (ei.source.y + ei.target.y) / 2\n    };\n    return Math.max(0, 1 - 2 * getEucliDis(pMid, iMid) / getEucliDis(ps, pt));\n  };\n  Bundling.prototype.getEdgeForces = function (e, eidx, divisions, lambda) {\n    var self = this;\n    var edgePoints = self.get('edgePoints');\n    var K = self.get('K');\n    var kp = K / (getEucliDis(e.source, e.target) * (divisions + 1));\n    var edgePointForces = [{\n      x: 0,\n      y: 0\n    }];\n    for (var i = 1; i < divisions; i++) {\n      var force = {\n        x: 0,\n        y: 0\n      };\n      var spring = self.getSpringForce({\n        pre: edgePoints[eidx][i - 1],\n        cur: edgePoints[eidx][i],\n        next: edgePoints[eidx][i + 1]\n      }, kp);\n      var electrostatic = self.getElectrostaticForce(i, eidx);\n      force.x = lambda * (spring.x + electrostatic.x);\n      force.y = lambda * (spring.y + electrostatic.y);\n      edgePointForces.push(force);\n    }\n    edgePointForces.push({\n      x: 0,\n      y: 0\n    });\n    return edgePointForces;\n  };\n  Bundling.prototype.getSpringForce = function (divisions, kp) {\n    var x = divisions.pre.x + divisions.next.x - 2 * divisions.cur.x;\n    var y = divisions.pre.y + divisions.next.y - 2 * divisions.cur.y;\n    x *= kp;\n    y *= kp;\n    return {\n      x: x,\n      y: y\n    };\n  };\n  Bundling.prototype.getElectrostaticForce = function (pidx, eidx) {\n    var self = this;\n    var eps = self.get('eps');\n    var edgeBundles = self.get('edgeBundles');\n    var edgePoints = self.get('edgePoints');\n    var edgeBundle = edgeBundles[eidx];\n    var resForce = {\n      x: 0,\n      y: 0\n    };\n    edgeBundle.forEach(function (eb) {\n      var force = {\n        x: edgePoints[eb][pidx].x - edgePoints[eidx][pidx].x,\n        y: edgePoints[eb][pidx].y - edgePoints[eidx][pidx].y\n      };\n      if (Math.abs(force.x) > eps || Math.abs(force.y) > eps) {\n        var length_1 = getEucliDis(edgePoints[eb][pidx], edgePoints[eidx][pidx]);\n        var diff = 1 / length_1;\n        resForce.x += force.x * diff;\n        resForce.y += force.y * diff;\n      }\n    });\n    return resForce;\n  };\n  Bundling.prototype.isTicking = function () {\n    return this.get('ticking');\n  };\n  Bundling.prototype.getSimulation = function () {\n    return this.get('forceSimulation');\n  };\n  Bundling.prototype.destroy = function () {\n    if (this.get('ticking')) {\n      this.getSimulation().stop();\n    }\n    _super.prototype.destroy.call(this);\n  };\n  return Bundling;\n}(Base);\nexport default Bundling;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}