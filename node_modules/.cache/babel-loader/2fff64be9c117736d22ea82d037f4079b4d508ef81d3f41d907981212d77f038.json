{"ast":null,"code":"// 访问状态\nvar TILE_STATE_DEFAULT = 0;\n// 访问状态\nvar TILE_STATE_VISITED = 1;\n// 可见状态\nvar TILE_STATE_VISIBLE = 2;\n\n/*\n * 瓦片更新状态策略 - 实时更新策略\n * 当前视野 currentTile 请求到数据就立即显示\n * 请求中的数据不显示不填补，渲染留白\n */\nexport function updateTileStateRealtime(tiles) {\n  tiles.forEach(function (tile) {\n    if (tile.isCurrent) {\n      tile.isVisible = tile.isLoaded;\n    }\n  });\n}\n\n/*\n * 瓦片更新状态策略 - 渐近更新策略 有透明度情况会导致颜色叠加\n * 对于当前视野 currentTile 且数据请求中的瓦片\n * 用最近上级的瓦片作为占位符\n * 如果没有最近上级瓦片可用，用最近的子级瓦片作为占位符\n */\nexport function updateTileStateOverlap(tiles) {\n  tiles.forEach(function (tile) {\n    tile.properties.state = TILE_STATE_DEFAULT;\n  });\n  tiles.forEach(function (tile) {\n    if (tile.isCurrent && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  });\n  tiles.forEach(function (tile) {\n    tile.isVisible = Boolean(tile.properties.state & TILE_STATE_VISIBLE);\n  });\n}\n\n/*\n * 瓦片更新状态策略 - 全部替换策略\n * 对于当前视野的所有 currentTile 瓦片在加载完成之前，使用最近的上级瓦片作为占位符\n */\nexport function updateTileStateReplace(tiles) {\n  tiles.forEach(function (tile) {\n    tile.properties.state = TILE_STATE_DEFAULT;\n  });\n  // 更新当前视野瓦片的上级瓦片可见状态\n  tiles.forEach(function (tile) {\n    if (tile.isCurrent) {\n      getPlaceholderInAncestors(tile);\n    }\n  });\n\n  // 通过 zoom 层级排序，最小的层级在上面\n  var sortedTiles = tiles.slice().sort(function (t1, t2) {\n    return t1.z - t2.z;\n  });\n  sortedTiles.forEach(function (tile) {\n    tile.isVisible = Boolean(tile.properties.state & TILE_STATE_VISIBLE);\n    if (tile.children.length && (tile.isVisible || tile.properties.state & TILE_STATE_VISITED)) {\n      // 如果瓦片可见，隐藏所有的子级瓦片\n      tile.children.forEach(function (child) {\n        child.properties.state = TILE_STATE_VISITED;\n      });\n    } else if (tile.isCurrent) {\n      getPlaceholderInChildren(tile);\n    }\n  });\n}\n\n/*\n * 查找上级已加载的瓦片作为占位符\n * 如果找到返回 true\n */\nfunction getPlaceholderInAncestors(tile) {\n  while (tile) {\n    if (tile.isLoaded) {\n      // tile.properties.state = tile.properties.state | TILE_STATE_VISIBLE\n      tile.properties.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n    tile = tile.parent;\n  }\n  return false;\n}\n\n/*\n * 递归查找将子级已加载瓦片作为占位符\n */\nfunction getPlaceholderInChildren(tile) {\n  tile.children.forEach(function (child) {\n    if (child.isLoaded) {\n      child.properties.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  });\n}","map":{"version":3,"names":["TILE_STATE_DEFAULT","TILE_STATE_VISITED","TILE_STATE_VISIBLE","updateTileStateRealtime","tiles","forEach","tile","isCurrent","isVisible","isLoaded","updateTileStateOverlap","properties","state","getPlaceholderInAncestors","getPlaceholderInChildren","Boolean","updateTileStateReplace","sortedTiles","slice","sort","t1","t2","z","children","length","child","parent"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-utils/es/tileset-manager/utils/strategies.js"],"sourcesContent":["// 访问状态\nvar TILE_STATE_DEFAULT = 0;\n// 访问状态\nvar TILE_STATE_VISITED = 1;\n// 可见状态\nvar TILE_STATE_VISIBLE = 2;\n\n/*\n * 瓦片更新状态策略 - 实时更新策略\n * 当前视野 currentTile 请求到数据就立即显示\n * 请求中的数据不显示不填补，渲染留白\n */\nexport function updateTileStateRealtime(tiles) {\n  tiles.forEach(function (tile) {\n    if (tile.isCurrent) {\n      tile.isVisible = tile.isLoaded;\n    }\n  });\n}\n\n/*\n * 瓦片更新状态策略 - 渐近更新策略 有透明度情况会导致颜色叠加\n * 对于当前视野 currentTile 且数据请求中的瓦片\n * 用最近上级的瓦片作为占位符\n * 如果没有最近上级瓦片可用，用最近的子级瓦片作为占位符\n */\nexport function updateTileStateOverlap(tiles) {\n  tiles.forEach(function (tile) {\n    tile.properties.state = TILE_STATE_DEFAULT;\n  });\n  tiles.forEach(function (tile) {\n    if (tile.isCurrent && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  });\n  tiles.forEach(function (tile) {\n    tile.isVisible = Boolean(tile.properties.state & TILE_STATE_VISIBLE);\n  });\n}\n\n/*\n * 瓦片更新状态策略 - 全部替换策略\n * 对于当前视野的所有 currentTile 瓦片在加载完成之前，使用最近的上级瓦片作为占位符\n */\nexport function updateTileStateReplace(tiles) {\n  tiles.forEach(function (tile) {\n    tile.properties.state = TILE_STATE_DEFAULT;\n  });\n  // 更新当前视野瓦片的上级瓦片可见状态\n  tiles.forEach(function (tile) {\n    if (tile.isCurrent) {\n      getPlaceholderInAncestors(tile);\n    }\n  });\n\n  // 通过 zoom 层级排序，最小的层级在上面\n  var sortedTiles = tiles.slice().sort(function (t1, t2) {\n    return t1.z - t2.z;\n  });\n  sortedTiles.forEach(function (tile) {\n    tile.isVisible = Boolean(tile.properties.state & TILE_STATE_VISIBLE);\n    if (tile.children.length && (tile.isVisible || tile.properties.state & TILE_STATE_VISITED)) {\n      // 如果瓦片可见，隐藏所有的子级瓦片\n      tile.children.forEach(function (child) {\n        child.properties.state = TILE_STATE_VISITED;\n      });\n    } else if (tile.isCurrent) {\n      getPlaceholderInChildren(tile);\n    }\n  });\n}\n\n/*\n * 查找上级已加载的瓦片作为占位符\n * 如果找到返回 true\n */\nfunction getPlaceholderInAncestors(tile) {\n  while (tile) {\n    if (tile.isLoaded) {\n      // tile.properties.state = tile.properties.state | TILE_STATE_VISIBLE\n      tile.properties.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n    tile = tile.parent;\n  }\n  return false;\n}\n\n/*\n * 递归查找将子级已加载瓦片作为占位符\n */\nfunction getPlaceholderInChildren(tile) {\n  tile.children.forEach(function (child) {\n    if (child.isLoaded) {\n      child.properties.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}