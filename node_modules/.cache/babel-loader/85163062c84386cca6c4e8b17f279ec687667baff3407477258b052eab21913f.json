{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { aProjectFlat } from '@antv/l7-utils';\nimport { vec2 } from 'gl-matrix';\nvar tmp = vec2.create();\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nvar capEnd = vec2.create();\nvar lineA = vec2.create();\nvar lineB = vec2.create();\nvar tangent = vec2.create();\nexport function computeMiter(lineTangent, miter, start, end, halfThick) {\n  vec2.add(lineTangent, start, end);\n  vec2.normalize(lineTangent, lineTangent);\n  miter = vec2.fromValues(-lineTangent[1], lineTangent[0]);\n  var tmpvec = vec2.fromValues(-start[1], start[0]);\n  return [halfThick / vec2.dot(miter, tmpvec), miter];\n}\nexport function computeNormal(out, dir) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\nexport function direction(out, a, b) {\n  vec2.sub(out, a, b);\n  vec2.normalize(out, out);\n  return out;\n}\nfunction isPointEqual(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\nexport function getArrayUnique(matrix) {\n  var map = new Map();\n  for (var i = 0; i < matrix.length; i++) {\n    var key = matrix[0].toString() + '-' + matrix[1].toString();\n    if (map.get(key)) {\n      matrix.splice(i, 1);\n      i++;\n    } else {\n      map.set(key, key);\n    }\n  }\n  return matrix;\n}\nvar ExtrudePolyline = /*#__PURE__*/function () {\n  function ExtrudePolyline() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ExtrudePolyline);\n    _defineProperty(this, \"lastFlip\", -1);\n    _defineProperty(this, \"miter\", vec2.fromValues(0, 0));\n    _defineProperty(this, \"started\", false);\n    _defineProperty(this, \"dash\", false);\n    _defineProperty(this, \"totalDistance\", 0);\n    _defineProperty(this, \"currentIndex\", 0);\n    this.join = opts.join || 'miter';\n    this.cap = opts.cap || 'butt';\n    this.miterLimit = opts.miterLimit || 10;\n    this.thickness = opts.thickness || 1;\n    this.dash = opts.dash || false;\n    this.complex = {\n      positions: [],\n      indices: [],\n      normals: [],\n      startIndex: 0,\n      indexes: []\n    };\n  }\n  _createClass(ExtrudePolyline, [{\n    key: \"simpleExtrude\",\n    value: function simpleExtrude(points) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var cur = points[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var amt = this.simpleSegment(complex, count, last, cur, next);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i = 0; _i < complex.positions.length / 6; _i++) {\n          complex.positions[_i * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"simpleExtrude_gaode2\",\n    value: function simpleExtrude_gaode2(points, originPoints) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var _originPoints$, _originPoints$i$, _originPoints$2;\n        var last = points[i - 1];\n        last.push((_originPoints$ = originPoints[i - 1][2]) !== null && _originPoints$ !== void 0 ? _originPoints$ : 0);\n        // @ts-ignore\n        var originLast = originPoints[i - 1];\n        var cur = points[i];\n        cur.push((_originPoints$i$ = originPoints[i][2]) !== null && _originPoints$i$ !== void 0 ? _originPoints$i$ : 0);\n        // @ts-ignore\n        var originCur = originPoints[i];\n        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$2 = originPoints[i + 1][2]) !== null && _originPoints$2 !== void 0 ? _originPoints$2 : 0]) : null;\n        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;\n        var amt = this.simpleSegment(complex, count,\n        // @ts-ignore\n        last,\n        // @ts-ignore\n        cur,\n        // @ts-ignore\n        next,\n        // @ts-ignore\n        originLast, originCur,\n        // @ts-ignore\n        originNext);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i2 = 0; _i2 < complex.positions.length / 6; _i2++) {\n          complex.positions[_i2 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"extrude_gaode2\",\n    value: function extrude_gaode2(points, originPoints) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var _originPoints$3, _originPoints$i$2, _originPoints$4;\n        var last = points[i - 1];\n        last.push((_originPoints$3 = originPoints[i - 1][2]) !== null && _originPoints$3 !== void 0 ? _originPoints$3 : 0);\n        // @ts-ignore\n        var originLast = originPoints[i - 1];\n        var cur = points[i];\n        cur.push((_originPoints$i$2 = originPoints[i][2]) !== null && _originPoints$i$2 !== void 0 ? _originPoints$i$2 : 0);\n        // @ts-ignore\n        var originCur = originPoints[i];\n        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$4 = originPoints[i + 1][2]) !== null && _originPoints$4 !== void 0 ? _originPoints$4 : 0]) : null;\n        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;\n        var amt = this.segment_gaode2(complex, count,\n        // @ts-ignore\n        last,\n        // @ts-ignore\n        cur,\n        // @ts-ignore\n        next,\n        // @ts-ignore\n        originLast, originCur,\n        // @ts-ignore\n        originNext);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i3 = 0; _i3 < complex.positions.length / 6; _i3++) {\n          complex.positions[_i3 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"extrude\",\n    value: function extrude(points) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var cur = points[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var amt = this.segment(complex, count, last, cur, next);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i4 = 0; _i4 < complex.positions.length / 6; _i4++) {\n          complex.positions[_i4 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"simpleSegment\",\n    value: function simpleSegment(complex, index, last, cur, next) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var flatCur = aProjectFlat([cur[0], cur[1]]);\n      var flatLast = aProjectFlat([last[0], last[1]]);\n      // @ts-ignore\n      direction(lineA, flatCur, flatLast);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n        this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        var flatNext = aProjectFlat([next[0], next[1]]);\n        if (isPointEqual(flatCur, flatNext)) {\n          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n        }\n        direction(lineB, flatNext, flatCur);\n\n        // stores tangent & miter\n\n        var _computeMiter = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter2 = _slicedToArray(_computeMiter, 2),\n          miterLen = _computeMiter2[0],\n          miter = _computeMiter2[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        flip = -1;\n\n        // the miter is now the normal for our next join\n        vec2.copy(this.normal, miter);\n        count += 2;\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"segment_gaode2\",\n    value: function segment_gaode2(complex, index, last, cur, next, originLast, originCur,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    originNext) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([originCur[0], originCur[1]]);\n      var flatLast = aProjectFlat([originLast[0], originLast[1]]);\n      // @ts-ignore\n      direction(lineA, cur, last);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n\n        // if the end cap is type square, we can just push the verts out a bit\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        if (capSquare) {\n          var _out = vec2.create();\n          var _out2 = vec2.create();\n          vec2.sub(_out2, lineA, this.normal);\n          vec2.add(_out, lineA, this.normal);\n          normals.push(_out2[0], _out2[1], 0);\n          normals.push(_out[0], _out[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        // @ts-ignore\n        if (isPointEqual(cur, next)) {\n          vec2.add(\n          // @ts-ignore\n          next,\n          // @ts-ignore\n          cur, vec2.normalize(\n          // @ts-ignore\n          next,\n          // @ts-ignore\n          vec2.subtract(next, cur, last)));\n        }\n        // @ts-ignore\n        direction(lineB, next, cur);\n        // stores tangent & miter\n\n        var _computeMiter3 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter4 = _slicedToArray(_computeMiter3, 2),\n          miterLen = _computeMiter4[0],\n          miter = _computeMiter4[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n\n          // now add the bevel triangle\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp); // store normal for next round\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n\n          // the miter is now the normal for our next join\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"segment\",\n    value: function segment(complex, index, last, cur, next) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([cur[0], cur[1]]);\n      var flatLast = aProjectFlat([last[0], last[1]]);\n      // @ts-ignore\n      direction(lineA, flatCur, flatLast);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n\n        // if the end cap is type square, we can just push the verts out a bit\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          // this.extrusions(positions, normals, last, out, this.thickness);\n          // last = capEnd;\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, cur, lineA, this.thickness);\n          // cur = capEnd;\n          var _out3 = vec2.create();\n          var _out4 = vec2.create();\n          vec2.sub(_out4, lineA, this.normal);\n          vec2.add(_out3, lineA, this.normal);\n          // this.extrusions(positions, normals, cur, out, this.thickness);\n          normals.push(_out4[0], _out4[1], 0);\n          normals.push(_out3[0], _out3[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n\n        // this.extrusions(positions, normals, cur, this.normal, this.thickness);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        var flatNext = aProjectFlat([next[0], next[1]]);\n        if (isPointEqual(flatCur, flatNext)) {\n          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n        }\n        direction(lineB, flatNext, flatCur);\n\n        // stores tangent & miter\n\n        var _computeMiter5 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter6 = _slicedToArray(_computeMiter5, 2),\n          miterLen = _computeMiter6[0],\n          miter = _computeMiter6[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n\n          // now add the bevel triangle\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp); // store normal for next round\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n\n          // the miter is now the normal for our next join\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"extrusions\",\n    value: function extrusions(positions, normals, point,\n    // 顶点\n    normal,\n    // 法向量\n    thickness,\n    // 高度\n    distanceRadio) {\n      normals.push(normal[0], normal[1], 0);\n      normals.push(normal[0], normal[1], 0);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, -thickness, point[2] | 0);\n      this.complex.indexes.push(this.currentIndex);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, thickness, point[2] | 0);\n      this.complex.indexes.push(this.currentIndex);\n      this.currentIndex++;\n    }\n  }, {\n    key: \"lineSegmentDistance\",\n    value: function lineSegmentDistance(b1, a1) {\n      var dx = a1[0] - b1[0];\n      var dy = a1[1] - b1[1];\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  }]);\n  return ExtrudePolyline;\n}();\nexport { ExtrudePolyline as default };","map":{"version":3,"names":["_slicedToArray","_toConsumableArray","_classCallCheck","_createClass","_defineProperty","aProjectFlat","vec2","tmp","create","capEnd","lineA","lineB","tangent","computeMiter","lineTangent","miter","start","end","halfThick","add","normalize","fromValues","tmpvec","dot","computeNormal","out","dir","set","direction","a","b","sub","isPointEqual","getArrayUnique","matrix","map","Map","i","length","key","toString","get","splice","ExtrudePolyline","opts","arguments","undefined","join","cap","miterLimit","thickness","dash","complex","positions","indices","normals","startIndex","indexes","value","simpleExtrude","points","lastFlip","started","normal","totalDistance","total","count","last","cur","next","amt","simpleSegment","_i","simpleExtrude_gaode2","originPoints","_originPoints$","_originPoints$i$","_originPoints$2","push","originLast","originCur","concat","originNext","_i2","extrude_gaode2","_originPoints$3","_originPoints$i$2","_originPoints$4","segment_gaode2","_i3","extrude","segment","_i4","index","flatCur","flatLast","segmentDistance","lineSegmentDistance","extrusions","apply","flatNext","subtract","_computeMiter","_computeMiter2","miterLen","flip","copy","capSquare","joinBevel","out1","out2","currentIndex","_out","_out2","_computeMiter3","_computeMiter4","bevel","limit","_out3","_out4","_computeMiter5","_computeMiter6","point","distanceRadio","b1","a1","dx","dy","Math","sqrt","default"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-layers/es/utils/extrude_polyline.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { aProjectFlat } from '@antv/l7-utils';\nimport { vec2 } from 'gl-matrix';\nvar tmp = vec2.create();\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nvar capEnd = vec2.create();\nvar lineA = vec2.create();\nvar lineB = vec2.create();\nvar tangent = vec2.create();\nexport function computeMiter(lineTangent, miter, start, end, halfThick) {\n  vec2.add(lineTangent, start, end);\n  vec2.normalize(lineTangent, lineTangent);\n  miter = vec2.fromValues(-lineTangent[1], lineTangent[0]);\n  var tmpvec = vec2.fromValues(-start[1], start[0]);\n  return [halfThick / vec2.dot(miter, tmpvec), miter];\n}\nexport function computeNormal(out, dir) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\nexport function direction(out, a, b) {\n  vec2.sub(out, a, b);\n  vec2.normalize(out, out);\n  return out;\n}\nfunction isPointEqual(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\nexport function getArrayUnique(matrix) {\n  var map = new Map();\n  for (var i = 0; i < matrix.length; i++) {\n    var key = matrix[0].toString() + '-' + matrix[1].toString();\n    if (map.get(key)) {\n      matrix.splice(i, 1);\n      i++;\n    } else {\n      map.set(key, key);\n    }\n  }\n  return matrix;\n}\nvar ExtrudePolyline = /*#__PURE__*/function () {\n  function ExtrudePolyline() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ExtrudePolyline);\n    _defineProperty(this, \"lastFlip\", -1);\n    _defineProperty(this, \"miter\", vec2.fromValues(0, 0));\n    _defineProperty(this, \"started\", false);\n    _defineProperty(this, \"dash\", false);\n    _defineProperty(this, \"totalDistance\", 0);\n    _defineProperty(this, \"currentIndex\", 0);\n    this.join = opts.join || 'miter';\n    this.cap = opts.cap || 'butt';\n    this.miterLimit = opts.miterLimit || 10;\n    this.thickness = opts.thickness || 1;\n    this.dash = opts.dash || false;\n    this.complex = {\n      positions: [],\n      indices: [],\n      normals: [],\n      startIndex: 0,\n      indexes: []\n    };\n  }\n  _createClass(ExtrudePolyline, [{\n    key: \"simpleExtrude\",\n    value: function simpleExtrude(points) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var cur = points[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var amt = this.simpleSegment(complex, count, last, cur, next);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i = 0; _i < complex.positions.length / 6; _i++) {\n          complex.positions[_i * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"simpleExtrude_gaode2\",\n    value: function simpleExtrude_gaode2(points, originPoints) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var _originPoints$, _originPoints$i$, _originPoints$2;\n        var last = points[i - 1];\n        last.push((_originPoints$ = originPoints[i - 1][2]) !== null && _originPoints$ !== void 0 ? _originPoints$ : 0);\n        // @ts-ignore\n        var originLast = originPoints[i - 1];\n        var cur = points[i];\n        cur.push((_originPoints$i$ = originPoints[i][2]) !== null && _originPoints$i$ !== void 0 ? _originPoints$i$ : 0);\n        // @ts-ignore\n        var originCur = originPoints[i];\n        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$2 = originPoints[i + 1][2]) !== null && _originPoints$2 !== void 0 ? _originPoints$2 : 0]) : null;\n        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;\n        var amt = this.simpleSegment(complex, count,\n        // @ts-ignore\n        last,\n        // @ts-ignore\n        cur,\n        // @ts-ignore\n        next,\n        // @ts-ignore\n        originLast, originCur,\n        // @ts-ignore\n        originNext);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i2 = 0; _i2 < complex.positions.length / 6; _i2++) {\n          complex.positions[_i2 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"extrude_gaode2\",\n    value: function extrude_gaode2(points, originPoints) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var _originPoints$3, _originPoints$i$2, _originPoints$4;\n        var last = points[i - 1];\n        last.push((_originPoints$3 = originPoints[i - 1][2]) !== null && _originPoints$3 !== void 0 ? _originPoints$3 : 0);\n        // @ts-ignore\n        var originLast = originPoints[i - 1];\n        var cur = points[i];\n        cur.push((_originPoints$i$2 = originPoints[i][2]) !== null && _originPoints$i$2 !== void 0 ? _originPoints$i$2 : 0);\n        // @ts-ignore\n        var originCur = originPoints[i];\n        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$4 = originPoints[i + 1][2]) !== null && _originPoints$4 !== void 0 ? _originPoints$4 : 0]) : null;\n        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;\n        var amt = this.segment_gaode2(complex, count,\n        // @ts-ignore\n        last,\n        // @ts-ignore\n        cur,\n        // @ts-ignore\n        next,\n        // @ts-ignore\n        originLast, originCur,\n        // @ts-ignore\n        originNext);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i3 = 0; _i3 < complex.positions.length / 6; _i3++) {\n          complex.positions[_i3 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"extrude\",\n    value: function extrude(points) {\n      var complex = this.complex;\n      if (points.length <= 1) {\n        return complex;\n      }\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      // 去除数组里重复的点\n      // points = getArrayUnique(points);\n      var total = points.length;\n      var count = complex.startIndex;\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var cur = points[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var amt = this.segment(complex, count, last, cur, next);\n        count += amt;\n      }\n      if (this.dash) {\n        for (var _i4 = 0; _i4 < complex.positions.length / 6; _i4++) {\n          complex.positions[_i4 * 6 + 5] = this.totalDistance;\n        }\n      }\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"simpleSegment\",\n    value: function simpleSegment(complex, index, last, cur, next) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var flatCur = aProjectFlat([cur[0], cur[1]]);\n      var flatLast = aProjectFlat([last[0], last[1]]);\n      // @ts-ignore\n      direction(lineA, flatCur, flatLast);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n        this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        var flatNext = aProjectFlat([next[0], next[1]]);\n        if (isPointEqual(flatCur, flatNext)) {\n          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n        }\n        direction(lineB, flatNext, flatCur);\n\n        // stores tangent & miter\n\n        var _computeMiter = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter2 = _slicedToArray(_computeMiter, 2),\n          miterLen = _computeMiter2[0],\n          miter = _computeMiter2[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        flip = -1;\n\n        // the miter is now the normal for our next join\n        vec2.copy(this.normal, miter);\n        count += 2;\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"segment_gaode2\",\n    value: function segment_gaode2(complex, index, last, cur, next, originLast, originCur,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    originNext) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([originCur[0], originCur[1]]);\n      var flatLast = aProjectFlat([originLast[0], originLast[1]]);\n      // @ts-ignore\n      direction(lineA, cur, last);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n\n        // if the end cap is type square, we can just push the verts out a bit\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        if (capSquare) {\n          var _out = vec2.create();\n          var _out2 = vec2.create();\n          vec2.sub(_out2, lineA, this.normal);\n          vec2.add(_out, lineA, this.normal);\n          normals.push(_out2[0], _out2[1], 0);\n          normals.push(_out[0], _out[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        // @ts-ignore\n        if (isPointEqual(cur, next)) {\n          vec2.add(\n          // @ts-ignore\n          next,\n          // @ts-ignore\n          cur, vec2.normalize(\n          // @ts-ignore\n          next,\n          // @ts-ignore\n          vec2.subtract(next, cur, last)));\n        }\n        // @ts-ignore\n        direction(lineB, next, cur);\n        // stores tangent & miter\n\n        var _computeMiter3 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter4 = _slicedToArray(_computeMiter3, 2),\n          miterLen = _computeMiter4[0],\n          miter = _computeMiter4[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n\n          // now add the bevel triangle\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp); // store normal for next round\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n\n          // the miter is now the normal for our next join\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"segment\",\n    value: function segment(complex, index, last, cur, next) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([cur[0], cur[1]]);\n      var flatLast = aProjectFlat([last[0], last[1]]);\n      // @ts-ignore\n      direction(lineA, flatCur, flatLast);\n      var segmentDistance = 0;\n      if (this.dash) {\n        // @ts-ignore\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n      if (!this.started) {\n        this.started = true;\n\n        // if the end cap is type square, we can just push the verts out a bit\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          // this.extrusions(positions, normals, last, out, this.thickness);\n          // last = capEnd;\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n      indices.push(index + 0, index + 1, index + 2);\n      if (!next) {\n        computeNormal(this.normal, lineA);\n        if (capSquare) {\n          // vec2.scaleAndAdd(capEnd, cur, lineA, this.thickness);\n          // cur = capEnd;\n          var _out3 = vec2.create();\n          var _out4 = vec2.create();\n          vec2.sub(_out4, lineA, this.normal);\n          vec2.add(_out3, lineA, this.normal);\n          // this.extrusions(positions, normals, cur, out, this.thickness);\n          normals.push(_out4[0], _out4[1], 0);\n          normals.push(_out3[0], _out3[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n\n        // this.extrusions(positions, normals, cur, this.normal, this.thickness);\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        var flatNext = aProjectFlat([next[0], next[1]]);\n        if (isPointEqual(flatCur, flatNext)) {\n          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n        }\n        direction(lineB, flatNext, flatCur);\n\n        // stores tangent & miter\n\n        var _computeMiter5 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n          _computeMiter6 = _slicedToArray(_computeMiter5, 2),\n          miterLen = _computeMiter6[0],\n          miter = _computeMiter6[1];\n        // normal(tmp, lineA)\n\n        // get orientation\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n\n          // now add the bevel triangle\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp); // store normal for next round\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          this.complex.indexes.push(this.currentIndex);\n          this.currentIndex++;\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n\n          // the miter is now the normal for our next join\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n        this.lastFlip = flip;\n      }\n      return count;\n    }\n  }, {\n    key: \"extrusions\",\n    value: function extrusions(positions, normals, point,\n    // 顶点\n    normal,\n    // 法向量\n    thickness,\n    // 高度\n    distanceRadio) {\n      normals.push(normal[0], normal[1], 0);\n      normals.push(normal[0], normal[1], 0);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, -thickness, point[2] | 0);\n      this.complex.indexes.push(this.currentIndex);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, thickness, point[2] | 0);\n      this.complex.indexes.push(this.currentIndex);\n      this.currentIndex++;\n    }\n  }, {\n    key: \"lineSegmentDistance\",\n    value: function lineSegmentDistance(b1, a1) {\n      var dx = a1[0] - b1[0];\n      var dy = a1[1] - b1[1];\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  }]);\n  return ExtrudePolyline;\n}();\nexport { ExtrudePolyline as default };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}