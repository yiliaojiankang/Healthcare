{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __values } from \"tslib\";\nimport { isArray, isString } from '@antv/util';\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\nexport function isBetween(value, start, end) {\n  var min = Math.min(start, end);\n  var max = Math.max(start, end);\n  return value >= min && value <= max;\n}\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\nexport function padEnd(source, targetLength, padValue) {\n  if (isString(source)) {\n    return source.padEnd(targetLength, padValue);\n  } else if (isArray(source)) {\n    var sourceLength = source.length;\n    if (sourceLength < targetLength) {\n      var diff = targetLength - sourceLength;\n      for (var i = 0; i < diff; i++) {\n        source.push(padValue);\n      }\n    }\n  }\n  return source;\n}\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\nexport function omit(obj, keys) {\n  if (typeof obj === 'object') {\n    keys.forEach(function (key) {\n      delete obj[key];\n    });\n  }\n  return obj;\n}\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\nexport function uniq(sourceArray, targetArray, map) {\n  var e_1, _a;\n  if (targetArray === void 0) {\n    targetArray = [];\n  }\n  if (map === void 0) {\n    map = new Map();\n  }\n  try {\n    for (var sourceArray_1 = __values(sourceArray), sourceArray_1_1 = sourceArray_1.next(); !sourceArray_1_1.done; sourceArray_1_1 = sourceArray_1.next()) {\n      var source = sourceArray_1_1.value;\n      if (!map.has(source)) {\n        targetArray.push(source);\n        map.set(source, true);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (sourceArray_1_1 && !sourceArray_1_1.done && (_a = sourceArray_1.return)) _a.call(sourceArray_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return targetArray;\n}","map":{"version":3,"names":["isArray","isString","isBetween","value","start","end","min","Math","max","padEnd","source","targetLength","padValue","sourceLength","length","diff","i","push","omit","obj","keys","forEach","key","uniq","sourceArray","targetArray","map","Map","sourceArray_1","__values","sourceArray_1_1","next","done","has","set"],"sources":["../../src/util/helper.ts"],"sourcesContent":["import { isArray, isString } from '@antv/util';\n\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\nexport function isBetween(value: number, start: number, end: number): boolean {\n  const min = Math.min(start, end);\n  const max = Math.max(start, end);\n\n  return value >= min && value <= max;\n}\n\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\nexport function padEnd(source: string | any[], targetLength: number, padValue: any) {\n  if (isString(source)) {\n    return source.padEnd(targetLength, padValue);\n  } else if (isArray(source)) {\n    const sourceLength = source.length;\n    if (sourceLength < targetLength) {\n      const diff = targetLength - sourceLength;\n      for (let i = 0; i < diff; i++) {\n        source.push(padValue);\n      }\n    }\n  }\n\n  return source;\n}\n\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\nexport function omit<T = any>(obj: T, keys: string[]): T {\n  if (typeof obj === 'object') {\n    keys.forEach((key: string) => {\n      delete obj[key];\n    });\n  }\n\n  return obj;\n}\n\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\nexport function uniq(sourceArray: any[], targetArray: any[] = [], map: Map<any, boolean> = new Map()) {\n  for (const source of sourceArray) {\n    if (!map.has(source)) {\n      targetArray.push(source);\n      map.set(source, true);\n    }\n  }\n  return targetArray;\n}\n"],"mappings":";;AAAA,SAASA,OAAO,EAAEC,QAAQ,QAAQ,YAAY;AAE9C;;;;;;;;AAQA,OAAM,SAAUC,SAASA,CAACC,KAAa,EAAEC,KAAa,EAAEC,GAAW;EACjE,IAAMC,GAAG,GAAGC,IAAI,CAACD,GAAG,CAACF,KAAK,EAAEC,GAAG,CAAC;EAChC,IAAMG,GAAG,GAAGD,IAAI,CAACC,GAAG,CAACJ,KAAK,EAAEC,GAAG,CAAC;EAEhC,OAAOF,KAAK,IAAIG,GAAG,IAAIH,KAAK,IAAIK,GAAG;AACrC;AAEA;;;;;;;;;;AAUA,OAAM,SAAUC,MAAMA,CAACC,MAAsB,EAAEC,YAAoB,EAAEC,QAAa;EAChF,IAAIX,QAAQ,CAACS,MAAM,CAAC,EAAE;IACpB,OAAOA,MAAM,CAACD,MAAM,CAACE,YAAY,EAAEC,QAAQ,CAAC;GAC7C,MAAM,IAAIZ,OAAO,CAACU,MAAM,CAAC,EAAE;IAC1B,IAAMG,YAAY,GAAGH,MAAM,CAACI,MAAM;IAClC,IAAID,YAAY,GAAGF,YAAY,EAAE;MAC/B,IAAMI,IAAI,GAAGJ,YAAY,GAAGE,YAAY;MACxC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,EAAEC,CAAC,EAAE,EAAE;QAC7BN,MAAM,CAACO,IAAI,CAACL,QAAQ,CAAC;;;;EAK3B,OAAOF,MAAM;AACf;AAEA;;;;;;AAMA,OAAM,SAAUQ,IAAIA,CAAUC,GAAM,EAAEC,IAAc;EAClD,IAAI,OAAOD,GAAG,KAAK,QAAQ,EAAE;IAC3BC,IAAI,CAACC,OAAO,CAAC,UAACC,GAAW;MACvB,OAAOH,GAAG,CAACG,GAAG,CAAC;IACjB,CAAC,CAAC;;EAGJ,OAAOH,GAAG;AACZ;AAEA;;;;;;AAMA,OAAM,SAAUI,IAAIA,CAACC,WAAkB,EAAEC,WAAuB,EAAEC,GAAkC;;EAA3D,IAAAD,WAAA;IAAAA,WAAA,KAAuB;EAAA;EAAE,IAAAC,GAAA;IAAAA,GAAA,OAA6BC,GAAG,EAAE;EAAA;;IAClG,KAAqB,IAAAC,aAAA,GAAAC,QAAA,CAAAL,WAAW,GAAAM,eAAA,GAAAF,aAAA,CAAAG,IAAA,KAAAD,eAAA,CAAAE,IAAA,EAAAF,eAAA,GAAAF,aAAA,CAAAG,IAAA,IAAE;MAA7B,IAAMrB,MAAM,GAAAoB,eAAA,CAAA3B,KAAA;MACf,IAAI,CAACuB,GAAG,CAACO,GAAG,CAACvB,MAAM,CAAC,EAAE;QACpBe,WAAW,CAACR,IAAI,CAACP,MAAM,CAAC;QACxBgB,GAAG,CAACQ,GAAG,CAACxB,MAAM,EAAE,IAAI,CAAC;;;;;;;;;;;;;;EAGzB,OAAOe,WAAW;AACpB"},"metadata":{},"sourceType":"module","externalDependencies":[]}