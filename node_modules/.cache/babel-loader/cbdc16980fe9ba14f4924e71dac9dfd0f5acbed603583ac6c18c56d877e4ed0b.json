{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport LngLat, { earthRadius } from \"../geo/lng_lat\";\n\n/*\n * The average circumference of the world in meters.\n */\nvar earthCircumfrence = 2 * Math.PI * earthRadius; // meters\n\n/*\n * The circumference at a line of latitude in meters.\n */\nfunction circumferenceAtLatitude(latitude) {\n  return earthCircumfrence * Math.cos(latitude * Math.PI / 180);\n}\nexport function mercatorXfromLng(lng) {\n  return (180 + lng) / 360;\n}\nexport function mercatorYfromLat(lat) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;\n}\nexport function mercatorZfromAltitude(altitude, lat) {\n  return altitude / circumferenceAtLatitude(lat);\n}\nexport function lngFromMercatorX(x) {\n  return x * 360 - 180;\n}\nexport function latFromMercatorY(y) {\n  var y2 = 180 - y * 360;\n  return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n}\nexport function altitudeFromMercatorZ(z, y) {\n  return z * circumferenceAtLatitude(latFromMercatorY(y));\n}\n\n/**\n * Determine the Mercator scale factor for a given latitude, see\n * https://en.wikipedia.org/wiki/Mercator_projection#Scale_factor\n *\n * At the equator the scale factor will be 1, which increases at higher latitudes.\n *\n * @param {number} lat Latitude\n * @returns {number} scale factor\n * @private\n */\nexport function mercatorScale(lat) {\n  return 1 / Math.cos(lat * Math.PI / 180);\n}\nvar MercatorCoordinate = /*#__PURE__*/function () {\n  function MercatorCoordinate(x, y) {\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, MercatorCoordinate);\n    this.x = +x;\n    this.y = +y;\n    this.z = +z;\n  }\n  _createClass(MercatorCoordinate, [{\n    key: \"toLngLat\",\n    value: function toLngLat() {\n      return new LngLat(lngFromMercatorX(this.x), latFromMercatorY(this.y));\n    }\n  }, {\n    key: \"toAltitude\",\n    value: function toAltitude() {\n      return altitudeFromMercatorZ(this.z, this.y);\n    }\n  }, {\n    key: \"meterInMercatorCoordinateUnits\",\n    value: function meterInMercatorCoordinateUnits() {\n      // 1 meter / circumference at equator in meters * Mercator projection scale factor at this latitude\n      return 1 / earthCircumfrence * mercatorScale(latFromMercatorY(this.y));\n    }\n  }], [{\n    key: \"fromLngLat\",\n    value: function fromLngLat(lngLatLike) {\n      var altitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var lngLat = LngLat.convert(lngLatLike);\n      return new MercatorCoordinate(mercatorXfromLng(lngLat.lng), mercatorYfromLat(lngLat.lat), mercatorZfromAltitude(altitude, lngLat.lat));\n    }\n  }]);\n  return MercatorCoordinate;\n}();\nexport { MercatorCoordinate as default };\nexport { MercatorCoordinate };","map":{"version":3,"names":["_classCallCheck","_createClass","LngLat","earthRadius","earthCircumfrence","Math","PI","circumferenceAtLatitude","latitude","cos","mercatorXfromLng","lng","mercatorYfromLat","lat","log","tan","mercatorZfromAltitude","altitude","lngFromMercatorX","x","latFromMercatorY","y","y2","atan","exp","altitudeFromMercatorZ","z","mercatorScale","MercatorCoordinate","arguments","length","undefined","key","value","toLngLat","toAltitude","meterInMercatorCoordinateUnits","fromLngLat","lngLatLike","lngLat","convert","default"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-map/es/geo/mercator.js"],"sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport LngLat, { earthRadius } from \"../geo/lng_lat\";\n\n/*\n * The average circumference of the world in meters.\n */\nvar earthCircumfrence = 2 * Math.PI * earthRadius; // meters\n\n/*\n * The circumference at a line of latitude in meters.\n */\nfunction circumferenceAtLatitude(latitude) {\n  return earthCircumfrence * Math.cos(latitude * Math.PI / 180);\n}\nexport function mercatorXfromLng(lng) {\n  return (180 + lng) / 360;\n}\nexport function mercatorYfromLat(lat) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;\n}\nexport function mercatorZfromAltitude(altitude, lat) {\n  return altitude / circumferenceAtLatitude(lat);\n}\nexport function lngFromMercatorX(x) {\n  return x * 360 - 180;\n}\nexport function latFromMercatorY(y) {\n  var y2 = 180 - y * 360;\n  return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n}\nexport function altitudeFromMercatorZ(z, y) {\n  return z * circumferenceAtLatitude(latFromMercatorY(y));\n}\n\n/**\n * Determine the Mercator scale factor for a given latitude, see\n * https://en.wikipedia.org/wiki/Mercator_projection#Scale_factor\n *\n * At the equator the scale factor will be 1, which increases at higher latitudes.\n *\n * @param {number} lat Latitude\n * @returns {number} scale factor\n * @private\n */\nexport function mercatorScale(lat) {\n  return 1 / Math.cos(lat * Math.PI / 180);\n}\nvar MercatorCoordinate = /*#__PURE__*/function () {\n  function MercatorCoordinate(x, y) {\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, MercatorCoordinate);\n    this.x = +x;\n    this.y = +y;\n    this.z = +z;\n  }\n  _createClass(MercatorCoordinate, [{\n    key: \"toLngLat\",\n    value: function toLngLat() {\n      return new LngLat(lngFromMercatorX(this.x), latFromMercatorY(this.y));\n    }\n  }, {\n    key: \"toAltitude\",\n    value: function toAltitude() {\n      return altitudeFromMercatorZ(this.z, this.y);\n    }\n  }, {\n    key: \"meterInMercatorCoordinateUnits\",\n    value: function meterInMercatorCoordinateUnits() {\n      // 1 meter / circumference at equator in meters * Mercator projection scale factor at this latitude\n      return 1 / earthCircumfrence * mercatorScale(latFromMercatorY(this.y));\n    }\n  }], [{\n    key: \"fromLngLat\",\n    value: function fromLngLat(lngLatLike) {\n      var altitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var lngLat = LngLat.convert(lngLatLike);\n      return new MercatorCoordinate(mercatorXfromLng(lngLat.lng), mercatorYfromLat(lngLat.lat), mercatorZfromAltitude(altitude, lngLat.lat));\n    }\n  }]);\n  return MercatorCoordinate;\n}();\nexport { MercatorCoordinate as default };\nexport { MercatorCoordinate };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}