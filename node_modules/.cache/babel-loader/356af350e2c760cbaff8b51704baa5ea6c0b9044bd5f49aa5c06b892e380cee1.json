{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __read, __spreadArray } from \"tslib\";\nimport { each } from '@antv/util';\nimport { COMPONENT_TYPE } from '../../constant';\nimport { BBox } from '../../util/bbox';\nimport { isAutoPadding, parsePadding } from '../../util/padding';\nimport { PaddingCal } from './padding-cal';\n/**\n * @ignore\n * 根据 view 中的组件，计算实际的 padding 数值\n * @param view\n */\nexport function calculatePadding(view) {\n  var padding = view.padding;\n  // 如果不是 auto padding，那么直接解析之后返回\n  if (!isAutoPadding(padding)) {\n    return new (PaddingCal.bind.apply(PaddingCal, __spreadArray([void 0], __read(parsePadding(padding)), false)))();\n  }\n  // 是 auto padding，根据组件的情况，来计算 padding\n  var viewBBox = view.viewBBox;\n  var paddingCal = new PaddingCal();\n  var axisComponents = [];\n  var paddingComponents = [];\n  var otherComponents = [];\n  each(view.getComponents(), function (co) {\n    var type = co.type;\n    if (type === COMPONENT_TYPE.AXIS) {\n      axisComponents.push(co);\n    } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {\n      paddingComponents.push(co);\n    } else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {\n      otherComponents.push(co);\n    }\n  });\n  // 进行坐标轴布局，应该是取 padding 的并集，而不是进行相加\n  each(axisComponents, function (co) {\n    var component = co.component;\n    var bboxObject = component.getLayoutBBox();\n    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n    var exceed = componentBBox.exceed(viewBBox);\n    // 在对组件分组之后，先对 axis 进行处理，然后取最大的超出即可。\n    paddingCal.max(exceed);\n  });\n  // 有 padding 的组件布局\n  each(paddingComponents, function (co) {\n    var component = co.component,\n      direction = co.direction;\n    var bboxObject = component.getLayoutBBox();\n    var componentPadding = component.get('padding');\n    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding);\n    // 按照方向计算 padding\n    paddingCal.inc(componentBBox, direction);\n  });\n  // 其他组件布局\n  each(otherComponents, function (co) {\n    var component = co.component,\n      direction = co.direction;\n    var bboxObject = component.getLayoutBBox();\n    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n    // 按照方向计算 padding\n    paddingCal.inc(componentBBox, direction);\n  });\n  return paddingCal;\n}","map":{"version":3,"names":["each","COMPONENT_TYPE","BBox","isAutoPadding","parsePadding","PaddingCal","calculatePadding","view","padding","bind","apply","__spreadArray","__read","viewBBox","paddingCal","axisComponents","paddingComponents","otherComponents","getComponents","co","type","AXIS","push","LEGEND","SLIDER","SCROLLBAR","includes","GRID","TOOLTIP","component","bboxObject","getLayoutBBox","componentBBox","x","y","width","height","exceed","max","direction","componentPadding","get","expand","inc"],"sources":["../../../src/chart/layout/auto.ts"],"sourcesContent":["import { each } from '@antv/util';\nimport { COMPONENT_TYPE } from '../../constant';\nimport { ComponentOption, Padding } from '../../interface';\nimport { BBox } from '../../util/bbox';\nimport { isAutoPadding, parsePadding } from '../../util/padding';\nimport View from '../view';\nimport { PaddingCal } from './padding-cal';\n\n/**\n * @ignore\n * 根据 view 中的组件，计算实际的 padding 数值\n * @param view\n */\nexport function calculatePadding(view: View): PaddingCal {\n  const padding = view.padding;\n\n  // 如果不是 auto padding，那么直接解析之后返回\n  if (!isAutoPadding(padding)) {\n    return new PaddingCal(...parsePadding(padding));\n  }\n\n  // 是 auto padding，根据组件的情况，来计算 padding\n  const { viewBBox } = view;\n\n  const paddingCal = new PaddingCal();\n\n  const axisComponents = [];\n  const paddingComponents = [];\n  const otherComponents = [];\n\n  each(view.getComponents(), (co: ComponentOption) => {\n    const { type } = co;\n    if (type === COMPONENT_TYPE.AXIS) {\n      axisComponents.push(co);\n    } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {\n      paddingComponents.push(co);\n    } else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {\n      otherComponents.push(co);\n    }\n  });\n\n  // 进行坐标轴布局，应该是取 padding 的并集，而不是进行相加\n  each(axisComponents, (co: ComponentOption) => {\n    const { component } = co;\n    const bboxObject = component.getLayoutBBox();\n    const componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n\n    const exceed = componentBBox.exceed(viewBBox);\n\n    // 在对组件分组之后，先对 axis 进行处理，然后取最大的超出即可。\n    paddingCal.max(exceed);\n  });\n\n  // 有 padding 的组件布局\n  each(paddingComponents, (co: ComponentOption) => {\n    const { component, direction } = co;\n    const bboxObject = component.getLayoutBBox();\n    const componentPadding: Padding = component.get('padding');\n    const componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(\n      componentPadding\n    );\n    // 按照方向计算 padding\n    paddingCal.inc(componentBBox, direction);\n  });\n\n  // 其他组件布局\n  each(otherComponents, (co: ComponentOption) => {\n    const { component, direction } = co;\n    const bboxObject = component.getLayoutBBox();\n    const componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n    // 按照方向计算 padding\n    paddingCal.inc(componentBBox, direction);\n  });\n\n  return paddingCal;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}