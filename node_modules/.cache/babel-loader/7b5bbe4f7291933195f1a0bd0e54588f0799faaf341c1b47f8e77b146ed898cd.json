{"ast":null,"code":"import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\nexport default class CholeskyDecomposition {\n  constructor(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n    if (!value.isSymmetric()) {\n      throw new Error('Matrix is not symmetric');\n    }\n    let a = value;\n    let dimension = a.rows;\n    let l = new Matrix(dimension, dimension);\n    let positiveDefinite = true;\n    let i, j, k;\n    for (j = 0; j < dimension; j++) {\n      let d = 0;\n      for (k = 0; k < j; k++) {\n        let s = 0;\n        for (i = 0; i < k; i++) {\n          s += l.get(k, i) * l.get(j, i);\n        }\n        s = (a.get(j, k) - s) / l.get(k, k);\n        l.set(j, k, s);\n        d = d + s * s;\n      }\n      d = a.get(j, j) - d;\n      positiveDefinite &= d > 0;\n      l.set(j, j, Math.sqrt(Math.max(d, 0)));\n      for (k = j + 1; k < dimension; k++) {\n        l.set(j, k, 0);\n      }\n    }\n    this.L = l;\n    this.positiveDefinite = Boolean(positiveDefinite);\n  }\n  isPositiveDefinite() {\n    return this.positiveDefinite;\n  }\n  solve(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n    let l = this.L;\n    let dimension = l.rows;\n    if (value.rows !== dimension) {\n      throw new Error('Matrix dimensions do not match');\n    }\n    if (this.isPositiveDefinite() === false) {\n      throw new Error('Matrix is not positive definite');\n    }\n    let count = value.columns;\n    let B = value.clone();\n    let i, j, k;\n    for (k = 0; k < dimension; k++) {\n      for (j = 0; j < count; j++) {\n        for (i = 0; i < k; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n    for (k = dimension - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        for (i = k + 1; i < dimension; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n    return B;\n  }\n  get lowerTriangularMatrix() {\n    return this.L;\n  }\n}","map":{"version":3,"names":["Matrix","WrapperMatrix2D","CholeskyDecomposition","constructor","value","checkMatrix","isSymmetric","Error","a","dimension","rows","l","positiveDefinite","i","j","k","d","s","get","set","Math","sqrt","max","L","Boolean","isPositiveDefinite","solve","count","columns","B","clone","lowerTriangularMatrix"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/layout/node_modules/ml-matrix/src/dc/cholesky.js"],"sourcesContent":["import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nexport default class CholeskyDecomposition {\n  constructor(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n    if (!value.isSymmetric()) {\n      throw new Error('Matrix is not symmetric');\n    }\n\n    let a = value;\n    let dimension = a.rows;\n    let l = new Matrix(dimension, dimension);\n    let positiveDefinite = true;\n    let i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n      let d = 0;\n      for (k = 0; k < j; k++) {\n        let s = 0;\n        for (i = 0; i < k; i++) {\n          s += l.get(k, i) * l.get(j, i);\n        }\n        s = (a.get(j, k) - s) / l.get(k, k);\n        l.set(j, k, s);\n        d = d + s * s;\n      }\n\n      d = a.get(j, j) - d;\n\n      positiveDefinite &= d > 0;\n      l.set(j, j, Math.sqrt(Math.max(d, 0)));\n      for (k = j + 1; k < dimension; k++) {\n        l.set(j, k, 0);\n      }\n    }\n\n    this.L = l;\n    this.positiveDefinite = Boolean(positiveDefinite);\n  }\n\n  isPositiveDefinite() {\n    return this.positiveDefinite;\n  }\n\n  solve(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    let l = this.L;\n    let dimension = l.rows;\n\n    if (value.rows !== dimension) {\n      throw new Error('Matrix dimensions do not match');\n    }\n    if (this.isPositiveDefinite() === false) {\n      throw new Error('Matrix is not positive definite');\n    }\n\n    let count = value.columns;\n    let B = value.clone();\n    let i, j, k;\n\n    for (k = 0; k < dimension; k++) {\n      for (j = 0; j < count; j++) {\n        for (i = 0; i < k; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    for (k = dimension - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        for (i = k + 1; i < dimension; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    return B;\n  }\n\n  get lowerTriangularMatrix() {\n    return this.L;\n  }\n}\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,WAAW;AAC9B,OAAOC,eAAe,MAAM,yBAAyB;AAErD,eAAe,MAAMC,qBAAqB,CAAC;EACzCC,WAAWA,CAACC,KAAK,EAAE;IACjBA,KAAK,GAAGH,eAAe,CAACI,WAAW,CAACD,KAAK,CAAC;IAC1C,IAAI,CAACA,KAAK,CAACE,WAAW,CAAC,CAAC,EAAE;MACxB,MAAM,IAAIC,KAAK,CAAC,yBAAyB,CAAC;IAC5C;IAEA,IAAIC,CAAC,GAAGJ,KAAK;IACb,IAAIK,SAAS,GAAGD,CAAC,CAACE,IAAI;IACtB,IAAIC,CAAC,GAAG,IAAIX,MAAM,CAACS,SAAS,EAAEA,SAAS,CAAC;IACxC,IAAIG,gBAAgB,GAAG,IAAI;IAC3B,IAAIC,CAAC,EAAEC,CAAC,EAAEC,CAAC;IAEX,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,SAAS,EAAEK,CAAC,EAAE,EAAE;MAC9B,IAAIE,CAAC,GAAG,CAAC;MACT,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,CAAC,EAAEC,CAAC,EAAE,EAAE;QACtB,IAAIE,CAAC,GAAG,CAAC;QACT,KAAKJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,CAAC,EAAEF,CAAC,EAAE,EAAE;UACtBI,CAAC,IAAIN,CAAC,CAACO,GAAG,CAACH,CAAC,EAAEF,CAAC,CAAC,GAAGF,CAAC,CAACO,GAAG,CAACJ,CAAC,EAAED,CAAC,CAAC;QAChC;QACAI,CAAC,GAAG,CAACT,CAAC,CAACU,GAAG,CAACJ,CAAC,EAAEC,CAAC,CAAC,GAAGE,CAAC,IAAIN,CAAC,CAACO,GAAG,CAACH,CAAC,EAAEA,CAAC,CAAC;QACnCJ,CAAC,CAACQ,GAAG,CAACL,CAAC,EAAEC,CAAC,EAAEE,CAAC,CAAC;QACdD,CAAC,GAAGA,CAAC,GAAGC,CAAC,GAAGA,CAAC;MACf;MAEAD,CAAC,GAAGR,CAAC,CAACU,GAAG,CAACJ,CAAC,EAAEA,CAAC,CAAC,GAAGE,CAAC;MAEnBJ,gBAAgB,IAAII,CAAC,GAAG,CAAC;MACzBL,CAAC,CAACQ,GAAG,CAACL,CAAC,EAAEA,CAAC,EAAEM,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAACN,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MACtC,KAAKD,CAAC,GAAGD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGN,SAAS,EAAEM,CAAC,EAAE,EAAE;QAClCJ,CAAC,CAACQ,GAAG,CAACL,CAAC,EAAEC,CAAC,EAAE,CAAC,CAAC;MAChB;IACF;IAEA,IAAI,CAACQ,CAAC,GAAGZ,CAAC;IACV,IAAI,CAACC,gBAAgB,GAAGY,OAAO,CAACZ,gBAAgB,CAAC;EACnD;EAEAa,kBAAkBA,CAAA,EAAG;IACnB,OAAO,IAAI,CAACb,gBAAgB;EAC9B;EAEAc,KAAKA,CAACtB,KAAK,EAAE;IACXA,KAAK,GAAGH,eAAe,CAACI,WAAW,CAACD,KAAK,CAAC;IAE1C,IAAIO,CAAC,GAAG,IAAI,CAACY,CAAC;IACd,IAAId,SAAS,GAAGE,CAAC,CAACD,IAAI;IAEtB,IAAIN,KAAK,CAACM,IAAI,KAAKD,SAAS,EAAE;MAC5B,MAAM,IAAIF,KAAK,CAAC,gCAAgC,CAAC;IACnD;IACA,IAAI,IAAI,CAACkB,kBAAkB,CAAC,CAAC,KAAK,KAAK,EAAE;MACvC,MAAM,IAAIlB,KAAK,CAAC,iCAAiC,CAAC;IACpD;IAEA,IAAIoB,KAAK,GAAGvB,KAAK,CAACwB,OAAO;IACzB,IAAIC,CAAC,GAAGzB,KAAK,CAAC0B,KAAK,CAAC,CAAC;IACrB,IAAIjB,CAAC,EAAEC,CAAC,EAAEC,CAAC;IAEX,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,SAAS,EAAEM,CAAC,EAAE,EAAE;MAC9B,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,KAAK,EAAEb,CAAC,EAAE,EAAE;QAC1B,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,CAAC,EAAEF,CAAC,EAAE,EAAE;UACtBgB,CAAC,CAACV,GAAG,CAACJ,CAAC,EAAED,CAAC,EAAEe,CAAC,CAACX,GAAG,CAACH,CAAC,EAAED,CAAC,CAAC,GAAGe,CAAC,CAACX,GAAG,CAACL,CAAC,EAAEC,CAAC,CAAC,GAAGH,CAAC,CAACO,GAAG,CAACH,CAAC,EAAEF,CAAC,CAAC,CAAC;QACtD;QACAgB,CAAC,CAACV,GAAG,CAACJ,CAAC,EAAED,CAAC,EAAEe,CAAC,CAACX,GAAG,CAACH,CAAC,EAAED,CAAC,CAAC,GAAGH,CAAC,CAACO,GAAG,CAACH,CAAC,EAAEA,CAAC,CAAC,CAAC;MACxC;IACF;IAEA,KAAKA,CAAC,GAAGN,SAAS,GAAG,CAAC,EAAEM,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACnC,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,KAAK,EAAEb,CAAC,EAAE,EAAE;QAC1B,KAAKD,CAAC,GAAGE,CAAC,GAAG,CAAC,EAAEF,CAAC,GAAGJ,SAAS,EAAEI,CAAC,EAAE,EAAE;UAClCgB,CAAC,CAACV,GAAG,CAACJ,CAAC,EAAED,CAAC,EAAEe,CAAC,CAACX,GAAG,CAACH,CAAC,EAAED,CAAC,CAAC,GAAGe,CAAC,CAACX,GAAG,CAACL,CAAC,EAAEC,CAAC,CAAC,GAAGH,CAAC,CAACO,GAAG,CAACL,CAAC,EAAEE,CAAC,CAAC,CAAC;QACtD;QACAc,CAAC,CAACV,GAAG,CAACJ,CAAC,EAAED,CAAC,EAAEe,CAAC,CAACX,GAAG,CAACH,CAAC,EAAED,CAAC,CAAC,GAAGH,CAAC,CAACO,GAAG,CAACH,CAAC,EAAEA,CAAC,CAAC,CAAC;MACxC;IACF;IAEA,OAAOc,CAAC;EACV;EAEA,IAAIE,qBAAqBA,CAAA,EAAG;IAC1B,OAAO,IAAI,CAACR,CAAC;EACf;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}