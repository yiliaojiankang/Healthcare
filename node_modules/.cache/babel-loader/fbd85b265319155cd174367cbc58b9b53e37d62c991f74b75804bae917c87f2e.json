{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { mat3, vec3, ext, vec2 } from '@antv/matrix-util';\nimport { isArray, each } from '@antv/util';\nvar transform = ext.transform;\n/**\n * 对比对象，用于对象数组排序\n * @param   {string}       attributeName  排序依据的字段名称\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\nexport var compare = function compare(attributeName) {\n  return function (m, n) {\n    return m[attributeName] - n[attributeName];\n  };\n};\n/**\n * 是否在区间内\n * @param   {number}       value  值\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\nvar isBetween = function isBetween(value, min, max) {\n  return value >= min && value <= max;\n};\n/**\n * 获取两条线段的交点\n * @param  {Point}  p0 第一条线段起点\n * @param  {Point}  p1 第一条线段终点\n * @param  {Point}  p2 第二条线段起点\n * @param  {Point}  p3 第二条线段终点\n * @return {Point}  交点\n */\nexport var getLineIntersect = function getLineIntersect(p0, p1, p2, p3) {\n  var tolerance = 0.0001;\n  var E = {\n    x: p2.x - p0.x,\n    y: p2.y - p0.y\n  };\n  var D0 = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n  var D1 = {\n    x: p3.x - p2.x,\n    y: p3.y - p2.y\n  };\n  var kross = D0.x * D1.y - D0.y * D1.x;\n  var sqrKross = kross * kross;\n  var invertKross = 1 / kross;\n  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;\n  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;\n  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\n    var s = (E.x * D1.y - E.y * D1.x) * invertKross;\n    var t = (E.x * D0.y - E.y * D0.x) * invertKross;\n    if (!isBetween(s, 0, 1) || !isBetween(t, 0, 1)) return null;\n    return {\n      x: p0.x + s * D0.x,\n      y: p0.y + s * D0.y\n    };\n  }\n  return null;\n};\n/**\n * point and rectangular intersection point\n * @param  {IRect} rect  rect\n * @param  {Point} point point\n * @return {PointPoint} rst;\n */\nexport var getRectIntersectByPoint = function getRectIntersectByPoint(rect, point) {\n  var x = rect.x,\n    y = rect.y,\n    width = rect.width,\n    height = rect.height;\n  var cx = x + width / 2;\n  var cy = y + height / 2;\n  var points = [];\n  var center = {\n    x: cx,\n    y: cy\n  };\n  points.push({\n    x: x,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y\n  });\n  var rst = null;\n  for (var i = 1; i < points.length; i++) {\n    rst = getLineIntersect(points[i - 1], points[i], center, point);\n    if (rst) {\n      break;\n    }\n  }\n  return rst;\n};\n/**\n * get point and circle inIntersect\n * @param {ICircle} circle 圆点，x,y,r\n * @param {Point} point 点 x,y\n * @return {Point} applied point\n */\nexport var getCircleIntersectByPoint = function getCircleIntersectByPoint(circle, point) {\n  var cx = circle.x,\n    cy = circle.y,\n    r = circle.r;\n  var x = point.x,\n    y = point.y;\n  var dx = x - cx;\n  var dy = y - cy;\n  if (dx * dx + dy * dy < r * r) {\n    return null;\n  }\n  var angle = Math.atan(dy / dx);\n  return {\n    x: cx + Math.abs(r * Math.cos(angle)) * Math.sign(dx),\n    y: cy + Math.abs(r * Math.sin(angle)) * Math.sign(dy)\n  };\n};\n/**\n * get point and ellipse inIntersect\n * @param {Object} ellipse 椭圆 x,y,rx,ry\n * @param {Object} point 点 x,y\n * @return {object} applied point\n */\nexport var getEllipseIntersectByPoint = function getEllipseIntersectByPoint(ellipse, point) {\n  var a = ellipse.rx;\n  var b = ellipse.ry;\n  var cx = ellipse.x;\n  var cy = ellipse.y;\n  var dx = point.x - cx;\n  var dy = point.y - cy;\n  // 直接通过 x,y 求夹角，求出来的范围是 -PI, PI\n  var angle = Math.atan2(dy / b, dx / a);\n  if (angle < 0) {\n    angle += 2 * Math.PI; // 转换到 0，2PI\n  }\n\n  return {\n    x: cx + a * Math.cos(angle),\n    y: cy + b * Math.sin(angle)\n  };\n};\n/**\n * coordinate matrix transformation\n * @param  {number} point   coordinate\n * @param  {Matrix} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {Point} transformed point\n */\nexport var applyMatrix = function applyMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n  var vector = [point.x, point.y, tag];\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  vec3.transformMat3(vector, vector, matrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n * coordinate matrix invert transformation\n * @param  {number} point   coordinate\n * @param  {number} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {object} transformed point\n */\nexport var invertMatrix = function invertMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  var inversedMatrix = mat3.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], matrix);\n  if (!inversedMatrix) {\n    inversedMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  var vector = [point.x, point.y, tag];\n  vec3.transformMat3(vector, vector, inversedMatrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n *\n * @param p1 First coordinate\n * @param p2 second coordinate\n * @param p3 three coordinate\n */\nexport var getCircleCenterByPoints = function getCircleCenterByPoints(p1, p2, p3) {\n  var a = p1.x - p2.x;\n  var b = p1.y - p2.y;\n  var c = p1.x - p3.x;\n  var d = p1.y - p3.y;\n  var e = (p1.x * p1.x - p2.x * p2.x - p2.y * p2.y + p1.y * p1.y) / 2;\n  var f = (p1.x * p1.x - p3.x * p3.x - p3.y * p3.y + p1.y * p1.y) / 2;\n  var denominator = b * c - a * d;\n  return {\n    x: -(d * e - b * f) / denominator,\n    y: -(a * f - c * e) / denominator\n  };\n};\n/**\n * get distance by two points\n * @param p1 first point\n * @param p2 second point\n */\nexport var distance = function distance(p1, p2) {\n  var vx = p1.x - p2.x;\n  var vy = p1.y - p2.y;\n  return Math.sqrt(vx * vx + vy * vy);\n};\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\nexport var scaleMatrix = function scaleMatrix(matrix, ratio) {\n  var result = [];\n  matrix.forEach(function (row) {\n    var newRow = [];\n    row.forEach(function (v) {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n/**\n * Floyd Warshall algorithm for shortest path distances matrix\n * @param  {array} adjMatrix   adjacency matrix\n * @return {array} distances   shortest path distances matrix\n */\nexport var floydWarshall = function floydWarshall(adjMatrix) {\n  // initialize\n  var dist = [];\n  var size = adjMatrix.length;\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  }\n  // floyd\n  for (var k = 0; k < size; k += 1) {\n    for (var i = 0; i < size; i += 1) {\n      for (var j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n  return dist;\n};\n/**\n * get adjacency matrix\n * @param data graph data\n * @param directed whether it's a directed graph\n */\nexport var getAdjMatrix = function getAdjMatrix(data, directed) {\n  var nodes = data.nodes,\n    edges = data.edges;\n  var matrix = [];\n  // map node with index in data.nodes\n  var nodeMap = {};\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n  if (edges) {\n    edges.forEach(function (e) {\n      var source = e.source,\n        target = e.target;\n      var sIndex = nodeMap[source];\n      var tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n  return matrix;\n};\n/**\n * 平移group\n * @param group Group 实例\n * @param vec 移动向量\n */\nexport var translate = function translate(group, vec) {\n  group.translate(vec.x, vec.y);\n};\n/**\n * 移动到指定坐标点\n * @param group Group 实例\n * @param point 移动到的坐标点\n */\nexport var move = function move(group, point, animate, animateCfg) {\n  if (animateCfg === void 0) {\n    animateCfg = {\n      duration: 500\n    };\n  }\n  var matrix = group.getMatrix();\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  var bbox = group.getCanvasBBox();\n  var vx = point.x - bbox.minX;\n  var vy = point.y - bbox.minY;\n  if (animate) {\n    var dx_1 = vx * matrix[0];\n    var dy_1 = vy * matrix[4];\n    var lastX_1 = 0;\n    var lastY_1 = 0;\n    var newX_1 = 0;\n    var newY_1 = 0;\n    group.animate(function (ratio) {\n      newX_1 = dx_1 * ratio;\n      newY_1 = dy_1 * ratio;\n      matrix = transform(matrix, [['t', newX_1 - lastX_1, newY_1 - lastY_1]]);\n      lastX_1 = newX_1;\n      lastY_1 = newY_1;\n      return {\n        matrix: matrix\n      };\n    }, animateCfg);\n  } else {\n    var movedMatrix = transform(matrix, [['t', vx, vy]]);\n    group.setMatrix(movedMatrix);\n  }\n};\n/**\n * 缩放 group\n * @param group Group 实例\n * @param point 在x 和 y 方向上的缩放比例\n */\nexport var scale = function scale(group, ratio) {\n  var matrix = group.getMatrix();\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  var scaleXY = ratio;\n  if (!isArray(ratio)) {\n    scaleXY = [ratio, ratio];\n  }\n  if (isArray(ratio) && ratio.length === 1) {\n    scaleXY = [ratio[0], ratio[0]];\n  }\n  matrix = transform(matrix, [['s', scaleXY[0], scaleXY[1]]]);\n  group.setMatrix(matrix);\n};\n/**\n *\n * @param group Group 实例\n * @param ratio 选择角度\n */\nexport var rotate = function rotate(group, angle) {\n  var matrix = group.getMatrix();\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  matrix = transform(matrix, [['r', angle]]);\n  group.setMatrix(matrix);\n};\nexport var getDegree = function getDegree(n, nodeIdxMap, edges) {\n  var degrees = [];\n  for (var i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n  edges.forEach(function (e) {\n    if (e.source) {\n      degrees[nodeIdxMap[e.source]] += 1;\n    }\n    if (e.target) {\n      degrees[nodeIdxMap[e.target]] += 1;\n    }\n  });\n  return degrees;\n};\n// 判断点Q是否在p1和p2的线段上\nfunction onSegment(p1, p2, q) {\n  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {\n    return true;\n  }\n  return false;\n}\n/**\n * 判断点P在多边形内-射线法. Borrow from https://github.com/antvis/util/blob/master/packages/path-util/src/point-in-polygon.ts\n * @param points\n * @param x\n * @param y\n */\nexport var isPointInPolygon = function isPointInPolygon(points, x, y) {\n  var isHit = false;\n  var n = points.length;\n  // 判断两个double在eps精度下的大小关系\n  var tolerance = 1e-6;\n  function dcmp(xValue) {\n    if (Math.abs(xValue) < tolerance) {\n      return 0;\n    }\n    return xValue < 0 ? -1 : 1;\n  }\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n  for (var i = 0; i < n; i++) {\n    var p1 = points[i];\n    var p2 = points[(i + 1) % n];\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    }\n    // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {\n      isHit = !isHit;\n    }\n  }\n  return isHit;\n};\n// 判断两个BBox是否相交\nexport var intersectBBox = function intersectBBox(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n};\nvar lineIntersectPolygon = function lineIntersectPolygon(lines, line) {\n  var isIntersect = false;\n  each(lines, function (l) {\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n/**\n * 判断两个polygon是否相交。\n * borrow from @antv/path-util\n * @param points1 polygon1的顶点数组\n * @param points2 polygon2的顶点数组\n */\nexport var isPolygonsIntersect = function isPolygonsIntersect(points1, points2) {\n  var getBBox = function getBBox(points) {\n    var xArr = points.map(function (p) {\n      return p[0];\n    });\n    var yArr = points.map(function (p) {\n      return p[1];\n    });\n    return {\n      minX: Math.min.apply(null, xArr),\n      maxX: Math.max.apply(null, xArr),\n      minY: Math.min.apply(null, yArr),\n      maxY: Math.max.apply(null, yArr)\n    };\n  };\n  var parseToLines = function parseToLines(points) {\n    var lines = [];\n    var count = points.length;\n    for (var i = 0; i < count - 1; i++) {\n      var point = points[i];\n      var next = points[i + 1];\n      lines.push({\n        from: {\n          x: point[0],\n          y: point[1]\n        },\n        to: {\n          x: next[0],\n          y: next[1]\n        }\n      });\n    }\n    if (lines.length > 1) {\n      var first = points[0];\n      var last = points[count - 1];\n      lines.push({\n        from: {\n          x: last[0],\n          y: last[1]\n        },\n        to: {\n          x: first[0],\n          y: first[1]\n        }\n      });\n    }\n    return lines;\n  };\n  // 空数组，或者一个点返回 false\n  if (points1.length < 2 || points2.length < 2) {\n    return false;\n  }\n  var bbox1 = getBBox(points1);\n  var bbox2 = getBBox(points2);\n  // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n  if (!intersectBBox(bbox1, bbox2)) {\n    return false;\n  }\n  var isIn = false;\n  // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n  each(points2, function (point) {\n    if (isPointInPolygon(points1, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n  if (isIn) {\n    return true;\n  }\n  each(points1, function (point) {\n    if (isPointInPolygon(points2, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n  if (isIn) {\n    return true;\n  }\n  var lines1 = parseToLines(points1);\n  var lines2 = parseToLines(points2);\n  var isIntersect = false;\n  each(lines2, function (line) {\n    if (lineIntersectPolygon(lines1, line)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\nvar Line = /** @class */function () {\n  function Line(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n  Line.prototype.getBBox = function () {\n    var minX = Math.min(this.x1, this.x2);\n    var minY = Math.min(this.y1, this.y2);\n    var maxX = Math.max(this.x1, this.x2);\n    var maxY = Math.max(this.y1, this.y2);\n    var res = {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n    return res;\n  };\n  return Line;\n}();\nexport { Line };\nexport var getBBoxBoundLine = function getBBoxBoundLine(bbox, direction) {\n  var bounds = {\n    top: [bbox.minX, bbox.minY, bbox.maxX, bbox.minY],\n    left: [bbox.minX, bbox.minY, bbox.minX, bbox.maxY],\n    bottom: [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY],\n    right: [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY]\n  };\n  return bounds[direction];\n};\n/**\n * 计算两条线段相交时，相交点对第一条线段上的分割比例\n */\nvar fractionAlongLineA = function fractionAlongLineA(la, lb) {\n  var uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  var ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  var uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n  if (uB) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return ua;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n};\nexport var itemIntersectByLine = function itemIntersectByLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var countIntersections = 0;\n  var intersections = [];\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n      x1 = _a[0],\n      y1 = _a[1],\n      x2 = _a[2],\n      y2 = _a[3];\n    intersections[i] = getLineIntersect({\n      x: line.x1,\n      y: line.y1\n    }, {\n      x: line.x2,\n      y: line.y2\n    }, {\n      x: x1,\n      y: y1\n    }, {\n      x: x2,\n      y: y2\n    });\n    if (intersections[i]) {\n      countIntersections += 1;\n    }\n  }\n  return [intersections, countIntersections];\n};\nexport var fractionToLine = function fractionToLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var minDistance = Number.POSITIVE_INFINITY;\n  var countIntersections = 0;\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n      x1 = _a[0],\n      y1 = _a[1],\n      x2 = _a[2],\n      y2 = _a[3];\n    var testDistance = fractionAlongLineA(line, new Line(x1, y1, x2, y2));\n    testDistance = Math.abs(testDistance - 0.5);\n    if (testDistance >= 0 && testDistance <= 1) {\n      countIntersections += 1;\n      minDistance = testDistance < minDistance ? testDistance : minDistance;\n    }\n  }\n  if (countIntersections === 0) return -1;\n  return minDistance;\n};\nexport var getPointsCenter = function getPointsCenter(points) {\n  var centerX = 0;\n  var centerY = 0;\n  if (points.length > 0) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var point = points_1[_i];\n      centerX += point.x;\n      centerY += point.y;\n    }\n    centerX /= points.length;\n    centerY /= points.length;\n  }\n  return {\n    x: centerX,\n    y: centerY\n  };\n};\nexport var squareDist = function squareDist(a, b) {\n  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\n};\nexport var pointLineSquareDist = function pointLineSquareDist(point, line) {\n  var x1 = line.x1;\n  var y1 = line.y1;\n  var x2 = line.x2 - x1;\n  var y2 = line.y2 - y1;\n  var px = point.x - x1;\n  var py = point.y - y1;\n  var dotprod = px * x2 + py * y2;\n  var projlenSq;\n  if (dotprod <= 0) {\n    projlenSq = 0;\n  } else {\n    px = x2 - px;\n    py = y2 - py;\n    dotprod = px * x2 + py * y2;\n    if (dotprod <= 0) {\n      projlenSq = 0;\n    } else {\n      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n    }\n  }\n  var lenSq = px * px + py * py - projlenSq;\n  if (lenSq < 0) {\n    lenSq = 0;\n  }\n  return lenSq;\n};\nexport var isPointsOverlap = function isPointsOverlap(p1, p2, e) {\n  if (e === void 0) {\n    e = 1e-3;\n  }\n  return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) < Math.pow(e, 2);\n};\n/**\n * 点到矩形的距离的平方：矩形内部点视作距离为0，外部的点若投影落在矩形边上则为点到矩形边的最近的垂直距离，否则为点到矩形顶点的距离，\n * @param point IPoint\n * @param rect IRect\n */\nexport var pointRectSquareDist = function pointRectSquareDist(point, rect) {\n  var isLeft = point.x < rect.x;\n  var isRight = point.x > rect.x + rect.width;\n  var isTop = point.y > rect.y + rect.height;\n  var isBottom = point.y < rect.y;\n  var isPointOutside = isLeft || isRight || isTop || isBottom;\n  if (!isPointOutside) {\n    return 0;\n  }\n  if (isTop && !isLeft && !isRight) {\n    return Math.pow(rect.y + rect.height - point.y, 2);\n  }\n  if (isBottom && !isLeft && !isRight) {\n    return Math.pow(point.y - rect.y, 2);\n  }\n  if (isLeft && !isTop && !isBottom) {\n    return Math.pow(rect.x - point.x, 2);\n  }\n  if (isRight && !isTop && !isBottom) {\n    return Math.pow(rect.x + rect.width - point.x, 2);\n  }\n  var dx = Math.min(Math.abs(rect.x - point.x), Math.abs(rect.x + rect.width - point.x));\n  var dy = Math.min(Math.abs(rect.y - point.y), Math.abs(rect.y + rect.height - point.y));\n  return dx * dx + dy * dy;\n};\n/**\n * point to line distance\n * @param  {array} line 线的四个顶点 [x1, y1, x2, y2]\n * @param  {object} point 坐标点 {x, y}\n * @return {Number|NaN} distance\n */\nexport var pointLineDistance = function pointLineDistance(line, point) {\n  var x1 = line[0],\n    y1 = line[1],\n    x2 = line[2],\n    y2 = line[3];\n  var x = point.x,\n    y = point.y;\n  var d = [x2 - x1, y2 - y1];\n  if (vec2.exactEquals(d, [0, 0])) {\n    return NaN;\n  }\n  var u = [-d[1], d[0]];\n  // @ts-ignore\n  vec2.normalize(u, u);\n  var a = [x - x1, y - y1];\n  // @ts-ignore\n  return Math.abs(vec2.dot(a, u));\n};\n/**\n * Linearly interpolate between start and end, where alpha is the percent distance along the line.\n * alpha = 0 will be start, and alpha = 1 will be end.\n * @param {number} start\n * @param {number} end\n * @param {number} alpha interpolation factor, typically in the closed interval [0, 1]\n * @returns {number}\n */\nexport var lerp = function lerp(start, end, alpha) {\n  return start + (end - start) * alpha;\n};\n/**\n * Linearly interpolate between start and end arrays, where alpha is the percent distance along the line.\n * alpha = 0 will be start, and alpha = 1 will be end.\n * @param {number[]} start\n * @param {number[]} end\n * @param {number} alpha interpolation factor, typically in the closed interval [0, 1]\n * @returns {number[]}\n */\nexport var lerpArray = function lerpArray(start, end, alpha) {\n  var len = Math.min(start.length, end.length);\n  var out = new Array(len);\n  for (var i = 0; i < len; i++) {\n    out[i] = lerp(start[i], end[i], alpha);\n  }\n  return out;\n};","map":{"version":3,"names":["mat3","vec3","ext","vec2","isArray","each","transform","compare","attributeName","m","n","isBetween","value","min","max","getLineIntersect","p0","p1","p2","p3","tolerance","E","x","y","D0","D1","kross","sqrKross","invertKross","sqrLen0","sqrLen1","s","t","getRectIntersectByPoint","rect","point","width","height","cx","cy","points","center","push","rst","i","length","getCircleIntersectByPoint","circle","r","dx","dy","angle","Math","atan","abs","cos","sign","sin","getEllipseIntersectByPoint","ellipse","a","rx","b","ry","atan2","PI","applyMatrix","matrix","tag","vector","isNaN","transformMat3","invertMatrix","inversedMatrix","invert","getCircleCenterByPoints","c","d","e","f","denominator","distance","vx","vy","sqrt","scaleMatrix","ratio","result","forEach","row","newRow","v","floydWarshall","adjMatrix","dist","size","j","Infinity","k","getAdjMatrix","data","directed","nodes","edges","nodeMap","Error","node","id","source","target","sIndex","tIndex","translate","group","vec","move","animate","animateCfg","duration","getMatrix","bbox","getCanvasBBox","minX","minY","dx_1","dy_1","lastX_1","lastY_1","newX_1","newY_1","movedMatrix","setMatrix","scale","scaleXY","rotate","getDegree","nodeIdxMap","degrees","onSegment","q","isPointInPolygon","isHit","dcmp","xValue","intersectBBox","box1","box2","maxX","maxY","lineIntersectPolygon","lines","line","isIntersect","l","from","to","isPolygonsIntersect","points1","points2","getBBox","xArr","map","p","yArr","apply","parseToLines","count","next","first","last","bbox1","bbox2","isIn","lines1","lines2","Line","x1","y1","x2","y2","prototype","res","getBBoxBoundLine","direction","bounds","top","left","bottom","right","fractionAlongLineA","la","lb","uaT","ubT","uB","ua","ub","Number","POSITIVE_INFINITY","itemIntersectByLine","item","directions","countIntersections","intersections","_a","fractionToLine","minDistance","testDistance","getPointsCenter","centerX","centerY","_i","points_1","squareDist","pow","pointLineSquareDist","px","py","dotprod","projlenSq","lenSq","isPointsOverlap","pointRectSquareDist","isLeft","isRight","isTop","isBottom","isPointOutside","pointLineDistance","exactEquals","NaN","u","normalize","dot","lerp","start","end","alpha","lerpArray","len","out","Array"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/g6-core/es/util/math.js"],"sourcesContent":["import { mat3, vec3, ext, vec2 } from '@antv/matrix-util';\nimport { isArray, each } from '@antv/util';\nvar transform = ext.transform;\n/**\n * 对比对象，用于对象数组排序\n * @param   {string}       attributeName  排序依据的字段名称\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\nexport var compare = function compare(attributeName) {\n  return function (m, n) {\n    return m[attributeName] - n[attributeName];\n  };\n};\n/**\n * 是否在区间内\n * @param   {number}       value  值\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\nvar isBetween = function isBetween(value, min, max) {\n  return value >= min && value <= max;\n};\n/**\n * 获取两条线段的交点\n * @param  {Point}  p0 第一条线段起点\n * @param  {Point}  p1 第一条线段终点\n * @param  {Point}  p2 第二条线段起点\n * @param  {Point}  p3 第二条线段终点\n * @return {Point}  交点\n */\nexport var getLineIntersect = function getLineIntersect(p0, p1, p2, p3) {\n  var tolerance = 0.0001;\n  var E = {\n    x: p2.x - p0.x,\n    y: p2.y - p0.y\n  };\n  var D0 = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n  var D1 = {\n    x: p3.x - p2.x,\n    y: p3.y - p2.y\n  };\n  var kross = D0.x * D1.y - D0.y * D1.x;\n  var sqrKross = kross * kross;\n  var invertKross = 1 / kross;\n  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;\n  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;\n  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\n    var s = (E.x * D1.y - E.y * D1.x) * invertKross;\n    var t = (E.x * D0.y - E.y * D0.x) * invertKross;\n    if (!isBetween(s, 0, 1) || !isBetween(t, 0, 1)) return null;\n    return {\n      x: p0.x + s * D0.x,\n      y: p0.y + s * D0.y\n    };\n  }\n  return null;\n};\n/**\n * point and rectangular intersection point\n * @param  {IRect} rect  rect\n * @param  {Point} point point\n * @return {PointPoint} rst;\n */\nexport var getRectIntersectByPoint = function getRectIntersectByPoint(rect, point) {\n  var x = rect.x,\n    y = rect.y,\n    width = rect.width,\n    height = rect.height;\n  var cx = x + width / 2;\n  var cy = y + height / 2;\n  var points = [];\n  var center = {\n    x: cx,\n    y: cy\n  };\n  points.push({\n    x: x,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y\n  });\n  var rst = null;\n  for (var i = 1; i < points.length; i++) {\n    rst = getLineIntersect(points[i - 1], points[i], center, point);\n    if (rst) {\n      break;\n    }\n  }\n  return rst;\n};\n/**\n * get point and circle inIntersect\n * @param {ICircle} circle 圆点，x,y,r\n * @param {Point} point 点 x,y\n * @return {Point} applied point\n */\nexport var getCircleIntersectByPoint = function getCircleIntersectByPoint(circle, point) {\n  var cx = circle.x,\n    cy = circle.y,\n    r = circle.r;\n  var x = point.x,\n    y = point.y;\n  var dx = x - cx;\n  var dy = y - cy;\n  if (dx * dx + dy * dy < r * r) {\n    return null;\n  }\n  var angle = Math.atan(dy / dx);\n  return {\n    x: cx + Math.abs(r * Math.cos(angle)) * Math.sign(dx),\n    y: cy + Math.abs(r * Math.sin(angle)) * Math.sign(dy)\n  };\n};\n/**\n * get point and ellipse inIntersect\n * @param {Object} ellipse 椭圆 x,y,rx,ry\n * @param {Object} point 点 x,y\n * @return {object} applied point\n */\nexport var getEllipseIntersectByPoint = function getEllipseIntersectByPoint(ellipse, point) {\n  var a = ellipse.rx;\n  var b = ellipse.ry;\n  var cx = ellipse.x;\n  var cy = ellipse.y;\n  var dx = point.x - cx;\n  var dy = point.y - cy;\n  // 直接通过 x,y 求夹角，求出来的范围是 -PI, PI\n  var angle = Math.atan2(dy / b, dx / a);\n  if (angle < 0) {\n    angle += 2 * Math.PI; // 转换到 0，2PI\n  }\n\n  return {\n    x: cx + a * Math.cos(angle),\n    y: cy + b * Math.sin(angle)\n  };\n};\n/**\n * coordinate matrix transformation\n * @param  {number} point   coordinate\n * @param  {Matrix} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {Point} transformed point\n */\nexport var applyMatrix = function applyMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n  var vector = [point.x, point.y, tag];\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  vec3.transformMat3(vector, vector, matrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n * coordinate matrix invert transformation\n * @param  {number} point   coordinate\n * @param  {number} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {object} transformed point\n */\nexport var invertMatrix = function invertMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  var inversedMatrix = mat3.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], matrix);\n  if (!inversedMatrix) {\n    inversedMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  var vector = [point.x, point.y, tag];\n  vec3.transformMat3(vector, vector, inversedMatrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n *\n * @param p1 First coordinate\n * @param p2 second coordinate\n * @param p3 three coordinate\n */\nexport var getCircleCenterByPoints = function getCircleCenterByPoints(p1, p2, p3) {\n  var a = p1.x - p2.x;\n  var b = p1.y - p2.y;\n  var c = p1.x - p3.x;\n  var d = p1.y - p3.y;\n  var e = (p1.x * p1.x - p2.x * p2.x - p2.y * p2.y + p1.y * p1.y) / 2;\n  var f = (p1.x * p1.x - p3.x * p3.x - p3.y * p3.y + p1.y * p1.y) / 2;\n  var denominator = b * c - a * d;\n  return {\n    x: -(d * e - b * f) / denominator,\n    y: -(a * f - c * e) / denominator\n  };\n};\n/**\n * get distance by two points\n * @param p1 first point\n * @param p2 second point\n */\nexport var distance = function distance(p1, p2) {\n  var vx = p1.x - p2.x;\n  var vy = p1.y - p2.y;\n  return Math.sqrt(vx * vx + vy * vy);\n};\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\nexport var scaleMatrix = function scaleMatrix(matrix, ratio) {\n  var result = [];\n  matrix.forEach(function (row) {\n    var newRow = [];\n    row.forEach(function (v) {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n/**\n * Floyd Warshall algorithm for shortest path distances matrix\n * @param  {array} adjMatrix   adjacency matrix\n * @return {array} distances   shortest path distances matrix\n */\nexport var floydWarshall = function floydWarshall(adjMatrix) {\n  // initialize\n  var dist = [];\n  var size = adjMatrix.length;\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  }\n  // floyd\n  for (var k = 0; k < size; k += 1) {\n    for (var i = 0; i < size; i += 1) {\n      for (var j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n  return dist;\n};\n/**\n * get adjacency matrix\n * @param data graph data\n * @param directed whether it's a directed graph\n */\nexport var getAdjMatrix = function getAdjMatrix(data, directed) {\n  var nodes = data.nodes,\n    edges = data.edges;\n  var matrix = [];\n  // map node with index in data.nodes\n  var nodeMap = {};\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n  if (edges) {\n    edges.forEach(function (e) {\n      var source = e.source,\n        target = e.target;\n      var sIndex = nodeMap[source];\n      var tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n  return matrix;\n};\n/**\n * 平移group\n * @param group Group 实例\n * @param vec 移动向量\n */\nexport var translate = function translate(group, vec) {\n  group.translate(vec.x, vec.y);\n};\n/**\n * 移动到指定坐标点\n * @param group Group 实例\n * @param point 移动到的坐标点\n */\nexport var move = function move(group, point, animate, animateCfg) {\n  if (animateCfg === void 0) {\n    animateCfg = {\n      duration: 500\n    };\n  }\n  var matrix = group.getMatrix();\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  var bbox = group.getCanvasBBox();\n  var vx = point.x - bbox.minX;\n  var vy = point.y - bbox.minY;\n  if (animate) {\n    var dx_1 = vx * matrix[0];\n    var dy_1 = vy * matrix[4];\n    var lastX_1 = 0;\n    var lastY_1 = 0;\n    var newX_1 = 0;\n    var newY_1 = 0;\n    group.animate(function (ratio) {\n      newX_1 = dx_1 * ratio;\n      newY_1 = dy_1 * ratio;\n      matrix = transform(matrix, [['t', newX_1 - lastX_1, newY_1 - lastY_1]]);\n      lastX_1 = newX_1;\n      lastY_1 = newY_1;\n      return {\n        matrix: matrix\n      };\n    }, animateCfg);\n  } else {\n    var movedMatrix = transform(matrix, [['t', vx, vy]]);\n    group.setMatrix(movedMatrix);\n  }\n};\n/**\n * 缩放 group\n * @param group Group 实例\n * @param point 在x 和 y 方向上的缩放比例\n */\nexport var scale = function scale(group, ratio) {\n  var matrix = group.getMatrix();\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  var scaleXY = ratio;\n  if (!isArray(ratio)) {\n    scaleXY = [ratio, ratio];\n  }\n  if (isArray(ratio) && ratio.length === 1) {\n    scaleXY = [ratio[0], ratio[0]];\n  }\n  matrix = transform(matrix, [['s', scaleXY[0], scaleXY[1]]]);\n  group.setMatrix(matrix);\n};\n/**\n *\n * @param group Group 实例\n * @param ratio 选择角度\n */\nexport var rotate = function rotate(group, angle) {\n  var matrix = group.getMatrix();\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  matrix = transform(matrix, [['r', angle]]);\n  group.setMatrix(matrix);\n};\nexport var getDegree = function getDegree(n, nodeIdxMap, edges) {\n  var degrees = [];\n  for (var i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n  edges.forEach(function (e) {\n    if (e.source) {\n      degrees[nodeIdxMap[e.source]] += 1;\n    }\n    if (e.target) {\n      degrees[nodeIdxMap[e.target]] += 1;\n    }\n  });\n  return degrees;\n};\n// 判断点Q是否在p1和p2的线段上\nfunction onSegment(p1, p2, q) {\n  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {\n    return true;\n  }\n  return false;\n}\n/**\n * 判断点P在多边形内-射线法. Borrow from https://github.com/antvis/util/blob/master/packages/path-util/src/point-in-polygon.ts\n * @param points\n * @param x\n * @param y\n */\nexport var isPointInPolygon = function isPointInPolygon(points, x, y) {\n  var isHit = false;\n  var n = points.length;\n  // 判断两个double在eps精度下的大小关系\n  var tolerance = 1e-6;\n  function dcmp(xValue) {\n    if (Math.abs(xValue) < tolerance) {\n      return 0;\n    }\n    return xValue < 0 ? -1 : 1;\n  }\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n  for (var i = 0; i < n; i++) {\n    var p1 = points[i];\n    var p2 = points[(i + 1) % n];\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    }\n    // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {\n      isHit = !isHit;\n    }\n  }\n  return isHit;\n};\n// 判断两个BBox是否相交\nexport var intersectBBox = function intersectBBox(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n};\nvar lineIntersectPolygon = function lineIntersectPolygon(lines, line) {\n  var isIntersect = false;\n  each(lines, function (l) {\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n/**\n * 判断两个polygon是否相交。\n * borrow from @antv/path-util\n * @param points1 polygon1的顶点数组\n * @param points2 polygon2的顶点数组\n */\nexport var isPolygonsIntersect = function isPolygonsIntersect(points1, points2) {\n  var getBBox = function getBBox(points) {\n    var xArr = points.map(function (p) {\n      return p[0];\n    });\n    var yArr = points.map(function (p) {\n      return p[1];\n    });\n    return {\n      minX: Math.min.apply(null, xArr),\n      maxX: Math.max.apply(null, xArr),\n      minY: Math.min.apply(null, yArr),\n      maxY: Math.max.apply(null, yArr)\n    };\n  };\n  var parseToLines = function parseToLines(points) {\n    var lines = [];\n    var count = points.length;\n    for (var i = 0; i < count - 1; i++) {\n      var point = points[i];\n      var next = points[i + 1];\n      lines.push({\n        from: {\n          x: point[0],\n          y: point[1]\n        },\n        to: {\n          x: next[0],\n          y: next[1]\n        }\n      });\n    }\n    if (lines.length > 1) {\n      var first = points[0];\n      var last = points[count - 1];\n      lines.push({\n        from: {\n          x: last[0],\n          y: last[1]\n        },\n        to: {\n          x: first[0],\n          y: first[1]\n        }\n      });\n    }\n    return lines;\n  };\n  // 空数组，或者一个点返回 false\n  if (points1.length < 2 || points2.length < 2) {\n    return false;\n  }\n  var bbox1 = getBBox(points1);\n  var bbox2 = getBBox(points2);\n  // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n  if (!intersectBBox(bbox1, bbox2)) {\n    return false;\n  }\n  var isIn = false;\n  // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n  each(points2, function (point) {\n    if (isPointInPolygon(points1, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n  if (isIn) {\n    return true;\n  }\n  each(points1, function (point) {\n    if (isPointInPolygon(points2, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n  if (isIn) {\n    return true;\n  }\n  var lines1 = parseToLines(points1);\n  var lines2 = parseToLines(points2);\n  var isIntersect = false;\n  each(lines2, function (line) {\n    if (lineIntersectPolygon(lines1, line)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\nvar Line = /** @class */function () {\n  function Line(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n  Line.prototype.getBBox = function () {\n    var minX = Math.min(this.x1, this.x2);\n    var minY = Math.min(this.y1, this.y2);\n    var maxX = Math.max(this.x1, this.x2);\n    var maxY = Math.max(this.y1, this.y2);\n    var res = {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n    return res;\n  };\n  return Line;\n}();\nexport { Line };\nexport var getBBoxBoundLine = function getBBoxBoundLine(bbox, direction) {\n  var bounds = {\n    top: [bbox.minX, bbox.minY, bbox.maxX, bbox.minY],\n    left: [bbox.minX, bbox.minY, bbox.minX, bbox.maxY],\n    bottom: [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY],\n    right: [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY]\n  };\n  return bounds[direction];\n};\n/**\n * 计算两条线段相交时，相交点对第一条线段上的分割比例\n */\nvar fractionAlongLineA = function fractionAlongLineA(la, lb) {\n  var uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  var ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  var uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n  if (uB) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return ua;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n};\nexport var itemIntersectByLine = function itemIntersectByLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var countIntersections = 0;\n  var intersections = [];\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n      x1 = _a[0],\n      y1 = _a[1],\n      x2 = _a[2],\n      y2 = _a[3];\n    intersections[i] = getLineIntersect({\n      x: line.x1,\n      y: line.y1\n    }, {\n      x: line.x2,\n      y: line.y2\n    }, {\n      x: x1,\n      y: y1\n    }, {\n      x: x2,\n      y: y2\n    });\n    if (intersections[i]) {\n      countIntersections += 1;\n    }\n  }\n  return [intersections, countIntersections];\n};\nexport var fractionToLine = function fractionToLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var minDistance = Number.POSITIVE_INFINITY;\n  var countIntersections = 0;\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n      x1 = _a[0],\n      y1 = _a[1],\n      x2 = _a[2],\n      y2 = _a[3];\n    var testDistance = fractionAlongLineA(line, new Line(x1, y1, x2, y2));\n    testDistance = Math.abs(testDistance - 0.5);\n    if (testDistance >= 0 && testDistance <= 1) {\n      countIntersections += 1;\n      minDistance = testDistance < minDistance ? testDistance : minDistance;\n    }\n  }\n  if (countIntersections === 0) return -1;\n  return minDistance;\n};\nexport var getPointsCenter = function getPointsCenter(points) {\n  var centerX = 0;\n  var centerY = 0;\n  if (points.length > 0) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var point = points_1[_i];\n      centerX += point.x;\n      centerY += point.y;\n    }\n    centerX /= points.length;\n    centerY /= points.length;\n  }\n  return {\n    x: centerX,\n    y: centerY\n  };\n};\nexport var squareDist = function squareDist(a, b) {\n  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\n};\nexport var pointLineSquareDist = function pointLineSquareDist(point, line) {\n  var x1 = line.x1;\n  var y1 = line.y1;\n  var x2 = line.x2 - x1;\n  var y2 = line.y2 - y1;\n  var px = point.x - x1;\n  var py = point.y - y1;\n  var dotprod = px * x2 + py * y2;\n  var projlenSq;\n  if (dotprod <= 0) {\n    projlenSq = 0;\n  } else {\n    px = x2 - px;\n    py = y2 - py;\n    dotprod = px * x2 + py * y2;\n    if (dotprod <= 0) {\n      projlenSq = 0;\n    } else {\n      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n    }\n  }\n  var lenSq = px * px + py * py - projlenSq;\n  if (lenSq < 0) {\n    lenSq = 0;\n  }\n  return lenSq;\n};\nexport var isPointsOverlap = function isPointsOverlap(p1, p2, e) {\n  if (e === void 0) {\n    e = 1e-3;\n  }\n  return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) < Math.pow(e, 2);\n};\n/**\n * 点到矩形的距离的平方：矩形内部点视作距离为0，外部的点若投影落在矩形边上则为点到矩形边的最近的垂直距离，否则为点到矩形顶点的距离，\n * @param point IPoint\n * @param rect IRect\n */\nexport var pointRectSquareDist = function pointRectSquareDist(point, rect) {\n  var isLeft = point.x < rect.x;\n  var isRight = point.x > rect.x + rect.width;\n  var isTop = point.y > rect.y + rect.height;\n  var isBottom = point.y < rect.y;\n  var isPointOutside = isLeft || isRight || isTop || isBottom;\n  if (!isPointOutside) {\n    return 0;\n  }\n  if (isTop && !isLeft && !isRight) {\n    return Math.pow(rect.y + rect.height - point.y, 2);\n  }\n  if (isBottom && !isLeft && !isRight) {\n    return Math.pow(point.y - rect.y, 2);\n  }\n  if (isLeft && !isTop && !isBottom) {\n    return Math.pow(rect.x - point.x, 2);\n  }\n  if (isRight && !isTop && !isBottom) {\n    return Math.pow(rect.x + rect.width - point.x, 2);\n  }\n  var dx = Math.min(Math.abs(rect.x - point.x), Math.abs(rect.x + rect.width - point.x));\n  var dy = Math.min(Math.abs(rect.y - point.y), Math.abs(rect.y + rect.height - point.y));\n  return dx * dx + dy * dy;\n};\n/**\n * point to line distance\n * @param  {array} line 线的四个顶点 [x1, y1, x2, y2]\n * @param  {object} point 坐标点 {x, y}\n * @return {Number|NaN} distance\n */\nexport var pointLineDistance = function pointLineDistance(line, point) {\n  var x1 = line[0],\n    y1 = line[1],\n    x2 = line[2],\n    y2 = line[3];\n  var x = point.x,\n    y = point.y;\n  var d = [x2 - x1, y2 - y1];\n  if (vec2.exactEquals(d, [0, 0])) {\n    return NaN;\n  }\n  var u = [-d[1], d[0]];\n  // @ts-ignore\n  vec2.normalize(u, u);\n  var a = [x - x1, y - y1];\n  // @ts-ignore\n  return Math.abs(vec2.dot(a, u));\n};\n/**\n * Linearly interpolate between start and end, where alpha is the percent distance along the line.\n * alpha = 0 will be start, and alpha = 1 will be end.\n * @param {number} start\n * @param {number} end\n * @param {number} alpha interpolation factor, typically in the closed interval [0, 1]\n * @returns {number}\n */\nexport var lerp = function lerp(start, end, alpha) {\n  return start + (end - start) * alpha;\n};\n/**\n * Linearly interpolate between start and end arrays, where alpha is the percent distance along the line.\n * alpha = 0 will be start, and alpha = 1 will be end.\n * @param {number[]} start\n * @param {number[]} end\n * @param {number} alpha interpolation factor, typically in the closed interval [0, 1]\n * @returns {number[]}\n */\nexport var lerpArray = function lerpArray(start, end, alpha) {\n  var len = Math.min(start.length, end.length);\n  var out = new Array(len);\n  for (var i = 0; i < len; i++) {\n    out[i] = lerp(start[i], end[i], alpha);\n  }\n  return out;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}