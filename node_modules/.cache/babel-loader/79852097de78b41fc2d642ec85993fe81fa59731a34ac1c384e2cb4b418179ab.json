{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { encodePickingColor } from \"../color\";\nimport { a_Color, a_filter, a_Position, a_vertexId } from \"./commonFeatureFunc\";\nimport { PointFillTriangulation as triangulation } from \"./triangulation\";\nexport var pointFillModel = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var descriptors, features, enablePicking, shape2d, updateFuncs, featureLayout, verticesNum, indices, size;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          descriptors = _ref.descriptors, features = _ref.features, enablePicking = _ref.enablePicking, shape2d = _ref.shape2d;\n          updateFuncs = {\n            // fixed feature func\n            a_Color: a_Color,\n            a_Position: a_Position,\n            filter: a_filter,\n            a_vertexId: a_vertexId,\n            a_PickingColor: function a_PickingColor(feature) {\n              var id = feature.id;\n              return enablePicking ? encodePickingColor(id) : [0, 0, 0];\n            },\n            // pointFill feature func\n            a_Shape: function a_Shape(feature) {\n              var _feature$shape = feature.shape,\n                shape = _feature$shape === void 0 ? 2 : _feature$shape;\n              var shapeIndex = shape2d.indexOf(shape);\n              return [shapeIndex];\n            },\n            a_Extrude: function a_Extrude(feature, featureIdx, vertex, attributeIdx) {\n              var extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];\n              var extrudeIndex = attributeIdx % 4 * 3;\n              return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];\n            },\n            a_Size: function a_Size(feature) {\n              var _feature$size = feature.size,\n                pointSize = _feature$size === void 0 ? 5 : _feature$size;\n              return Array.isArray(pointSize) ? [pointSize[0]] : [pointSize];\n            }\n          };\n          featureLayout = {\n            sizePerElement: 0,\n            elements: []\n          };\n          verticesNum = 0;\n          indices = [];\n          size = 3;\n          features.forEach(function (feature, featureIdx) {\n            var _triangulation = triangulation(feature),\n              indicesForCurrentFeature = _triangulation.indices,\n              verticesForCurrentFeature = _triangulation.vertices,\n              normalsForCurrentFeature = _triangulation.normals,\n              vertexSize = _triangulation.size,\n              indexes = _triangulation.indexes;\n            indicesForCurrentFeature.forEach(function (i) {\n              indices.push(i + verticesNum);\n            });\n            size = vertexSize;\n            var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;\n            featureLayout.sizePerElement = size;\n            featureLayout.elements.push({\n              featureIdx: featureIdx,\n              vertices: verticesForCurrentFeature,\n              normals: normalsForCurrentFeature,\n              offset: verticesNum\n            });\n            verticesNum += verticesNumForCurrentFeature;\n            var _loop = function _loop(vertexIdx) {\n              var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];\n              var vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);\n              var vertexIndex = 0;\n              if (indexes && indexes[vertexIdx] !== undefined) {\n                vertexIndex = indexes[vertexIdx];\n              }\n              descriptors.forEach(function (descriptor) {\n                // @ts-ignore\n                if (descriptor && updateFuncs[descriptor.name]) {\n                  var _descriptor$buffer$da;\n                  // @ts-ignore\n                  (_descriptor$buffer$da = descriptor.buffer.data).push.apply(_descriptor$buffer$da, _toConsumableArray(updateFuncs[descriptor.name](feature, featureIdx, vertice, vertexIdx, normal, vertexIndex)));\n                }\n              });\n            };\n            for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {\n              _loop(vertexIdx);\n            }\n          });\n          return _context.abrupt(\"return\", {\n            descriptors: descriptors,\n            featureLayout: featureLayout,\n            indices: indices\n          });\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function pointFillModel(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["_toConsumableArray","_asyncToGenerator","_regeneratorRuntime","encodePickingColor","a_Color","a_filter","a_Position","a_vertexId","PointFillTriangulation","triangulation","pointFillModel","_ref2","mark","_callee","_ref","descriptors","features","enablePicking","shape2d","updateFuncs","featureLayout","verticesNum","indices","size","wrap","_callee$","_context","prev","next","filter","a_PickingColor","feature","id","a_Shape","_feature$shape","shape","shapeIndex","indexOf","a_Extrude","featureIdx","vertex","attributeIdx","extrude","extrudeIndex","a_Size","_feature$size","pointSize","Array","isArray","sizePerElement","elements","forEach","_triangulation","indicesForCurrentFeature","verticesForCurrentFeature","vertices","normalsForCurrentFeature","normals","vertexSize","indexes","i","push","verticesNumForCurrentFeature","length","offset","_loop","vertexIdx","normal","slice","vertice","vertexIndex","undefined","descriptor","name","_descriptor$buffer$da","buffer","data","apply","abrupt","stop","_x","arguments"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-utils/es/workers/pointFillModel.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { encodePickingColor } from \"../color\";\nimport { a_Color, a_filter, a_Position, a_vertexId } from \"./commonFeatureFunc\";\nimport { PointFillTriangulation as triangulation } from \"./triangulation\";\nexport var pointFillModel = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var descriptors, features, enablePicking, shape2d, updateFuncs, featureLayout, verticesNum, indices, size;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          descriptors = _ref.descriptors, features = _ref.features, enablePicking = _ref.enablePicking, shape2d = _ref.shape2d;\n          updateFuncs = {\n            // fixed feature func\n            a_Color: a_Color,\n            a_Position: a_Position,\n            filter: a_filter,\n            a_vertexId: a_vertexId,\n            a_PickingColor: function a_PickingColor(feature) {\n              var id = feature.id;\n              return enablePicking ? encodePickingColor(id) : [0, 0, 0];\n            },\n            // pointFill feature func\n            a_Shape: function a_Shape(feature) {\n              var _feature$shape = feature.shape,\n                shape = _feature$shape === void 0 ? 2 : _feature$shape;\n              var shapeIndex = shape2d.indexOf(shape);\n              return [shapeIndex];\n            },\n            a_Extrude: function a_Extrude(feature, featureIdx, vertex, attributeIdx) {\n              var extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];\n              var extrudeIndex = attributeIdx % 4 * 3;\n              return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];\n            },\n            a_Size: function a_Size(feature) {\n              var _feature$size = feature.size,\n                pointSize = _feature$size === void 0 ? 5 : _feature$size;\n              return Array.isArray(pointSize) ? [pointSize[0]] : [pointSize];\n            }\n          };\n          featureLayout = {\n            sizePerElement: 0,\n            elements: []\n          };\n          verticesNum = 0;\n          indices = [];\n          size = 3;\n          features.forEach(function (feature, featureIdx) {\n            var _triangulation = triangulation(feature),\n              indicesForCurrentFeature = _triangulation.indices,\n              verticesForCurrentFeature = _triangulation.vertices,\n              normalsForCurrentFeature = _triangulation.normals,\n              vertexSize = _triangulation.size,\n              indexes = _triangulation.indexes;\n            indicesForCurrentFeature.forEach(function (i) {\n              indices.push(i + verticesNum);\n            });\n            size = vertexSize;\n            var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;\n            featureLayout.sizePerElement = size;\n            featureLayout.elements.push({\n              featureIdx: featureIdx,\n              vertices: verticesForCurrentFeature,\n              normals: normalsForCurrentFeature,\n              offset: verticesNum\n            });\n            verticesNum += verticesNumForCurrentFeature;\n            var _loop = function _loop(vertexIdx) {\n              var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];\n              var vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);\n              var vertexIndex = 0;\n              if (indexes && indexes[vertexIdx] !== undefined) {\n                vertexIndex = indexes[vertexIdx];\n              }\n              descriptors.forEach(function (descriptor) {\n                // @ts-ignore\n                if (descriptor && updateFuncs[descriptor.name]) {\n                  var _descriptor$buffer$da;\n                  // @ts-ignore\n                  (_descriptor$buffer$da = descriptor.buffer.data).push.apply(_descriptor$buffer$da, _toConsumableArray(updateFuncs[descriptor.name](feature, featureIdx, vertice, vertexIdx, normal, vertexIndex)));\n                }\n              });\n            };\n            for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {\n              _loop(vertexIdx);\n            }\n          });\n          return _context.abrupt(\"return\", {\n            descriptors: descriptors,\n            featureLayout: featureLayout,\n            indices: indices\n          });\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function pointFillModel(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}