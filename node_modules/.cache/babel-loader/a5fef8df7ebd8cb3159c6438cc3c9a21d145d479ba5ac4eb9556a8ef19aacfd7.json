{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __extends } from \"tslib\";\nimport { each, isArray, isFunction, isString, debounce, throttle } from '@antv/util';\nimport { createAction, createCallbackAction } from './action/register';\nimport InteractionContext from './context';\nimport Interaction from './interaction';\n// 将字符串转换成 action\nexport function parseAction(actionStr, context, arg) {\n  var arr = actionStr.split(':');\n  var actionName = arr[0];\n  // 如果已经初始化过 action ，则直接引用之前的 action\n  var action = context.getAction(actionName) || createAction(actionName, context);\n  if (!action) {\n    throw new Error(\"There is no action named \".concat(actionName));\n  }\n  var methodName = arr[1];\n  return {\n    action: action,\n    methodName: methodName,\n    arg: arg\n  };\n}\n// 执行 Action\nfunction executeAction(actionObject) {\n  var action = actionObject.action,\n    methodName = actionObject.methodName,\n    arg = actionObject.arg;\n  if (action[methodName]) {\n    action[methodName](arg);\n  } else {\n    throw new Error(\"Action(\".concat(action.name, \") doesn't have a method called \").concat(methodName));\n  }\n}\nvar STEP_NAMES = {\n  START: 'start',\n  SHOW_ENABLE: 'showEnable',\n  END: 'end',\n  ROLLBACK: 'rollback',\n  PROCESSING: 'processing'\n};\n/**\n * 支持语法的交互类\n */\nvar GrammarInteraction = /** @class */function (_super) {\n  __extends(GrammarInteraction, _super);\n  function GrammarInteraction(view, steps) {\n    var _this = _super.call(this, view, steps) || this;\n    _this.callbackCaches = {};\n    // 某个触发和反馈在本环节是否执行或\n    _this.emitCaches = {};\n    _this.steps = steps;\n    return _this;\n  }\n  /**\n   * 初始化\n   */\n  GrammarInteraction.prototype.init = function () {\n    this.initContext();\n    _super.prototype.init.call(this);\n  };\n  /**\n   * 清理资源\n   */\n  GrammarInteraction.prototype.destroy = function () {\n    _super.prototype.destroy.call(this); // 先清理事件\n    this.steps = null;\n    if (this.context) {\n      this.context.destroy();\n      this.context = null;\n    }\n    this.callbackCaches = null;\n    this.view = null;\n  };\n  /**\n   * 绑定事件\n   */\n  GrammarInteraction.prototype.initEvents = function () {\n    var _this = this;\n    each(this.steps, function (stepArr, stepName) {\n      each(stepArr, function (step) {\n        var callback = _this.getActionCallback(stepName, step);\n        if (callback) {\n          // 如果存在 callback，才绑定，有时候会出现无 callback 的情况\n          _this.bindEvent(step.trigger, callback);\n        }\n      });\n    });\n  };\n  /**\n   * 清理绑定的事件\n   */\n  GrammarInteraction.prototype.clearEvents = function () {\n    var _this = this;\n    each(this.steps, function (stepArr, stepName) {\n      each(stepArr, function (step) {\n        var callback = _this.getActionCallback(stepName, step);\n        if (callback) {\n          _this.offEvent(step.trigger, callback);\n        }\n      });\n    });\n  };\n  // 初始化上下文，并初始化 action\n  GrammarInteraction.prototype.initContext = function () {\n    var view = this.view;\n    var context = new InteractionContext(view);\n    this.context = context;\n    var steps = this.steps;\n    // 生成具体的 Action\n    each(steps, function (subSteps) {\n      each(subSteps, function (step) {\n        if (isFunction(step.action)) {\n          // 如果传入回调函数，则直接生成 CallbackAction\n          step.actionObject = {\n            action: createCallbackAction(step.action, context),\n            methodName: 'execute'\n          };\n        } else if (isString(step.action)) {\n          // 如果是字符串\n          step.actionObject = parseAction(step.action, context, step.arg);\n        } else if (isArray(step.action)) {\n          // 如果是数组\n          var actionArr = step.action;\n          var argArr_1 = isArray(step.arg) ? step.arg : [step.arg];\n          step.actionObject = [];\n          each(actionArr, function (actionStr, idx) {\n            step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));\n          });\n        }\n        // 如果 action 既不是字符串，也不是函数，则不会生成 actionObject\n      });\n    });\n  };\n  // 是否允许指定阶段名称执行\n  GrammarInteraction.prototype.isAllowStep = function (stepName) {\n    var currentStepName = this.currentStepName;\n    var steps = this.steps;\n    // 相同的阶段允许同时执行\n    if (currentStepName === stepName) {\n      return true;\n    }\n    if (stepName === STEP_NAMES.SHOW_ENABLE) {\n      // 示能在整个过程中都可用\n      return true;\n    }\n    if (stepName === STEP_NAMES.PROCESSING) {\n      // 只有当前是 start 时，才允许 processing\n      return currentStepName === STEP_NAMES.START;\n    }\n    if (stepName === STEP_NAMES.START) {\n      // 如果当前是 processing，则无法 start，必须等待 end 后才能执行\n      return currentStepName !== STEP_NAMES.PROCESSING;\n    }\n    if (stepName === STEP_NAMES.END) {\n      return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;\n    }\n    if (stepName === STEP_NAMES.ROLLBACK) {\n      if (steps[STEP_NAMES.END]) {\n        // 如果定义了 end, 只有 end 时才允许回滚\n        return currentStepName === STEP_NAMES.END;\n      } else if (currentStepName === STEP_NAMES.START) {\n        // 如果未定义 end, 则判断是否是开始\n        return true;\n      }\n    }\n    return false;\n  };\n  // 具体的指定阶段是否允许执行\n  GrammarInteraction.prototype.isAllowExecute = function (stepName, step) {\n    if (this.isAllowStep(stepName)) {\n      var key = this.getKey(stepName, step);\n      // 如果是在本环节内仅允许触发一次，同时已经触发过，则不允许再触发\n      if (step.once && this.emitCaches[key]) {\n        return false;\n      }\n      // 如果是允许的阶段，则验证 isEnable 方法\n      if (step.isEnable) {\n        return step.isEnable(this.context);\n      }\n      return true; // 如果没有 isEnable 则允许执行\n    }\n\n    return false;\n  };\n  GrammarInteraction.prototype.enterStep = function (stepName) {\n    this.currentStepName = stepName;\n    this.emitCaches = {}; // 清除所有本环节触发的缓存\n  };\n  // 执行完某个触发和反馈（子环节）\n  GrammarInteraction.prototype.afterExecute = function (stepName, step) {\n    // show enable 不计入正常的流程，其他情况则设置当前的 step\n    if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {\n      this.enterStep(stepName);\n    }\n    var key = this.getKey(stepName, step);\n    // 一旦执行，则缓存标记为，一直保持到跳出改环节\n    this.emitCaches[key] = true;\n  };\n  // 获取某个环节的唯一的键值\n  GrammarInteraction.prototype.getKey = function (stepName, step) {\n    return stepName + step.trigger + step.action;\n  };\n  // 获取 step 的回调函数，如果已经生成，则直接返回，如果未生成，则创建\n  GrammarInteraction.prototype.getActionCallback = function (stepName, step) {\n    var _this = this;\n    var context = this.context;\n    var callbackCaches = this.callbackCaches;\n    var actionObject = step.actionObject;\n    if (step.action && actionObject) {\n      var key = this.getKey(stepName, step);\n      if (!callbackCaches[key]) {\n        // 动态生成执行的方法，执行对应 action 的名称\n        var actionCallback = function (event) {\n          context.event = event; // 保证检测时的 event\n          if (_this.isAllowExecute(stepName, step)) {\n            // 如果是数组时，则依次执行\n            if (isArray(actionObject)) {\n              each(actionObject, function (obj) {\n                context.event = event; // 可能触发新的事件，保证执行前的 context.event 是正确的\n                executeAction(obj);\n              });\n            } else {\n              context.event = event; // 保证执行前的 context.event 是正确的\n              executeAction(actionObject);\n            }\n            _this.afterExecute(stepName, step);\n            if (step.callback) {\n              context.event = event; // 保证执行前的 context.event 是正确的\n              step.callback(context);\n            }\n          } else {\n            // 如果未通过验证，则事件不要绑定在上面\n            context.event = null;\n          }\n        };\n        // 如果设置了 debounce\n        if (step.debounce) {\n          callbackCaches[key] = debounce(actionCallback, step.debounce.wait, step.debounce.immediate);\n        } else if (step.throttle) {\n          // 设置 throttle\n          callbackCaches[key] = throttle(actionCallback, step.throttle.wait, {\n            leading: step.throttle.leading,\n            trailing: step.throttle.trailing\n          });\n        } else {\n          // 直接设置\n          callbackCaches[key] = actionCallback;\n        }\n      }\n      return callbackCaches[key];\n    }\n    return null;\n  };\n  GrammarInteraction.prototype.bindEvent = function (eventName, callback) {\n    var nameArr = eventName.split(':');\n    if (nameArr[0] === 'window') {\n      window.addEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.addEventListener(nameArr[1], callback);\n    } else {\n      this.view.on(eventName, callback);\n    }\n  };\n  GrammarInteraction.prototype.offEvent = function (eventName, callback) {\n    var nameArr = eventName.split(':');\n    if (nameArr[0] === 'window') {\n      window.removeEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.removeEventListener(nameArr[1], callback);\n    } else {\n      this.view.off(eventName, callback);\n    }\n  };\n  return GrammarInteraction;\n}(Interaction);\nexport default GrammarInteraction;","map":{"version":3,"names":["each","isArray","isFunction","isString","debounce","throttle","createAction","createCallbackAction","InteractionContext","Interaction","parseAction","actionStr","context","arg","arr","split","actionName","action","getAction","Error","concat","methodName","executeAction","actionObject","name","STEP_NAMES","START","SHOW_ENABLE","END","ROLLBACK","PROCESSING","GrammarInteraction","_super","__extends","view","steps","_this","call","callbackCaches","emitCaches","prototype","init","initContext","destroy","initEvents","stepArr","stepName","step","callback","getActionCallback","bindEvent","trigger","clearEvents","offEvent","subSteps","actionArr","argArr_1","idx","push","isAllowStep","currentStepName","isAllowExecute","key","getKey","once","isEnable","enterStep","afterExecute","actionCallback","event","obj","wait","immediate","leading","trailing","eventName","nameArr","window","addEventListener","document","on","removeEventListener","off"],"sources":["../../src/interaction/grammar-interaction.ts"],"sourcesContent":["import { each, isArray, isFunction, isString, debounce, throttle } from '@antv/util';\nimport { View } from '../chart';\nimport { ActionCallback, IAction, IInteractionContext, LooseObject } from '../interface';\nimport { createAction, createCallbackAction } from './action/register';\nimport InteractionContext from './context';\nimport Interaction from './interaction';\n\n// 将字符串转换成 action\nexport function parseAction(actionStr: string, context: IInteractionContext, arg?: any): ActionObject {\n  const arr = actionStr.split(':');\n  const actionName = arr[0];\n  // 如果已经初始化过 action ，则直接引用之前的 action\n  const action = context.getAction(actionName) || createAction(actionName, context);\n  if (!action) {\n    throw new Error(`There is no action named ${actionName}`);\n  }\n  const methodName = arr[1];\n  return {\n    action,\n    methodName,\n    arg,\n  };\n}\n\n// 执行 Action\nfunction executeAction(actionObject: ActionObject) {\n  const { action, methodName, arg } = actionObject;\n  if (action[methodName]) {\n    action[methodName](arg);\n  } else {\n    throw new Error(`Action(${action.name}) doesn't have a method called ${methodName}`);\n  }\n}\n\nconst STEP_NAMES = {\n  START: 'start',\n  SHOW_ENABLE: 'showEnable',\n  END: 'end',\n  ROLLBACK: 'rollback',\n  PROCESSING: 'processing',\n};\n\n/** 交互环节的定义 */\nexport interface InteractionStep {\n  /**\n   * 触发事件，支持 view，chart 的各种事件，也支持 document、window 的事件\n   */\n  trigger: string;\n  /**\n   * 是否可以触发 action\n   * @param context - 交互的上下文\n   */\n  isEnable?: (context: IInteractionContext) => boolean;\n  /**\n   * 反馈，支持三种方式：\n   * - action:method : action 的名字和方法的组合\n   * - [’action1:method1‘, ’action2:method‘]\n   * - ActionCallback: 回调函数\n   */\n  action: string | string[] | ActionCallback;\n  /**\n   * 反馈，具体 action method 的参数：\n   * - 当传递多个 action 时，args 必须是一个数组\n   */\n  arg?: any | any[];\n  /**\n   * 回调函数，action 执行后执行\n   */\n  callback?: (context: IInteractionContext) => void;\n  /**\n   * @private\n   * 不需要用户传入，通过上面的属性计算出来的属性\n   */\n  actionObject?: ActionObject | ActionObject[];\n  /**\n   * 在一个环节内是否只允许执行一次\n   */\n  once?: boolean;\n  /**\n   * 是否增加节流\n   */\n  throttle?: ThrottleOption;\n  /**\n   * 是否延迟\n   */\n  debounce?: DebounceOption;\n}\n\n// action 执行时支持 debounce 和 throttle，可以参考：https://css-tricks.com/debouncing-throttling-explained-examples/\n/**\n * debounce 的配置\n */\nexport interface DebounceOption {\n  /**\n   * 等待时间\n   */\n  wait: number;\n  /**\n   * 是否马上执行\n   */\n  immediate?: boolean;\n}\n\n/**\n * throttle 的配置\n */\nexport interface ThrottleOption {\n  /**\n   * 等待时间\n   */\n  wait: number;\n  /**\n   * 马上就执行\n   */\n  leading?: boolean;\n  /**\n   * 执行完毕后再执行一次\n   */\n  trailing?: boolean;\n}\n\n/** 缓存 action 对象，仅用于当前文件 */\ninterface ActionObject {\n  /**\n   * 缓存的 action\n   */\n  action: IAction;\n  /**\n   * action 的方法\n   */\n  methodName: string;\n  /**\n   * 用户传递的 action 方法的参数\n   */\n  arg?: any;\n}\n\n/** 交互的所有环节 */\nexport interface InteractionSteps {\n  /**\n   * 显示交互可以进行\n   */\n  showEnable?: InteractionStep[];\n  /**\n   * 交互开始\n   */\n  start?: InteractionStep[];\n  /**\n   * 交互持续\n   */\n  processing?: InteractionStep[];\n  /**\n   * 交互结束\n   */\n  end?: InteractionStep[];\n  /**\n   * 交互回滚\n   */\n  rollback?: InteractionStep[];\n}\n\n/**\n * 支持语法的交互类\n */\nexport default class GrammarInteraction extends Interaction {\n  // 存储的交互环节\n  private steps: InteractionSteps;\n  /** 当前执行到的阶段 */\n  public currentStepName: string;\n  /**\n   * 当前交互的上下文\n   */\n  public context: IInteractionContext;\n\n  private callbackCaches: LooseObject = {};\n  // 某个触发和反馈在本环节是否执行或\n  private emitCaches: LooseObject = {};\n\n  constructor(view: View, steps: InteractionSteps) {\n    super(view, steps);\n    this.steps = steps;\n  }\n\n  /**\n   * 初始化\n   */\n  public init() {\n    this.initContext();\n    super.init();\n  }\n\n  /**\n   * 清理资源\n   */\n  public destroy() {\n    super.destroy(); // 先清理事件\n    this.steps = null;\n    if (this.context) {\n      this.context.destroy();\n      this.context = null;\n    }\n\n    this.callbackCaches = null;\n    this.view = null;\n  }\n\n  /**\n   * 绑定事件\n   */\n  protected initEvents() {\n    each(this.steps, (stepArr, stepName) => {\n      each(stepArr, (step) => {\n        const callback = this.getActionCallback(stepName, step);\n        if (callback) {\n          // 如果存在 callback，才绑定，有时候会出现无 callback 的情况\n          this.bindEvent(step.trigger, callback);\n        }\n      });\n    });\n  }\n\n  /**\n   * 清理绑定的事件\n   */\n  protected clearEvents() {\n    each(this.steps, (stepArr, stepName) => {\n      each(stepArr, (step) => {\n        const callback = this.getActionCallback(stepName, step);\n        if (callback) {\n          this.offEvent(step.trigger, callback);\n        }\n      });\n    });\n  }\n\n  // 初始化上下文，并初始化 action\n  private initContext() {\n    const view = this.view;\n    const context = new InteractionContext(view);\n    this.context = context;\n    const steps = this.steps;\n    // 生成具体的 Action\n    each(steps, (subSteps: InteractionStep[]) => {\n      each(subSteps, (step: InteractionStep) => {\n        if (isFunction(step.action)) {\n          // 如果传入回调函数，则直接生成 CallbackAction\n          step.actionObject = {\n            action: createCallbackAction(step.action, context),\n            methodName: 'execute',\n          };\n        } else if (isString(step.action)) {\n          // 如果是字符串\n          step.actionObject = parseAction(step.action, context, step.arg);\n        } else if (isArray(step.action)) {\n          // 如果是数组\n          const actionArr = step.action;\n          const argArr = isArray(step.arg) ? step.arg : [step.arg];\n          step.actionObject = [];\n          each(actionArr, (actionStr, idx) => {\n            (step.actionObject as ActionObject[]).push(parseAction(actionStr, context, argArr[idx]));\n          });\n        }\n        // 如果 action 既不是字符串，也不是函数，则不会生成 actionObject\n      });\n    });\n  }\n\n  // 是否允许指定阶段名称执行\n  private isAllowStep(stepName: string): boolean {\n    const currentStepName = this.currentStepName;\n    const steps = this.steps;\n    // 相同的阶段允许同时执行\n    if (currentStepName === stepName) {\n      return true;\n    }\n\n    if (stepName === STEP_NAMES.SHOW_ENABLE) {\n      // 示能在整个过程中都可用\n      return true;\n    }\n\n    if (stepName === STEP_NAMES.PROCESSING) {\n      // 只有当前是 start 时，才允许 processing\n      return currentStepName === STEP_NAMES.START;\n    }\n\n    if (stepName === STEP_NAMES.START) {\n      // 如果当前是 processing，则无法 start，必须等待 end 后才能执行\n      return currentStepName !== STEP_NAMES.PROCESSING;\n    }\n\n    if (stepName === STEP_NAMES.END) {\n      return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;\n    }\n\n    if (stepName === STEP_NAMES.ROLLBACK) {\n      if (steps[STEP_NAMES.END]) {\n        // 如果定义了 end, 只有 end 时才允许回滚\n        return currentStepName === STEP_NAMES.END;\n      } else if (currentStepName === STEP_NAMES.START) {\n        // 如果未定义 end, 则判断是否是开始\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // 具体的指定阶段是否允许执行\n  private isAllowExecute(stepName: string, step: InteractionStep): boolean {\n    if (this.isAllowStep(stepName)) {\n      const key = this.getKey(stepName, step);\n      // 如果是在本环节内仅允许触发一次，同时已经触发过，则不允许再触发\n      if (step.once && this.emitCaches[key]) {\n        return false;\n      }\n      // 如果是允许的阶段，则验证 isEnable 方法\n      if (step.isEnable) {\n        return step.isEnable(this.context);\n      }\n      return true; // 如果没有 isEnable 则允许执行\n    }\n    return false;\n  }\n\n  private enterStep(stepName: string) {\n    this.currentStepName = stepName;\n    this.emitCaches = {}; // 清除所有本环节触发的缓存\n  }\n\n  // 执行完某个触发和反馈（子环节）\n  private afterExecute(stepName: string, step) {\n    // show enable 不计入正常的流程，其他情况则设置当前的 step\n    if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {\n      this.enterStep(stepName);\n    }\n    const key = this.getKey(stepName, step);\n    // 一旦执行，则缓存标记为，一直保持到跳出改环节\n    this.emitCaches[key] = true;\n  }\n  // 获取某个环节的唯一的键值\n  private getKey(stepName, step) {\n    return stepName + step.trigger + step.action;\n  }\n\n  // 获取 step 的回调函数，如果已经生成，则直接返回，如果未生成，则创建\n  private getActionCallback(stepName: string, step: InteractionStep): (e: object) => void {\n    const context = this.context;\n    const callbackCaches = this.callbackCaches;\n    const actionObject = step.actionObject;\n    if (step.action && actionObject) {\n      const key = this.getKey(stepName, step);\n      if (!callbackCaches[key]) {\n        // 动态生成执行的方法，执行对应 action 的名称\n        const actionCallback = (event) => {\n          context.event = event; // 保证检测时的 event\n          if (this.isAllowExecute(stepName, step)) {\n            // 如果是数组时，则依次执行\n            if (isArray(actionObject)) {\n              each(actionObject, (obj: ActionObject) => {\n                context.event = event; // 可能触发新的事件，保证执行前的 context.event 是正确的\n                executeAction(obj);\n              });\n            } else {\n              context.event = event; // 保证执行前的 context.event 是正确的\n              executeAction(actionObject);\n            }\n            this.afterExecute(stepName, step);\n            if (step.callback) {\n              context.event = event; // 保证执行前的 context.event 是正确的\n              step.callback(context);\n            }\n          } else {\n            // 如果未通过验证，则事件不要绑定在上面\n            context.event = null;\n          }\n        };\n        // 如果设置了 debounce\n        if (step.debounce) {\n          callbackCaches[key] = debounce(actionCallback, step.debounce.wait, step.debounce.immediate);\n        } else if (step.throttle) {\n          // 设置 throttle\n          callbackCaches[key] = throttle(actionCallback, step.throttle.wait, {\n            leading: step.throttle.leading,\n            trailing: step.throttle.trailing,\n          });\n        } else {\n          // 直接设置\n          callbackCaches[key] = actionCallback;\n        }\n      }\n      return callbackCaches[key];\n    }\n    return null;\n  }\n\n  private bindEvent(eventName, callback) {\n    const nameArr = eventName.split(':');\n    if (nameArr[0] === 'window') {\n      window.addEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.addEventListener(nameArr[1], callback);\n    } else {\n      this.view.on(eventName, callback);\n    }\n  }\n\n  private offEvent(eventName, callback) {\n    const nameArr = eventName.split(':');\n    if (nameArr[0] === 'window') {\n      window.removeEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.removeEventListener(nameArr[1], callback);\n    } else {\n      this.view.off(eventName, callback);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}