{"ast":null,"code":"import { __values } from \"tslib\";\nimport { each, get, isNil, deepMix, groupBy } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { antiCollision } from './util';\nimport { translate } from '../../../../util/transform';\n/** 拐点偏移量, 暂不可配置 */\nvar INFLECTION_OFFSET = 4;\n/** 标签偏移量, distance between label and edge: offsetX */\nvar LABEL_OFFSET_X = 4;\n/** 标签与牵引线的偏移量 */\nvar LABEL_TEXT_LINE_OFFSET = 4;\nfunction drawLabelline(item, coordinate, inRight) {\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n  var radius = coordinate.getRadius();\n  var startPoint = {\n    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),\n    y: item.y\n  };\n  var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n  var p1 = {\n    x: startPoint.x,\n    y: startPoint.y\n  };\n  var p2 = {\n    x: inflectionPoint.x,\n    y: inflectionPoint.y\n  };\n  var endPoint = polarToCartesian(center.x, center.y, radius, item.angle);\n  var path = '';\n  // 文本被调整下去了，则添加拐点连接线\n  if (startPoint.y !== inflectionPoint.y) {\n    var offset = inRight ? 4 : -4;\n    p1.y = startPoint.y;\n    /** 是否在第一象限 */\n    if (item.angle < 0 && item.angle >= -Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第二象限 */\n    if (item.angle > 0 && item.angle < Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第三象限 */\n    if (item.angle > Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第四象限 */\n    if (item.angle < -Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n  }\n  path = [\"M \".concat(startPoint.x, \",\").concat(startPoint.y), \"L \".concat(p1.x, \",\").concat(p1.y), \"L \".concat(p2.x, \",\").concat(p2.y), \"L \".concat(inflectionPoint.x, \",\").concat(inflectionPoint.y), \"L \".concat(endPoint.x, \",\").concat(endPoint.y)].join(' ');\n  item.labelLine = deepMix({}, item.labelLine, {\n    path: path\n  });\n}\n/**\n * 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型\n * region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)\n */\nexport function pieSpiderLabelLayout(items, labels, shapes, region) {\n  var e_1, _a;\n  /** 坐标系 */\n  var coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n  var radius = coordinate.getRadius();\n  /** label shapes */\n  var labelsMap = {};\n  try {\n    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {\n      var labelShape = labels_1_1.value;\n      labelsMap[labelShape.get('id')] = labelShape;\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (labels_1_1 && !labels_1_1.done && (_a = labels_1.return)) _a.call(labels_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  var labelHeight = get(items[0], 'labelHeight', 14);\n  var labelOffset = Math.max(get(items[0], 'offset', 0), INFLECTION_OFFSET);\n  // step 1: adjust items to spider\n  each(items, function (item) {\n    if (!item) return;\n    var label = get(labelsMap, [item.id]);\n    if (!label) return;\n    var inRight = item.x > center.x || item.x === center.x && item.y > center.y;\n    var offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;\n    var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n    var totalOffset = labelOffset + offsetX;\n    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);\n    item.y = inflectionPoint.y;\n  });\n  var start = coordinate.start,\n    end = coordinate.end;\n  var LEFT_HALF_KEY = 'left';\n  var RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  var separateLabels = groupBy(items, function (item) {\n    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;\n  });\n  // step2: calculate totalHeight\n  var totalHeight = (radius + labelOffset) * 2 + labelHeight;\n  each(separateLabels, function (half) {\n    var halfHeight = half.length * labelHeight;\n    if (halfHeight > totalHeight) {\n      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));\n    }\n  });\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  var labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalHeight / 2,\n    maxY: center.y + totalHeight / 2\n  };\n  // step 3: antiCollision\n  each(separateLabels, function (half, key) {\n    var maxLabelsCountForOneSide = totalHeight / labelHeight;\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort(function (a, b) {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n      each(half, function (labelItem, idx) {\n        if (idx > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n  var startY = labelsContainerRange.minY;\n  var endY = labelsContainerRange.maxY;\n  // step4: applyTo labels and adjust labelLines\n  each(separateLabels, function (half, key) {\n    var inRight = key === RIGHT_HALF_KEY;\n    each(half, function (item) {\n      var label = get(labelsMap, item && [item.id]);\n      if (!label) {\n        return;\n      }\n      // out of range, hidden\n      if (item.y < startY || item.y > endY) {\n        label.set('visible', false);\n        return;\n      }\n      var labelContent = label.getChildByIndex(0);\n      var box = labelContent.getCanvasBBox();\n      var originalPos = {\n        x: inRight ? box.x : box.maxX,\n        y: box.y + box.height / 2 /** vertical-align: middle */\n      };\n      translate(labelContent, item.x - originalPos.x /** 从 pos.x 移动到 item.x */, item.y - originalPos.y);\n      // adjust labelLines\n      if (item.labelLine) {\n        drawLabelline(item, coordinate, inRight);\n      }\n    });\n  });\n}","map":{"version":3,"names":["each","get","isNil","deepMix","groupBy","polarToCartesian","antiCollision","translate","INFLECTION_OFFSET","LABEL_OFFSET_X","LABEL_TEXT_LINE_OFFSET","drawLabelline","item","coordinate","inRight","center","getCenter","radius","getRadius","startPoint","x","y","inflectionPoint","angle","p1","p2","endPoint","path","offset","Math","PI","max","min","concat","join","labelLine","pieSpiderLabelLayout","items","labels","shapes","region","labelsMap","labels_1","__values","labels_1_1","next","done","labelShape","value","labelHeight","labelOffset","label","id","offsetX","totalOffset","start","end","LEFT_HALF_KEY","RIGHT_HALF_KEY","separateLabels","totalHeight","half","halfHeight","length","abs","labelsContainerRange","minX","maxX","minY","maxY","key","maxLabelsCountForOneSide","sort","a","b","percent","labelItem","idx","set","invisible","startY","endY","labelContent","getChildByIndex","box","getCanvasBBox","originalPos","height"],"sources":["../../../../../src/geometry/label/layout/pie/spider.ts"],"sourcesContent":["import { BBox, IGroup, IShape } from '@antv/g-base';\nimport { each, get, isNil, deepMix, groupBy } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { LabelItem, PolarLabelItem } from '../../interface';\nimport { antiCollision } from './util';\nimport { translate } from '../../../../util/transform';\nimport { Coordinate } from '@antv/coord';\n\n/** 拐点偏移量, 暂不可配置 */\nconst INFLECTION_OFFSET = 4;\n/** 标签偏移量, distance between label and edge: offsetX */\nconst LABEL_OFFSET_X = 4;\n/** 标签与牵引线的偏移量 */\nconst LABEL_TEXT_LINE_OFFSET = 4;\n\nfunction drawLabelline(item: PolarLabelItem, coordinate: Coordinate, inRight: boolean) {\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  const startPoint = {\n    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),\n    y: item.y,\n  };\n  const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n  const p1 = { x: startPoint.x, y: startPoint.y };\n  const p2 = { x: inflectionPoint.x, y: inflectionPoint.y };\n\n  const endPoint = polarToCartesian(center.x, center.y, radius, item.angle);\n  let path = '';\n\n  // 文本被调整下去了，则添加拐点连接线\n  if (startPoint.y !== inflectionPoint.y) {\n    const offset = inRight ? 4 : -4;\n    p1.y = startPoint.y;\n\n    /** 是否在第一象限 */\n    if (item.angle < 0 && item.angle >= -Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第二象限 */\n    if (item.angle > 0 && item.angle < Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第三象限 */\n    if (item.angle > Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第四象限 */\n    if (item.angle < -Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n  }\n\n  path = [\n    `M ${startPoint.x},${startPoint.y}`,\n    `L ${p1.x},${p1.y}`,\n    `L ${p2.x},${p2.y}`,\n    `L ${inflectionPoint.x},${inflectionPoint.y}`,\n    `L ${endPoint.x},${endPoint.y}`,\n  ].join(' ');\n  item.labelLine = deepMix({}, item.labelLine, { path });\n}\n\n/**\n * 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型\n * region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)\n */\nexport function pieSpiderLabelLayout(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  /** 坐标系 */\n  const coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  /** label shapes */\n  const labelsMap: Record<string /** id */, IGroup> = {};\n  for (const labelShape of labels) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  const labelHeight: number = get(items[0], 'labelHeight', 14);\n  const labelOffset: number = Math.max(get(items[0], 'offset', 0), INFLECTION_OFFSET);\n\n  // step 1: adjust items to spider\n  each(items, (item) => {\n    if (!item) return;\n    const label = get(labelsMap, [item.id]);\n    if (!label) return;\n\n    const inRight = item.x > center.x || (item.x === center.x && item.y > center.y);\n    const offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;\n    const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n\n    const totalOffset = labelOffset + offsetX;\n    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);\n    item.y = inflectionPoint.y;\n  });\n\n  const { start, end } = coordinate;\n  const LEFT_HALF_KEY = 'left';\n  const RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  const separateLabels = groupBy(items, (item) => (item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY));\n\n  // step2: calculate totalHeight\n  let totalHeight = (radius + labelOffset) * 2 + labelHeight;\n\n  each(separateLabels, (half: PolarLabelItem[]) => {\n    const halfHeight = half.length * labelHeight;\n    if (halfHeight > totalHeight) {\n      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));\n    }\n  });\n\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  const labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalHeight / 2,\n    maxY: center.y + totalHeight / 2,\n  };\n\n  // step 3: antiCollision\n  each(separateLabels, (half, key) => {\n    const maxLabelsCountForOneSide = totalHeight / labelHeight;\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort((a, b) => {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n\n      each(half, (labelItem: PolarLabelItem, idx) => {\n        if (idx > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n\n  const startY = labelsContainerRange.minY;\n  const endY = labelsContainerRange.maxY;\n\n  // step4: applyTo labels and adjust labelLines\n  each(separateLabels, (half, key) => {\n    const inRight = key === RIGHT_HALF_KEY;\n\n    each(half, (item) => {\n      const label: IGroup = get(labelsMap, item && [item.id]);\n      if (!label) {\n        return;\n      }\n      // out of range, hidden\n      if (item.y < startY || item.y > endY) {\n        label.set('visible', false);\n        return;\n      }\n\n      const labelContent = label.getChildByIndex(0);\n      const box = labelContent.getCanvasBBox();\n      const originalPos = { x: inRight ? box.x : box.maxX, y: box.y + box.height / 2 /** vertical-align: middle */ };\n\n      translate(labelContent as any, item.x - originalPos.x /** 从 pos.x 移动到 item.x */, item.y - originalPos.y);\n\n      // adjust labelLines\n      if (item.labelLine) {\n        drawLabelline(item, coordinate, inRight);\n      }\n    });\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}