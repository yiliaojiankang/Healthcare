{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isArray } from '@antv/util';\n/**\n * 根据 edges 获取对应的 node 结构\n */\nexport function getNodes(edges, sourceField, targetField) {\n  var nodes = [];\n  edges.forEach(function (e) {\n    var source = e[sourceField];\n    var target = e[targetField];\n    if (!nodes.includes(source)) {\n      nodes.push(source);\n    }\n    if (!nodes.includes(target)) {\n      nodes.push(target);\n    }\n  });\n  return nodes;\n}\n/**\n * 根据 edges 获取对应的 dfs 邻接矩阵\n */\nexport function getMatrix(edges, nodes, sourceField, targetField) {\n  var graphMatrix = {};\n  nodes.forEach(function (pre) {\n    graphMatrix[pre] = {};\n    nodes.forEach(function (next) {\n      graphMatrix[pre][next] = 0;\n    });\n  });\n  edges.forEach(function (edge) {\n    graphMatrix[edge[sourceField]][edge[targetField]] = 1;\n  });\n  return graphMatrix;\n}\n/**\n * 使用 DFS 思路切断桑基图数据中的环（会丢失数据），保证顺序\n * @param data\n * @param sourceField\n * @param targetField\n */\nexport function cutoffCircle(edges, sourceField, targetField) {\n  if (!isArray(edges)) return [];\n  // 待删除的环状结构\n  var removedData = [];\n  // 获取所有的节点\n  var nodes = getNodes(edges, sourceField, targetField);\n  // 获取节点与边的邻接矩阵\n  var graphMatrix = getMatrix(edges, nodes, sourceField, targetField);\n  // visited：标记节点访问状态, 0：未访问,1：访问中, -1：已访问\n  var visited = {};\n  // 初始化visited\n  nodes.forEach(function (node) {\n    visited[node] = 0;\n  });\n  // 图的深度遍历函数\n  function DFS(dfsNode) {\n    // 节点状态置为正在访问\n    visited[dfsNode] = 1;\n    nodes.forEach(function (node) {\n      if (graphMatrix[dfsNode][node] != 0) {\n        // 当前节点在访问中，再次被访问，证明有环，移动到 removeData\n        if (visited[node] == 1) {\n          // 拼接为字符串，方便最后过滤\n          removedData.push(\"\".concat(dfsNode, \"_\").concat(node));\n        } else if (visited[node] == -1) {\n          // 当前结点及后边的结点都被访问过，直接跳至下一个结点\n          return;\n        } else {\n          DFS(node); // 否则递归访问\n        }\n      }\n    });\n    //遍历过所有相连的结点后，把本节点标记为-1\n    visited[dfsNode] = -1;\n  }\n  // 对每个节点执行 dfs 操作\n  nodes.forEach(function (node) {\n    //该结点后边的结点都被访问过了，跳过它\n    if (visited[node] == -1) {\n      return;\n    }\n    DFS(node);\n  });\n  if (removedData.length !== 0) {\n    console.warn(\"sankey data contains circle, \".concat(removedData.length, \" records removed.\"), removedData);\n  }\n  // 过滤 remove 路径\n  return edges.filter(function (edge) {\n    return removedData.findIndex(function (i) {\n      return i === \"\".concat(edge[sourceField], \"_\").concat(edge[targetField]);\n    }) < 0;\n  });\n}","map":{"version":3,"names":["isArray","getNodes","edges","sourceField","targetField","nodes","forEach","e","source","target","includes","push","getMatrix","graphMatrix","pre","next","edge","cutoffCircle","removedData","visited","node","DFS","dfsNode","concat","length","console","warn","filter","findIndex","i"],"sources":["../../../src/plots/sankey/circle.ts"],"sourcesContent":["import { isArray } from '@antv/util';\nimport { Data } from '../../types';\n\n/**\n * 根据 edges 获取对应的 node 结构\n */\nexport function getNodes(edges: Data, sourceField: string, targetField: string): string[] {\n  const nodes = [];\n  edges.forEach((e) => {\n    const source = e[sourceField] as string;\n    const target = e[targetField] as string;\n    if (!nodes.includes(source)) {\n      nodes.push(source);\n    }\n    if (!nodes.includes(target)) {\n      nodes.push(target);\n    }\n  });\n  return nodes;\n}\n\n/**\n * 根据 edges 获取对应的 dfs 邻接矩阵\n */\nexport function getMatrix(\n  edges: Data,\n  nodes: string[],\n  sourceField: string,\n  targetField: string\n): Record<string, Record<string, number>> {\n  const graphMatrix = {};\n\n  nodes.forEach((pre) => {\n    graphMatrix[pre] = {};\n    nodes.forEach((next) => {\n      graphMatrix[pre][next] = 0;\n    });\n  });\n\n  edges.forEach((edge) => {\n    graphMatrix[edge[sourceField]][edge[targetField]] = 1;\n  });\n\n  return graphMatrix;\n}\n\n/**\n * 使用 DFS 思路切断桑基图数据中的环（会丢失数据），保证顺序\n * @param data\n * @param sourceField\n * @param targetField\n */\nexport function cutoffCircle(edges: Data, sourceField: string, targetField: string): Data {\n  if (!isArray(edges)) return [];\n\n  // 待删除的环状结构\n  const removedData = [];\n\n  // 获取所有的节点\n  const nodes = getNodes(edges, sourceField, targetField);\n  // 获取节点与边的邻接矩阵\n  const graphMatrix = getMatrix(edges, nodes, sourceField, targetField);\n\n  // visited：标记节点访问状态, 0：未访问,1：访问中, -1：已访问\n  const visited = {};\n  // 初始化visited\n  nodes.forEach((node) => {\n    visited[node] = 0;\n  });\n\n  // 图的深度遍历函数\n  function DFS(dfsNode) {\n    // 节点状态置为正在访问\n    visited[dfsNode] = 1;\n    nodes.forEach((node) => {\n      if (graphMatrix[dfsNode][node] != 0) {\n        // 当前节点在访问中，再次被访问，证明有环，移动到 removeData\n        if (visited[node] == 1) {\n          // 拼接为字符串，方便最后过滤\n          removedData.push(`${dfsNode}_${node}`);\n        } else if (visited[node] == -1) {\n          // 当前结点及后边的结点都被访问过，直接跳至下一个结点\n          return;\n        } else {\n          DFS(node); // 否则递归访问\n        }\n      }\n    });\n    //遍历过所有相连的结点后，把本节点标记为-1\n    visited[dfsNode] = -1;\n  }\n\n  // 对每个节点执行 dfs 操作\n  nodes.forEach((node) => {\n    //该结点后边的结点都被访问过了，跳过它\n    if (visited[node] == -1) {\n      return;\n    }\n    DFS(node);\n  });\n\n  if (removedData.length !== 0) {\n    console.warn(`sankey data contains circle, ${removedData.length} records removed.`, removedData);\n  }\n\n  // 过滤 remove 路径\n  return edges.filter((edge) => removedData.findIndex((i) => i === `${edge[sourceField]}_${edge[targetField]}`) < 0);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}