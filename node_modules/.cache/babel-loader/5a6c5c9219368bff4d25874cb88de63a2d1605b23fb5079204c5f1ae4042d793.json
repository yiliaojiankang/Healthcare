{"ast":null,"code":"/*\n * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)\n * graph data required (nodes, edges)\n */\nimport { assign, forIn, isFunction } from '@antv/util';\nvar DEFAULT_OPTIONS = {\n  y: 0,\n  nodeWidthRatio: 0.05,\n  weight: false,\n  nodePaddingRatio: 0.1,\n  id: function (node) {\n    return node.id;\n  },\n  source: function (edge) {\n    return edge.source;\n  },\n  target: function (edge) {\n    return edge.target;\n  },\n  sourceWeight: function (edge) {\n    return edge.value || 1;\n  },\n  targetWeight: function (edge) {\n    return edge.value || 1;\n  },\n  sortBy: null // optional, id | weight | frequency | {function}\n};\n/**\n * 处理节点的value、edges\n * @param nodeById\n * @param edges\n * @param options\n */\nfunction processGraph(nodeById, edges, options) {\n  forIn(nodeById, function (node, id) {\n    // in edges, out edges\n    node.inEdges = edges.filter(function (edge) {\n      return \"\".concat(options.target(edge)) === \"\".concat(id);\n    });\n    node.outEdges = edges.filter(function (edge) {\n      return \"\".concat(options.source(edge)) === \"\".concat(id);\n    });\n    // frequency\n    node.edges = node.outEdges.concat(node.inEdges);\n    node.frequency = node.edges.length;\n    // weight\n    node.value = 0;\n    node.inEdges.forEach(function (edge) {\n      node.value += options.targetWeight(edge);\n    });\n    node.outEdges.forEach(function (edge) {\n      node.value += options.sourceWeight(edge);\n    });\n  });\n}\n/**\n * 节点排序\n * @param nodes\n * @param options\n */\nfunction sortNodes(nodes, options) {\n  var sortMethods = {\n    weight: function (a, b) {\n      return b.value - a.value;\n    },\n    frequency: function (a, b) {\n      return b.frequency - a.frequency;\n    },\n    id: function (a, b) {\n      return \"\".concat(options.id(a)).localeCompare(\"\".concat(options.id(b)));\n    }\n  };\n  var method = sortMethods[options.sortBy];\n  if (!method && isFunction(options.sortBy)) {\n    method = options.sortBy;\n  }\n  if (method) {\n    nodes.sort(method);\n  }\n}\nfunction layoutNodes(nodes, options) {\n  var len = nodes.length;\n  if (!len) {\n    throw new TypeError(\"Invalid nodes: it's empty!\");\n  }\n  if (options.weight) {\n    var nodePaddingRatio_1 = options.nodePaddingRatio;\n    if (nodePaddingRatio_1 < 0 || nodePaddingRatio_1 >= 1) {\n      throw new TypeError('Invalid nodePaddingRatio: it must be in range [0, 1)!');\n    }\n    var margin_1 = nodePaddingRatio_1 / (2 * len);\n    var nodeWidthRatio_1 = options.nodeWidthRatio;\n    if (nodeWidthRatio_1 <= 0 || nodeWidthRatio_1 >= 1) {\n      throw new TypeError('Invalid nodeWidthRatio: it must be in range (0, 1)!');\n    }\n    var totalValue_1 = 0;\n    nodes.forEach(function (node) {\n      totalValue_1 += node.value;\n    });\n    nodes.forEach(function (node) {\n      node.weight = node.value / totalValue_1;\n      node.width = node.weight * (1 - nodePaddingRatio_1);\n      node.height = nodeWidthRatio_1;\n    });\n    nodes.forEach(function (node, index) {\n      // x\n      var deltaX = 0;\n      for (var i = index - 1; i >= 0; i--) {\n        deltaX += nodes[i].width + 2 * margin_1;\n      }\n      var minX = node.minX = margin_1 + deltaX;\n      var maxX = node.maxX = node.minX + node.width;\n      var minY = node.minY = options.y - nodeWidthRatio_1 / 2;\n      var maxY = node.maxY = minY + nodeWidthRatio_1;\n      node.x = [minX, maxX, maxX, minX];\n      node.y = [minY, minY, maxY, maxY];\n      /* points\n       * 3---2\n       * |   |\n       * 0---1\n       */\n      // node.x = minX + 0.5 * node.width;\n      // node.y = options.y;\n    });\n  } else {\n    var deltaX_1 = 1 / len;\n    nodes.forEach(function (node, index) {\n      node.x = (index + 0.5) * deltaX_1;\n      node.y = options.y;\n    });\n  }\n  return nodes;\n}\nfunction locatingEdges(nodeById, edges, options) {\n  if (options.weight) {\n    var valueById_1 = {};\n    forIn(nodeById, function (node, id) {\n      valueById_1[id] = node.value;\n    });\n    edges.forEach(function (edge) {\n      var sId = options.source(edge);\n      var tId = options.target(edge);\n      var sNode = nodeById[sId];\n      var tNode = nodeById[tId];\n      if (sNode && tNode) {\n        var sValue = valueById_1[sId];\n        var currentSValue = options.sourceWeight(edge);\n        var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;\n        var sEnd = sStart + currentSValue / sNode.value * sNode.width;\n        valueById_1[sId] -= currentSValue;\n        var tValue = valueById_1[tId];\n        var currentTValue = options.targetWeight(edge);\n        var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;\n        var tEnd = tStart + currentTValue / tNode.value * tNode.width;\n        valueById_1[tId] -= currentTValue;\n        var y = options.y;\n        edge.x = [sStart, sEnd, tStart, tEnd];\n        edge.y = [y, y, y, y];\n        // 将edge的source与target的id换为 sourceNode与targetNode\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  } else {\n    edges.forEach(function (edge) {\n      var sNode = nodeById[options.source(edge)];\n      var tNode = nodeById[options.target(edge)];\n      if (sNode && tNode) {\n        edge.x = [sNode.x, tNode.x];\n        edge.y = [sNode.y, tNode.y];\n        // 将edge的source与target的id换为 sourceNode与targetNode\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  }\n  return edges;\n}\nexport function getDefaultOptions(options) {\n  return assign({}, DEFAULT_OPTIONS, options);\n}\nexport function chordLayout(chordLayoutOptions, chordLayoutInputData) {\n  var options = getDefaultOptions(chordLayoutOptions);\n  var nodeById = {};\n  var nodes = chordLayoutInputData.nodes;\n  var links = chordLayoutInputData.links;\n  nodes.forEach(function (node) {\n    var id = options.id(node);\n    nodeById[id] = node;\n  });\n  processGraph(nodeById, links, options);\n  sortNodes(nodes, options);\n  var outputNodes = layoutNodes(nodes, options);\n  var outputLinks = locatingEdges(nodeById, links, options);\n  return {\n    nodes: outputNodes,\n    links: outputLinks\n  };\n}","map":{"version":3,"names":["assign","forIn","isFunction","DEFAULT_OPTIONS","y","nodeWidthRatio","weight","nodePaddingRatio","id","node","source","edge","target","sourceWeight","value","targetWeight","sortBy","processGraph","nodeById","edges","options","inEdges","filter","concat","outEdges","frequency","length","forEach","sortNodes","nodes","sortMethods","a","b","localeCompare","method","sort","layoutNodes","len","TypeError","nodePaddingRatio_1","margin_1","nodeWidthRatio_1","totalValue_1","width","height","index","deltaX","i","minX","maxX","minY","maxY","x","deltaX_1","locatingEdges","valueById_1","sId","tId","sNode","tNode","sValue","currentSValue","sStart","sEnd","tValue","currentTValue","tStart","tEnd","getDefaultOptions","chordLayout","chordLayoutOptions","chordLayoutInputData","links","outputNodes","outputLinks"],"sources":["../../../src/utils/transform/chord.ts"],"sourcesContent":["/*\n * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)\n * graph data required (nodes, edges)\n */\nimport { assign, forIn, isFunction } from '@antv/util';\nimport { NodeLinkData } from '../../types/relation-data';\n\nconst DEFAULT_OPTIONS: ChordLayoutOptions = {\n  y: 0,\n  nodeWidthRatio: 0.05, // width of the node, (0, 1)\n  weight: false,\n  nodePaddingRatio: 0.1, // margin ratio, [0, 1)\n  id: (node) => node.id,\n  source: (edge) => edge.source,\n  target: (edge) => edge.target,\n  sourceWeight: (edge) => edge.value || 1,\n  targetWeight: (edge) => edge.value || 1,\n  sortBy: null, // optional, id | weight | frequency | {function}\n};\n\nexport type ChordLayoutOptions = {\n  weight?: boolean;\n  y?: number;\n  nodeWidthRatio?: number; // 节点的宽度比例，对应于极坐标系的厚度，(0, 1)\n  nodePaddingRatio?: number; // 节点之间的间距的比例，[0, 1)\n  id?(node: any): any;\n  source?(edge: any): any;\n  target?(edge: any): any;\n  sourceWeight?(edge: any): number;\n  targetWeight?(edge: any): number;\n  sortBy?: 'id' | 'weight' | 'frequency' | null | ((a: any, b: any) => number);\n};\n\ntype OutputNode = {\n  readonly id: number;\n  readonly name: string;\n  // readonly depth: number;\n  readonly value: number;\n\n  // 用于绘制 polygon\n  x: number[];\n  y: number[];\n};\n\ntype OutputLink = {\n  readonly source: OutputNode;\n  readonly target: OutputNode;\n  readonly value: number;\n\n  // 用于绘制 edge\n  x?: number[];\n  y?: number[];\n};\n\ntype ChordLayoutOutputData = {\n  readonly nodes: OutputNode[];\n  readonly links: OutputLink[];\n};\n\n/**\n * 处理节点的value、edges\n * @param nodeById\n * @param edges\n * @param options\n */\nfunction processGraph(nodeById, edges, options) {\n  forIn(nodeById, (node, id) => {\n    // in edges, out edges\n    node.inEdges = edges.filter((edge) => `${options.target(edge)}` === `${id}`);\n    node.outEdges = edges.filter((edge) => `${options.source(edge)}` === `${id}`);\n    // frequency\n    node.edges = node.outEdges.concat(node.inEdges);\n    node.frequency = node.edges.length;\n    // weight\n    node.value = 0;\n    node.inEdges.forEach((edge) => {\n      node.value += options.targetWeight(edge);\n    });\n    node.outEdges.forEach((edge) => {\n      node.value += options.sourceWeight(edge);\n    });\n  });\n}\n\n/**\n * 节点排序\n * @param nodes\n * @param options\n */\nfunction sortNodes(nodes, options) {\n  const sortMethods = {\n    weight: (a, b) => b.value - a.value,\n    frequency: (a, b) => b.frequency - a.frequency,\n    id: (a, b) => `${options.id(a)}`.localeCompare(`${options.id(b)}`),\n  };\n  let method = sortMethods[options.sortBy];\n  if (!method && isFunction(options.sortBy)) {\n    method = options.sortBy;\n  }\n  if (method) {\n    nodes.sort(method);\n  }\n}\n\nfunction layoutNodes(nodes, options): OutputNode[] {\n  const len = nodes.length;\n  if (!len) {\n    throw new TypeError(\"Invalid nodes: it's empty!\");\n  }\n  if (options.weight) {\n    const nodePaddingRatio = options.nodePaddingRatio;\n    if (nodePaddingRatio < 0 || nodePaddingRatio >= 1) {\n      throw new TypeError('Invalid nodePaddingRatio: it must be in range [0, 1)!');\n    }\n    const margin = nodePaddingRatio / (2 * len);\n    const nodeWidthRatio = options.nodeWidthRatio;\n    if (nodeWidthRatio <= 0 || nodeWidthRatio >= 1) {\n      throw new TypeError('Invalid nodeWidthRatio: it must be in range (0, 1)!');\n    }\n    let totalValue = 0;\n    nodes.forEach((node) => {\n      totalValue += node.value;\n    });\n    nodes.forEach((node) => {\n      node.weight = node.value / totalValue;\n      node.width = node.weight * (1 - nodePaddingRatio);\n      node.height = nodeWidthRatio;\n    });\n    nodes.forEach((node, index) => {\n      // x\n      let deltaX = 0;\n      for (let i = index - 1; i >= 0; i--) {\n        deltaX += nodes[i].width + 2 * margin;\n      }\n      const minX = (node.minX = margin + deltaX);\n      const maxX = (node.maxX = node.minX + node.width);\n      const minY = (node.minY = options.y - nodeWidthRatio / 2);\n      const maxY = (node.maxY = minY + nodeWidthRatio);\n      node.x = [minX, maxX, maxX, minX];\n      node.y = [minY, minY, maxY, maxY];\n      /* points\n       * 3---2\n       * |   |\n       * 0---1\n       */\n      // node.x = minX + 0.5 * node.width;\n      // node.y = options.y;\n    });\n  } else {\n    const deltaX = 1 / len;\n    nodes.forEach((node, index) => {\n      node.x = (index + 0.5) * deltaX;\n      node.y = options.y;\n    });\n  }\n  return nodes;\n}\n\nfunction locatingEdges(nodeById, edges, options): OutputLink[] {\n  if (options.weight) {\n    const valueById = {};\n    forIn(nodeById, (node, id) => {\n      valueById[id] = node.value;\n    });\n    edges.forEach((edge) => {\n      const sId = options.source(edge);\n      const tId = options.target(edge);\n      const sNode = nodeById[sId];\n      const tNode = nodeById[tId];\n      if (sNode && tNode) {\n        const sValue = valueById[sId];\n        const currentSValue = options.sourceWeight(edge);\n        const sStart = sNode.minX + ((sNode.value - sValue) / sNode.value) * sNode.width;\n        const sEnd = sStart + (currentSValue / sNode.value) * sNode.width;\n        valueById[sId] -= currentSValue;\n\n        const tValue = valueById[tId];\n        const currentTValue = options.targetWeight(edge);\n        const tStart = tNode.minX + ((tNode.value - tValue) / tNode.value) * tNode.width;\n        const tEnd = tStart + (currentTValue / tNode.value) * tNode.width;\n        valueById[tId] -= currentTValue;\n\n        const y = options.y;\n        edge.x = [sStart, sEnd, tStart, tEnd];\n        edge.y = [y, y, y, y];\n        // 将edge的source与target的id换为 sourceNode与targetNode\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  } else {\n    edges.forEach((edge) => {\n      const sNode = nodeById[options.source(edge)];\n      const tNode = nodeById[options.target(edge)];\n      if (sNode && tNode) {\n        edge.x = [sNode.x, tNode.x];\n        edge.y = [sNode.y, tNode.y];\n        // 将edge的source与target的id换为 sourceNode与targetNode\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  }\n  return edges;\n}\n\nexport function getDefaultOptions(options: ChordLayoutOptions): ChordLayoutOptions {\n  return assign({}, DEFAULT_OPTIONS, options);\n}\n\nexport function chordLayout(\n  chordLayoutOptions: ChordLayoutOptions,\n  chordLayoutInputData: NodeLinkData\n): ChordLayoutOutputData {\n  const options = getDefaultOptions(chordLayoutOptions);\n  const nodeById = {};\n  const nodes = chordLayoutInputData.nodes;\n  const links = chordLayoutInputData.links;\n  nodes.forEach((node) => {\n    const id = options.id(node);\n    nodeById[id] = node;\n  });\n  processGraph(nodeById, links, options);\n  sortNodes(nodes, options);\n  const outputNodes = layoutNodes(nodes, options);\n  const outputLinks = locatingEdges(nodeById, links, options);\n  return {\n    nodes: outputNodes,\n    links: outputLinks,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}