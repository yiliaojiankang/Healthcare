{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _util = require(\"@antv/util\");\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\nvar _vector = _interopRequireDefault(require(\"./utils/vector\"));\nvar _nodeProperties = require(\"./utils/node-properties\");\nvar _dataPreprocessing = require(\"./utils/data-preprocessing\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar getModularity = function getModularity(nodes, adjMatrix, ks, m) {\n  var length = adjMatrix.length;\n  var param = 2 * m;\n  var modularity = 0;\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      var entry = adjMatrix[i][j] || 0;\n      var ki = ks[i] || 0;\n      var kj = ks[j] || 0;\n      modularity += entry - ki * kj / param;\n    }\n  }\n  modularity *= 1 / param;\n  return modularity;\n};\n// 模块惯性度，衡量属性相似度\nvar getInertialModularity = function getInertialModularity(nodes, allPropertiesWeight) {\n  if (nodes === void 0) {\n    nodes = [];\n  }\n  var length = nodes.length;\n  var totalProperties = new _vector.default([]);\n  for (var i = 0; i < length; i++) {\n    totalProperties = totalProperties.add(new _vector.default(allPropertiesWeight[i]));\n  }\n  // 均值向量\n  var avgProperties = totalProperties.avg(length);\n  avgProperties.normalize();\n  // 节点集合的方差: 节点v与均值向量的平方欧式距离之和\n  var variance = 0;\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new _vector.default(allPropertiesWeight[i]);\n    var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);\n    variance += squareEuclideanDistance;\n  }\n  // 任意两点间的欧式平方距离\n  var squareEuclideanDistanceInfo = [];\n  nodes.forEach(function () {\n    squareEuclideanDistanceInfo.push([]);\n  });\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new _vector.default(allPropertiesWeight[i]);\n    nodes[i]['clusterInertial'] = 0;\n    for (var j = 0; j < length; j++) {\n      if (i === j) {\n        squareEuclideanDistanceInfo[i][j] = 0;\n        continue;\n      }\n      var propertiesj = new _vector.default(allPropertiesWeight[j]);\n      squareEuclideanDistanceInfo[i][j] = propertiesi.squareEuclideanDistance(propertiesj);\n      nodes[i]['clusterInertial'] += squareEuclideanDistanceInfo[i][j];\n    }\n  }\n  // 计算模块惯性度\n  var inertialModularity = 0;\n  var param = 2 * length * variance;\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (i === j || clusteri !== clusterj) continue;\n      var inertial = nodes[i].clusterInertial * nodes[j].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i][j] / param;\n      inertialModularity += inertial;\n    }\n  }\n  return Number(inertialModularity.toFixed(4));\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold 差值阈值\n * @param inertialModularity 是否使用惯性模块度（即节点属性相似性）\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n * @param inertialWeight 惯性模块度权重\n */\nvar louvain = function louvain(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {\n  if (directed === void 0) {\n    directed = false;\n  }\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n  if (threshold === void 0) {\n    threshold = 0.0001;\n  }\n  if (inertialModularity === void 0) {\n    inertialModularity = false;\n  }\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = ['id'];\n  }\n  if (inertialWeight === void 0) {\n    inertialWeight = 1;\n  }\n  // the origin data\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var allPropertiesWeight = [];\n  if (inertialModularity) {\n    nodes.forEach(function (node, index) {\n      node.properties = node.properties || {};\n      node.originIndex = index;\n    });\n    var nodeTypeInfo_1 = [];\n    if (nodes.every(function (node) {\n      return node.hasOwnProperty('nodeType');\n    })) {\n      nodeTypeInfo_1 = Array.from(new Set(nodes.map(function (node) {\n        return node.nodeType;\n      })));\n      nodes.forEach(function (node) {\n        node.properties.nodeType = nodeTypeInfo_1.findIndex(function (nodeType) {\n          return nodeType === node.nodeType;\n        });\n      });\n    }\n    // 所有节点属性集合\n    var properties = (0, _nodeProperties.getAllProperties)(nodes, propertyKey);\n    // 所有节点属性one-hot特征向量集合\n    allPropertiesWeight = (0, _dataPreprocessing.oneHot)(properties, involvedKeys, uninvolvedKeys);\n  }\n  var uniqueId = 1;\n  var clusters = {};\n  var nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach(function (node, i) {\n    var cid = String(uniqueId++);\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  });\n  // the adjacent matrix of calNodes inside clusters\n  var adjMatrix = (0, _adjacentMatrix.default)(graphData, directed);\n  // the sum of each row in adjacent matrix\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  var neighbors = {};\n  // the sum of the weights of all edges in the graph\n  var m = 0;\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n  m /= 2;\n  var totalModularity = Infinity;\n  var previousModularity = Infinity;\n  var iter = 0;\n  var finalNodes = [];\n  var finalClusters = {};\n  while (true) {\n    if (inertialModularity && nodes.every(function (node) {\n      return node.hasOwnProperty('properties');\n    })) {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m) + getInertialModularity(nodes, allPropertiesWeight) * inertialWeight;\n    } else {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    }\n    // 第一次迭代previousModularity直接赋值\n    if (iter === 0) {\n      previousModularity = totalModularity;\n      finalNodes = nodes;\n      finalClusters = clusters;\n    }\n    var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold;\n    // 总模块度增加才更新最优解\n    if (totalModularity > previousModularity) {\n      finalNodes = nodes.map(function (node) {\n        return {\n          node: node,\n          clusterId: node.clusterId\n        };\n      });\n      finalClusters = (0, _util.clone)(clusters);\n      previousModularity = totalModularity;\n    }\n    // whether to terminate the iterations\n    if (increaseWithinThreshold || iter > 100) {\n      break;\n    }\n    ;\n    iter++;\n    // pre compute some values for current clusters\n    Object.keys(clusters).forEach(function (clusterId) {\n      // sum of weights of edges to nodes in cluster\n      var sumTot = 0;\n      edges.forEach(function (edge) {\n        var source = edge.source,\n          target = edge.target;\n        var sourceClusterId = nodeMap[source].node.clusterId;\n        var targetClusterId = nodeMap[target].node.clusterId;\n        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {\n          sumTot = sumTot + (edge[weightPropertyName] || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    });\n    // move the nodes to increase the delta modularity\n    nodes.forEach(function (node, i) {\n      var selfCluster = clusters[node.clusterId];\n      var bestIncrease = 0;\n      var bestCluster;\n      var commonParam = ks[i] / (2 * m);\n      // sum of weights of edges from node to nodes in cluster\n      var kiin = 0;\n      var selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(function (scNode) {\n        var scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      });\n      // the modurarity for **removing** the node i from the origin cluster of node i\n      var removeModurarity = kiin - selfCluster.sumTot * commonParam;\n      // nodes for **removing** node i into this neighbor cluster\n      var selfClusterNodesAfterRemove = selfClusterNodes.filter(function (scNode) {\n        return scNode.id !== node.id;\n      });\n      var propertiesWeightRemove = [];\n      selfClusterNodesAfterRemove.forEach(function (nodeRemove, index) {\n        propertiesWeightRemove[index] = allPropertiesWeight[nodeRemove.originIndex];\n      });\n      // the inertialModularity for **removing** the node i from the origin cluster of node i\n      var removeInertialModularity = getInertialModularity(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight;\n      // the neightbors of the node\n      var nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(function (neighborNodeId) {\n        var neighborNode = nodeMap[neighborNodeId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        // if the node and the neighbor of node are in the same cluster, reutrn\n        if (neighborClusterId === node.clusterId) return;\n        var neighborCluster = clusters[neighborClusterId];\n        var clusterNodes = neighborCluster.nodes;\n        // if the cluster is empty, remove the cluster and return\n        if (!clusterNodes || !clusterNodes.length) return;\n        // sum of weights of edges from node to nodes in cluster\n        var neighborClusterKiin = 0;\n        clusterNodes.forEach(function (cNode) {\n          var cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        });\n        // the modurarity for **adding** node i into this neighbor cluster\n        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;\n        // nodes for **adding** node i into this neighbor cluster\n        var clusterNodesAfterAdd = clusterNodes.concat([node]);\n        var propertiesWeightAdd = [];\n        clusterNodesAfterAdd.forEach(function (nodeAdd, index) {\n          propertiesWeightAdd[index] = allPropertiesWeight[nodeAdd.originIndex];\n        });\n        // the inertialModularity for **adding** node i into this neighbor cluster\n        var addInertialModularity = getInertialModularity(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight;\n        // the increase modurarity is the difference between addModurarity and removeModurarity\n        var increase = addModurarity - removeModurarity;\n        if (inertialModularity) {\n          increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);\n        }\n        // find the best cluster to move node i into\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      });\n      // if found a best cluster to move into\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        var previousClusterId_1 = node.clusterId;\n        node.clusterId = bestCluster.id;\n        // move the node to the best cluster\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        // remove from origin cluster\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n        // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n        var neighborClusterSumTot_1 = 0;\n        var selfClusterSumTot_1 = 0;\n        edges.forEach(function (edge) {\n          var source = edge.source,\n            target = edge.target;\n          var sourceClusterId = nodeMap[source].node.clusterId;\n          var targetClusterId = nodeMap[target].node.clusterId;\n          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {\n            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {\n            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n        });\n        // the nodes of the clusters to move into and remove are changed, update their sumTot\n        bestCluster.sumTot = neighborClusterSumTot_1;\n        selfCluster.sumTot = selfClusterSumTot_1;\n      }\n    });\n  }\n  // delete the empty clusters, assign increasing clusterId\n  var newClusterIdMap = {};\n  var clusterIdx = 0;\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    var cluster = finalClusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete finalClusters[clusterId];\n      return;\n    }\n    var newId = String(clusterIdx + 1);\n    if (newId === clusterId) {\n      return;\n    }\n    cluster.id = newId;\n    cluster.nodes = cluster.nodes.map(function (item) {\n      return {\n        id: item.id,\n        clusterId: newId\n      };\n    });\n    finalClusters[newId] = cluster;\n    newClusterIdMap[clusterId] = newId;\n    delete finalClusters[clusterId];\n    clusterIdx++;\n  });\n  // restore node clusterId\n  finalNodes.forEach(function (nodeInfo) {\n    var node = nodeInfo.node,\n      clusterId = nodeInfo.clusterId;\n    if (!node) return;\n    node.clusterId = clusterId;\n    if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];\n  });\n  // get the cluster edges\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n      target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    if (!sourceClusterId || !targetClusterId) return;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    clustersArray.push(finalClusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\nvar _default = louvain;\nexports.default = _default;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","default","_util","_adjacentMatrix","_interopRequireDefault","_vector","_nodeProperties","_dataPreprocessing","obj","__esModule","getModularity","nodes","adjMatrix","ks","m","length","param","modularity","i","clusteri","clusterId","j","clusterj","entry","ki","kj","getInertialModularity","allPropertiesWeight","totalProperties","add","avgProperties","avg","normalize","variance","propertiesi","squareEuclideanDistance","squareEuclideanDistanceInfo","forEach","push","propertiesj","inertialModularity","inertial","clusterInertial","Math","pow","Number","toFixed","louvain","graphData","directed","weightPropertyName","threshold","propertyKey","involvedKeys","uninvolvedKeys","inertialWeight","undefined","_a","_b","edges","node","index","properties","originIndex","nodeTypeInfo_1","every","hasOwnProperty","Array","from","Set","map","nodeType","findIndex","getAllProperties","oneHot","uniqueId","clusters","nodeMap","cid","String","id","idx","neighbors","row","k","iid","jid","totalModularity","Infinity","previousModularity","iter","finalNodes","finalClusters","increaseWithinThreshold","clone","keys","sumTot","edge","source","target","sourceClusterId","targetClusterId","selfCluster","bestIncrease","bestCluster","commonParam","kiin","selfClusterNodes","scNode","scNodeIdx","removeModurarity","selfClusterNodesAfterRemove","filter","propertiesWeightRemove","nodeRemove","removeInertialModularity","nodeNeighborIds","neighborNodeId","neighborNode","neighborClusterId","neighborCluster","clusterNodes","neighborClusterKiin","cNode","cNodeIdx","addModurarity","clusterNodesAfterAdd","concat","propertiesWeightAdd","nodeAdd","addInertialModularity","increase","previousClusterId_1","nodeInSelfClusterIdx","indexOf","splice","neighborClusterSumTot_1","selfClusterSumTot_1","newClusterIdMap","clusterIdx","cluster","newId","item","nodeInfo","clusterEdges","clusterEdgeMap","weight","newEdgeId","count","newEdge","clustersArray","_default"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/algorithm/lib/louvain.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _util = require(\"@antv/util\");\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\nvar _vector = _interopRequireDefault(require(\"./utils/vector\"));\nvar _nodeProperties = require(\"./utils/node-properties\");\nvar _dataPreprocessing = require(\"./utils/data-preprocessing\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar getModularity = function getModularity(nodes, adjMatrix, ks, m) {\n  var length = adjMatrix.length;\n  var param = 2 * m;\n  var modularity = 0;\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      var entry = adjMatrix[i][j] || 0;\n      var ki = ks[i] || 0;\n      var kj = ks[j] || 0;\n      modularity += entry - ki * kj / param;\n    }\n  }\n  modularity *= 1 / param;\n  return modularity;\n};\n// 模块惯性度，衡量属性相似度\nvar getInertialModularity = function getInertialModularity(nodes, allPropertiesWeight) {\n  if (nodes === void 0) {\n    nodes = [];\n  }\n  var length = nodes.length;\n  var totalProperties = new _vector.default([]);\n  for (var i = 0; i < length; i++) {\n    totalProperties = totalProperties.add(new _vector.default(allPropertiesWeight[i]));\n  }\n  // 均值向量\n  var avgProperties = totalProperties.avg(length);\n  avgProperties.normalize();\n  // 节点集合的方差: 节点v与均值向量的平方欧式距离之和\n  var variance = 0;\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new _vector.default(allPropertiesWeight[i]);\n    var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);\n    variance += squareEuclideanDistance;\n  }\n  // 任意两点间的欧式平方距离\n  var squareEuclideanDistanceInfo = [];\n  nodes.forEach(function () {\n    squareEuclideanDistanceInfo.push([]);\n  });\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new _vector.default(allPropertiesWeight[i]);\n    nodes[i]['clusterInertial'] = 0;\n    for (var j = 0; j < length; j++) {\n      if (i === j) {\n        squareEuclideanDistanceInfo[i][j] = 0;\n        continue;\n      }\n      var propertiesj = new _vector.default(allPropertiesWeight[j]);\n      squareEuclideanDistanceInfo[i][j] = propertiesi.squareEuclideanDistance(propertiesj);\n      nodes[i]['clusterInertial'] += squareEuclideanDistanceInfo[i][j];\n    }\n  }\n  // 计算模块惯性度\n  var inertialModularity = 0;\n  var param = 2 * length * variance;\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (i === j || clusteri !== clusterj) continue;\n      var inertial = nodes[i].clusterInertial * nodes[j].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i][j] / param;\n      inertialModularity += inertial;\n    }\n  }\n  return Number(inertialModularity.toFixed(4));\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold 差值阈值\n * @param inertialModularity 是否使用惯性模块度（即节点属性相似性）\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n * @param inertialWeight 惯性模块度权重\n */\nvar louvain = function louvain(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {\n  if (directed === void 0) {\n    directed = false;\n  }\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n  if (threshold === void 0) {\n    threshold = 0.0001;\n  }\n  if (inertialModularity === void 0) {\n    inertialModularity = false;\n  }\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = ['id'];\n  }\n  if (inertialWeight === void 0) {\n    inertialWeight = 1;\n  }\n  // the origin data\n  var _a = graphData.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = graphData.edges,\n    edges = _b === void 0 ? [] : _b;\n  var allPropertiesWeight = [];\n  if (inertialModularity) {\n    nodes.forEach(function (node, index) {\n      node.properties = node.properties || {};\n      node.originIndex = index;\n    });\n    var nodeTypeInfo_1 = [];\n    if (nodes.every(function (node) {\n      return node.hasOwnProperty('nodeType');\n    })) {\n      nodeTypeInfo_1 = Array.from(new Set(nodes.map(function (node) {\n        return node.nodeType;\n      })));\n      nodes.forEach(function (node) {\n        node.properties.nodeType = nodeTypeInfo_1.findIndex(function (nodeType) {\n          return nodeType === node.nodeType;\n        });\n      });\n    }\n    // 所有节点属性集合\n    var properties = (0, _nodeProperties.getAllProperties)(nodes, propertyKey);\n    // 所有节点属性one-hot特征向量集合\n    allPropertiesWeight = (0, _dataPreprocessing.oneHot)(properties, involvedKeys, uninvolvedKeys);\n  }\n  var uniqueId = 1;\n  var clusters = {};\n  var nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach(function (node, i) {\n    var cid = String(uniqueId++);\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  });\n  // the adjacent matrix of calNodes inside clusters\n  var adjMatrix = (0, _adjacentMatrix.default)(graphData, directed);\n  // the sum of each row in adjacent matrix\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  var neighbors = {};\n  // the sum of the weights of all edges in the graph\n  var m = 0;\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n  m /= 2;\n  var totalModularity = Infinity;\n  var previousModularity = Infinity;\n  var iter = 0;\n  var finalNodes = [];\n  var finalClusters = {};\n  while (true) {\n    if (inertialModularity && nodes.every(function (node) {\n      return node.hasOwnProperty('properties');\n    })) {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m) + getInertialModularity(nodes, allPropertiesWeight) * inertialWeight;\n    } else {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    }\n    // 第一次迭代previousModularity直接赋值\n    if (iter === 0) {\n      previousModularity = totalModularity;\n      finalNodes = nodes;\n      finalClusters = clusters;\n    }\n    var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold;\n    // 总模块度增加才更新最优解\n    if (totalModularity > previousModularity) {\n      finalNodes = nodes.map(function (node) {\n        return {\n          node: node,\n          clusterId: node.clusterId\n        };\n      });\n      finalClusters = (0, _util.clone)(clusters);\n      previousModularity = totalModularity;\n    }\n    // whether to terminate the iterations\n    if (increaseWithinThreshold || iter > 100) {\n      break;\n    }\n    ;\n    iter++;\n    // pre compute some values for current clusters\n    Object.keys(clusters).forEach(function (clusterId) {\n      // sum of weights of edges to nodes in cluster\n      var sumTot = 0;\n      edges.forEach(function (edge) {\n        var source = edge.source,\n          target = edge.target;\n        var sourceClusterId = nodeMap[source].node.clusterId;\n        var targetClusterId = nodeMap[target].node.clusterId;\n        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {\n          sumTot = sumTot + (edge[weightPropertyName] || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    });\n    // move the nodes to increase the delta modularity\n    nodes.forEach(function (node, i) {\n      var selfCluster = clusters[node.clusterId];\n      var bestIncrease = 0;\n      var bestCluster;\n      var commonParam = ks[i] / (2 * m);\n      // sum of weights of edges from node to nodes in cluster\n      var kiin = 0;\n      var selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(function (scNode) {\n        var scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      });\n      // the modurarity for **removing** the node i from the origin cluster of node i\n      var removeModurarity = kiin - selfCluster.sumTot * commonParam;\n      // nodes for **removing** node i into this neighbor cluster\n      var selfClusterNodesAfterRemove = selfClusterNodes.filter(function (scNode) {\n        return scNode.id !== node.id;\n      });\n      var propertiesWeightRemove = [];\n      selfClusterNodesAfterRemove.forEach(function (nodeRemove, index) {\n        propertiesWeightRemove[index] = allPropertiesWeight[nodeRemove.originIndex];\n      });\n      // the inertialModularity for **removing** the node i from the origin cluster of node i\n      var removeInertialModularity = getInertialModularity(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight;\n      // the neightbors of the node\n      var nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(function (neighborNodeId) {\n        var neighborNode = nodeMap[neighborNodeId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        // if the node and the neighbor of node are in the same cluster, reutrn\n        if (neighborClusterId === node.clusterId) return;\n        var neighborCluster = clusters[neighborClusterId];\n        var clusterNodes = neighborCluster.nodes;\n        // if the cluster is empty, remove the cluster and return\n        if (!clusterNodes || !clusterNodes.length) return;\n        // sum of weights of edges from node to nodes in cluster\n        var neighborClusterKiin = 0;\n        clusterNodes.forEach(function (cNode) {\n          var cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        });\n        // the modurarity for **adding** node i into this neighbor cluster\n        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;\n        // nodes for **adding** node i into this neighbor cluster\n        var clusterNodesAfterAdd = clusterNodes.concat([node]);\n        var propertiesWeightAdd = [];\n        clusterNodesAfterAdd.forEach(function (nodeAdd, index) {\n          propertiesWeightAdd[index] = allPropertiesWeight[nodeAdd.originIndex];\n        });\n        // the inertialModularity for **adding** node i into this neighbor cluster\n        var addInertialModularity = getInertialModularity(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight;\n        // the increase modurarity is the difference between addModurarity and removeModurarity\n        var increase = addModurarity - removeModurarity;\n        if (inertialModularity) {\n          increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);\n        }\n        // find the best cluster to move node i into\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      });\n      // if found a best cluster to move into\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        var previousClusterId_1 = node.clusterId;\n        node.clusterId = bestCluster.id;\n        // move the node to the best cluster\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        // remove from origin cluster\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n        // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n        var neighborClusterSumTot_1 = 0;\n        var selfClusterSumTot_1 = 0;\n        edges.forEach(function (edge) {\n          var source = edge.source,\n            target = edge.target;\n          var sourceClusterId = nodeMap[source].node.clusterId;\n          var targetClusterId = nodeMap[target].node.clusterId;\n          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {\n            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {\n            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n        });\n        // the nodes of the clusters to move into and remove are changed, update their sumTot\n        bestCluster.sumTot = neighborClusterSumTot_1;\n        selfCluster.sumTot = selfClusterSumTot_1;\n      }\n    });\n  }\n  // delete the empty clusters, assign increasing clusterId\n  var newClusterIdMap = {};\n  var clusterIdx = 0;\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    var cluster = finalClusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete finalClusters[clusterId];\n      return;\n    }\n    var newId = String(clusterIdx + 1);\n    if (newId === clusterId) {\n      return;\n    }\n    cluster.id = newId;\n    cluster.nodes = cluster.nodes.map(function (item) {\n      return {\n        id: item.id,\n        clusterId: newId\n      };\n    });\n    finalClusters[newId] = cluster;\n    newClusterIdMap[clusterId] = newId;\n    delete finalClusters[clusterId];\n    clusterIdx++;\n  });\n  // restore node clusterId\n  finalNodes.forEach(function (nodeInfo) {\n    var node = nodeInfo.node,\n      clusterId = nodeInfo.clusterId;\n    if (!node) return;\n    node.clusterId = clusterId;\n    if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];\n  });\n  // get the cluster edges\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n      target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    if (!sourceClusterId || !targetClusterId) return;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    clustersArray.push(finalClusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\nvar _default = louvain;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}