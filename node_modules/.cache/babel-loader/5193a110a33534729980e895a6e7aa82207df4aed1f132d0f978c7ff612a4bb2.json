{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { deepMix, get, isArray } from '@antv/util';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport { polarToCartesian } from '../../util/graphics';\nimport PolarLabel from './polar';\n/**\n * 饼图 label\n */\nvar PieLabel = /** @class */function (_super) {\n  __extends(PieLabel, _super);\n  function PieLabel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.defaultLayout = 'distribute';\n    return _this;\n  }\n  PieLabel.prototype.getDefaultLabelCfg = function (offset, position) {\n    var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);\n    return deepMix({}, cfg, get(this.geometry.theme, 'pieLabels', {}));\n  };\n  /** @override */\n  PieLabel.prototype.getLabelOffset = function (offset) {\n    return _super.prototype.getLabelOffset.call(this, offset) || 0;\n  };\n  PieLabel.prototype.getLabelRotate = function (angle, offset, isLabelLimit) {\n    var rotate;\n    if (offset < 0) {\n      rotate = angle;\n      if (rotate > Math.PI / 2) {\n        rotate = rotate - Math.PI;\n      }\n      if (rotate < -Math.PI / 2) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  };\n  PieLabel.prototype.getLabelAlign = function (point) {\n    var coordinate = this.getCoordinate();\n    var center = coordinate.getCenter();\n    var align;\n    if (point.angle <= Math.PI / 2 && point.x >= center.x) {\n      align = 'left';\n    } else {\n      align = 'right';\n    }\n    if (point.offset <= 0) {\n      if (align === 'right') {\n        align = 'left';\n      } else {\n        align = 'right';\n      }\n    }\n    return align;\n  };\n  PieLabel.prototype.getArcPoint = function (point) {\n    return point;\n  };\n  PieLabel.prototype.getPointAngle = function (point) {\n    var coordinate = this.getCoordinate();\n    var startPoint = {\n      x: isArray(point.x) ? point.x[0] : point.x,\n      y: point.y[0]\n    };\n    var endPoint = {\n      x: isArray(point.x) ? point.x[1] : point.x,\n      y: point.y[1]\n    };\n    var angle;\n    var startAngle = getAngleByPoint(coordinate, startPoint);\n    if (point.points && point.points[0].y === point.points[1].y) {\n      angle = startAngle;\n    } else {\n      var endAngle = getAngleByPoint(coordinate, endPoint);\n      if (startAngle >= endAngle) {\n        // 100% pie slice\n        endAngle = endAngle + Math.PI * 2;\n      }\n      angle = startAngle + (endAngle - startAngle) / 2;\n    }\n    return angle;\n  };\n  /** @override */\n  PieLabel.prototype.getCirclePoint = function (angle, offset) {\n    var coordinate = this.getCoordinate();\n    var center = coordinate.getCenter();\n    var r = coordinate.getRadius() + offset;\n    return __assign(__assign({}, polarToCartesian(center.x, center.y, r, angle)), {\n      angle: angle,\n      r: r\n    });\n  };\n  return PieLabel;\n}(PolarLabel);\nexport default PieLabel;","map":{"version":3,"names":["deepMix","get","isArray","getAngleByPoint","polarToCartesian","PolarLabel","PieLabel","_super","__extends","_this","apply","arguments","defaultLayout","prototype","getDefaultLabelCfg","offset","position","cfg","call","geometry","theme","getLabelOffset","getLabelRotate","angle","isLabelLimit","rotate","Math","PI","getLabelAlign","point","coordinate","getCoordinate","center","getCenter","align","x","getArcPoint","getPointAngle","startPoint","y","endPoint","startAngle","points","endAngle","getCirclePoint","r","getRadius","__assign"],"sources":["../../../src/geometry/label/pie.ts"],"sourcesContent":["import { deepMix, get, isArray } from '@antv/util';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport { polarToCartesian } from '../../util/graphics';\nimport { LabelItem } from './interface';\nimport PolarLabel from './polar';\n\n/**\n * 饼图 label\n */\nexport default class PieLabel extends PolarLabel {\n  public defaultLayout = 'distribute';\n\n  protected getDefaultLabelCfg(offset?: number, position?: string) {\n    const cfg = super.getDefaultLabelCfg(offset, position);\n    return deepMix({}, cfg, get(this.geometry.theme, 'pieLabels', {}));\n  }\n\n  /** @override */\n  protected getLabelOffset(offset: string | number): number {\n    return super.getLabelOffset(offset) || 0;\n  }\n\n  protected getLabelRotate(angle: number, offset: number, isLabelLimit: boolean) {\n    let rotate;\n    if (offset < 0) {\n      rotate = angle;\n      if (rotate > Math.PI / 2) {\n        rotate = rotate - Math.PI;\n      }\n      if (rotate < -Math.PI / 2) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  }\n\n  protected getLabelAlign(point: LabelItem) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n\n    let align;\n    if (point.angle <= Math.PI / 2 && point.x >= center.x) {\n      align = 'left';\n    } else {\n      align = 'right';\n    }\n    if (point.offset <= 0) {\n      if (align === 'right') {\n        align = 'left';\n      } else {\n        align = 'right';\n      }\n    }\n    return align;\n  }\n\n  protected getArcPoint(point) {\n    return point;\n  }\n\n  protected getPointAngle(point) {\n    const coordinate = this.getCoordinate();\n    const startPoint = {\n      x: isArray(point.x) ? point.x[0] : point.x,\n      y: point.y[0],\n    };\n    const endPoint = {\n      x: isArray(point.x) ? point.x[1] : point.x,\n      y: point.y[1],\n    };\n    let angle;\n    const startAngle = getAngleByPoint(coordinate, startPoint);\n    if (point.points && point.points[0].y === point.points[1].y) {\n      angle = startAngle;\n    } else {\n      let endAngle = getAngleByPoint(coordinate, endPoint);\n      if (startAngle >= endAngle) {\n        // 100% pie slice\n        endAngle = endAngle + Math.PI * 2;\n      }\n      angle = startAngle + (endAngle - startAngle) / 2;\n    }\n    return angle;\n  }\n\n  /** @override */\n  protected getCirclePoint(angle: number, offset: number) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n    const r = coordinate.getRadius() + offset;\n    return {\n      ...polarToCartesian(center.x, center.y, r, angle),\n      angle,\n      r,\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}