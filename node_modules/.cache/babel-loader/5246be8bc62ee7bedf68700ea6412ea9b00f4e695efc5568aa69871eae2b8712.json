{"ast":null,"code":"import { assign, isArray, reduce, size } from '@antv/util';\nimport * as d3Hierarchy from 'd3-hierarchy';\nimport { getAllNodes, getField } from './util';\nvar DEFAULT_OPTIONS = {\n  field: 'value',\n  size: [1, 1],\n  round: false,\n  padding: 0,\n  // 默认降序\n  sort: function (a, b) {\n    return b.value - a.value;\n  },\n  as: ['x', 'y'],\n  // 是否忽略 parentValue, 当设置为 true 时，父节点的权重由子元素决定\n  ignoreParentValue: true\n};\nexport function partition(data, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  var as = options.as;\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n  var field;\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n  var partition = function (data) {\n    return d3Hierarchy.partition().size(options.size).round(options.round).padding(options.padding)(\n    /**\n     * d3Hierarchy 布局中需指定 sum 函数计算 node 值，规则是：从当前 node 开始以 post-order traversal 的次序为当前节点以及每个后代节点调用指定的 value 函数，并返回当前 node。\n     * for example:\n     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}\n     * parent 所得的计算值是 sum(node(parent)) + sum(node(child1)) + sum(node(child2))\n     * sum 函数中，d 为用户传入的 data, children 为保留字段\n     */\n    d3Hierarchy.hierarchy(data).sum(function (d) {\n      return size(d.children) ? options.ignoreParentValue ? 0 : d[field] - reduce(d.children, function (a, b) {\n        return a + b[field];\n      }, 0) : d[field];\n    }).sort(options.sort));\n  };\n  var root = partition(data);\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n  var x = as[0];\n  var y = as[1];\n  root.each(function (node) {\n    var _a, _b;\n    node[x] = [node.x0, node.x1, node.x1, node.x0];\n    node[y] = [node.y1, node.y1, node.y0, node.y0];\n    // 旭日图兼容下 旧版本\n    node.name = node.name || ((_a = node.data) === null || _a === void 0 ? void 0 : _a.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);\n    node.data.name = node.name;\n    ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n  return getAllNodes(root);\n}","map":{"version":3,"names":["assign","isArray","reduce","size","d3Hierarchy","getAllNodes","getField","DEFAULT_OPTIONS","field","round","padding","sort","a","b","value","as","ignoreParentValue","partition","data","options","length","TypeError","e","console","warn","hierarchy","sum","d","children","root","x","y","each","node","x0","x1","y1","y0","name","_a","_b","label","forEach","prop","indexOf"],"sources":["../../../src/utils/hierarchy/partition.ts"],"sourcesContent":["import { assign, isArray, reduce, size } from '@antv/util';\nimport * as d3Hierarchy from 'd3-hierarchy';\nimport { getAllNodes, getField } from './util';\n\nconst DEFAULT_OPTIONS: Options = {\n  field: 'value',\n  size: [1, 1], // width, height\n  round: false,\n  padding: 0,\n  // 默认降序\n  sort: (a, b) => b.value - a.value,\n  as: ['x', 'y'],\n  // 是否忽略 parentValue, 当设置为 true 时，父节点的权重由子元素决定\n  ignoreParentValue: true,\n};\n\nexport interface Options {\n  field: string;\n  size?: [number, number];\n  round?: boolean;\n  ratio?: number;\n  padding?: number;\n  sort?: (a: any, b: any) => any; // Function;\n  as?: [string, string];\n\n  ignoreParentValue?: boolean;\n}\n\nexport function partition(data: any, options: Options): any[] {\n  options = assign({} as Options, DEFAULT_OPTIONS, options);\n  const as = options.as;\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n\n  let field;\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  const partition = (data) =>\n    d3Hierarchy.partition().size(options.size).round(options.round).padding(options.padding)(\n      /**\n       * d3Hierarchy 布局中需指定 sum 函数计算 node 值，规则是：从当前 node 开始以 post-order traversal 的次序为当前节点以及每个后代节点调用指定的 value 函数，并返回当前 node。\n       * for example:\n       * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}\n       * parent 所得的计算值是 sum(node(parent)) + sum(node(child1)) + sum(node(child2))\n       * sum 函数中，d 为用户传入的 data, children 为保留字段\n       */\n      d3Hierarchy\n        .hierarchy(data)\n        .sum((d) =>\n          size(d.children)\n            ? options.ignoreParentValue\n              ? 0\n              : d[field] - reduce(d.children, (a, b) => a + b[field], 0)\n            : d[field]\n        )\n        .sort(options.sort)\n    );\n  const root = partition(data);\n\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n  const x = as[0];\n  const y = as[1];\n\n  root.each((node) => {\n    node[x] = [node.x0, node.x1, node.x1, node.x0];\n    node[y] = [node.y1, node.y1, node.y0, node.y0];\n    // 旭日图兼容下 旧版本\n    node.name = node.name || node.data?.name || node.data?.label;\n    node.data.name = node.name;\n\n    ['x0', 'x1', 'y0', 'y1'].forEach((prop) => {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n\n  return getAllNodes(root);\n}\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAEC,IAAI,QAAQ,YAAY;AAC1D,OAAO,KAAKC,WAAW,MAAM,cAAc;AAC3C,SAASC,WAAW,EAAEC,QAAQ,QAAQ,QAAQ;AAE9C,IAAMC,eAAe,GAAY;EAC/BC,KAAK,EAAE,OAAO;EACdL,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACZM,KAAK,EAAE,KAAK;EACZC,OAAO,EAAE,CAAC;EACV;EACAC,IAAI,EAAE,SAAAA,CAACC,CAAC,EAAEC,CAAC;IAAK,OAAAA,CAAC,CAACC,KAAK,GAAGF,CAAC,CAACE,KAAK;EAAjB,CAAiB;EACjCC,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;EACd;EACAC,iBAAiB,EAAE;CACpB;AAcD,OAAM,SAAUC,SAASA,CAACC,IAAS,EAAEC,OAAgB;EACnDA,OAAO,GAAGnB,MAAM,CAAC,EAAa,EAAEO,eAAe,EAAEY,OAAO,CAAC;EACzD,IAAMJ,EAAE,GAAGI,OAAO,CAACJ,EAAE;EACrB,IAAI,CAACd,OAAO,CAACc,EAAE,CAAC,IAAIA,EAAE,CAACK,MAAM,KAAK,CAAC,EAAE;IACnC,MAAM,IAAIC,SAAS,CAAC,qEAAqE,CAAC;;EAG5F,IAAIb,KAAK;EACT,IAAI;IACFA,KAAK,GAAGF,QAAQ,CAACa,OAAO,CAAC;GAC1B,CAAC,OAAOG,CAAC,EAAE;IACVC,OAAO,CAACC,IAAI,CAACF,CAAC,CAAC;;EAGjB,IAAML,SAAS,GAAG,SAAAA,CAACC,IAAI;IACrB,OAAAd,WAAW,CAACa,SAAS,EAAE,CAACd,IAAI,CAACgB,OAAO,CAAChB,IAAI,CAAC,CAACM,KAAK,CAACU,OAAO,CAACV,KAAK,CAAC,CAACC,OAAO,CAACS,OAAO,CAACT,OAAO,CAAC;IACtF;;;;;;;IAOAN,WAAW,CACRqB,SAAS,CAACP,IAAI,CAAC,CACfQ,GAAG,CAAC,UAACC,CAAC;MACL,OAAAxB,IAAI,CAACwB,CAAC,CAACC,QAAQ,CAAC,GACZT,OAAO,CAACH,iBAAiB,GACvB,CAAC,GACDW,CAAC,CAACnB,KAAK,CAAC,GAAGN,MAAM,CAACyB,CAAC,CAACC,QAAQ,EAAE,UAAChB,CAAC,EAAEC,CAAC;QAAK,OAAAD,CAAC,GAAGC,CAAC,CAACL,KAAK,CAAC;MAAZ,CAAY,EAAE,CAAC,CAAC,GAC1DmB,CAAC,CAACnB,KAAK,CAAC;IAJZ,CAIY,CACb,CACAG,IAAI,CAACQ,OAAO,CAACR,IAAI,CAAC,CACtB;EAlBD,CAkBC;EACH,IAAMkB,IAAI,GAAGZ,SAAS,CAACC,IAAI,CAAC;EAE5B;;;;;EAKA,IAAMY,CAAC,GAAGf,EAAE,CAAC,CAAC,CAAC;EACf,IAAMgB,CAAC,GAAGhB,EAAE,CAAC,CAAC,CAAC;EAEfc,IAAI,CAACG,IAAI,CAAC,UAACC,IAAI;;IACbA,IAAI,CAACH,CAAC,CAAC,GAAG,CAACG,IAAI,CAACC,EAAE,EAAED,IAAI,CAACE,EAAE,EAAEF,IAAI,CAACE,EAAE,EAAEF,IAAI,CAACC,EAAE,CAAC;IAC9CD,IAAI,CAACF,CAAC,CAAC,GAAG,CAACE,IAAI,CAACG,EAAE,EAAEH,IAAI,CAACG,EAAE,EAAEH,IAAI,CAACI,EAAE,EAAEJ,IAAI,CAACI,EAAE,CAAC;IAC9C;IACAJ,IAAI,CAACK,IAAI,GAAGL,IAAI,CAACK,IAAI,KAAI,CAAAC,EAAA,GAAAN,IAAI,CAACf,IAAI,cAAAqB,EAAA,uBAAAA,EAAA,CAAED,IAAI,MAAI,CAAAE,EAAA,GAAAP,IAAI,CAACf,IAAI,cAAAsB,EAAA,uBAAAA,EAAA,CAAEC,KAAK;IAC5DR,IAAI,CAACf,IAAI,CAACoB,IAAI,GAAGL,IAAI,CAACK,IAAI;IAE1B,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAACI,OAAO,CAAC,UAACC,IAAI;MACpC,IAAI5B,EAAE,CAAC6B,OAAO,CAACD,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;QAC3B,OAAOV,IAAI,CAACU,IAAI,CAAC;;IAErB,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,OAAOtC,WAAW,CAACwB,IAAI,CAAC;AAC1B"},"metadata":{},"sourceType":"module","externalDependencies":[]}