{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __assign, __extends, __spreadArray } from \"tslib\";\nimport EventEmitter from '@antv/event-emitter';\nimport { ext } from '@antv/matrix-util';\nimport { clone, deepMix, each, isPlainObject, isString, debounce } from '@antv/util';\nimport { getDegree, getAdjMatrix as getAdjacentMatrix, Stack, floydWarshall } from '@antv/algorithm';\nimport { lerp, move } from '../util/math';\nimport { dataValidation, singleDataValidation } from '../util/validation';\nimport Global from '../global';\nimport { ItemController, ModeController, StateController, ViewController } from './controller';\nimport { plainCombosToTrees, traverseTree, reconstructTree, traverseTreeUp, getAnimateCfgWithCallback } from '../util/graphic';\nimport Hull from '../item/hull';\nvar transform = ext.transform;\nvar NODE = 'node';\nvar AbstractGraph = /** @class */function (_super) {\n  __extends(AbstractGraph, _super);\n  function AbstractGraph(cfg) {\n    var _this = _super.call(this) || this;\n    /**\n     * 根据 comboTree 结构整理 Combo 相关的图形绘制层级，包括 Combo 本身、节点、边\n     * @param {GraphData} data 数据\n     */\n    _this.sortCombos = debounce(function () {\n      var comboSorted = _this.get('comboSorted');\n      if (!_this || _this.destroyed || comboSorted) return;\n      _this.set('comboSorted', true);\n      var depthMap = [];\n      var dataDepthMap = {};\n      var comboTrees = _this.get('comboTrees');\n      (comboTrees || []).forEach(function (cTree) {\n        traverseTree(cTree, function (child) {\n          if (depthMap[child.depth]) depthMap[child.depth].push(child.id);else depthMap[child.depth] = [child.id];\n          dataDepthMap[child.id] = child.depth;\n          return true;\n        });\n      });\n      var edges = _this.getEdges().concat(_this.get('vedges'));\n      (edges || []).forEach(function (edgeItem) {\n        var edge = edgeItem.getModel();\n        var sourceDepth = dataDepthMap[edge.source] || 0;\n        var targetDepth = dataDepthMap[edge.target] || 0;\n        var depth = Math.max(sourceDepth, targetDepth);\n        if (depthMap[depth]) depthMap[depth].push(edge.id);else depthMap[depth] = [edge.id];\n      });\n      depthMap.forEach(function (array) {\n        if (!array || !array.length) return;\n        for (var i = array.length - 1; i >= 0; i--) {\n          var item = _this.findById(array[i]);\n          if (item) item.toFront();\n        }\n      });\n    }, 500, false);\n    _this.cfg = deepMix(_this.getDefaultCfg(), cfg);\n    _this.init();\n    _this.animating = false;\n    _this.destroyed = false;\n    // 启用 stack 后，实例化 undoStack 和 redoStack\n    if (_this.cfg.enabledStack) {\n      // 实例化 undo 和 redo 栈\n      _this.undoStack = new Stack(_this.cfg.maxStep);\n      _this.redoStack = new Stack(_this.cfg.maxStep);\n    }\n    return _this;\n  }\n  AbstractGraph.prototype.init = function () {\n    this.initCanvas();\n    // instance controller\n    var viewController = new ViewController(this);\n    var modeController = new ModeController(this);\n    var itemController = new ItemController(this);\n    var stateController = new StateController(this);\n    this.set({\n      viewController: viewController,\n      modeController: modeController,\n      itemController: itemController,\n      stateController: stateController\n    });\n    // 初始化布局机制\n    this.initLayoutController();\n    // 初始化事件机制\n    this.initEventController();\n    this.initGroups();\n    /** 初始化插件 */\n    this.initPlugins();\n  };\n  // 初始化所有 Group\n  AbstractGraph.prototype.initGroups = function () {\n    var canvas = this.get('canvas');\n    if (!canvas) return;\n    var el = canvas.get('el');\n    var _a = (el || {}).id,\n      id = _a === void 0 ? 'g6' : _a;\n    var group = canvas.addGroup({\n      id: \"\".concat(id, \"-root\"),\n      className: Global.rootContainerClassName\n    });\n    if (this.get('groupByTypes')) {\n      var edgeGroup = group.addGroup({\n        id: \"\".concat(id, \"-edge\"),\n        className: Global.edgeContainerClassName\n      });\n      var nodeGroup = group.addGroup({\n        id: \"\".concat(id, \"-node\"),\n        className: Global.nodeContainerClassName\n      });\n      var comboGroup = group.addGroup({\n        id: \"\".concat(id, \"-combo\"),\n        className: Global.comboContainerClassName\n      });\n      // 用于存储自定义的群组\n      comboGroup.toBack();\n      this.set({\n        nodeGroup: nodeGroup,\n        edgeGroup: edgeGroup,\n        comboGroup: comboGroup\n      });\n    }\n    var delegateGroup = group.addGroup({\n      id: \"\".concat(id, \"-delegate\"),\n      className: Global.delegateContainerClassName\n    });\n    this.set({\n      delegateGroup: delegateGroup\n    });\n    this.set('group', group);\n  };\n  // eslint-disable-next-line class-methods-use-this\n  AbstractGraph.prototype.getDefaultCfg = function () {\n    return {\n      /**\n       * Container could be dom object or dom id\n       */\n      container: undefined,\n      /**\n       * Canvas width\n       * unit pixel if undefined force fit width\n       */\n      width: undefined,\n      /**\n       * Canvas height\n       * unit pixel if undefined force fit height\n       */\n      height: undefined,\n      /**\n       * renderer canvas or svg\n       * @type {string}\n       */\n      renderer: 'canvas',\n      /**\n       * control graph behaviors\n       */\n      modes: {},\n      /**\n       * 注册插件\n       */\n      plugins: [],\n      /**\n       * source data\n       */\n      data: {},\n      /**\n       * Fit view padding (client scale)\n       */\n      fitViewPadding: 10,\n      /**\n       * Minimum scale size\n       */\n      minZoom: 0.02,\n      /**\n       * Maxmum scale size\n       */\n      maxZoom: 10,\n      /**\n       *  capture events\n       */\n      event: true,\n      /**\n       * group node & edges into different graphic groups\n       */\n      groupByTypes: true,\n      /**\n       * determine if it's a directed graph\n       */\n      directed: false,\n      /**\n       * when data or shape changed, should canvas draw automatically\n       */\n      autoPaint: true,\n      /**\n       * store all the node instances\n       */\n      nodes: [],\n      /**\n       * store all the edge instances\n       */\n      edges: [],\n      /**\n       * store all the combo instances\n       */\n      combos: [],\n      /**\n       * store all the edge instances which are virtual edges related to collapsed combo\n       */\n      vedges: [],\n      /**\n       * all the instances indexed by id\n       */\n      itemMap: {},\n      /**\n       * 边直接连接到节点的中心，不再考虑锚点\n       */\n      linkCenter: false,\n      /**\n       * 默认的节点配置，data 上定义的配置会覆盖这些配置。例如：\n       * defaultNode: {\n       *  type: 'rect',\n       *  size: [60, 40],\n       *  style: {\n       *    //... 样式配置项\n       *  }\n       * }\n       * 若数据项为 { id: 'node', x: 100, y: 100 }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'rect', size: [60, 40] }\n       * 若数据项为 { id: 'node', x: 100, y: 100, type: 'circle' }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'circle', size: [60, 40] }\n       */\n      defaultNode: {},\n      /**\n       * 默认边配置，data 上定义的配置会覆盖这些配置。用法同 defaultNode\n       */\n      defaultEdge: {},\n      /**\n       * 节点默认样式，也可以添加状态样式\n       * 例如：\n       * const graph = new G6.Graph({\n       *  nodeStateStyles: {\n       *    selected: { fill: '#ccc', stroke: '#666' },\n       *    active: { lineWidth: 2 }\n       *  },\n       *  ...\n       * });\n       *\n       */\n      nodeStateStyles: {},\n      /**\n       * 边默认样式，用法同nodeStateStyle\n       */\n      edgeStateStyles: {},\n      /**\n       * graph 状态\n       */\n      states: {},\n      /**\n       * 是否启用全局动画\n       */\n      animate: false,\n      /**\n       * 动画设置,仅在 animate 为 true 时有效\n       */\n      animateCfg: {\n        /**\n         * 帧回调函数，用于自定义节点运动路径，为空时线性运动\n         */\n        onFrame: undefined,\n        /**\n         * 动画时长(ms)\n         */\n        duration: 500,\n        /**\n         * 指定动画动效\n         */\n        easing: 'easeLinear'\n      },\n      callback: undefined,\n      // 默认不启用 undo & redo 功能\n      enabledStack: false,\n      // 只有当 enabledStack 为 true 时才起作用\n      maxStep: 10,\n      // 存储图上的 tooltip dom，方便销毁\n      tooltips: [],\n      // 达到这一节点数量(默认值 1000)，将开启性能优化模式。目前包括：节点状态样式变更是否影响相关边的更新\n      optimizeThreshold: 1000\n    };\n  };\n  /**\n   * 将值设置到 this.cfg 变量上面\n   * @param key 键 或 对象值\n   * @param val 值\n   */\n  AbstractGraph.prototype.set = function (key, val) {\n    if (isPlainObject(key)) {\n      this.cfg = __assign(__assign({}, this.cfg), key);\n    } else {\n      this.cfg[key] = val;\n    }\n    if (key === 'enabledStack' && val && !this.undoStack && !this.redoStack) {\n      this.undoStack = new Stack(this.cfg.maxStep);\n      this.redoStack = new Stack(this.cfg.maxStep);\n    }\n    return this;\n  };\n  /**\n   * 获取 this.cfg 中的值\n   * @param key 键\n   */\n  AbstractGraph.prototype.get = function (key) {\n    var _a;\n    return (_a = this.cfg) === null || _a === void 0 ? void 0 : _a[key];\n  };\n  /**\n   * 获取 graph 的根图形分组\n   * @return 根 group\n   */\n  AbstractGraph.prototype.getGroup = function () {\n    return this.get('group');\n  };\n  /**\n   * 获取 graph 的 DOM 容器\n   * @return DOM 容器\n   */\n  AbstractGraph.prototype.getContainer = function () {\n    return this.get('container');\n  };\n  /**\n   * 获取 graph 的最小缩放比例\n   * @return minZoom\n   */\n  AbstractGraph.prototype.getMinZoom = function () {\n    return this.get('minZoom');\n  };\n  /**\n   * 设置 graph 的最小缩放比例\n   * @return minZoom\n   */\n  AbstractGraph.prototype.setMinZoom = function (ratio) {\n    return this.set('minZoom', ratio);\n  };\n  /**\n   * 获取 graph 的最大缩放比例\n   * @param maxZoom\n   */\n  AbstractGraph.prototype.getMaxZoom = function () {\n    return this.get('maxZoom');\n  };\n  /**\n   * 设置 graph 的最大缩放比例\n   * @param maxZoom\n   */\n  AbstractGraph.prototype.setMaxZoom = function (ratio) {\n    return this.set('maxZoom', ratio);\n  };\n  /**\n   * 获取 graph 的宽度\n   * @return width\n   */\n  AbstractGraph.prototype.getWidth = function () {\n    return this.get('width');\n  };\n  /**\n   * 获取 graph 的高度\n   * @return width\n   */\n  AbstractGraph.prototype.getHeight = function () {\n    return this.get('height');\n  };\n  /**\n   * 清理元素多个状态\n   * @param {string|Item} item 元素id或元素实例\n   * @param {string[]} states 状态\n   */\n  AbstractGraph.prototype.clearItemStates = function (item, states) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n    var itemController = this.get('itemController');\n    if (!states) {\n      states = item.get('states');\n    }\n    itemController.clearItemStates(item, states);\n    var stateController = this.get('stateController');\n    stateController.updateStates(item, states, false);\n  };\n  /**\n   * 设置各个节点样式，以及在各种状态下节点 keyShape 的样式。\n   * 若是自定义节点切在各种状态下\n   * graph.node(node => {\n   *  return {\n   *    type: 'rect',\n   *    label: node.id,\n   *    style: { fill: '#666' },\n   *    stateStyles: {\n   *       selected: { fill: 'blue' },\n   *       custom: { fill: 'green' }\n   *     }\n   *   }\n   * });\n   * @param {function} nodeFn 指定每个节点样式\n   */\n  AbstractGraph.prototype.node = function (nodeFn) {\n    if (typeof nodeFn === 'function') {\n      this.set('nodeMapper', nodeFn);\n    }\n  };\n  /**\n   * 设置各个边样式\n   * @param {function} edgeFn 指定每个边的样式,用法同 node\n   */\n  AbstractGraph.prototype.edge = function (edgeFn) {\n    if (typeof edgeFn === 'function') {\n      this.set('edgeMapper', edgeFn);\n    }\n  };\n  /**\n   * 设置各个 combo 的配置\n   * @param comboFn\n   */\n  AbstractGraph.prototype.combo = function (comboFn) {\n    if (typeof comboFn === 'function') {\n      this.set('comboMapper', comboFn);\n    }\n  };\n  /**\n   * 根据 ID 查询图元素实例\n   * @param id 图元素 ID\n   */\n  AbstractGraph.prototype.findById = function (id) {\n    return this.get('itemMap')[id];\n  };\n  /**\n   * 根据对应规则查找单个元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge | group)\n   * @param {(item: T, index: number) => T} fn 指定规则\n   * @return {T} 元素实例\n   */\n  AbstractGraph.prototype.find = function (type, fn) {\n    var result;\n    var items = this.get(\"\".concat(type, \"s\"));\n    // eslint-disable-next-line consistent-return\n    each(items, function (item, i) {\n      if (fn(item, i)) {\n        result = item;\n        return result;\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有满足规则的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} fn 指定规则\n   * @return {array} 元素实例\n   */\n  AbstractGraph.prototype.findAll = function (type, fn) {\n    var result = [];\n    each(this.get(\"\".concat(type, \"s\")), function (item, i) {\n      if (fn(item, i)) {\n        result.push(item);\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有处于指定状态的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} state 状态\n   * @return {object} 元素实例\n   */\n  AbstractGraph.prototype.findAllByState = function (type, state, additionalFilter) {\n    if (additionalFilter) {\n      return this.findAll(type, function (item) {\n        return item.hasState(state) && additionalFilter(item);\n      });\n    } else {\n      return this.findAll(type, function (item) {\n        return item.hasState(state);\n      });\n    }\n  };\n  /**\n   * 平移画布\n   * @param dx 水平方向位移\n   * @param dy 垂直方向位移\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n  AbstractGraph.prototype.translate = function (dx, dy, animate, animateCfg) {\n    var _this = this;\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix());\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n    if (animate) {\n      var animateConfig = getAnimateCfgWithCallback({\n        animateCfg: animateCfg,\n        callback: function callback() {\n          return _this.emit('viewportchange', {\n            action: 'translate',\n            matrix: group.getMatrix()\n          });\n        }\n      });\n      move(group, {\n        x: group.getCanvasBBox().x + dx,\n        y: group.getCanvasBBox().y + dy\n      }, animate, animateConfig || {\n        duration: 500,\n        easing: 'easeCubic'\n      });\n    } else {\n      matrix = transform(matrix, [['t', dx, dy]]);\n      group.setMatrix(matrix);\n      this.emit('viewportchange', {\n        action: 'translate',\n        matrix: matrix\n      });\n      this.autoPaint();\n    }\n  };\n  /**\n   * 平移画布到某点\n   * @param {number} x 水平坐标\n   * @param {number} y 垂直坐标\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n  AbstractGraph.prototype.moveTo = function (x, y, animate, animateCfg) {\n    var group = this.get('group');\n    move(group, {\n      x: x,\n      y: y\n    }, animate, animateCfg || {\n      duration: 500,\n      easing: 'easeCubic'\n    });\n    this.emit('viewportchange', {\n      action: 'move',\n      matrix: group.getMatrix()\n    });\n  };\n  /**\n   * 调整视口适应视图\n   * @param {object} padding 四周围边距\n   * @param {FitViewRules} rules fitView的规则\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n  AbstractGraph.prototype.fitView = function (padding, rules, animate, animateCfg) {\n    if (padding) {\n      this.set('fitViewPadding', padding);\n    }\n    var viewController = this.get('viewController');\n    if (rules) {\n      viewController.fitViewByRules(rules, animate, animateCfg);\n    } else {\n      viewController.fitView(animate, animateCfg);\n    }\n    this.autoPaint();\n  };\n  /**\n   * 调整视口适应视图，不缩放，仅将图 bbox 中心对齐到画布中心\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n  AbstractGraph.prototype.fitCenter = function (animate, animateCfg) {\n    var viewController = this.get('viewController');\n    viewController.fitCenter(animate, animateCfg);\n    this.autoPaint();\n  };\n  /**\n   * 新增行为\n   * @param {string | ModeOption | ModeType[]} behaviors 添加的行为\n   * @param {string | string[]} modes 添加到对应的模式\n   * @return {Graph} Graph\n   */\n  AbstractGraph.prototype.addBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, true);\n    return this;\n  };\n  /**\n   * 移除行为\n   * @param {string | ModeOption | ModeType[]} behaviors 移除的行为\n   * @param {string | string[]} modes 从指定的模式中移除\n   * @return {Graph} Graph\n   */\n  AbstractGraph.prototype.removeBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, false);\n    return this;\n  };\n  /**\n   * 更新行为参数\n   * @param {string | ModeOption | ModeType} behavior 需要更新的行为\n   * @param {string | string[]} modes 指定的模式中的行为，不指定则为 default\n   * @return {Graph} Graph\n   */\n  AbstractGraph.prototype.updateBehavior = function (behavior, newCfg, mode) {\n    var modeController = this.get('modeController');\n    modeController.updateBehavior(behavior, newCfg, mode);\n    return this;\n  };\n  /**\n   * 伸缩窗口\n   * @param ratio 伸缩比例\n   * @param center 以center的x, y坐标为中心缩放\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   * @return {boolean} 缩放是否成功\n   */\n  AbstractGraph.prototype.zoom = function (ratio, center, animate, animateCfg) {\n    var _this = this;\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix()) || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    var minZoom = this.get('minZoom');\n    var maxZoom = this.get('maxZoom');\n    var currentZoom = this.getZoom() || 1;\n    var targetZoom = currentZoom * ratio;\n    var finalRatio = ratio;\n    var failed = false;\n    if (minZoom && targetZoom < minZoom) {\n      finalRatio = minZoom / currentZoom;\n      failed = true;\n    } else if (maxZoom && targetZoom > maxZoom) {\n      finalRatio = maxZoom / currentZoom;\n      failed = true;\n    }\n    if (center) {\n      matrix = transform(matrix, [['t', -center.x, -center.y], ['s', finalRatio, finalRatio], ['t', center.x, center.y]]);\n    } else {\n      matrix = transform(matrix, [['s', finalRatio, finalRatio]]);\n    }\n    if (animate) {\n      // Clone the original matrix to perform the animation\n      var aniMatrix_1 = clone(group.getMatrix());\n      if (!aniMatrix_1) {\n        aniMatrix_1 = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      }\n      var initialRatio_1 = aniMatrix_1[0];\n      var targetRatio_1 = initialRatio_1 * finalRatio;\n      var animateConfig = getAnimateCfgWithCallback({\n        animateCfg: animateCfg,\n        callback: function callback() {\n          return _this.emit('viewportchange', {\n            action: 'zoom',\n            matrix: group.getMatrix()\n          });\n        }\n      });\n      group.animate(function (ratio) {\n        if (ratio === 1) {\n          // Reuse the first transformation\n          aniMatrix_1 = matrix;\n        } else {\n          var scale = lerp(initialRatio_1, targetRatio_1, ratio) / aniMatrix_1[0];\n          if (center) {\n            aniMatrix_1 = transform(aniMatrix_1, [['t', -center.x, -center.y], ['s', scale, scale], ['t', center.x, center.y]]);\n          } else {\n            aniMatrix_1 = transform(aniMatrix_1, [['s', scale, scale]]);\n          }\n        }\n        return {\n          matrix: aniMatrix_1\n        };\n      }, animateConfig);\n    } else {\n      group.setMatrix(matrix);\n      this.emit('viewportchange', {\n        action: 'zoom',\n        matrix: matrix\n      });\n      this.autoPaint();\n    }\n    return !failed;\n  };\n  /**\n   * 伸缩视口到一固定比例\n   * @param {number} toRatio 伸缩比例\n   * @param {Point} center 以center的x, y坐标为中心缩放\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   * @return {boolean} 缩放是否成功\n   */\n  AbstractGraph.prototype.zoomTo = function (toRatio, center, animate, animateCfg) {\n    var ratio = toRatio / this.getZoom();\n    return this.zoom(ratio, center, animate, animateCfg);\n  };\n  /**\n   * 将元素移动到视口中心\n   * @param {Item} item 指定元素\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n  AbstractGraph.prototype.focusItem = function (item, animate, animateCfg) {\n    var viewController = this.get('viewController');\n    var isAnimate = false;\n    if (animate) isAnimate = true;else if (animate === undefined) isAnimate = this.get('animate');\n    var curAniamteCfg = {};\n    if (animateCfg) curAniamteCfg = animateCfg;else if (animateCfg === undefined) curAniamteCfg = this.get('animateCfg');\n    viewController.focus(item, isAnimate, curAniamteCfg);\n    this.autoPaint();\n  };\n  /**\n   * Focus on the passed items\n   * @param {Item[]} items Items you want to focus on\n   * @param {boolean} zoomToFit Wether to zoom on the passed items\n   * @param {boolean} animate Wether to animate the transition\n   * @param {GraphAnimateConfig} animateCfg Animation configuration\n   */\n  AbstractGraph.prototype.focusItems = function (items, zoomToFit, animate, animateCfg) {\n    var viewController = this.get('viewController');\n    viewController.focusItems(items, zoomToFit, animate, animateCfg);\n  };\n  /**\n   * 自动重绘\n   * @internal 仅供内部更新机制调用，外部根据需求调用 render 或 paint 接口\n   */\n  AbstractGraph.prototype.autoPaint = function () {\n    if (this.get('autoPaint')) {\n      this.paint();\n    }\n  };\n  /**\n   * 仅画布重新绘制\n   */\n  AbstractGraph.prototype.paint = function () {\n    this.emit('beforepaint');\n    this.get('canvas').draw();\n    this.emit('afterpaint');\n  };\n  /**\n   * 将屏幕坐标转换为视口坐标\n   * @param {number} clientX 屏幕x坐标\n   * @param {number} clientY 屏幕y坐标\n   * @return {Point} 视口坐标\n   */\n  AbstractGraph.prototype.getPointByClient = function (clientX, clientY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByClient(clientX, clientY);\n  };\n  /**\n   * 将绘制坐标转换为屏幕坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {Point} 绘制坐标\n   */\n  AbstractGraph.prototype.getClientByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getClientByPoint(x, y);\n  };\n  /**\n   * 将画布坐标转换为绘制坐标\n   * @param {number} canvasX 画布 x 坐标\n   * @param {number} canvasY 画布 y 坐标\n   * @return {object} 绘制坐标\n   */\n  AbstractGraph.prototype.getPointByCanvas = function (canvasX, canvasY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByCanvas(canvasX, canvasY);\n  };\n  /**\n   * 将绘制坐标转换为画布坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {object} 画布坐标\n   */\n  AbstractGraph.prototype.getCanvasByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getCanvasByPoint(x, y);\n  };\n  /**\n   * 获取图内容的中心绘制坐标\n   * @return {object} 中心绘制坐标\n   */\n  AbstractGraph.prototype.getGraphCenterPoint = function () {\n    var bbox = this.get('group').getCanvasBBox();\n    return {\n      x: (bbox.minX + bbox.maxX) / 2,\n      y: (bbox.minY + bbox.maxY) / 2\n    };\n  };\n  /**\n   * 获取视口中心绘制坐标\n   * @return {object} 视口中心绘制坐标\n   */\n  AbstractGraph.prototype.getViewPortCenterPoint = function () {\n    return this.getPointByCanvas(this.get('width') / 2, this.get('height') / 2);\n  };\n  /**\n   * 显示元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n  AbstractGraph.prototype.showItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, true);\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.nodes = [{\n            id: id,\n            visible: true\n          }];\n          break;\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.edges = [{\n            id: id,\n            visible: true\n          }];\n          break;\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.combos = [{\n            id: id,\n            visible: true\n          }];\n          break;\n        default:\n          break;\n      }\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 隐藏元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n  AbstractGraph.prototype.hideItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, false);\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.nodes = [{\n            id: id,\n            visible: false\n          }];\n          break;\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.edges = [{\n            id: id,\n            visible: false\n          }];\n          break;\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.combos = [{\n            id: id,\n            visible: false\n          }];\n          break;\n        default:\n          break;\n      }\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 刷新元素\n   * @param {string|object} item 元素id或元素实例\n   */\n  AbstractGraph.prototype.refreshItem = function (item) {\n    var itemController = this.get('itemController');\n    itemController.refreshItem(item);\n  };\n  /**\n   * 设置是否在更新/刷新后自动重绘\n   * @param {boolean} auto 自动重绘\n   */\n  AbstractGraph.prototype.setAutoPaint = function (auto) {\n    var self = this;\n    self.set('autoPaint', auto);\n    var canvas = self.get('canvas');\n    canvas.set('autoDraw', auto);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n  AbstractGraph.prototype.remove = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    this.removeItem(item, stack);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n  AbstractGraph.prototype.removeItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    var nodeItem = item;\n    if (isString(item)) nodeItem = this.findById(item);\n    if (!nodeItem && isString(item)) {\n      console.warn(\"The item \".concat(item, \" to be removed does not exist!\"));\n    } else if (nodeItem) {\n      var type = '';\n      if (nodeItem.getType) type = nodeItem.getType();\n      // 将删除的元素入栈\n      if (stack && this.get('enabledStack')) {\n        var deletedModel = __assign(__assign({}, nodeItem.getModel()), {\n          itemType: type\n        });\n        var before = {};\n        switch (type) {\n          case 'node':\n            {\n              before.nodes = [deletedModel];\n              before.edges = [];\n              var edges = nodeItem.getEdges();\n              for (var i = edges.length - 1; i >= 0; i--) {\n                before.edges.push(__assign(__assign({}, edges[i].getModel()), {\n                  itemType: 'edge'\n                }));\n              }\n              break;\n            }\n          case 'edge':\n            before.edges = [deletedModel];\n            break;\n          case 'combo':\n            before.combos = [deletedModel];\n            break;\n          default:\n            break;\n        }\n        this.pushStack('delete', {\n          before: before,\n          after: {}\n        });\n      }\n      if (type === 'node') {\n        var model = nodeItem.getModel();\n        // 如果删除的是节点，且该节点存在于某个 Combo 中，则需要先将 node 从 combo 中移除，否则删除节点后，操作 combo 会出错\n        if (model.comboId) {\n          this.updateComboTree(nodeItem, undefined, false);\n        }\n      }\n      var itemController = this.get('itemController');\n      itemController.removeItem(nodeItem);\n      if (type === 'combo') {\n        var newComboTrees = reconstructTree(this.get('comboTrees'));\n        this.set('comboTrees', newComboTrees);\n      }\n    }\n  };\n  AbstractGraph.prototype.innerAddItem = function (type, model, itemController) {\n    // 添加节点、边或combo之前，先验证数据是否符合规范\n    if (!singleDataValidation(type, model)) {\n      return false;\n    }\n    if (model.id && this.findById(model.id)) {\n      console.warn(\"This item exists already. Be sure the id %c\".concat(model.id, \"%c is unique.\"), 'font-size: 20px; color: red;', '');\n      return;\n    }\n    var item;\n    var comboTrees = this.get('comboTrees') || [];\n    if (type === 'combo') {\n      var itemMap_1 = this.get('itemMap');\n      var foundParent_1 = false;\n      comboTrees.forEach(function (ctree) {\n        if (foundParent_1) return; // terminate the forEach after the tree containing the item is done\n        traverseTreeUp(ctree, function (child) {\n          // find the parent\n          if (model.parentId === child.id) {\n            foundParent_1 = true;\n            var newCombo = __assign({\n              id: model.id,\n              depth: child.depth + 2\n            }, model);\n            if (child.children) child.children.push(newCombo);else child.children = [newCombo];\n            model.depth = newCombo.depth;\n            item = itemController.addItem(type, model);\n          }\n          var childItem = itemMap_1[child.id];\n          // after the parent is found, update all the ancestors\n          if (foundParent_1 && childItem && childItem.getType && childItem.getType() === 'combo') {\n            itemController.updateCombo(childItem, child.children);\n          }\n          return true;\n        });\n      });\n      // if the parent is not found, add it to the root\n      if (!foundParent_1) {\n        var newCombo = __assign({\n          id: model.id,\n          depth: 0\n        }, model);\n        model.depth = newCombo.depth;\n        comboTrees.push(newCombo);\n        item = itemController.addItem(type, model);\n      }\n      this.set('comboTrees', comboTrees);\n      if (model.collapsed) {\n        this.collapseCombo(item, false);\n        this.updateCombo(item);\n      }\n    } else if (type === 'node' && isString(model.comboId) && comboTrees) {\n      var parentCombo = this.findById(model.comboId);\n      if (parentCombo && parentCombo.getType && parentCombo.getType() !== 'combo') {\n        console.warn(\"'\".concat(model.comboId, \"' is not a id of a combo in the graph, the node will be added without combo.\"));\n      }\n      item = itemController.addItem(type, model);\n      var itemMap_2 = this.get('itemMap');\n      var foundParent_2 = false,\n        foundNode_1 = false;\n      comboTrees.forEach(function (ctree) {\n        if (foundNode_1 || foundParent_2) return; // terminate the forEach\n        traverseTreeUp(ctree, function (child) {\n          if (child.id === model.id) {\n            // if the item exists in the tree already, terminate\n            foundNode_1 = true;\n            return false;\n          }\n          if (model.comboId === child.id && !foundNode_1) {\n            // found the parent, add the item to the children of its parent in the tree\n            foundParent_2 = true;\n            var cloneNode = clone(model);\n            cloneNode.itemType = 'node';\n            if (child.children) child.children.push(cloneNode);else child.children = [cloneNode];\n            cloneNode.depth = child.depth + 1;\n          }\n          // update the size of all the ancestors\n          if (foundParent_2 && itemMap_2[child.id].getType && itemMap_2[child.id].getType() === 'combo') {\n            itemController.updateCombo(itemMap_2[child.id], child.children);\n          }\n          return true;\n        });\n      });\n    } else {\n      item = itemController.addItem(type, model);\n    }\n    if (type === 'node' && model.comboId || type === 'combo' && model.parentId) {\n      // add the combo to the parent's children array\n      var parentCombo = this.findById(model.comboId || model.parentId);\n      if (parentCombo && parentCombo.getType && parentCombo.getType() === 'combo') parentCombo.addChild(item);\n    }\n    return item;\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\n   * @return {Item} 元素实例\n   */\n  AbstractGraph.prototype.addItem = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n    var currentComboSorted = this.get('comboSorted');\n    this.set('comboSorted', currentComboSorted && !sortCombo);\n    var itemController = this.get('itemController');\n    var item = this.innerAddItem(type, model, itemController);\n    if (item === false || item === true) {\n      return item;\n    }\n    var combos = this.get('combos');\n    if (combos && combos.length > 0) {\n      this.sortCombos();\n    }\n    this.autoPaint();\n    if (stack && this.get('enabledStack')) {\n      var addedModel = __assign(__assign({}, item.getModel()), {\n        itemType: type\n      });\n      var after = {};\n      switch (type) {\n        case 'node':\n          after.nodes = [addedModel];\n          break;\n        case 'edge':\n          after.edges = [addedModel];\n          break;\n        case 'combo':\n          after.combos = [addedModel];\n          break;\n        default:\n          break;\n      }\n      this.pushStack('add', {\n        before: {},\n        after: after\n      });\n    }\n    return item;\n  };\n  AbstractGraph.prototype.addItems = function (items, stack, sortCombo) {\n    if (items === void 0) {\n      items = [];\n    }\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n    var currentComboSorted = this.get('comboSorted');\n    this.set('comboSorted', currentComboSorted && !sortCombo);\n    var itemController = this.get('itemController');\n    var returnItems = [];\n    // 1. add anything that is not an edge.\n    // Add undefined as a placeholder for the next cycle. This way we return items matching the input order\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n      if (item.type !== 'edge' && item.type !== 'vedge') {\n        returnItems.push(this.innerAddItem(item.type, item.model, itemController));\n      } else {\n        returnItems.push(undefined);\n      }\n    }\n    // 2. add all the edges\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n      if (item.type === 'edge' || item.type === 'vedge') {\n        returnItems[i] = this.innerAddItem(item.type, item.model, itemController);\n      }\n    }\n    if (sortCombo) {\n      var combos = this.get('combos');\n      if (combos && combos.length > 0) {\n        this.sortCombos();\n      }\n    }\n    this.autoPaint();\n    if (stack && this.get('enabledStack')) {\n      var after = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      for (var i = 0; i < items.length; i++) {\n        var type = items[i].type;\n        var returnItem = returnItems[i];\n        if (!!returnItem && returnItem !== true) {\n          var addedModel = __assign(__assign({}, returnItem.getModel()), {\n            itemType: type\n          });\n          switch (type) {\n            case 'node':\n              after.nodes.push(addedModel);\n              break;\n            case 'edge':\n              after.edges.push(addedModel);\n              break;\n            case 'combo':\n              after.combos.push(addedModel);\n              break;\n            default:\n              break;\n          }\n        }\n      }\n      this.pushStack('addItems', {\n        before: {},\n        after: after\n      });\n    }\n    return returnItems;\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\n   * @return {Item} 元素实例\n   */\n  AbstractGraph.prototype.add = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n    return this.addItem(type, model, stack, sortCombo);\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   */\n  AbstractGraph.prototype.updateItem = function (item, cfg, stack) {\n    var _this = this;\n    if (stack === void 0) {\n      stack = true;\n    }\n    var itemController = this.get('itemController');\n    var currentItem;\n    if (isString(item)) {\n      currentItem = this.findById(item);\n    } else {\n      currentItem = item;\n    }\n    var stackEnabled = stack && this.get('enabledStack');\n    var unupdatedModel;\n    if (stackEnabled) {\n      unupdatedModel = clone(currentItem.getModel());\n    }\n    var type = '';\n    if (currentItem.getType) type = currentItem.getType();\n    var states = __spreadArray([], currentItem.getStates(), true);\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, false);\n      });\n    }\n    itemController.updateItem(currentItem, cfg);\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, true);\n      });\n    }\n    if (stackEnabled) {\n      var before = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      var after = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      var afterModel = __assign({\n        id: unupdatedModel.id\n      }, cfg);\n      switch (type) {\n        case 'node':\n          before.nodes.push(unupdatedModel);\n          after.nodes.push(afterModel);\n          break;\n        case 'edge':\n          before.edges.push(unupdatedModel);\n          after.edges.push(afterModel);\n          break;\n        case 'combo':\n          before.combos.push(unupdatedModel);\n          after.combos.push(afterModel);\n          break;\n        default:\n          break;\n      }\n      this.pushStack('update', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n  AbstractGraph.prototype.update = function (item, cfg, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    this.updateItem(item, cfg, stack);\n  };\n  /**\n   * 设置元素状态\n   * @param {Item} item 元素id或元素实例\n   * @param {string} state 状态名称\n   * @param {string | boolean} value 是否启用状态 或 状态值\n   */\n  AbstractGraph.prototype.setItemState = function (item, state, value) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n    var itemController = this.get('itemController');\n    itemController.setItemState(item, state, value);\n    var stateController = this.get('stateController');\n    stateController.updateState(item, state, value);\n  };\n  /**\n   * 将指定状态的优先级提升为最高优先级\n   * @param {Item} item 元素id或元素实例\n   * @param state 状态名称\n   */\n  AbstractGraph.prototype.priorityState = function (item, state) {\n    var itemController = this.get('itemController');\n    itemController.priorityState(item, state);\n  };\n  /**\n   * 设置视图初始化数据\n   * @param {GraphData} data 初始化数据\n   */\n  AbstractGraph.prototype.data = function (data) {\n    dataValidation(data);\n    this.set('data', data);\n  };\n  /**\n   * 根据data接口的数据渲染视图\n   */\n  AbstractGraph.prototype.render = function () {\n    var self = this;\n    this.set('comboSorted', false);\n    var data = this.get('data');\n    if (this.get('enabledStack')) {\n      // render 之前清空 redo 和 undo 栈\n      this.clearStack();\n    }\n    if (!data) {\n      throw new Error('data must be defined first');\n    }\n    var _a = data.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = data.edges,\n      edges = _b === void 0 ? [] : _b,\n      _c = data.combos,\n      combos = _c === void 0 ? [] : _c;\n    this.clear(true);\n    this.emit('beforerender');\n    self.addItems(nodes.map(function (node) {\n      return {\n        type: 'node',\n        model: node\n      };\n    }), false, false);\n    // process the data to tree structure\n    if ((combos === null || combos === void 0 ? void 0 : combos.length) !== 0) {\n      var comboTrees = plainCombosToTrees(combos, nodes);\n      this.set('comboTrees', comboTrees);\n      // add combos\n      self.addCombos(combos);\n    }\n    self.addItems(edges.map(function (edge) {\n      return {\n        type: 'edge',\n        model: edge\n      };\n    }), false, false);\n    var animate = self.get('animate');\n    if (self.get('fitView') || self.get('fitCenter')) {\n      self.set('animate', false);\n    }\n    // layout\n    var layoutController = self.get('layoutController');\n    if (layoutController) {\n      layoutController.layout(success);\n      if (this.destroyed) return;\n    } else {\n      success();\n    }\n    // 将在 onLayoutEnd 中被调用\n    function success() {\n      // 自底向上将 collapsed 的 combo 合起\n      (self.get('comboTrees') || []).forEach(function (ctree) {\n        traverseTreeUp(ctree, function (child) {\n          var item = self.findById(child.id);\n          if (item.getType() === 'combo' && child.collapsed) {\n            self.collapseCombo(child.id, false);\n            self.updateCombo(item);\n          }\n          return true;\n        });\n      });\n      // fitView 与 fitCenter 共存时，fitView 优先，fitCenter 不再执行\n      if (self.get('fitView')) {\n        self.fitView();\n      } else if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n      self.autoPaint();\n      self.emit('afterrender');\n      if (self.get('fitView') || self.get('fitCenter')) {\n        self.set('animate', animate);\n      }\n      setTimeout(function () {\n        var _a;\n        (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n          combo.set('animate', true);\n        });\n      }, 0);\n    }\n    if (!this.get('groupByTypes')) {\n      if (combos && combos.length !== 0) {\n        this.sortCombos();\n      } else {\n        // 为提升性能，选择数量少的进行操作\n        if (data.nodes && data.edges && data.nodes.length < data.edges.length) {\n          var nodesArr = this.getNodes();\n          // 遍历节点实例，将所有节点提前。\n          nodesArr.forEach(function (node) {\n            node.toFront();\n          });\n        } else {\n          var edgesArr = this.getEdges();\n          // 遍历节点实例，将所有节点提前。\n          edgesArr.forEach(function (edge) {\n            edge.toBack();\n          });\n        }\n      }\n    }\n  };\n  /**\n   * 接收数据进行渲染\n   * @Param {Object} data 初始化数据\n   */\n  AbstractGraph.prototype.read = function (data) {\n    this.data(data);\n    this.render();\n  };\n  // 比较item\n  AbstractGraph.prototype.diffItems = function (type, items, models) {\n    var self = this;\n    var item;\n    var itemMap = this.get('itemMap');\n    each(models, function (model) {\n      item = itemMap[model.id];\n      if (item) {\n        if (self.get('animate') && type === NODE) {\n          var containerMatrix = item.getContainer().getMatrix();\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          item.set('originAttrs', {\n            x: containerMatrix[6],\n            y: containerMatrix[7]\n          });\n        }\n        self.updateItem(item, model, false);\n      } else {\n        item = self.addItem(type, model, false);\n      }\n      if (item) items[\"\".concat(type, \"s\")].push(item);\n    });\n  };\n  /**\n   * 更改源数据，根据新数据重新渲染视图\n   * @param {GraphData | TreeGraphData} data 源数据\n   * @param {boolean} 是否入栈，默认为true\n   * @return {object} this\n   */\n  AbstractGraph.prototype.changeData = function (propsData, stack) {\n    var _this = this;\n    var _a;\n    if (stack === void 0) {\n      stack = true;\n    }\n    var self = this;\n    var data = propsData || self.get('data');\n    if (!dataValidation(data)) {\n      return this;\n    }\n    this.emit('beforechangedata');\n    if (stack && this.get('enabledStack')) {\n      this.pushStack('changedata', {\n        before: self.save(),\n        after: data\n      });\n    }\n    this.set('comboSorted', false);\n    // 删除 hulls\n    this.removeHulls();\n    // 更改数据源后，取消所有状态\n    this.getNodes().map(function (node) {\n      return self.clearItemStates(node);\n    });\n    this.getEdges().map(function (edge) {\n      return self.clearItemStates(edge);\n    });\n    var canvas = this.get('canvas');\n    var localRefresh = canvas.get('localRefresh');\n    canvas.set('localRefresh', false);\n    if (!self.get('data')) {\n      self.data(data);\n      self.render();\n    }\n    var itemMap = this.get('itemMap');\n    var items = {\n      nodes: [],\n      edges: []\n    };\n    var combosData = data.combos;\n    if (combosData) {\n      var comboTrees = plainCombosToTrees(combosData, data.nodes);\n      this.set('comboTrees', comboTrees);\n    } else {\n      this.set('comboTrees', []);\n    }\n    this.diffItems('node', items, data.nodes);\n    each(itemMap, function (item, id) {\n      itemMap[id].getModel().depth = 0;\n      if (item.getType && item.getType() === 'edge') return;\n      if (item.getType && item.getType() === 'combo') {\n        delete itemMap[id];\n        item.destroy();\n      } else if (items.nodes.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    });\n    // clear the destroyed combos here to avoid removing sub nodes before removing the parent combo\n    var comboItems = this.getCombos();\n    var combosLength = comboItems.length;\n    for (var i = combosLength - 1; i >= 0; i--) {\n      if (comboItems[i].destroyed) {\n        comboItems.splice(i, 1);\n      }\n    }\n    // process the data to tree structure\n    if (combosData) {\n      // add combos\n      self.addCombos(combosData);\n      if (!this.get('groupByTypes')) {\n        this.sortCombos();\n      }\n    }\n    this.diffItems('edge', items, data.edges);\n    each(itemMap, function (item, id) {\n      if (item.getType && (item.getType() === 'node' || item.getType() === 'combo')) return;\n      if (items.edges.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    });\n    // 自底向上将 collapsed 的 combo 合起\n    (this.get('comboTrees') || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        var item = _this.findById(child.id);\n        if (item.getType() === 'combo' && child.collapsed) {\n          _this.collapseCombo(child.id, false);\n        }\n        return true;\n      });\n    });\n    this.set({\n      nodes: items.nodes,\n      edges: items.edges\n    });\n    var _b = (this.get('layout') || {}).relayoutAtChangeData,\n      relayoutAtChangeData = _b === void 0 ? true : _b;\n    var layoutController = this.get('layoutController');\n    if (relayoutAtChangeData && layoutController) {\n      layoutController.changeData(function () {\n        setTimeout(function () {\n          var _a;\n          (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n            combo.set('animate', true);\n          });\n        }, 0);\n      });\n      if (self.get('animate') && !layoutController.getLayoutType()) {\n        // 如果没有指定布局\n        self.positionsAnimate();\n        (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n          return combo.set('animate', true);\n        });\n      } else {\n        self.autoPaint();\n      }\n    }\n    setTimeout(function () {\n      canvas.set('localRefresh', localRefresh);\n    }, 16);\n    this.set('data', data);\n    this.emit('afterchangedata');\n    return this;\n  };\n  /**\n   * 私有方法，在 render 和 changeData 的时候批量添加数据中所有平铺的 combos\n   * @param {ComboConfig[]} combos 平铺的 combos 数据\n   */\n  AbstractGraph.prototype.addCombos = function (combos) {\n    var self = this;\n    var comboTrees = self.get('comboTrees');\n    var itemController = this.get('itemController');\n    itemController.addCombos(comboTrees, combos);\n  };\n  /**\n   * 根据已经存在的节点或 combo 创建新的 combo\n   * @param combo combo ID 或 Combo 配置\n   * @param childrenIds 添加到 Combo 中的元素，包括节点和 combo\n   */\n  AbstractGraph.prototype.createCombo = function (combo, childrenIds, stack) {\n    var _this = this;\n    if (stack === void 0) {\n      stack = true;\n    }\n    var itemController = this.get('itemController');\n    this.set('comboSorted', false);\n    // step 1: 创建新的 Combo\n    var comboId = '';\n    var comboConfig;\n    if (!combo) return;\n    if (isString(combo)) {\n      comboId = combo;\n      comboConfig = {\n        id: combo\n      };\n    } else {\n      comboId = combo.id;\n      if (!comboId) {\n        console.warn('Create combo failed. Please assign a unique string id for the adding combo.');\n        return;\n      }\n      comboConfig = combo;\n    }\n    var shouldStack = stack && this.get('enabledStack');\n    // cache the children's old parent for stack\n    var childrenParentCache = {\n      nodes: [],\n      combos: []\n    };\n    if (shouldStack) {\n      childrenIds.forEach(function (childId) {\n        var childItem = _this.findById(childId);\n        var childType = childItem.getType();\n        if (childType !== 'node' && childType !== 'combo') return;\n        var childModel = childItem.getModel();\n        childrenParentCache[\"\".concat(childType, \"s\")].push({\n          id: childId,\n          parentId: childType === 'node' ? childModel.comboId : childModel.parentId\n        });\n      });\n    }\n    // step 2: Pull children out of their parents\n    var comboTrees = this.get('comboTrees');\n    var childrenIdsSet = new Set(childrenIds);\n    var pulledComboTreesById = new Map();\n    if (comboTrees) {\n      comboTrees.forEach(function (ctree) {\n        traverseTreeUp(ctree, function (treeNode, parentTreeNode, index) {\n          if (childrenIdsSet.has(treeNode.id)) {\n            if (parentTreeNode) {\n              var parentItem = _this.findById(parentTreeNode.id);\n              var item = _this.findById(treeNode.id);\n              // Removing current item from the tree during the traversal is ok because children traversal is done\n              // in an *inverse order* - indices of the next-traversed items are not disturbed by the removal.\n              parentTreeNode.children.splice(index, 1);\n              parentItem.removeChild(item);\n              // We have to update the parent node geometry since nodes were removed from them, _while they are still visible_\n              // (combos may be moved inside the new combo and become hidden)\n              itemController.updateCombo(parentItem, parentTreeNode.children);\n            }\n            if (treeNode.itemType === 'combo') {\n              pulledComboTreesById.set(treeNode.id, treeNode);\n            }\n          }\n          return true;\n        });\n      });\n      comboTrees = comboTrees.filter(function (ctree) {\n        return !childrenIdsSet.has(ctree.id);\n      });\n      this.set('comboTrees', comboTrees);\n    }\n    // step 3: 更新 children，根据类型添加 comboId 或 parentId\n    var newChildrenParent = {\n      nodes: [],\n      combos: []\n    };\n    var trees = childrenIds.map(function (elementId) {\n      var item = _this.findById(elementId);\n      var model = item.getModel();\n      var type = '';\n      if (item.getType) type = item.getType();\n      // Combos will be just moved around, so their children can be preserved\n      var cItem = pulledComboTreesById.get(elementId) || {\n        id: item.getID(),\n        itemType: type\n      };\n      if (type === 'combo') {\n        cItem.parentId = comboId;\n        model.parentId = comboId;\n      } else if (type === 'node') {\n        cItem.comboId = comboId;\n        model.comboId = comboId;\n      }\n      if (shouldStack) {\n        newChildrenParent[\"\".concat(type, \"s\")].push({\n          id: model.id,\n          parentId: comboId\n        });\n      }\n      return cItem;\n    });\n    comboConfig.children = trees;\n    // step 4: 添加 Combo，addItem 时会将子将元素添加到 Combo 中\n    this.addItem('combo', comboConfig, false);\n    this.set('comboSorted', false);\n    // step 5: 更新 comboTrees 结构\n    if (comboTrees) {\n      comboTrees.forEach(function (ctree) {\n        traverseTree(ctree, function (treeNode) {\n          // Set the children to the newly created combo\n          if (treeNode.id === comboId) {\n            treeNode.itemType = 'combo';\n            treeNode.children = trees;\n            return false;\n          }\n          return true;\n        });\n      });\n      this.sortCombos();\n    }\n    if (shouldStack) {\n      newChildrenParent.combos.push(comboConfig);\n      this.pushStack('createCombo', {\n        before: childrenParentCache,\n        after: newChildrenParent\n      });\n    }\n    // Fixes issue of nested child combos not being interactive (under parent on graph).\n    var comboItem = this.findById(comboId);\n    if (!comboItem.getModel().parentId && comboItem.getChildren().combos.length) {\n      this.updateComboTree(comboItem, undefined, false);\n    }\n    setTimeout(function () {\n      comboItem.set('animate', true);\n    }, 0);\n  };\n  /**\n   * 解散 combo\n   * @param {String | INode | ICombo} combo 需要被解散的 Combo item 或 id\n   */\n  AbstractGraph.prototype.uncombo = function (combo, stack) {\n    var _this = this;\n    var _a, _b;\n    if (stack === void 0) {\n      stack = true;\n    }\n    var self = this;\n    var comboItem = combo;\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item is not a combo!');\n      return;\n    }\n    var comboModel = comboItem.getModel();\n    var parentId = comboItem.getModel().parentId;\n    var comboTrees = self.get('comboTrees');\n    if (!comboTrees) comboTrees = [];\n    var itemMap = this.get('itemMap');\n    var comboId = comboItem.get('id');\n    var treeToBeUncombo;\n    var brothers = [];\n    var comboItems = this.get('combos');\n    var parentItem = this.findById(parentId);\n    var shouldStack = stack && this.get('enabledStack');\n    var comboConfig = {};\n    if (shouldStack) {\n      comboConfig = clone(comboModel);\n      comboConfig.children = [];\n    }\n    comboTrees.forEach(function (ctree) {\n      if (treeToBeUncombo) return; // terminate the forEach\n      traverseTreeUp(ctree, function (subtree) {\n        var _a;\n        // find the combo to be uncomboed, delete the combo from map and cache\n        if (subtree.id === comboId) {\n          treeToBeUncombo = subtree;\n          // delete the related edges\n          var edgeIds = comboItem.getEdges().map(function (edge) {\n            return edge.getID();\n          });\n          edgeIds.forEach(function (edgeId) {\n            _this.removeItem(edgeId, false);\n          });\n          var index = comboItems.indexOf(comboItem);\n          comboItems.splice(index, 1);\n          delete itemMap[comboId];\n          var itemModel = clone(comboItem.getModel());\n          comboItem.destroy();\n          _this.emit('afterremoveitem', {\n            item: itemModel,\n            type: 'combo'\n          });\n        }\n        // find the parent to remove the combo from the combo's brothers array and add the combo's children to the combo's brothers array in the tree\n        if (parentId && treeToBeUncombo && subtree.id === parentId) {\n          parentItem.removeCombo(comboItem);\n          brothers = subtree.children; // the combo's brothers\n          // remove the combo from its brothers array\n          var index = brothers.indexOf(treeToBeUncombo);\n          if (index !== -1) {\n            brothers.splice(index, 1);\n          }\n          // append the combo's children to the combo's brothers array\n          (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            var item = _this.findById(child.id);\n            var childModel = item.getModel();\n            if (item.getType && item.getType() === 'combo') {\n              child.parentId = parentId;\n              delete child.comboId;\n              childModel.parentId = parentId; // update the parentId of the model\n              delete childModel.comboId;\n            } else if (item.getType && item.getType() === 'node') {\n              child.comboId = parentId;\n              childModel.comboId = parentId; // update the parentId of the model\n            }\n\n            parentItem.addChild(item);\n            brothers.push(child);\n          });\n          _this.updateCombo(parentItem);\n          return false;\n        }\n        return true;\n      });\n    });\n    // if the parentId is not found, remove the combo from the roots\n    if (!parentId && treeToBeUncombo) {\n      var index = comboTrees.indexOf(treeToBeUncombo);\n      comboTrees.splice(index, 1);\n      // modify the parentId of the children\n      (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n        child.parentId = undefined;\n        var childModel = _this.findById(child.id).getModel();\n        delete childModel.parentId; // update the parentId of the model\n        delete childModel.comboId; // update the comboId of the model\n        if (child.itemType !== 'node') comboTrees.push(child);\n      });\n    }\n    if (shouldStack) {\n      // cache the children's old parent and combo model for stack\n      var childrenParentCache_1 = {\n        nodes: [],\n        combos: []\n      };\n      var childNewParent_1 = {\n        nodes: [],\n        combos: []\n      };\n      (_b = treeToBeUncombo.children) === null || _b === void 0 ? void 0 : _b.forEach(function (child) {\n        var childItem = _this.findById(child.id);\n        var childType = childItem.getType();\n        if (childType !== 'node' && childType !== 'combo') return;\n        childrenParentCache_1[\"\".concat(childType, \"s\")].push({\n          id: child.id,\n          parentId: comboId\n        });\n        childNewParent_1[\"\".concat(childType, \"s\")].push({\n          id: child.id,\n          parentId: parentId\n        });\n      });\n      childrenParentCache_1.combos.push(comboConfig);\n      this.pushStack('uncombo', {\n        before: childrenParentCache_1,\n        after: childNewParent_1\n      });\n    }\n  };\n  /**\n   * 根据 combo 位置更新内部节点位置 followCombo = true\n   * 或根据内部元素的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围，followCombo = false\n   */\n  AbstractGraph.prototype.updateCombos = function (followCombo) {\n    var _this = this;\n    if (followCombo === void 0) {\n      followCombo = false;\n    }\n    var self = this;\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        var _a;\n        if (!child) {\n          return true;\n        }\n        var childItem = itemMap[child.id];\n        if (((_a = childItem === null || childItem === void 0 ? void 0 : childItem.getType) === null || _a === void 0 ? void 0 : _a.call(childItem)) === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true);\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, false);\n          });\n          // 更新具体的 Combo\n          itemController.updateCombo(childItem, child.children, followCombo);\n          // 更新 Combo 后，还原已有的状态\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, true);\n          });\n        }\n        return true;\n      });\n    });\n    self.sortCombos();\n  };\n  /**\n   * 根据节点的 bbox 更新 combo 及其祖先 combos 的绘制，包括 combos 的位置和范围\n   * @param {String | ICombo} combo 需要被更新的 Combo 或 id，若指定，则该 Combo 及所有祖先 Combod 都会被更新\n   */\n  AbstractGraph.prototype.updateCombo = function (combo) {\n    var _this = this;\n    var self = this;\n    var comboItem = combo;\n    var comboId;\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item to be updated is not a combo!');\n      return;\n    }\n    comboId = comboItem.get('id');\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (!child) {\n          return true;\n        }\n        var childItem = itemMap[child.id];\n        if (comboId === child.id && childItem && childItem.getType && childItem.getType() === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true);\n          // || !item.getStateStyle(stateName)\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, false);\n            }\n          });\n          // 更新具体的 Combo\n          itemController.updateCombo(childItem, child.children);\n          // 更新 Combo 后，还原已有的状态\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, true);\n            }\n          });\n          if (comboId) comboId = child.parentId;\n        }\n        return true;\n      });\n    });\n  };\n  /**\n   * 更新树结构，例如移动子树等\n   * @param {String | INode | ICombo} item 需要被更新的 Combo 或 节点 id\n   * @param {string | undefined} parentId 新的父 combo id，undefined 代表没有父 combo\n   */\n  AbstractGraph.prototype.updateComboTree = function (item, parentId, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    var self = this;\n    this.set('comboSorted', false);\n    var uItem;\n    if (isString(item)) {\n      uItem = self.findById(item);\n    } else {\n      uItem = item;\n    }\n    var model = uItem.getModel();\n    var oldParentId = model.comboId || model.parentId;\n    var type = '';\n    if (uItem.getType) type = uItem.getType();\n    // 若 item 是 Combo，且 parentId 是其子孙 combo 的 id，则警告并终止\n    if (parentId && type === 'combo') {\n      var comboTrees = this.get('comboTrees');\n      var valid_1 = true;\n      var itemSubTree_1;\n      (comboTrees || []).forEach(function (ctree) {\n        if (itemSubTree_1) return;\n        traverseTree(ctree, function (subTree) {\n          if (itemSubTree_1) return;\n          // 找到从 item 开始的子树\n          if (subTree.id === uItem.getID()) {\n            itemSubTree_1 = subTree;\n          }\n          return true;\n        });\n      });\n      // 在以 item 为根的子树中寻找与 parentId 相同的后继元素\n      traverseTree(itemSubTree_1, function (subTree) {\n        if (subTree.id === parentId) {\n          valid_1 = false;\n          return false;\n        }\n        return true;\n      });\n      // parentId 是 item 的一个后继元素，不能进行更新\n      if (!valid_1) {\n        console.warn('Failed to update the combo tree! The parentId points to a descendant of the combo!');\n        return;\n      }\n    }\n    if (stack && this.get('enabledStack')) {\n      var beforeData = {},\n        afterData = {};\n      if (type === 'combo') {\n        beforeData.combos = [{\n          id: model.id,\n          parentId: model.parentId\n        }];\n        afterData.combos = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      } else if (type === 'node') {\n        beforeData.nodes = [{\n          id: model.id,\n          parentId: model.comboId\n        }];\n        afterData.nodes = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      }\n      this.pushStack('updateComboTree', {\n        before: beforeData,\n        after: afterData\n      });\n    }\n    // 当 combo 存在 parentId 或 comboId 时，才将其移除\n    if (model.parentId || model.comboId) {\n      var combo = this.findById(model.parentId || model.comboId);\n      if (combo) {\n        combo.removeChild(uItem);\n      }\n    }\n    if (type === 'combo') {\n      model.parentId = parentId;\n    } else if (type === 'node') {\n      model.comboId = parentId;\n    }\n    // 只有当移入到指定 combo 时才添加\n    if (parentId) {\n      var parentCombo = this.findById(parentId);\n      if (parentCombo) {\n        // 将元素添加到 parentCombo 中\n        parentCombo.addChild(uItem);\n      }\n    }\n    // 如果原先有父亲 combo，则从原父 combo 的子元素数组中删除\n    if (oldParentId) {\n      var parentCombo = this.findById(oldParentId);\n      if (parentCombo) {\n        // 将元素从 parentCombo 中移除\n        parentCombo.removeChild(uItem);\n      }\n    }\n    var newComboTrees = reconstructTree(this.get('comboTrees'), model.id, parentId);\n    this.set('comboTrees', newComboTrees);\n    this.updateCombos();\n  };\n  /**\n   * 导出图数据\n   * @return {object} data\n   */\n  AbstractGraph.prototype.save = function () {\n    var nodes = [];\n    var edges = [];\n    var combos = [];\n    each(this.get('nodes'), function (node) {\n      nodes.push(node.getModel());\n    });\n    each(this.get('edges'), function (edge) {\n      edges.push(edge.getModel());\n    });\n    each(this.get('combos'), function (combo) {\n      combos.push(combo.getModel());\n    });\n    return {\n      nodes: nodes,\n      edges: edges,\n      combos: combos\n    };\n  };\n  /**\n   * 改变画布大小\n   * @param  {number} width  画布宽度\n   * @param  {number} height 画布高度\n   * @return {object} this\n   */\n  AbstractGraph.prototype.changeSize = function (width, height) {\n    var viewController = this.get('viewController');\n    viewController.changeSize(width, height);\n    return this;\n  };\n  /**\n   * 当源数据在外部发生变更时，根据新数据刷新视图。但是不刷新节点位置\n   */\n  AbstractGraph.prototype.refresh = function () {\n    var self = this;\n    self.emit('beforegraphrefresh');\n    if (self.get('animate')) {\n      self.positionsAnimate();\n    } else {\n      var nodes = self.get('nodes');\n      var edges = self.get('edges');\n      var vedges = self.get('edges');\n      each(nodes, function (node) {\n        node.refresh();\n      });\n      each(edges, function (edge) {\n        edge.refresh();\n      });\n      each(vedges, function (vedge) {\n        vedge.refresh();\n      });\n    }\n    self.emit('aftergraphrefresh');\n    self.autoPaint();\n  };\n  /**\n   * 获取当前图中所有节点的item实例\n   * @return {INode} item数组\n   */\n  AbstractGraph.prototype.getNodes = function () {\n    return this.get('nodes');\n  };\n  /**\n   * 获取当前图中所有边的item实例\n   * @return {IEdge} item数组\n   */\n  AbstractGraph.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取图中所有的 combo 实例\n   */\n  AbstractGraph.prototype.getCombos = function () {\n    return this.get('combos');\n  };\n  /**\n   * 获取指定 Combo 中所有的节点\n   * @param comboId combo ID\n   */\n  AbstractGraph.prototype.getComboChildren = function (combo) {\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo does not exist!');\n      return;\n    }\n    return combo.getChildren();\n  };\n  /**\n   * 根据 graph 上的 animateCfg 进行视图中节点位置动画接口\n   */\n  AbstractGraph.prototype.positionsAnimate = function (referComboModel) {\n    var self = this;\n    self.emit('beforeanimate');\n    var animateCfg = self.get('animateCfg');\n    var onFrame = animateCfg.onFrame;\n    var nodes = referComboModel ? self.getNodes().concat(self.getCombos()) : self.getNodes();\n    var toNodes = nodes.map(function (node) {\n      var model = node.getModel();\n      return {\n        id: model.id,\n        x: model.x,\n        y: model.y\n      };\n    });\n    self.stopAnimate();\n    var canvas = self.get('canvas');\n    self.animating = true;\n    setTimeout(function () {\n      canvas.animate(function (ratio) {\n        each(toNodes, function (data) {\n          var node = self.findById(data.id);\n          if (!node || node.destroyed) {\n            return;\n          }\n          var originAttrs = node.get('originAttrs');\n          var model = node.get('model');\n          var containerMatrix = node.getContainer().getMatrix();\n          if (originAttrs === undefined || originAttrs === null) {\n            // 变换前存在位置，设置到 originAttrs 上。否则标记 0 表示变换前不存在位置，不需要计算动画\n            if (containerMatrix) {\n              originAttrs = {\n                x: containerMatrix[6],\n                y: containerMatrix[7]\n              };\n            }\n            node.set('originAttrs', originAttrs || 0);\n          }\n          if (onFrame) {\n            var attrs = onFrame(node, ratio, data, originAttrs || {\n              x: 0,\n              y: 0\n            });\n            node.set('model', Object.assign(model, attrs));\n          } else if (originAttrs) {\n            // 变换前存在位置，进行动画\n            model.x = originAttrs.x + (data.x - originAttrs.x) * ratio;\n            model.y = originAttrs.y + (data.y - originAttrs.y) * ratio;\n          } else {\n            // 若在变换前不存在位置信息，则直接放到最终位置上\n            model.x = data.x;\n            model.y = data.y;\n          }\n        });\n        self.refreshPositions(referComboModel);\n      }, {\n        duration: animateCfg.duration,\n        easing: animateCfg.easing,\n        callback: function callback() {\n          each(nodes, function (node) {\n            node.set('originAttrs', null);\n          });\n          if (animateCfg.callback) {\n            animateCfg.callback();\n          }\n          self.emit('afteranimate');\n          self.animating = false;\n        }\n      });\n    }, 0);\n  };\n  /**\n   * 当节点位置在外部发生改变时，刷新所有节点位置，重计算边\n   */\n  AbstractGraph.prototype.refreshPositions = function (referComboModel) {\n    var self = this;\n    self.emit('beforegraphrefreshposition');\n    var nodes = self.get('nodes');\n    var edges = self.get('edges');\n    var vedges = self.get('vedges');\n    var combos = self.get('combos');\n    var model;\n    var updatedNodes = {};\n    var updateItems = function updateItems(items) {\n      each(items, function (item) {\n        model = item.getModel();\n        var originAttrs = item.get('originAttrs');\n        if (originAttrs && model.x === originAttrs.x && model.y === originAttrs.y) {\n          return;\n        }\n        var changed = item.updatePosition({\n          x: model.x,\n          y: model.y\n        });\n        updatedNodes[model.id] = changed;\n        if (model.comboId) updatedNodes[model.comboId] = updatedNodes[model.comboId] || changed;\n        if (model.parentId) updatedNodes[model.parentId] = updatedNodes[model.parentId] || changed;\n      });\n    };\n    updateItems(combos);\n    updateItems(nodes);\n    if (combos && combos.length !== 0) {\n      if (referComboModel) {\n        updateItems(combos);\n        self.updateCombos();\n      } else {\n        self.updateCombos();\n      }\n    }\n    each(edges, function (edge) {\n      var sourceModel = edge.getSource().getModel();\n      var target = edge.getTarget();\n      // 避免 target 是纯对象的情况下调用 getModel 方法\n      // 拖动生成边的时候 target 会是纯对象\n      if (!isPlainObject(target)) {\n        var targetModel = target.getModel();\n        if (updatedNodes[sourceModel.id] || updatedNodes[targetModel.id] || edge.getModel().isComboEdge) {\n          edge.refresh();\n        }\n      }\n    });\n    each(vedges, function (vedge) {\n      vedge.refresh();\n    });\n    self.emit('aftergraphrefreshposition');\n    self.autoPaint();\n  };\n  AbstractGraph.prototype.stopAnimate = function () {\n    var canvas = this.get('canvas');\n    var timeline = canvas.cfg.timeline;\n    if (timeline) {\n      timeline.stopAllAnimations();\n    }\n  };\n  AbstractGraph.prototype.isAnimating = function () {\n    return this.animating;\n  };\n  /**\n   * 获取当前视口伸缩比例\n   * @return {number} 比例\n   */\n  AbstractGraph.prototype.getZoom = function () {\n    var matrix = this.get('group').getMatrix();\n    return matrix ? matrix[0] : 1;\n  };\n  /**\n   * 获取当前的行为模式\n   * @return {string} 当前行为模式\n   */\n  AbstractGraph.prototype.getCurrentMode = function () {\n    var modeController = this.get('modeController');\n    return modeController.getMode();\n  };\n  /**\n   * 切换行为模式\n   * @param {string} mode 指定模式\n   * @return {object} this\n   */\n  AbstractGraph.prototype.setMode = function (mode) {\n    var modeController = this.get('modeController');\n    modeController.setMode(mode);\n    return this;\n  };\n  /**\n   * 清除画布元素\n   * @return {object} this\n   */\n  AbstractGraph.prototype.clear = function (avoidEmit) {\n    var _a;\n    if (avoidEmit === void 0) {\n      avoidEmit = false;\n    }\n    (_a = this.get('canvas')) === null || _a === void 0 ? void 0 : _a.clear();\n    this.initGroups();\n    // 清空画布时同时清除数据\n    this.set({\n      itemMap: {},\n      nodes: [],\n      edges: [],\n      vedges: [],\n      groups: [],\n      combos: [],\n      comboTrees: []\n    });\n    if (!avoidEmit) this.emit('afterrender');\n    return this;\n  };\n  /**\n   * 更换布局配置项\n   * @param {object} cfg 新布局配置项\n   * @param {'center' | 'begin'} align 对齐方式，可选中心（center）对齐到对齐点，或左上角（begin）对齐到对齐点\n   * @param {IPoint} alignPoint 画布上的对齐点，为 Canvas 坐标系（Canvas DOM）\n   * 若 cfg 含有 type 字段或为 String 类型，且与现有布局方法不同，则更换布局\n   * 若 cfg 不包括 type ，则保持原有布局方法，仅更新布局配置项\n   */\n  AbstractGraph.prototype.updateLayout = function (cfg, align, alignPoint, stack) {\n    var _this = this;\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    if (stack === void 0) {\n      stack = true;\n    }\n    var layoutController = this.get('layoutController');\n    if (isString(cfg)) {\n      cfg = {\n        type: cfg\n      };\n    }\n    // align the graph after layout\n    if (align) {\n      var toPoint_1 = alignPoint;\n      if (!toPoint_1) {\n        if (align === 'begin') toPoint_1 = {\n          x: 0,\n          y: 0\n        };else toPoint_1 = {\n          x: this.getWidth() / 2,\n          y: this.getHeight() / 2\n        };\n      }\n      // translate to point coordinate system\n      toPoint_1 = this.getPointByCanvas(toPoint_1.x, toPoint_1.y);\n      var forceTypes = ['force', 'gForce', 'fruchterman', 'force2'];\n      // if it is force layout, only center takes effect, and assign center force\n      if (forceTypes.includes(cfg.type) || !cfg.type && forceTypes.includes(layoutController === null || layoutController === void 0 ? void 0 : layoutController.layoutType)) {\n        cfg.center = [toPoint_1.x, toPoint_1.y];\n      } else {\n        this.once('afterlayout', function (e) {\n          var matrix = _this.getGroup().getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          toPoint_1.x = toPoint_1.x * matrix[0] + matrix[6];\n          toPoint_1.y = toPoint_1.y * matrix[0] + matrix[7];\n          var _a = _this.getGroup().getCanvasBBox(),\n            minX = _a.minX,\n            maxX = _a.maxX,\n            minY = _a.minY,\n            maxY = _a.maxY;\n          var bboxPoint = {\n            x: (minX + maxX) / 2,\n            y: (minY + maxY) / 2\n          };\n          if (align === 'begin') {\n            bboxPoint.x = minX;\n            bboxPoint.y = minY;\n          }\n          _this.translate(toPoint_1.x - bboxPoint.x, toPoint_1.y - bboxPoint.y);\n        });\n      }\n    }\n    var oriLayoutCfg = __assign({}, this.get('layout'));\n    var layoutCfg = {};\n    Object.assign(layoutCfg, oriLayoutCfg, cfg);\n    if (cfg.pipes && !cfg.type) delete layoutCfg.type;else if (!cfg.pipes && layoutCfg.type) delete layoutCfg.pipes;\n    this.set('layout', layoutCfg);\n    if (!layoutController) return;\n    if (layoutController.isLayoutTypeSame(layoutCfg) && layoutCfg.gpuEnabled === oriLayoutCfg.gpuEnabled) {\n      // no type or same type, or switch the gpu and cpu, update layout\n      layoutController.updateLayoutCfg(layoutCfg);\n    } else {\n      // has different type, change layout\n      layoutController.changeLayout(layoutCfg);\n    }\n    if (stack && this.get('enabledStack')) {\n      this.pushStack('layout', {\n        before: oriLayoutCfg,\n        after: layoutCfg\n      });\n    }\n  };\n  /**\n   * 销毁布局，changeData 时不会再使用原来的布局方法对新数据进行布局\n   */\n  AbstractGraph.prototype.destroyLayout = function () {\n    var layoutController = this.get('layoutController');\n    layoutController === null || layoutController === void 0 ? void 0 : layoutController.destroyLayout();\n  };\n  /**\n   * 重新以当前示例中配置的属性进行一次布局\n   */\n  AbstractGraph.prototype.layout = function () {\n    var _a;\n    var layoutController = this.get('layoutController');\n    var layoutCfg = this.get('layout');\n    if (!layoutCfg || !layoutController) return;\n    if (layoutCfg.workerEnabled) {\n      // 如果使用web worker布局\n      layoutController.layout();\n      return;\n    }\n    if ((_a = layoutController.layoutMethods) === null || _a === void 0 ? void 0 : _a.length) {\n      layoutController.relayout(true);\n    } else {\n      layoutController.layout();\n    }\n  };\n  /**\n   * 收起指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n  AbstractGraph.prototype.collapseCombo = function (combo, stack) {\n    var _this = this;\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (this.destroyed) return;\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n    if (!combo) {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n    this.emit('beforecollapseexpandcombo', {\n      action: 'collapse',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.collapseCombo(combo, stack);\n    comboModel.collapsed = true;\n    // add virtual edges\n    var edges = this.getEdges().concat(this.get('vedges'));\n    // find all the descendant nodes and combos\n    var cNodesCombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate the forEach\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false;\n        // if the combo is found\n        if (comboModel.id === subTree.id) found = true;\n        if (found) {\n          // if the combo is found, concat the descendant nodes and combos\n          var item = _this.findById(subTree.id);\n          if (item && item.getType && item.getType() === 'combo') {\n            cNodesCombos = cNodesCombos.concat(item.getNodes());\n            cNodesCombos = cNodesCombos.concat(item.getCombos());\n          }\n        }\n        return true;\n      });\n    });\n    var addedVEdgeMap = {};\n    edges.forEach(function (edge) {\n      var _a = edge.getModel(),\n        isVEdge = _a.isVEdge,\n        _b = _a.size,\n        size = _b === void 0 ? 1 : _b;\n      if (edge.isVisible() && !isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n      var otherEnd = null;\n      var otherEndIsSource;\n      if (source.getModel().id === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {\n        // source is the current combo, or descent node/combo is the source but not the target)\n        otherEnd = target;\n        otherEndIsSource = false;\n      } else if (target.getModel().id === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // target is the current combo, or descent node/combo is the target but not the source)\n        otherEnd = source;\n        otherEndIsSource = true;\n      }\n      if (otherEnd) {\n        if (isVEdge) {\n          _this.removeItem(edge, false);\n          return;\n        }\n        var otherEndModel = otherEnd.getModel();\n        while (!otherEnd.isVisible()) {\n          var otherEndPId = otherEndModel.parentId,\n            otherEndCId = otherEndModel.comboId;\n          var otherEndParentId = otherEndPId || otherEndCId;\n          otherEnd = _this.findById(otherEndParentId);\n          if (!otherEnd || !otherEndParentId) return; // all the ancestors are hidden, then ignore the edge\n          otherEndModel = otherEnd.getModel();\n        }\n        var otherEndId = otherEndModel.id;\n        var vEdgeInfo = otherEndIsSource ? {\n          source: otherEndId,\n          target: comboModel.id,\n          size: size,\n          isVEdge: true\n        } : {\n          source: comboModel.id,\n          target: otherEndId,\n          size: size,\n          isVEdge: true\n        };\n        var key = \"\".concat(vEdgeInfo.source, \"-\").concat(vEdgeInfo.target);\n        if (addedVEdgeMap[key]) {\n          addedVEdgeMap[key].size += size;\n          return;\n        }\n        addedVEdgeMap[key] = vEdgeInfo;\n      }\n    });\n    // update the width of the virtual edges, which is the sum of merged actual edges\n    // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n    this.addItems(Object.values(addedVEdgeMap).map(function (edgeInfo) {\n      return {\n        type: 'vedge',\n        model: edgeInfo\n      };\n    }), false);\n    this.emit('aftercollapseexpandcombo', {\n      action: 'collapse',\n      item: combo\n    });\n  };\n  /**\n   * 展开指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n  AbstractGraph.prototype.expandCombo = function (combo, stack) {\n    var _this = this;\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.expandCombo(combo, stack);\n    comboModel.collapsed = false;\n    // add virtual edges\n    var edges = this.getEdges().concat(this.get('vedges'));\n    // find all the descendant nodes and combos\n    var cNodesCombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false;\n        if (comboModel.id === subTree.id) found = true;\n        if (found) {\n          var item = _this.findById(subTree.id);\n          if (item && item.getType && item.getType() === 'combo') {\n            cNodesCombos = cNodesCombos.concat(item.getNodes());\n            cNodesCombos = cNodesCombos.concat(item.getCombos());\n          }\n        }\n        return true;\n      });\n    });\n    var addedVEdgeMap = {};\n    edges.forEach(function (edge) {\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n      var sourceId = source.get('id');\n      var targetId = target.get('id');\n      var otherEnd = null;\n      var otherEndIsSource;\n      if (sourceId === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {\n        // the source is in the combo, the target is not\n        otherEnd = target;\n        otherEndIsSource = false;\n      } else if (targetId === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // the target is in the combo, the source is not\n        otherEnd = source;\n        otherEndIsSource = true;\n      } else if (cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // both source and target are in the combo, if the target and source are both visible, show the edge\n        if (source.isVisible() && target.isVisible()) {\n          edge.show();\n        }\n      }\n      if (otherEnd) {\n        var _a = edge.getModel(),\n          isVEdge = _a.isVEdge,\n          _b = _a.size,\n          size = _b === void 0 ? 1 : _b;\n        // ignore the virtual edges\n        if (isVEdge) {\n          _this.removeItem(edge, false);\n          return;\n        }\n        var otherEndModel = otherEnd.getModel();\n        // find the nearest visible ancestor\n        while (!otherEnd.isVisible()) {\n          var otherEndPId = otherEndModel.parentId,\n            otherEndCId = otherEndModel.comboId;\n          var otherEndParentId = otherEndPId || otherEndCId;\n          otherEnd = _this.findById(otherEndParentId);\n          if (!otherEnd || !otherEndParentId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          otherEndModel = otherEnd.getModel();\n        }\n        var otherEndId = otherEndModel.id;\n        var selfEnd = otherEndIsSource ? target : source;\n        var selfEndModel = selfEnd.getModel();\n        // find the nearest visible ancestor\n        while (!selfEnd.isVisible()) {\n          var selfEndPId = selfEndModel.parentId,\n            selfEndCId = selfEndModel.comboId;\n          var selfEndParentId = selfEndPId || selfEndCId;\n          selfEnd = _this.findById(selfEndParentId);\n          if (!selfEnd || !selfEndParentId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          if (selfEndModel.comboId === comboModel.id || selfEndModel.parentId === comboModel.id) {\n            break; // if the next ancestor is the combo, break the while\n          }\n\n          selfEndModel = selfEnd.getModel();\n        }\n        var selfEndId = selfEndModel.id;\n        if (otherEndId) {\n          var vEdgeInfo = otherEndIsSource ? {\n            source: otherEndId,\n            target: selfEndId,\n            isVEdge: true,\n            size: size\n          } : {\n            source: selfEndId,\n            target: otherEndId,\n            isVEdge: true,\n            size: size\n          };\n          var vedgeId = \"\".concat(vEdgeInfo.source, \"-\").concat(vEdgeInfo.target);\n          // update the width of the virtual edges, which is the sum of merged actual edges\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n          if (addedVEdgeMap[vedgeId]) {\n            addedVEdgeMap[vedgeId].size += size;\n            return;\n          }\n          addedVEdgeMap[vedgeId] = vEdgeInfo;\n        }\n      }\n    });\n    this.addItems(Object.values(addedVEdgeMap).map(function (edgeInfo) {\n      return {\n        type: 'vedge',\n        model: edgeInfo\n      };\n    }), false);\n    this.emit('aftercollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n  };\n  AbstractGraph.prototype.collapseExpandCombo = function (combo, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n    if (!combo || combo.getType && combo.getType() !== 'combo') return;\n    var comboModel = combo.getModel();\n    // if one ancestor combo of the combo is collapsed, it should not be collapsed or expanded\n    var parentItem = this.findById(comboModel.parentId);\n    while (parentItem) {\n      var parentModel = parentItem.getModel();\n      if (parentModel.collapsed) {\n        console.warn(\"Fail to expand the combo since it's ancestor combo is collapsed.\");\n        parentItem = undefined;\n        return;\n      }\n      parentItem = this.findById(parentModel.parentId);\n    }\n    var collapsed = comboModel.collapsed;\n    // 该群组已经处于收起状态，需要展开\n    if (collapsed) {\n      this.expandCombo(combo, stack);\n    } else {\n      this.collapseCombo(combo, stack);\n    }\n    this.updateCombo(combo);\n  };\n  /**\n   * 获取节点所有的邻居节点\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @returns {INode[]}\n   * @memberof IAbstractGraph\n   */\n  AbstractGraph.prototype.getNeighbors = function (node, type) {\n    var item = node;\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n    return item.getNeighbors(type);\n  };\n  /**\n   * 获取 node 的度数\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @param {('in' | 'out' | 'total' | 'all' | undefined)} 度数类型，in 入度，out 出度，total 总度数，all 返回三种类型度数的对象\n   * @returns {Number | Object} 该节点的度数\n   * @memberof IAbstractGraph\n   */\n  AbstractGraph.prototype.getNodeDegree = function (node, type, refresh) {\n    if (type === void 0) {\n      type = undefined;\n    }\n    if (refresh === void 0) {\n      refresh = false;\n    }\n    var item = node;\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n    var degrees = this.get('degrees');\n    if (!degrees || refresh) {\n      degrees = getDegree(this.save());\n      this.set('degrees', degrees);\n    }\n    var nodeDegrees = degrees[item.getID()];\n    var res = 0;\n    // 如果是通过 addItem 后面新增加的节点，此时它的所有度数都为 0\n    if (!nodeDegrees) {\n      return 0;\n    }\n    switch (type) {\n      case 'in':\n        res = nodeDegrees.inDegree;\n        break;\n      case 'out':\n        res = nodeDegrees.outDegree;\n        break;\n      case 'all':\n        res = nodeDegrees;\n        break;\n      default:\n        res = nodeDegrees.degree;\n        break;\n    }\n    return res;\n  };\n  AbstractGraph.prototype.getUndoStack = function () {\n    return this.undoStack;\n  };\n  AbstractGraph.prototype.getRedoStack = function () {\n    return this.redoStack;\n  };\n  /**\n   * 获取 undo 和 redo 栈的数据\n   */\n  AbstractGraph.prototype.getStackData = function () {\n    if (!this.get('enabledStack')) {\n      return null;\n    }\n    return {\n      undoStack: this.undoStack.toArray(),\n      redoStack: this.redoStack.toArray()\n    };\n  };\n  /**\n   * 清空 undo stack & redo stack\n   */\n  AbstractGraph.prototype.clearStack = function () {\n    if (this.get('enabledStack')) {\n      this.undoStack.clear();\n      this.redoStack.clear();\n      this.emit('stackchange', {\n        undoStack: this.undoStack,\n        redoStack: this.redoStack\n      });\n    }\n  };\n  /**\n   * 将操作类型和操作数据入栈\n   * @param action 操作类型\n   * @param data 入栈的数据\n   * @param stackType 栈的类型\n   */\n  AbstractGraph.prototype.pushStack = function (action, data, stackType) {\n    if (action === void 0) {\n      action = 'update';\n    }\n    if (stackType === void 0) {\n      stackType = 'undo';\n    }\n    if (!this.get('enabledStack')) {\n      console.warn('请先启用 undo & redo 功能，在实例化 Graph 时候配置 enabledStack: true !');\n      return;\n    }\n    var stackData = data ? clone(data) : {\n      before: {},\n      after: clone(this.save())\n    };\n    if (stackType === 'redo') {\n      this.redoStack.push({\n        action: action,\n        data: stackData\n      });\n    } else {\n      this.undoStack.push({\n        action: action,\n        data: stackData\n      });\n    }\n    this.emit('stackchange', {\n      action: action,\n      stackType: stackType,\n      undoStack: this.undoStack,\n      redoStack: this.redoStack\n    });\n  };\n  /**\n   * 获取邻接矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 邻接矩阵\n   * @memberof IAbstractGraph\n   */\n  AbstractGraph.prototype.getAdjMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n    return currentAdjMatrix;\n  };\n  /**\n   * 获取最短路径矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 最短路径矩阵\n   * @memberof IAbstractGraph\n   */\n  AbstractGraph.prototype.getShortestPathMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n    var currentShourtestPathMatrix = this.get('shortestPathMatrix');\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n    if (!currentShourtestPathMatrix || !cache) {\n      currentShourtestPathMatrix = floydWarshall(this.save(), directed);\n      this.set('shortestPathMatrix', currentShourtestPathMatrix);\n    }\n    return currentShourtestPathMatrix;\n  };\n  /**\n   * 重新定义监听函数，复写参数类型\n   */\n  AbstractGraph.prototype.on = function (eventName, callback, once) {\n    return _super.prototype.on.call(this, eventName, callback, once);\n  };\n  /**\n   * 销毁画布\n   */\n  AbstractGraph.prototype.destroy = function () {\n    var _a, _b, _c, _d, _e;\n    this.emit('beforedestroy');\n    this.clear();\n    // 清空栈数据\n    this.clearStack();\n    (_a = this.get('itemController')) === null || _a === void 0 ? void 0 : _a.destroy();\n    (_b = this.get('modeController')) === null || _b === void 0 ? void 0 : _b.destroy();\n    (_c = this.get('viewController')) === null || _c === void 0 ? void 0 : _c.destroy();\n    (_d = this.get('stateController')) === null || _d === void 0 ? void 0 : _d.destroy();\n    (_e = this.get('canvas')) === null || _e === void 0 ? void 0 : _e.destroy();\n    this.cfg = null;\n    this.destroyed = true;\n    this.redoStack = null;\n    this.undoStack = null;\n    this.emit('afterdestroy');\n  };\n  /**\n   * 创建凸包或凹包轮廓\n   * @param cfg HullCfg 轮廓配置项\n   */\n  AbstractGraph.prototype.createHull = function (cfg) {\n    if (!cfg.members || cfg.members.length < 1) {\n      console.warn('Create hull failed! The members is empty.');\n      return;\n    }\n    var parent = this.get('hullGroup');\n    var hullMap = this.get('hullMap');\n    if (!hullMap) {\n      hullMap = {};\n      this.set('hullMap', hullMap);\n    }\n    if (!parent || parent.get('destroyed')) {\n      parent = this.get('group').addGroup({\n        id: 'hullGroup'\n      });\n      parent.toBack();\n      this.set('hullGroup', parent);\n    }\n    if (hullMap[cfg.id]) {\n      console.warn('Existed hull id.');\n      return hullMap[cfg.id];\n    }\n    var group = parent.addGroup({\n      id: \"\".concat(cfg.id, \"-container\")\n    });\n    var hull = new Hull(this, __assign(__assign({}, cfg), {\n      group: group\n    }));\n    var hullId = hull.id;\n    hullMap[hullId] = hull;\n    return hull;\n  };\n  /**\n   * 获取当前 graph 中存在的包裹轮廓\n   * @return {[key: string]: Hull} Hull 的 map，hullId 对应的 hull 实例\n   */\n  AbstractGraph.prototype.getHulls = function () {\n    return this.get('hullMap');\n  };\n  /**\n   * 根据 hullId 获取对应的 hull\n   * @return Hull\n   */\n  AbstractGraph.prototype.getHullById = function (hullId) {\n    return this.get('hullMap')[hullId];\n  };\n  AbstractGraph.prototype.removeHull = function (hull) {\n    var _a;\n    var hullInstance;\n    if (isString(hull)) {\n      hullInstance = this.getHullById(hull);\n    } else {\n      hullInstance = hull;\n    }\n    (_a = this.get('hullMap')) === null || _a === void 0 ? true : delete _a[hullInstance.id];\n    hullInstance.destroy();\n  };\n  AbstractGraph.prototype.removeHulls = function () {\n    var hulls = this.getHulls();\n    if (!hulls || !Object.keys(hulls).length) return;\n    Object.keys(hulls).forEach(function (key) {\n      var hull = hulls[key];\n      hull.destroy();\n    });\n    this.set('hullMap', {});\n  };\n  return AbstractGraph;\n}(EventEmitter);\nexport default AbstractGraph;","map":{"version":3,"names":["__assign","__extends","__spreadArray","EventEmitter","ext","clone","deepMix","each","isPlainObject","isString","debounce","getDegree","getAdjMatrix","getAdjacentMatrix","Stack","floydWarshall","lerp","move","dataValidation","singleDataValidation","Global","ItemController","ModeController","StateController","ViewController","plainCombosToTrees","traverseTree","reconstructTree","traverseTreeUp","getAnimateCfgWithCallback","Hull","transform","NODE","AbstractGraph","_super","cfg","_this","call","sortCombos","comboSorted","get","destroyed","set","depthMap","dataDepthMap","comboTrees","forEach","cTree","child","depth","push","id","edges","getEdges","concat","edgeItem","edge","getModel","sourceDepth","source","targetDepth","target","Math","max","array","length","i","item","findById","toFront","getDefaultCfg","init","animating","enabledStack","undoStack","maxStep","redoStack","prototype","initCanvas","viewController","modeController","itemController","stateController","initLayoutController","initEventController","initGroups","initPlugins","canvas","el","_a","group","addGroup","className","rootContainerClassName","edgeGroup","edgeContainerClassName","nodeGroup","nodeContainerClassName","comboGroup","comboContainerClassName","toBack","delegateGroup","delegateContainerClassName","container","undefined","width","height","renderer","modes","plugins","data","fitViewPadding","minZoom","maxZoom","event","groupByTypes","directed","autoPaint","nodes","combos","vedges","itemMap","linkCenter","defaultNode","defaultEdge","nodeStateStyles","edgeStateStyles","states","animate","animateCfg","onFrame","duration","easing","callback","tooltips","optimizeThreshold","key","val","getGroup","getContainer","getMinZoom","setMinZoom","ratio","getMaxZoom","setMaxZoom","getWidth","getHeight","clearItemStates","updateStates","node","nodeFn","edgeFn","combo","comboFn","find","type","fn","result","items","findAll","findAllByState","state","additionalFilter","hasState","translate","dx","dy","matrix","getMatrix","animateConfig","emit","action","x","getCanvasBBox","y","setMatrix","moveTo","fitView","padding","rules","fitViewByRules","fitCenter","addBehaviors","behaviors","manipulateBehaviors","removeBehaviors","updateBehavior","behavior","newCfg","mode","zoom","center","currentZoom","getZoom","targetZoom","finalRatio","failed","aniMatrix_1","initialRatio_1","targetRatio_1","scale","zoomTo","toRatio","focusItem","isAnimate","curAniamteCfg","focus","focusItems","zoomToFit","paint","draw","getPointByClient","clientX","clientY","getClientByPoint","getPointByCanvas","canvasX","canvasY","getCanvasByPoint","getGraphCenterPoint","bbox","minX","maxX","minY","maxY","getViewPortCenterPoint","showItem","stack","object","changeItemVisibility","getID","getType","before","after","visible","pushStack","hideItem","refreshItem","setAutoPaint","auto","self","remove","removeItem","nodeItem","console","warn","deletedModel","itemType","model","comboId","updateComboTree","newComboTrees","innerAddItem","itemMap_1","foundParent_1","ctree","parentId","newCombo","children","addItem","childItem","updateCombo","collapsed","collapseCombo","parentCombo","itemMap_2","foundParent_2","foundNode_1","cloneNode","addChild","sortCombo","currentComboSorted","addedModel","addItems","returnItems","returnItem","add","updateItem","currentItem","stackEnabled","unupdatedModel","getStates","setItemState","afterModel","update","value","updateState","priorityState","render","clearStack","Error","_b","_c","clear","map","addCombos","layoutController","layout","success","setTimeout","getCombos","nodesArr","getNodes","edgesArr","read","diffItems","models","containerMatrix","changeData","propsData","save","removeHulls","localRefresh","combosData","destroy","indexOf","comboItems","combosLength","splice","relayoutAtChangeData","getLayoutType","positionsAnimate","createCombo","childrenIds","comboConfig","shouldStack","childrenParentCache","childId","childType","childModel","childrenIdsSet","Set","pulledComboTreesById","Map","treeNode","parentTreeNode","index","has","parentItem","removeChild","filter","newChildrenParent","trees","elementId","cItem","comboItem","getChildren","uncombo","comboModel","treeToBeUncombo","brothers","subtree","edgeIds","edgeId","itemModel","removeCombo","childrenParentCache_1","childNewParent_1","updateCombos","followCombo","getStateStyle","uItem","oldParentId","valid_1","itemSubTree_1","subTree","beforeData","afterData","changeSize","refresh","vedge","getComboChildren","referComboModel","toNodes","stopAnimate","originAttrs","attrs","Object","assign","refreshPositions","updatedNodes","updateItems","changed","updatePosition","sourceModel","getSource","getTarget","targetModel","isComboEdge","timeline","stopAllAnimations","isAnimating","getCurrentMode","getMode","setMode","avoidEmit","groups","updateLayout","align","alignPoint","toPoint_1","forceTypes","includes","layoutType","once","e","bboxPoint","oriLayoutCfg","layoutCfg","pipes","isLayoutTypeSame","gpuEnabled","updateLayoutCfg","changeLayout","destroyLayout","workerEnabled","layoutMethods","relayout","cNodesCombos","found","addedVEdgeMap","isVEdge","size","isVisible","otherEnd","otherEndIsSource","otherEndModel","otherEndPId","otherEndCId","otherEndParentId","otherEndId","vEdgeInfo","values","edgeInfo","expandCombo","sourceId","targetId","show","selfEnd","selfEndModel","selfEndPId","selfEndCId","selfEndParentId","selfEndId","vedgeId","collapseExpandCombo","parentModel","getNeighbors","getNodeDegree","degrees","nodeDegrees","res","inDegree","outDegree","degree","getUndoStack","getRedoStack","getStackData","toArray","stackType","stackData","cache","currentAdjMatrix","getShortestPathMatrix","currentShourtestPathMatrix","on","eventName","_d","_e","createHull","members","parent","hullMap","hull","hullId","getHulls","getHullById","removeHull","hullInstance","hulls","keys"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/g6-core/es/graph/graph.js"],"sourcesContent":["import { __assign, __extends, __spreadArray } from \"tslib\";\nimport EventEmitter from '@antv/event-emitter';\nimport { ext } from '@antv/matrix-util';\nimport { clone, deepMix, each, isPlainObject, isString, debounce } from '@antv/util';\nimport { getDegree, getAdjMatrix as getAdjacentMatrix, Stack, floydWarshall } from '@antv/algorithm';\nimport { lerp, move } from '../util/math';\nimport { dataValidation, singleDataValidation } from '../util/validation';\nimport Global from '../global';\nimport { ItemController, ModeController, StateController, ViewController } from './controller';\nimport { plainCombosToTrees, traverseTree, reconstructTree, traverseTreeUp, getAnimateCfgWithCallback } from '../util/graphic';\nimport Hull from '../item/hull';\nvar transform = ext.transform;\nvar NODE = 'node';\nvar AbstractGraph = /** @class */function (_super) {\n  __extends(AbstractGraph, _super);\n  function AbstractGraph(cfg) {\n    var _this = _super.call(this) || this;\n    /**\n     * 根据 comboTree 结构整理 Combo 相关的图形绘制层级，包括 Combo 本身、节点、边\n     * @param {GraphData} data 数据\n     */\n    _this.sortCombos = debounce(function () {\n      var comboSorted = _this.get('comboSorted');\n      if (!_this || _this.destroyed || comboSorted) return;\n      _this.set('comboSorted', true);\n      var depthMap = [];\n      var dataDepthMap = {};\n      var comboTrees = _this.get('comboTrees');\n      (comboTrees || []).forEach(function (cTree) {\n        traverseTree(cTree, function (child) {\n          if (depthMap[child.depth]) depthMap[child.depth].push(child.id);else depthMap[child.depth] = [child.id];\n          dataDepthMap[child.id] = child.depth;\n          return true;\n        });\n      });\n      var edges = _this.getEdges().concat(_this.get('vedges'));\n      (edges || []).forEach(function (edgeItem) {\n        var edge = edgeItem.getModel();\n        var sourceDepth = dataDepthMap[edge.source] || 0;\n        var targetDepth = dataDepthMap[edge.target] || 0;\n        var depth = Math.max(sourceDepth, targetDepth);\n        if (depthMap[depth]) depthMap[depth].push(edge.id);else depthMap[depth] = [edge.id];\n      });\n      depthMap.forEach(function (array) {\n        if (!array || !array.length) return;\n        for (var i = array.length - 1; i >= 0; i--) {\n          var item = _this.findById(array[i]);\n          if (item) item.toFront();\n        }\n      });\n    }, 500, false);\n    _this.cfg = deepMix(_this.getDefaultCfg(), cfg);\n    _this.init();\n    _this.animating = false;\n    _this.destroyed = false;\n    // 启用 stack 后，实例化 undoStack 和 redoStack\n    if (_this.cfg.enabledStack) {\n      // 实例化 undo 和 redo 栈\n      _this.undoStack = new Stack(_this.cfg.maxStep);\n      _this.redoStack = new Stack(_this.cfg.maxStep);\n    }\n    return _this;\n  }\n  AbstractGraph.prototype.init = function () {\n    this.initCanvas();\n    // instance controller\n    var viewController = new ViewController(this);\n    var modeController = new ModeController(this);\n    var itemController = new ItemController(this);\n    var stateController = new StateController(this);\n    this.set({\n      viewController: viewController,\n      modeController: modeController,\n      itemController: itemController,\n      stateController: stateController\n    });\n    // 初始化布局机制\n    this.initLayoutController();\n    // 初始化事件机制\n    this.initEventController();\n    this.initGroups();\n    /** 初始化插件 */\n    this.initPlugins();\n  };\n  // 初始化所有 Group\n  AbstractGraph.prototype.initGroups = function () {\n    var canvas = this.get('canvas');\n    if (!canvas) return;\n    var el = canvas.get('el');\n    var _a = (el || {}).id,\n      id = _a === void 0 ? 'g6' : _a;\n    var group = canvas.addGroup({\n      id: \"\".concat(id, \"-root\"),\n      className: Global.rootContainerClassName\n    });\n    if (this.get('groupByTypes')) {\n      var edgeGroup = group.addGroup({\n        id: \"\".concat(id, \"-edge\"),\n        className: Global.edgeContainerClassName\n      });\n      var nodeGroup = group.addGroup({\n        id: \"\".concat(id, \"-node\"),\n        className: Global.nodeContainerClassName\n      });\n      var comboGroup = group.addGroup({\n        id: \"\".concat(id, \"-combo\"),\n        className: Global.comboContainerClassName\n      });\n      // 用于存储自定义的群组\n      comboGroup.toBack();\n      this.set({\n        nodeGroup: nodeGroup,\n        edgeGroup: edgeGroup,\n        comboGroup: comboGroup\n      });\n    }\n    var delegateGroup = group.addGroup({\n      id: \"\".concat(id, \"-delegate\"),\n      className: Global.delegateContainerClassName\n    });\n    this.set({\n      delegateGroup: delegateGroup\n    });\n    this.set('group', group);\n  };\n  // eslint-disable-next-line class-methods-use-this\n  AbstractGraph.prototype.getDefaultCfg = function () {\n    return {\n      /**\n       * Container could be dom object or dom id\n       */\n      container: undefined,\n      /**\n       * Canvas width\n       * unit pixel if undefined force fit width\n       */\n      width: undefined,\n      /**\n       * Canvas height\n       * unit pixel if undefined force fit height\n       */\n      height: undefined,\n      /**\n       * renderer canvas or svg\n       * @type {string}\n       */\n      renderer: 'canvas',\n      /**\n       * control graph behaviors\n       */\n      modes: {},\n      /**\n       * 注册插件\n       */\n      plugins: [],\n      /**\n       * source data\n       */\n      data: {},\n      /**\n       * Fit view padding (client scale)\n       */\n      fitViewPadding: 10,\n      /**\n       * Minimum scale size\n       */\n      minZoom: 0.02,\n      /**\n       * Maxmum scale size\n       */\n      maxZoom: 10,\n      /**\n       *  capture events\n       */\n      event: true,\n      /**\n       * group node & edges into different graphic groups\n       */\n      groupByTypes: true,\n      /**\n       * determine if it's a directed graph\n       */\n      directed: false,\n      /**\n       * when data or shape changed, should canvas draw automatically\n       */\n      autoPaint: true,\n      /**\n       * store all the node instances\n       */\n      nodes: [],\n      /**\n       * store all the edge instances\n       */\n      edges: [],\n      /**\n       * store all the combo instances\n       */\n      combos: [],\n      /**\n       * store all the edge instances which are virtual edges related to collapsed combo\n       */\n      vedges: [],\n      /**\n       * all the instances indexed by id\n       */\n      itemMap: {},\n      /**\n       * 边直接连接到节点的中心，不再考虑锚点\n       */\n      linkCenter: false,\n      /**\n       * 默认的节点配置，data 上定义的配置会覆盖这些配置。例如：\n       * defaultNode: {\n       *  type: 'rect',\n       *  size: [60, 40],\n       *  style: {\n       *    //... 样式配置项\n       *  }\n       * }\n       * 若数据项为 { id: 'node', x: 100, y: 100 }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'rect', size: [60, 40] }\n       * 若数据项为 { id: 'node', x: 100, y: 100, type: 'circle' }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'circle', size: [60, 40] }\n       */\n      defaultNode: {},\n      /**\n       * 默认边配置，data 上定义的配置会覆盖这些配置。用法同 defaultNode\n       */\n      defaultEdge: {},\n      /**\n       * 节点默认样式，也可以添加状态样式\n       * 例如：\n       * const graph = new G6.Graph({\n       *  nodeStateStyles: {\n       *    selected: { fill: '#ccc', stroke: '#666' },\n       *    active: { lineWidth: 2 }\n       *  },\n       *  ...\n       * });\n       *\n       */\n      nodeStateStyles: {},\n      /**\n       * 边默认样式，用法同nodeStateStyle\n       */\n      edgeStateStyles: {},\n      /**\n       * graph 状态\n       */\n      states: {},\n      /**\n       * 是否启用全局动画\n       */\n      animate: false,\n      /**\n       * 动画设置,仅在 animate 为 true 时有效\n       */\n      animateCfg: {\n        /**\n         * 帧回调函数，用于自定义节点运动路径，为空时线性运动\n         */\n        onFrame: undefined,\n        /**\n         * 动画时长(ms)\n         */\n        duration: 500,\n        /**\n         * 指定动画动效\n         */\n        easing: 'easeLinear'\n      },\n      callback: undefined,\n      // 默认不启用 undo & redo 功能\n      enabledStack: false,\n      // 只有当 enabledStack 为 true 时才起作用\n      maxStep: 10,\n      // 存储图上的 tooltip dom，方便销毁\n      tooltips: [],\n      // 达到这一节点数量(默认值 1000)，将开启性能优化模式。目前包括：节点状态样式变更是否影响相关边的更新\n      optimizeThreshold: 1000\n    };\n  };\n  /**\n   * 将值设置到 this.cfg 变量上面\n   * @param key 键 或 对象值\n   * @param val 值\n   */\n  AbstractGraph.prototype.set = function (key, val) {\n    if (isPlainObject(key)) {\n      this.cfg = __assign(__assign({}, this.cfg), key);\n    } else {\n      this.cfg[key] = val;\n    }\n    if (key === 'enabledStack' && val && !this.undoStack && !this.redoStack) {\n      this.undoStack = new Stack(this.cfg.maxStep);\n      this.redoStack = new Stack(this.cfg.maxStep);\n    }\n    return this;\n  };\n  /**\n   * 获取 this.cfg 中的值\n   * @param key 键\n   */\n  AbstractGraph.prototype.get = function (key) {\n    var _a;\n    return (_a = this.cfg) === null || _a === void 0 ? void 0 : _a[key];\n  };\n  /**\n   * 获取 graph 的根图形分组\n   * @return 根 group\n   */\n  AbstractGraph.prototype.getGroup = function () {\n    return this.get('group');\n  };\n  /**\n   * 获取 graph 的 DOM 容器\n   * @return DOM 容器\n   */\n  AbstractGraph.prototype.getContainer = function () {\n    return this.get('container');\n  };\n  /**\n   * 获取 graph 的最小缩放比例\n   * @return minZoom\n   */\n  AbstractGraph.prototype.getMinZoom = function () {\n    return this.get('minZoom');\n  };\n  /**\n   * 设置 graph 的最小缩放比例\n   * @return minZoom\n   */\n  AbstractGraph.prototype.setMinZoom = function (ratio) {\n    return this.set('minZoom', ratio);\n  };\n  /**\n   * 获取 graph 的最大缩放比例\n   * @param maxZoom\n   */\n  AbstractGraph.prototype.getMaxZoom = function () {\n    return this.get('maxZoom');\n  };\n  /**\n   * 设置 graph 的最大缩放比例\n   * @param maxZoom\n   */\n  AbstractGraph.prototype.setMaxZoom = function (ratio) {\n    return this.set('maxZoom', ratio);\n  };\n  /**\n   * 获取 graph 的宽度\n   * @return width\n   */\n  AbstractGraph.prototype.getWidth = function () {\n    return this.get('width');\n  };\n  /**\n   * 获取 graph 的高度\n   * @return width\n   */\n  AbstractGraph.prototype.getHeight = function () {\n    return this.get('height');\n  };\n  /**\n   * 清理元素多个状态\n   * @param {string|Item} item 元素id或元素实例\n   * @param {string[]} states 状态\n   */\n  AbstractGraph.prototype.clearItemStates = function (item, states) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n    var itemController = this.get('itemController');\n    if (!states) {\n      states = item.get('states');\n    }\n    itemController.clearItemStates(item, states);\n    var stateController = this.get('stateController');\n    stateController.updateStates(item, states, false);\n  };\n  /**\n   * 设置各个节点样式，以及在各种状态下节点 keyShape 的样式。\n   * 若是自定义节点切在各种状态下\n   * graph.node(node => {\n   *  return {\n   *    type: 'rect',\n   *    label: node.id,\n   *    style: { fill: '#666' },\n   *    stateStyles: {\n   *       selected: { fill: 'blue' },\n   *       custom: { fill: 'green' }\n   *     }\n   *   }\n   * });\n   * @param {function} nodeFn 指定每个节点样式\n   */\n  AbstractGraph.prototype.node = function (nodeFn) {\n    if (typeof nodeFn === 'function') {\n      this.set('nodeMapper', nodeFn);\n    }\n  };\n  /**\n   * 设置各个边样式\n   * @param {function} edgeFn 指定每个边的样式,用法同 node\n   */\n  AbstractGraph.prototype.edge = function (edgeFn) {\n    if (typeof edgeFn === 'function') {\n      this.set('edgeMapper', edgeFn);\n    }\n  };\n  /**\n   * 设置各个 combo 的配置\n   * @param comboFn\n   */\n  AbstractGraph.prototype.combo = function (comboFn) {\n    if (typeof comboFn === 'function') {\n      this.set('comboMapper', comboFn);\n    }\n  };\n  /**\n   * 根据 ID 查询图元素实例\n   * @param id 图元素 ID\n   */\n  AbstractGraph.prototype.findById = function (id) {\n    return this.get('itemMap')[id];\n  };\n  /**\n   * 根据对应规则查找单个元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge | group)\n   * @param {(item: T, index: number) => T} fn 指定规则\n   * @return {T} 元素实例\n   */\n  AbstractGraph.prototype.find = function (type, fn) {\n    var result;\n    var items = this.get(\"\".concat(type, \"s\"));\n    // eslint-disable-next-line consistent-return\n    each(items, function (item, i) {\n      if (fn(item, i)) {\n        result = item;\n        return result;\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有满足规则的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} fn 指定规则\n   * @return {array} 元素实例\n   */\n  AbstractGraph.prototype.findAll = function (type, fn) {\n    var result = [];\n    each(this.get(\"\".concat(type, \"s\")), function (item, i) {\n      if (fn(item, i)) {\n        result.push(item);\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有处于指定状态的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} state 状态\n   * @return {object} 元素实例\n   */\n  AbstractGraph.prototype.findAllByState = function (type, state, additionalFilter) {\n    if (additionalFilter) {\n      return this.findAll(type, function (item) {\n        return item.hasState(state) && additionalFilter(item);\n      });\n    } else {\n      return this.findAll(type, function (item) {\n        return item.hasState(state);\n      });\n    }\n  };\n  /**\n   * 平移画布\n   * @param dx 水平方向位移\n   * @param dy 垂直方向位移\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n  AbstractGraph.prototype.translate = function (dx, dy, animate, animateCfg) {\n    var _this = this;\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix());\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n    if (animate) {\n      var animateConfig = getAnimateCfgWithCallback({\n        animateCfg: animateCfg,\n        callback: function callback() {\n          return _this.emit('viewportchange', {\n            action: 'translate',\n            matrix: group.getMatrix()\n          });\n        }\n      });\n      move(group, {\n        x: group.getCanvasBBox().x + dx,\n        y: group.getCanvasBBox().y + dy\n      }, animate, animateConfig || {\n        duration: 500,\n        easing: 'easeCubic'\n      });\n    } else {\n      matrix = transform(matrix, [['t', dx, dy]]);\n      group.setMatrix(matrix);\n      this.emit('viewportchange', {\n        action: 'translate',\n        matrix: matrix\n      });\n      this.autoPaint();\n    }\n  };\n  /**\n   * 平移画布到某点\n   * @param {number} x 水平坐标\n   * @param {number} y 垂直坐标\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n  AbstractGraph.prototype.moveTo = function (x, y, animate, animateCfg) {\n    var group = this.get('group');\n    move(group, {\n      x: x,\n      y: y\n    }, animate, animateCfg || {\n      duration: 500,\n      easing: 'easeCubic'\n    });\n    this.emit('viewportchange', {\n      action: 'move',\n      matrix: group.getMatrix()\n    });\n  };\n  /**\n   * 调整视口适应视图\n   * @param {object} padding 四周围边距\n   * @param {FitViewRules} rules fitView的规则\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n  AbstractGraph.prototype.fitView = function (padding, rules, animate, animateCfg) {\n    if (padding) {\n      this.set('fitViewPadding', padding);\n    }\n    var viewController = this.get('viewController');\n    if (rules) {\n      viewController.fitViewByRules(rules, animate, animateCfg);\n    } else {\n      viewController.fitView(animate, animateCfg);\n    }\n    this.autoPaint();\n  };\n  /**\n   * 调整视口适应视图，不缩放，仅将图 bbox 中心对齐到画布中心\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n  AbstractGraph.prototype.fitCenter = function (animate, animateCfg) {\n    var viewController = this.get('viewController');\n    viewController.fitCenter(animate, animateCfg);\n    this.autoPaint();\n  };\n  /**\n   * 新增行为\n   * @param {string | ModeOption | ModeType[]} behaviors 添加的行为\n   * @param {string | string[]} modes 添加到对应的模式\n   * @return {Graph} Graph\n   */\n  AbstractGraph.prototype.addBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, true);\n    return this;\n  };\n  /**\n   * 移除行为\n   * @param {string | ModeOption | ModeType[]} behaviors 移除的行为\n   * @param {string | string[]} modes 从指定的模式中移除\n   * @return {Graph} Graph\n   */\n  AbstractGraph.prototype.removeBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, false);\n    return this;\n  };\n  /**\n   * 更新行为参数\n   * @param {string | ModeOption | ModeType} behavior 需要更新的行为\n   * @param {string | string[]} modes 指定的模式中的行为，不指定则为 default\n   * @return {Graph} Graph\n   */\n  AbstractGraph.prototype.updateBehavior = function (behavior, newCfg, mode) {\n    var modeController = this.get('modeController');\n    modeController.updateBehavior(behavior, newCfg, mode);\n    return this;\n  };\n  /**\n   * 伸缩窗口\n   * @param ratio 伸缩比例\n   * @param center 以center的x, y坐标为中心缩放\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   * @return {boolean} 缩放是否成功\n   */\n  AbstractGraph.prototype.zoom = function (ratio, center, animate, animateCfg) {\n    var _this = this;\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix()) || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    var minZoom = this.get('minZoom');\n    var maxZoom = this.get('maxZoom');\n    var currentZoom = this.getZoom() || 1;\n    var targetZoom = currentZoom * ratio;\n    var finalRatio = ratio;\n    var failed = false;\n    if (minZoom && targetZoom < minZoom) {\n      finalRatio = minZoom / currentZoom;\n      failed = true;\n    } else if (maxZoom && targetZoom > maxZoom) {\n      finalRatio = maxZoom / currentZoom;\n      failed = true;\n    }\n    if (center) {\n      matrix = transform(matrix, [['t', -center.x, -center.y], ['s', finalRatio, finalRatio], ['t', center.x, center.y]]);\n    } else {\n      matrix = transform(matrix, [['s', finalRatio, finalRatio]]);\n    }\n    if (animate) {\n      // Clone the original matrix to perform the animation\n      var aniMatrix_1 = clone(group.getMatrix());\n      if (!aniMatrix_1) {\n        aniMatrix_1 = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      }\n      var initialRatio_1 = aniMatrix_1[0];\n      var targetRatio_1 = initialRatio_1 * finalRatio;\n      var animateConfig = getAnimateCfgWithCallback({\n        animateCfg: animateCfg,\n        callback: function callback() {\n          return _this.emit('viewportchange', {\n            action: 'zoom',\n            matrix: group.getMatrix()\n          });\n        }\n      });\n      group.animate(function (ratio) {\n        if (ratio === 1) {\n          // Reuse the first transformation\n          aniMatrix_1 = matrix;\n        } else {\n          var scale = lerp(initialRatio_1, targetRatio_1, ratio) / aniMatrix_1[0];\n          if (center) {\n            aniMatrix_1 = transform(aniMatrix_1, [['t', -center.x, -center.y], ['s', scale, scale], ['t', center.x, center.y]]);\n          } else {\n            aniMatrix_1 = transform(aniMatrix_1, [['s', scale, scale]]);\n          }\n        }\n        return {\n          matrix: aniMatrix_1\n        };\n      }, animateConfig);\n    } else {\n      group.setMatrix(matrix);\n      this.emit('viewportchange', {\n        action: 'zoom',\n        matrix: matrix\n      });\n      this.autoPaint();\n    }\n    return !failed;\n  };\n  /**\n   * 伸缩视口到一固定比例\n   * @param {number} toRatio 伸缩比例\n   * @param {Point} center 以center的x, y坐标为中心缩放\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   * @return {boolean} 缩放是否成功\n   */\n  AbstractGraph.prototype.zoomTo = function (toRatio, center, animate, animateCfg) {\n    var ratio = toRatio / this.getZoom();\n    return this.zoom(ratio, center, animate, animateCfg);\n  };\n  /**\n   * 将元素移动到视口中心\n   * @param {Item} item 指定元素\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n  AbstractGraph.prototype.focusItem = function (item, animate, animateCfg) {\n    var viewController = this.get('viewController');\n    var isAnimate = false;\n    if (animate) isAnimate = true;else if (animate === undefined) isAnimate = this.get('animate');\n    var curAniamteCfg = {};\n    if (animateCfg) curAniamteCfg = animateCfg;else if (animateCfg === undefined) curAniamteCfg = this.get('animateCfg');\n    viewController.focus(item, isAnimate, curAniamteCfg);\n    this.autoPaint();\n  };\n  /**\n   * Focus on the passed items\n   * @param {Item[]} items Items you want to focus on\n   * @param {boolean} zoomToFit Wether to zoom on the passed items\n   * @param {boolean} animate Wether to animate the transition\n   * @param {GraphAnimateConfig} animateCfg Animation configuration\n   */\n  AbstractGraph.prototype.focusItems = function (items, zoomToFit, animate, animateCfg) {\n    var viewController = this.get('viewController');\n    viewController.focusItems(items, zoomToFit, animate, animateCfg);\n  };\n  /**\n   * 自动重绘\n   * @internal 仅供内部更新机制调用，外部根据需求调用 render 或 paint 接口\n   */\n  AbstractGraph.prototype.autoPaint = function () {\n    if (this.get('autoPaint')) {\n      this.paint();\n    }\n  };\n  /**\n   * 仅画布重新绘制\n   */\n  AbstractGraph.prototype.paint = function () {\n    this.emit('beforepaint');\n    this.get('canvas').draw();\n    this.emit('afterpaint');\n  };\n  /**\n   * 将屏幕坐标转换为视口坐标\n   * @param {number} clientX 屏幕x坐标\n   * @param {number} clientY 屏幕y坐标\n   * @return {Point} 视口坐标\n   */\n  AbstractGraph.prototype.getPointByClient = function (clientX, clientY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByClient(clientX, clientY);\n  };\n  /**\n   * 将绘制坐标转换为屏幕坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {Point} 绘制坐标\n   */\n  AbstractGraph.prototype.getClientByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getClientByPoint(x, y);\n  };\n  /**\n   * 将画布坐标转换为绘制坐标\n   * @param {number} canvasX 画布 x 坐标\n   * @param {number} canvasY 画布 y 坐标\n   * @return {object} 绘制坐标\n   */\n  AbstractGraph.prototype.getPointByCanvas = function (canvasX, canvasY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByCanvas(canvasX, canvasY);\n  };\n  /**\n   * 将绘制坐标转换为画布坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {object} 画布坐标\n   */\n  AbstractGraph.prototype.getCanvasByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getCanvasByPoint(x, y);\n  };\n  /**\n   * 获取图内容的中心绘制坐标\n   * @return {object} 中心绘制坐标\n   */\n  AbstractGraph.prototype.getGraphCenterPoint = function () {\n    var bbox = this.get('group').getCanvasBBox();\n    return {\n      x: (bbox.minX + bbox.maxX) / 2,\n      y: (bbox.minY + bbox.maxY) / 2\n    };\n  };\n  /**\n   * 获取视口中心绘制坐标\n   * @return {object} 视口中心绘制坐标\n   */\n  AbstractGraph.prototype.getViewPortCenterPoint = function () {\n    return this.getPointByCanvas(this.get('width') / 2, this.get('height') / 2);\n  };\n  /**\n   * 显示元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n  AbstractGraph.prototype.showItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, true);\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.nodes = [{\n            id: id,\n            visible: true\n          }];\n          break;\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.edges = [{\n            id: id,\n            visible: true\n          }];\n          break;\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.combos = [{\n            id: id,\n            visible: true\n          }];\n          break;\n        default:\n          break;\n      }\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 隐藏元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n  AbstractGraph.prototype.hideItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, false);\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.nodes = [{\n            id: id,\n            visible: false\n          }];\n          break;\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.edges = [{\n            id: id,\n            visible: false\n          }];\n          break;\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.combos = [{\n            id: id,\n            visible: false\n          }];\n          break;\n        default:\n          break;\n      }\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 刷新元素\n   * @param {string|object} item 元素id或元素实例\n   */\n  AbstractGraph.prototype.refreshItem = function (item) {\n    var itemController = this.get('itemController');\n    itemController.refreshItem(item);\n  };\n  /**\n   * 设置是否在更新/刷新后自动重绘\n   * @param {boolean} auto 自动重绘\n   */\n  AbstractGraph.prototype.setAutoPaint = function (auto) {\n    var self = this;\n    self.set('autoPaint', auto);\n    var canvas = self.get('canvas');\n    canvas.set('autoDraw', auto);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n  AbstractGraph.prototype.remove = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    this.removeItem(item, stack);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n  AbstractGraph.prototype.removeItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    var nodeItem = item;\n    if (isString(item)) nodeItem = this.findById(item);\n    if (!nodeItem && isString(item)) {\n      console.warn(\"The item \".concat(item, \" to be removed does not exist!\"));\n    } else if (nodeItem) {\n      var type = '';\n      if (nodeItem.getType) type = nodeItem.getType();\n      // 将删除的元素入栈\n      if (stack && this.get('enabledStack')) {\n        var deletedModel = __assign(__assign({}, nodeItem.getModel()), {\n          itemType: type\n        });\n        var before = {};\n        switch (type) {\n          case 'node':\n            {\n              before.nodes = [deletedModel];\n              before.edges = [];\n              var edges = nodeItem.getEdges();\n              for (var i = edges.length - 1; i >= 0; i--) {\n                before.edges.push(__assign(__assign({}, edges[i].getModel()), {\n                  itemType: 'edge'\n                }));\n              }\n              break;\n            }\n          case 'edge':\n            before.edges = [deletedModel];\n            break;\n          case 'combo':\n            before.combos = [deletedModel];\n            break;\n          default:\n            break;\n        }\n        this.pushStack('delete', {\n          before: before,\n          after: {}\n        });\n      }\n      if (type === 'node') {\n        var model = nodeItem.getModel();\n        // 如果删除的是节点，且该节点存在于某个 Combo 中，则需要先将 node 从 combo 中移除，否则删除节点后，操作 combo 会出错\n        if (model.comboId) {\n          this.updateComboTree(nodeItem, undefined, false);\n        }\n      }\n      var itemController = this.get('itemController');\n      itemController.removeItem(nodeItem);\n      if (type === 'combo') {\n        var newComboTrees = reconstructTree(this.get('comboTrees'));\n        this.set('comboTrees', newComboTrees);\n      }\n    }\n  };\n  AbstractGraph.prototype.innerAddItem = function (type, model, itemController) {\n    // 添加节点、边或combo之前，先验证数据是否符合规范\n    if (!singleDataValidation(type, model)) {\n      return false;\n    }\n    if (model.id && this.findById(model.id)) {\n      console.warn(\"This item exists already. Be sure the id %c\".concat(model.id, \"%c is unique.\"), 'font-size: 20px; color: red;', '');\n      return;\n    }\n    var item;\n    var comboTrees = this.get('comboTrees') || [];\n    if (type === 'combo') {\n      var itemMap_1 = this.get('itemMap');\n      var foundParent_1 = false;\n      comboTrees.forEach(function (ctree) {\n        if (foundParent_1) return; // terminate the forEach after the tree containing the item is done\n        traverseTreeUp(ctree, function (child) {\n          // find the parent\n          if (model.parentId === child.id) {\n            foundParent_1 = true;\n            var newCombo = __assign({\n              id: model.id,\n              depth: child.depth + 2\n            }, model);\n            if (child.children) child.children.push(newCombo);else child.children = [newCombo];\n            model.depth = newCombo.depth;\n            item = itemController.addItem(type, model);\n          }\n          var childItem = itemMap_1[child.id];\n          // after the parent is found, update all the ancestors\n          if (foundParent_1 && childItem && childItem.getType && childItem.getType() === 'combo') {\n            itemController.updateCombo(childItem, child.children);\n          }\n          return true;\n        });\n      });\n      // if the parent is not found, add it to the root\n      if (!foundParent_1) {\n        var newCombo = __assign({\n          id: model.id,\n          depth: 0\n        }, model);\n        model.depth = newCombo.depth;\n        comboTrees.push(newCombo);\n        item = itemController.addItem(type, model);\n      }\n      this.set('comboTrees', comboTrees);\n      if (model.collapsed) {\n        this.collapseCombo(item, false);\n        this.updateCombo(item);\n      }\n    } else if (type === 'node' && isString(model.comboId) && comboTrees) {\n      var parentCombo = this.findById(model.comboId);\n      if (parentCombo && parentCombo.getType && parentCombo.getType() !== 'combo') {\n        console.warn(\"'\".concat(model.comboId, \"' is not a id of a combo in the graph, the node will be added without combo.\"));\n      }\n      item = itemController.addItem(type, model);\n      var itemMap_2 = this.get('itemMap');\n      var foundParent_2 = false,\n        foundNode_1 = false;\n      comboTrees.forEach(function (ctree) {\n        if (foundNode_1 || foundParent_2) return; // terminate the forEach\n        traverseTreeUp(ctree, function (child) {\n          if (child.id === model.id) {\n            // if the item exists in the tree already, terminate\n            foundNode_1 = true;\n            return false;\n          }\n          if (model.comboId === child.id && !foundNode_1) {\n            // found the parent, add the item to the children of its parent in the tree\n            foundParent_2 = true;\n            var cloneNode = clone(model);\n            cloneNode.itemType = 'node';\n            if (child.children) child.children.push(cloneNode);else child.children = [cloneNode];\n            cloneNode.depth = child.depth + 1;\n          }\n          // update the size of all the ancestors\n          if (foundParent_2 && itemMap_2[child.id].getType && itemMap_2[child.id].getType() === 'combo') {\n            itemController.updateCombo(itemMap_2[child.id], child.children);\n          }\n          return true;\n        });\n      });\n    } else {\n      item = itemController.addItem(type, model);\n    }\n    if (type === 'node' && model.comboId || type === 'combo' && model.parentId) {\n      // add the combo to the parent's children array\n      var parentCombo = this.findById(model.comboId || model.parentId);\n      if (parentCombo && parentCombo.getType && parentCombo.getType() === 'combo') parentCombo.addChild(item);\n    }\n    return item;\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\n   * @return {Item} 元素实例\n   */\n  AbstractGraph.prototype.addItem = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n    var currentComboSorted = this.get('comboSorted');\n    this.set('comboSorted', currentComboSorted && !sortCombo);\n    var itemController = this.get('itemController');\n    var item = this.innerAddItem(type, model, itemController);\n    if (item === false || item === true) {\n      return item;\n    }\n    var combos = this.get('combos');\n    if (combos && combos.length > 0) {\n      this.sortCombos();\n    }\n    this.autoPaint();\n    if (stack && this.get('enabledStack')) {\n      var addedModel = __assign(__assign({}, item.getModel()), {\n        itemType: type\n      });\n      var after = {};\n      switch (type) {\n        case 'node':\n          after.nodes = [addedModel];\n          break;\n        case 'edge':\n          after.edges = [addedModel];\n          break;\n        case 'combo':\n          after.combos = [addedModel];\n          break;\n        default:\n          break;\n      }\n      this.pushStack('add', {\n        before: {},\n        after: after\n      });\n    }\n    return item;\n  };\n  AbstractGraph.prototype.addItems = function (items, stack, sortCombo) {\n    if (items === void 0) {\n      items = [];\n    }\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n    var currentComboSorted = this.get('comboSorted');\n    this.set('comboSorted', currentComboSorted && !sortCombo);\n    var itemController = this.get('itemController');\n    var returnItems = [];\n    // 1. add anything that is not an edge.\n    // Add undefined as a placeholder for the next cycle. This way we return items matching the input order\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n      if (item.type !== 'edge' && item.type !== 'vedge') {\n        returnItems.push(this.innerAddItem(item.type, item.model, itemController));\n      } else {\n        returnItems.push(undefined);\n      }\n    }\n    // 2. add all the edges\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n      if (item.type === 'edge' || item.type === 'vedge') {\n        returnItems[i] = this.innerAddItem(item.type, item.model, itemController);\n      }\n    }\n    if (sortCombo) {\n      var combos = this.get('combos');\n      if (combos && combos.length > 0) {\n        this.sortCombos();\n      }\n    }\n    this.autoPaint();\n    if (stack && this.get('enabledStack')) {\n      var after = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      for (var i = 0; i < items.length; i++) {\n        var type = items[i].type;\n        var returnItem = returnItems[i];\n        if (!!returnItem && returnItem !== true) {\n          var addedModel = __assign(__assign({}, returnItem.getModel()), {\n            itemType: type\n          });\n          switch (type) {\n            case 'node':\n              after.nodes.push(addedModel);\n              break;\n            case 'edge':\n              after.edges.push(addedModel);\n              break;\n            case 'combo':\n              after.combos.push(addedModel);\n              break;\n            default:\n              break;\n          }\n        }\n      }\n      this.pushStack('addItems', {\n        before: {},\n        after: after\n      });\n    }\n    return returnItems;\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\n   * @return {Item} 元素实例\n   */\n  AbstractGraph.prototype.add = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n    return this.addItem(type, model, stack, sortCombo);\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   */\n  AbstractGraph.prototype.updateItem = function (item, cfg, stack) {\n    var _this = this;\n    if (stack === void 0) {\n      stack = true;\n    }\n    var itemController = this.get('itemController');\n    var currentItem;\n    if (isString(item)) {\n      currentItem = this.findById(item);\n    } else {\n      currentItem = item;\n    }\n    var stackEnabled = stack && this.get('enabledStack');\n    var unupdatedModel;\n    if (stackEnabled) {\n      unupdatedModel = clone(currentItem.getModel());\n    }\n    var type = '';\n    if (currentItem.getType) type = currentItem.getType();\n    var states = __spreadArray([], currentItem.getStates(), true);\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, false);\n      });\n    }\n    itemController.updateItem(currentItem, cfg);\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, true);\n      });\n    }\n    if (stackEnabled) {\n      var before = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      var after = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      var afterModel = __assign({\n        id: unupdatedModel.id\n      }, cfg);\n      switch (type) {\n        case 'node':\n          before.nodes.push(unupdatedModel);\n          after.nodes.push(afterModel);\n          break;\n        case 'edge':\n          before.edges.push(unupdatedModel);\n          after.edges.push(afterModel);\n          break;\n        case 'combo':\n          before.combos.push(unupdatedModel);\n          after.combos.push(afterModel);\n          break;\n        default:\n          break;\n      }\n      this.pushStack('update', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n  AbstractGraph.prototype.update = function (item, cfg, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    this.updateItem(item, cfg, stack);\n  };\n  /**\n   * 设置元素状态\n   * @param {Item} item 元素id或元素实例\n   * @param {string} state 状态名称\n   * @param {string | boolean} value 是否启用状态 或 状态值\n   */\n  AbstractGraph.prototype.setItemState = function (item, state, value) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n    var itemController = this.get('itemController');\n    itemController.setItemState(item, state, value);\n    var stateController = this.get('stateController');\n    stateController.updateState(item, state, value);\n  };\n  /**\n   * 将指定状态的优先级提升为最高优先级\n   * @param {Item} item 元素id或元素实例\n   * @param state 状态名称\n   */\n  AbstractGraph.prototype.priorityState = function (item, state) {\n    var itemController = this.get('itemController');\n    itemController.priorityState(item, state);\n  };\n  /**\n   * 设置视图初始化数据\n   * @param {GraphData} data 初始化数据\n   */\n  AbstractGraph.prototype.data = function (data) {\n    dataValidation(data);\n    this.set('data', data);\n  };\n  /**\n   * 根据data接口的数据渲染视图\n   */\n  AbstractGraph.prototype.render = function () {\n    var self = this;\n    this.set('comboSorted', false);\n    var data = this.get('data');\n    if (this.get('enabledStack')) {\n      // render 之前清空 redo 和 undo 栈\n      this.clearStack();\n    }\n    if (!data) {\n      throw new Error('data must be defined first');\n    }\n    var _a = data.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = data.edges,\n      edges = _b === void 0 ? [] : _b,\n      _c = data.combos,\n      combos = _c === void 0 ? [] : _c;\n    this.clear(true);\n    this.emit('beforerender');\n    self.addItems(nodes.map(function (node) {\n      return {\n        type: 'node',\n        model: node\n      };\n    }), false, false);\n    // process the data to tree structure\n    if ((combos === null || combos === void 0 ? void 0 : combos.length) !== 0) {\n      var comboTrees = plainCombosToTrees(combos, nodes);\n      this.set('comboTrees', comboTrees);\n      // add combos\n      self.addCombos(combos);\n    }\n    self.addItems(edges.map(function (edge) {\n      return {\n        type: 'edge',\n        model: edge\n      };\n    }), false, false);\n    var animate = self.get('animate');\n    if (self.get('fitView') || self.get('fitCenter')) {\n      self.set('animate', false);\n    }\n    // layout\n    var layoutController = self.get('layoutController');\n    if (layoutController) {\n      layoutController.layout(success);\n      if (this.destroyed) return;\n    } else {\n      success();\n    }\n    // 将在 onLayoutEnd 中被调用\n    function success() {\n      // 自底向上将 collapsed 的 combo 合起\n      (self.get('comboTrees') || []).forEach(function (ctree) {\n        traverseTreeUp(ctree, function (child) {\n          var item = self.findById(child.id);\n          if (item.getType() === 'combo' && child.collapsed) {\n            self.collapseCombo(child.id, false);\n            self.updateCombo(item);\n          }\n          return true;\n        });\n      });\n      // fitView 与 fitCenter 共存时，fitView 优先，fitCenter 不再执行\n      if (self.get('fitView')) {\n        self.fitView();\n      } else if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n      self.autoPaint();\n      self.emit('afterrender');\n      if (self.get('fitView') || self.get('fitCenter')) {\n        self.set('animate', animate);\n      }\n      setTimeout(function () {\n        var _a;\n        (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n          combo.set('animate', true);\n        });\n      }, 0);\n    }\n    if (!this.get('groupByTypes')) {\n      if (combos && combos.length !== 0) {\n        this.sortCombos();\n      } else {\n        // 为提升性能，选择数量少的进行操作\n        if (data.nodes && data.edges && data.nodes.length < data.edges.length) {\n          var nodesArr = this.getNodes();\n          // 遍历节点实例，将所有节点提前。\n          nodesArr.forEach(function (node) {\n            node.toFront();\n          });\n        } else {\n          var edgesArr = this.getEdges();\n          // 遍历节点实例，将所有节点提前。\n          edgesArr.forEach(function (edge) {\n            edge.toBack();\n          });\n        }\n      }\n    }\n  };\n  /**\n   * 接收数据进行渲染\n   * @Param {Object} data 初始化数据\n   */\n  AbstractGraph.prototype.read = function (data) {\n    this.data(data);\n    this.render();\n  };\n  // 比较item\n  AbstractGraph.prototype.diffItems = function (type, items, models) {\n    var self = this;\n    var item;\n    var itemMap = this.get('itemMap');\n    each(models, function (model) {\n      item = itemMap[model.id];\n      if (item) {\n        if (self.get('animate') && type === NODE) {\n          var containerMatrix = item.getContainer().getMatrix();\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          item.set('originAttrs', {\n            x: containerMatrix[6],\n            y: containerMatrix[7]\n          });\n        }\n        self.updateItem(item, model, false);\n      } else {\n        item = self.addItem(type, model, false);\n      }\n      if (item) items[\"\".concat(type, \"s\")].push(item);\n    });\n  };\n  /**\n   * 更改源数据，根据新数据重新渲染视图\n   * @param {GraphData | TreeGraphData} data 源数据\n   * @param {boolean} 是否入栈，默认为true\n   * @return {object} this\n   */\n  AbstractGraph.prototype.changeData = function (propsData, stack) {\n    var _this = this;\n    var _a;\n    if (stack === void 0) {\n      stack = true;\n    }\n    var self = this;\n    var data = propsData || self.get('data');\n    if (!dataValidation(data)) {\n      return this;\n    }\n    this.emit('beforechangedata');\n    if (stack && this.get('enabledStack')) {\n      this.pushStack('changedata', {\n        before: self.save(),\n        after: data\n      });\n    }\n    this.set('comboSorted', false);\n    // 删除 hulls\n    this.removeHulls();\n    // 更改数据源后，取消所有状态\n    this.getNodes().map(function (node) {\n      return self.clearItemStates(node);\n    });\n    this.getEdges().map(function (edge) {\n      return self.clearItemStates(edge);\n    });\n    var canvas = this.get('canvas');\n    var localRefresh = canvas.get('localRefresh');\n    canvas.set('localRefresh', false);\n    if (!self.get('data')) {\n      self.data(data);\n      self.render();\n    }\n    var itemMap = this.get('itemMap');\n    var items = {\n      nodes: [],\n      edges: []\n    };\n    var combosData = data.combos;\n    if (combosData) {\n      var comboTrees = plainCombosToTrees(combosData, data.nodes);\n      this.set('comboTrees', comboTrees);\n    } else {\n      this.set('comboTrees', []);\n    }\n    this.diffItems('node', items, data.nodes);\n    each(itemMap, function (item, id) {\n      itemMap[id].getModel().depth = 0;\n      if (item.getType && item.getType() === 'edge') return;\n      if (item.getType && item.getType() === 'combo') {\n        delete itemMap[id];\n        item.destroy();\n      } else if (items.nodes.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    });\n    // clear the destroyed combos here to avoid removing sub nodes before removing the parent combo\n    var comboItems = this.getCombos();\n    var combosLength = comboItems.length;\n    for (var i = combosLength - 1; i >= 0; i--) {\n      if (comboItems[i].destroyed) {\n        comboItems.splice(i, 1);\n      }\n    }\n    // process the data to tree structure\n    if (combosData) {\n      // add combos\n      self.addCombos(combosData);\n      if (!this.get('groupByTypes')) {\n        this.sortCombos();\n      }\n    }\n    this.diffItems('edge', items, data.edges);\n    each(itemMap, function (item, id) {\n      if (item.getType && (item.getType() === 'node' || item.getType() === 'combo')) return;\n      if (items.edges.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    });\n    // 自底向上将 collapsed 的 combo 合起\n    (this.get('comboTrees') || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        var item = _this.findById(child.id);\n        if (item.getType() === 'combo' && child.collapsed) {\n          _this.collapseCombo(child.id, false);\n        }\n        return true;\n      });\n    });\n    this.set({\n      nodes: items.nodes,\n      edges: items.edges\n    });\n    var _b = (this.get('layout') || {}).relayoutAtChangeData,\n      relayoutAtChangeData = _b === void 0 ? true : _b;\n    var layoutController = this.get('layoutController');\n    if (relayoutAtChangeData && layoutController) {\n      layoutController.changeData(function () {\n        setTimeout(function () {\n          var _a;\n          (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n            combo.set('animate', true);\n          });\n        }, 0);\n      });\n      if (self.get('animate') && !layoutController.getLayoutType()) {\n        // 如果没有指定布局\n        self.positionsAnimate();\n        (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n          return combo.set('animate', true);\n        });\n      } else {\n        self.autoPaint();\n      }\n    }\n    setTimeout(function () {\n      canvas.set('localRefresh', localRefresh);\n    }, 16);\n    this.set('data', data);\n    this.emit('afterchangedata');\n    return this;\n  };\n  /**\n   * 私有方法，在 render 和 changeData 的时候批量添加数据中所有平铺的 combos\n   * @param {ComboConfig[]} combos 平铺的 combos 数据\n   */\n  AbstractGraph.prototype.addCombos = function (combos) {\n    var self = this;\n    var comboTrees = self.get('comboTrees');\n    var itemController = this.get('itemController');\n    itemController.addCombos(comboTrees, combos);\n  };\n  /**\n   * 根据已经存在的节点或 combo 创建新的 combo\n   * @param combo combo ID 或 Combo 配置\n   * @param childrenIds 添加到 Combo 中的元素，包括节点和 combo\n   */\n  AbstractGraph.prototype.createCombo = function (combo, childrenIds, stack) {\n    var _this = this;\n    if (stack === void 0) {\n      stack = true;\n    }\n    var itemController = this.get('itemController');\n    this.set('comboSorted', false);\n    // step 1: 创建新的 Combo\n    var comboId = '';\n    var comboConfig;\n    if (!combo) return;\n    if (isString(combo)) {\n      comboId = combo;\n      comboConfig = {\n        id: combo\n      };\n    } else {\n      comboId = combo.id;\n      if (!comboId) {\n        console.warn('Create combo failed. Please assign a unique string id for the adding combo.');\n        return;\n      }\n      comboConfig = combo;\n    }\n    var shouldStack = stack && this.get('enabledStack');\n    // cache the children's old parent for stack\n    var childrenParentCache = {\n      nodes: [],\n      combos: []\n    };\n    if (shouldStack) {\n      childrenIds.forEach(function (childId) {\n        var childItem = _this.findById(childId);\n        var childType = childItem.getType();\n        if (childType !== 'node' && childType !== 'combo') return;\n        var childModel = childItem.getModel();\n        childrenParentCache[\"\".concat(childType, \"s\")].push({\n          id: childId,\n          parentId: childType === 'node' ? childModel.comboId : childModel.parentId\n        });\n      });\n    }\n    // step 2: Pull children out of their parents\n    var comboTrees = this.get('comboTrees');\n    var childrenIdsSet = new Set(childrenIds);\n    var pulledComboTreesById = new Map();\n    if (comboTrees) {\n      comboTrees.forEach(function (ctree) {\n        traverseTreeUp(ctree, function (treeNode, parentTreeNode, index) {\n          if (childrenIdsSet.has(treeNode.id)) {\n            if (parentTreeNode) {\n              var parentItem = _this.findById(parentTreeNode.id);\n              var item = _this.findById(treeNode.id);\n              // Removing current item from the tree during the traversal is ok because children traversal is done\n              // in an *inverse order* - indices of the next-traversed items are not disturbed by the removal.\n              parentTreeNode.children.splice(index, 1);\n              parentItem.removeChild(item);\n              // We have to update the parent node geometry since nodes were removed from them, _while they are still visible_\n              // (combos may be moved inside the new combo and become hidden)\n              itemController.updateCombo(parentItem, parentTreeNode.children);\n            }\n            if (treeNode.itemType === 'combo') {\n              pulledComboTreesById.set(treeNode.id, treeNode);\n            }\n          }\n          return true;\n        });\n      });\n      comboTrees = comboTrees.filter(function (ctree) {\n        return !childrenIdsSet.has(ctree.id);\n      });\n      this.set('comboTrees', comboTrees);\n    }\n    // step 3: 更新 children，根据类型添加 comboId 或 parentId\n    var newChildrenParent = {\n      nodes: [],\n      combos: []\n    };\n    var trees = childrenIds.map(function (elementId) {\n      var item = _this.findById(elementId);\n      var model = item.getModel();\n      var type = '';\n      if (item.getType) type = item.getType();\n      // Combos will be just moved around, so their children can be preserved\n      var cItem = pulledComboTreesById.get(elementId) || {\n        id: item.getID(),\n        itemType: type\n      };\n      if (type === 'combo') {\n        cItem.parentId = comboId;\n        model.parentId = comboId;\n      } else if (type === 'node') {\n        cItem.comboId = comboId;\n        model.comboId = comboId;\n      }\n      if (shouldStack) {\n        newChildrenParent[\"\".concat(type, \"s\")].push({\n          id: model.id,\n          parentId: comboId\n        });\n      }\n      return cItem;\n    });\n    comboConfig.children = trees;\n    // step 4: 添加 Combo，addItem 时会将子将元素添加到 Combo 中\n    this.addItem('combo', comboConfig, false);\n    this.set('comboSorted', false);\n    // step 5: 更新 comboTrees 结构\n    if (comboTrees) {\n      comboTrees.forEach(function (ctree) {\n        traverseTree(ctree, function (treeNode) {\n          // Set the children to the newly created combo\n          if (treeNode.id === comboId) {\n            treeNode.itemType = 'combo';\n            treeNode.children = trees;\n            return false;\n          }\n          return true;\n        });\n      });\n      this.sortCombos();\n    }\n    if (shouldStack) {\n      newChildrenParent.combos.push(comboConfig);\n      this.pushStack('createCombo', {\n        before: childrenParentCache,\n        after: newChildrenParent\n      });\n    }\n    // Fixes issue of nested child combos not being interactive (under parent on graph).\n    var comboItem = this.findById(comboId);\n    if (!comboItem.getModel().parentId && comboItem.getChildren().combos.length) {\n      this.updateComboTree(comboItem, undefined, false);\n    }\n    setTimeout(function () {\n      comboItem.set('animate', true);\n    }, 0);\n  };\n  /**\n   * 解散 combo\n   * @param {String | INode | ICombo} combo 需要被解散的 Combo item 或 id\n   */\n  AbstractGraph.prototype.uncombo = function (combo, stack) {\n    var _this = this;\n    var _a, _b;\n    if (stack === void 0) {\n      stack = true;\n    }\n    var self = this;\n    var comboItem = combo;\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item is not a combo!');\n      return;\n    }\n    var comboModel = comboItem.getModel();\n    var parentId = comboItem.getModel().parentId;\n    var comboTrees = self.get('comboTrees');\n    if (!comboTrees) comboTrees = [];\n    var itemMap = this.get('itemMap');\n    var comboId = comboItem.get('id');\n    var treeToBeUncombo;\n    var brothers = [];\n    var comboItems = this.get('combos');\n    var parentItem = this.findById(parentId);\n    var shouldStack = stack && this.get('enabledStack');\n    var comboConfig = {};\n    if (shouldStack) {\n      comboConfig = clone(comboModel);\n      comboConfig.children = [];\n    }\n    comboTrees.forEach(function (ctree) {\n      if (treeToBeUncombo) return; // terminate the forEach\n      traverseTreeUp(ctree, function (subtree) {\n        var _a;\n        // find the combo to be uncomboed, delete the combo from map and cache\n        if (subtree.id === comboId) {\n          treeToBeUncombo = subtree;\n          // delete the related edges\n          var edgeIds = comboItem.getEdges().map(function (edge) {\n            return edge.getID();\n          });\n          edgeIds.forEach(function (edgeId) {\n            _this.removeItem(edgeId, false);\n          });\n          var index = comboItems.indexOf(comboItem);\n          comboItems.splice(index, 1);\n          delete itemMap[comboId];\n          var itemModel = clone(comboItem.getModel());\n          comboItem.destroy();\n          _this.emit('afterremoveitem', {\n            item: itemModel,\n            type: 'combo'\n          });\n        }\n        // find the parent to remove the combo from the combo's brothers array and add the combo's children to the combo's brothers array in the tree\n        if (parentId && treeToBeUncombo && subtree.id === parentId) {\n          parentItem.removeCombo(comboItem);\n          brothers = subtree.children; // the combo's brothers\n          // remove the combo from its brothers array\n          var index = brothers.indexOf(treeToBeUncombo);\n          if (index !== -1) {\n            brothers.splice(index, 1);\n          }\n          // append the combo's children to the combo's brothers array\n          (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            var item = _this.findById(child.id);\n            var childModel = item.getModel();\n            if (item.getType && item.getType() === 'combo') {\n              child.parentId = parentId;\n              delete child.comboId;\n              childModel.parentId = parentId; // update the parentId of the model\n              delete childModel.comboId;\n            } else if (item.getType && item.getType() === 'node') {\n              child.comboId = parentId;\n              childModel.comboId = parentId; // update the parentId of the model\n            }\n\n            parentItem.addChild(item);\n            brothers.push(child);\n          });\n          _this.updateCombo(parentItem);\n          return false;\n        }\n        return true;\n      });\n    });\n    // if the parentId is not found, remove the combo from the roots\n    if (!parentId && treeToBeUncombo) {\n      var index = comboTrees.indexOf(treeToBeUncombo);\n      comboTrees.splice(index, 1);\n      // modify the parentId of the children\n      (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n        child.parentId = undefined;\n        var childModel = _this.findById(child.id).getModel();\n        delete childModel.parentId; // update the parentId of the model\n        delete childModel.comboId; // update the comboId of the model\n        if (child.itemType !== 'node') comboTrees.push(child);\n      });\n    }\n    if (shouldStack) {\n      // cache the children's old parent and combo model for stack\n      var childrenParentCache_1 = {\n        nodes: [],\n        combos: []\n      };\n      var childNewParent_1 = {\n        nodes: [],\n        combos: []\n      };\n      (_b = treeToBeUncombo.children) === null || _b === void 0 ? void 0 : _b.forEach(function (child) {\n        var childItem = _this.findById(child.id);\n        var childType = childItem.getType();\n        if (childType !== 'node' && childType !== 'combo') return;\n        childrenParentCache_1[\"\".concat(childType, \"s\")].push({\n          id: child.id,\n          parentId: comboId\n        });\n        childNewParent_1[\"\".concat(childType, \"s\")].push({\n          id: child.id,\n          parentId: parentId\n        });\n      });\n      childrenParentCache_1.combos.push(comboConfig);\n      this.pushStack('uncombo', {\n        before: childrenParentCache_1,\n        after: childNewParent_1\n      });\n    }\n  };\n  /**\n   * 根据 combo 位置更新内部节点位置 followCombo = true\n   * 或根据内部元素的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围，followCombo = false\n   */\n  AbstractGraph.prototype.updateCombos = function (followCombo) {\n    var _this = this;\n    if (followCombo === void 0) {\n      followCombo = false;\n    }\n    var self = this;\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        var _a;\n        if (!child) {\n          return true;\n        }\n        var childItem = itemMap[child.id];\n        if (((_a = childItem === null || childItem === void 0 ? void 0 : childItem.getType) === null || _a === void 0 ? void 0 : _a.call(childItem)) === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true);\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, false);\n          });\n          // 更新具体的 Combo\n          itemController.updateCombo(childItem, child.children, followCombo);\n          // 更新 Combo 后，还原已有的状态\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, true);\n          });\n        }\n        return true;\n      });\n    });\n    self.sortCombos();\n  };\n  /**\n   * 根据节点的 bbox 更新 combo 及其祖先 combos 的绘制，包括 combos 的位置和范围\n   * @param {String | ICombo} combo 需要被更新的 Combo 或 id，若指定，则该 Combo 及所有祖先 Combod 都会被更新\n   */\n  AbstractGraph.prototype.updateCombo = function (combo) {\n    var _this = this;\n    var self = this;\n    var comboItem = combo;\n    var comboId;\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item to be updated is not a combo!');\n      return;\n    }\n    comboId = comboItem.get('id');\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (!child) {\n          return true;\n        }\n        var childItem = itemMap[child.id];\n        if (comboId === child.id && childItem && childItem.getType && childItem.getType() === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true);\n          // || !item.getStateStyle(stateName)\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, false);\n            }\n          });\n          // 更新具体的 Combo\n          itemController.updateCombo(childItem, child.children);\n          // 更新 Combo 后，还原已有的状态\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, true);\n            }\n          });\n          if (comboId) comboId = child.parentId;\n        }\n        return true;\n      });\n    });\n  };\n  /**\n   * 更新树结构，例如移动子树等\n   * @param {String | INode | ICombo} item 需要被更新的 Combo 或 节点 id\n   * @param {string | undefined} parentId 新的父 combo id，undefined 代表没有父 combo\n   */\n  AbstractGraph.prototype.updateComboTree = function (item, parentId, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    var self = this;\n    this.set('comboSorted', false);\n    var uItem;\n    if (isString(item)) {\n      uItem = self.findById(item);\n    } else {\n      uItem = item;\n    }\n    var model = uItem.getModel();\n    var oldParentId = model.comboId || model.parentId;\n    var type = '';\n    if (uItem.getType) type = uItem.getType();\n    // 若 item 是 Combo，且 parentId 是其子孙 combo 的 id，则警告并终止\n    if (parentId && type === 'combo') {\n      var comboTrees = this.get('comboTrees');\n      var valid_1 = true;\n      var itemSubTree_1;\n      (comboTrees || []).forEach(function (ctree) {\n        if (itemSubTree_1) return;\n        traverseTree(ctree, function (subTree) {\n          if (itemSubTree_1) return;\n          // 找到从 item 开始的子树\n          if (subTree.id === uItem.getID()) {\n            itemSubTree_1 = subTree;\n          }\n          return true;\n        });\n      });\n      // 在以 item 为根的子树中寻找与 parentId 相同的后继元素\n      traverseTree(itemSubTree_1, function (subTree) {\n        if (subTree.id === parentId) {\n          valid_1 = false;\n          return false;\n        }\n        return true;\n      });\n      // parentId 是 item 的一个后继元素，不能进行更新\n      if (!valid_1) {\n        console.warn('Failed to update the combo tree! The parentId points to a descendant of the combo!');\n        return;\n      }\n    }\n    if (stack && this.get('enabledStack')) {\n      var beforeData = {},\n        afterData = {};\n      if (type === 'combo') {\n        beforeData.combos = [{\n          id: model.id,\n          parentId: model.parentId\n        }];\n        afterData.combos = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      } else if (type === 'node') {\n        beforeData.nodes = [{\n          id: model.id,\n          parentId: model.comboId\n        }];\n        afterData.nodes = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      }\n      this.pushStack('updateComboTree', {\n        before: beforeData,\n        after: afterData\n      });\n    }\n    // 当 combo 存在 parentId 或 comboId 时，才将其移除\n    if (model.parentId || model.comboId) {\n      var combo = this.findById(model.parentId || model.comboId);\n      if (combo) {\n        combo.removeChild(uItem);\n      }\n    }\n    if (type === 'combo') {\n      model.parentId = parentId;\n    } else if (type === 'node') {\n      model.comboId = parentId;\n    }\n    // 只有当移入到指定 combo 时才添加\n    if (parentId) {\n      var parentCombo = this.findById(parentId);\n      if (parentCombo) {\n        // 将元素添加到 parentCombo 中\n        parentCombo.addChild(uItem);\n      }\n    }\n    // 如果原先有父亲 combo，则从原父 combo 的子元素数组中删除\n    if (oldParentId) {\n      var parentCombo = this.findById(oldParentId);\n      if (parentCombo) {\n        // 将元素从 parentCombo 中移除\n        parentCombo.removeChild(uItem);\n      }\n    }\n    var newComboTrees = reconstructTree(this.get('comboTrees'), model.id, parentId);\n    this.set('comboTrees', newComboTrees);\n    this.updateCombos();\n  };\n  /**\n   * 导出图数据\n   * @return {object} data\n   */\n  AbstractGraph.prototype.save = function () {\n    var nodes = [];\n    var edges = [];\n    var combos = [];\n    each(this.get('nodes'), function (node) {\n      nodes.push(node.getModel());\n    });\n    each(this.get('edges'), function (edge) {\n      edges.push(edge.getModel());\n    });\n    each(this.get('combos'), function (combo) {\n      combos.push(combo.getModel());\n    });\n    return {\n      nodes: nodes,\n      edges: edges,\n      combos: combos\n    };\n  };\n  /**\n   * 改变画布大小\n   * @param  {number} width  画布宽度\n   * @param  {number} height 画布高度\n   * @return {object} this\n   */\n  AbstractGraph.prototype.changeSize = function (width, height) {\n    var viewController = this.get('viewController');\n    viewController.changeSize(width, height);\n    return this;\n  };\n  /**\n   * 当源数据在外部发生变更时，根据新数据刷新视图。但是不刷新节点位置\n   */\n  AbstractGraph.prototype.refresh = function () {\n    var self = this;\n    self.emit('beforegraphrefresh');\n    if (self.get('animate')) {\n      self.positionsAnimate();\n    } else {\n      var nodes = self.get('nodes');\n      var edges = self.get('edges');\n      var vedges = self.get('edges');\n      each(nodes, function (node) {\n        node.refresh();\n      });\n      each(edges, function (edge) {\n        edge.refresh();\n      });\n      each(vedges, function (vedge) {\n        vedge.refresh();\n      });\n    }\n    self.emit('aftergraphrefresh');\n    self.autoPaint();\n  };\n  /**\n   * 获取当前图中所有节点的item实例\n   * @return {INode} item数组\n   */\n  AbstractGraph.prototype.getNodes = function () {\n    return this.get('nodes');\n  };\n  /**\n   * 获取当前图中所有边的item实例\n   * @return {IEdge} item数组\n   */\n  AbstractGraph.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取图中所有的 combo 实例\n   */\n  AbstractGraph.prototype.getCombos = function () {\n    return this.get('combos');\n  };\n  /**\n   * 获取指定 Combo 中所有的节点\n   * @param comboId combo ID\n   */\n  AbstractGraph.prototype.getComboChildren = function (combo) {\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo does not exist!');\n      return;\n    }\n    return combo.getChildren();\n  };\n  /**\n   * 根据 graph 上的 animateCfg 进行视图中节点位置动画接口\n   */\n  AbstractGraph.prototype.positionsAnimate = function (referComboModel) {\n    var self = this;\n    self.emit('beforeanimate');\n    var animateCfg = self.get('animateCfg');\n    var onFrame = animateCfg.onFrame;\n    var nodes = referComboModel ? self.getNodes().concat(self.getCombos()) : self.getNodes();\n    var toNodes = nodes.map(function (node) {\n      var model = node.getModel();\n      return {\n        id: model.id,\n        x: model.x,\n        y: model.y\n      };\n    });\n    self.stopAnimate();\n    var canvas = self.get('canvas');\n    self.animating = true;\n    setTimeout(function () {\n      canvas.animate(function (ratio) {\n        each(toNodes, function (data) {\n          var node = self.findById(data.id);\n          if (!node || node.destroyed) {\n            return;\n          }\n          var originAttrs = node.get('originAttrs');\n          var model = node.get('model');\n          var containerMatrix = node.getContainer().getMatrix();\n          if (originAttrs === undefined || originAttrs === null) {\n            // 变换前存在位置，设置到 originAttrs 上。否则标记 0 表示变换前不存在位置，不需要计算动画\n            if (containerMatrix) {\n              originAttrs = {\n                x: containerMatrix[6],\n                y: containerMatrix[7]\n              };\n            }\n            node.set('originAttrs', originAttrs || 0);\n          }\n          if (onFrame) {\n            var attrs = onFrame(node, ratio, data, originAttrs || {\n              x: 0,\n              y: 0\n            });\n            node.set('model', Object.assign(model, attrs));\n          } else if (originAttrs) {\n            // 变换前存在位置，进行动画\n            model.x = originAttrs.x + (data.x - originAttrs.x) * ratio;\n            model.y = originAttrs.y + (data.y - originAttrs.y) * ratio;\n          } else {\n            // 若在变换前不存在位置信息，则直接放到最终位置上\n            model.x = data.x;\n            model.y = data.y;\n          }\n        });\n        self.refreshPositions(referComboModel);\n      }, {\n        duration: animateCfg.duration,\n        easing: animateCfg.easing,\n        callback: function callback() {\n          each(nodes, function (node) {\n            node.set('originAttrs', null);\n          });\n          if (animateCfg.callback) {\n            animateCfg.callback();\n          }\n          self.emit('afteranimate');\n          self.animating = false;\n        }\n      });\n    }, 0);\n  };\n  /**\n   * 当节点位置在外部发生改变时，刷新所有节点位置，重计算边\n   */\n  AbstractGraph.prototype.refreshPositions = function (referComboModel) {\n    var self = this;\n    self.emit('beforegraphrefreshposition');\n    var nodes = self.get('nodes');\n    var edges = self.get('edges');\n    var vedges = self.get('vedges');\n    var combos = self.get('combos');\n    var model;\n    var updatedNodes = {};\n    var updateItems = function updateItems(items) {\n      each(items, function (item) {\n        model = item.getModel();\n        var originAttrs = item.get('originAttrs');\n        if (originAttrs && model.x === originAttrs.x && model.y === originAttrs.y) {\n          return;\n        }\n        var changed = item.updatePosition({\n          x: model.x,\n          y: model.y\n        });\n        updatedNodes[model.id] = changed;\n        if (model.comboId) updatedNodes[model.comboId] = updatedNodes[model.comboId] || changed;\n        if (model.parentId) updatedNodes[model.parentId] = updatedNodes[model.parentId] || changed;\n      });\n    };\n    updateItems(combos);\n    updateItems(nodes);\n    if (combos && combos.length !== 0) {\n      if (referComboModel) {\n        updateItems(combos);\n        self.updateCombos();\n      } else {\n        self.updateCombos();\n      }\n    }\n    each(edges, function (edge) {\n      var sourceModel = edge.getSource().getModel();\n      var target = edge.getTarget();\n      // 避免 target 是纯对象的情况下调用 getModel 方法\n      // 拖动生成边的时候 target 会是纯对象\n      if (!isPlainObject(target)) {\n        var targetModel = target.getModel();\n        if (updatedNodes[sourceModel.id] || updatedNodes[targetModel.id] || edge.getModel().isComboEdge) {\n          edge.refresh();\n        }\n      }\n    });\n    each(vedges, function (vedge) {\n      vedge.refresh();\n    });\n    self.emit('aftergraphrefreshposition');\n    self.autoPaint();\n  };\n  AbstractGraph.prototype.stopAnimate = function () {\n    var canvas = this.get('canvas');\n    var timeline = canvas.cfg.timeline;\n    if (timeline) {\n      timeline.stopAllAnimations();\n    }\n  };\n  AbstractGraph.prototype.isAnimating = function () {\n    return this.animating;\n  };\n  /**\n   * 获取当前视口伸缩比例\n   * @return {number} 比例\n   */\n  AbstractGraph.prototype.getZoom = function () {\n    var matrix = this.get('group').getMatrix();\n    return matrix ? matrix[0] : 1;\n  };\n  /**\n   * 获取当前的行为模式\n   * @return {string} 当前行为模式\n   */\n  AbstractGraph.prototype.getCurrentMode = function () {\n    var modeController = this.get('modeController');\n    return modeController.getMode();\n  };\n  /**\n   * 切换行为模式\n   * @param {string} mode 指定模式\n   * @return {object} this\n   */\n  AbstractGraph.prototype.setMode = function (mode) {\n    var modeController = this.get('modeController');\n    modeController.setMode(mode);\n    return this;\n  };\n  /**\n   * 清除画布元素\n   * @return {object} this\n   */\n  AbstractGraph.prototype.clear = function (avoidEmit) {\n    var _a;\n    if (avoidEmit === void 0) {\n      avoidEmit = false;\n    }\n    (_a = this.get('canvas')) === null || _a === void 0 ? void 0 : _a.clear();\n    this.initGroups();\n    // 清空画布时同时清除数据\n    this.set({\n      itemMap: {},\n      nodes: [],\n      edges: [],\n      vedges: [],\n      groups: [],\n      combos: [],\n      comboTrees: []\n    });\n    if (!avoidEmit) this.emit('afterrender');\n    return this;\n  };\n  /**\n   * 更换布局配置项\n   * @param {object} cfg 新布局配置项\n   * @param {'center' | 'begin'} align 对齐方式，可选中心（center）对齐到对齐点，或左上角（begin）对齐到对齐点\n   * @param {IPoint} alignPoint 画布上的对齐点，为 Canvas 坐标系（Canvas DOM）\n   * 若 cfg 含有 type 字段或为 String 类型，且与现有布局方法不同，则更换布局\n   * 若 cfg 不包括 type ，则保持原有布局方法，仅更新布局配置项\n   */\n  AbstractGraph.prototype.updateLayout = function (cfg, align, alignPoint, stack) {\n    var _this = this;\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    if (stack === void 0) {\n      stack = true;\n    }\n    var layoutController = this.get('layoutController');\n    if (isString(cfg)) {\n      cfg = {\n        type: cfg\n      };\n    }\n    // align the graph after layout\n    if (align) {\n      var toPoint_1 = alignPoint;\n      if (!toPoint_1) {\n        if (align === 'begin') toPoint_1 = {\n          x: 0,\n          y: 0\n        };else toPoint_1 = {\n          x: this.getWidth() / 2,\n          y: this.getHeight() / 2\n        };\n      }\n      // translate to point coordinate system\n      toPoint_1 = this.getPointByCanvas(toPoint_1.x, toPoint_1.y);\n      var forceTypes = ['force', 'gForce', 'fruchterman', 'force2'];\n      // if it is force layout, only center takes effect, and assign center force\n      if (forceTypes.includes(cfg.type) || !cfg.type && forceTypes.includes(layoutController === null || layoutController === void 0 ? void 0 : layoutController.layoutType)) {\n        cfg.center = [toPoint_1.x, toPoint_1.y];\n      } else {\n        this.once('afterlayout', function (e) {\n          var matrix = _this.getGroup().getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          toPoint_1.x = toPoint_1.x * matrix[0] + matrix[6];\n          toPoint_1.y = toPoint_1.y * matrix[0] + matrix[7];\n          var _a = _this.getGroup().getCanvasBBox(),\n            minX = _a.minX,\n            maxX = _a.maxX,\n            minY = _a.minY,\n            maxY = _a.maxY;\n          var bboxPoint = {\n            x: (minX + maxX) / 2,\n            y: (minY + maxY) / 2\n          };\n          if (align === 'begin') {\n            bboxPoint.x = minX;\n            bboxPoint.y = minY;\n          }\n          _this.translate(toPoint_1.x - bboxPoint.x, toPoint_1.y - bboxPoint.y);\n        });\n      }\n    }\n    var oriLayoutCfg = __assign({}, this.get('layout'));\n    var layoutCfg = {};\n    Object.assign(layoutCfg, oriLayoutCfg, cfg);\n    if (cfg.pipes && !cfg.type) delete layoutCfg.type;else if (!cfg.pipes && layoutCfg.type) delete layoutCfg.pipes;\n    this.set('layout', layoutCfg);\n    if (!layoutController) return;\n    if (layoutController.isLayoutTypeSame(layoutCfg) && layoutCfg.gpuEnabled === oriLayoutCfg.gpuEnabled) {\n      // no type or same type, or switch the gpu and cpu, update layout\n      layoutController.updateLayoutCfg(layoutCfg);\n    } else {\n      // has different type, change layout\n      layoutController.changeLayout(layoutCfg);\n    }\n    if (stack && this.get('enabledStack')) {\n      this.pushStack('layout', {\n        before: oriLayoutCfg,\n        after: layoutCfg\n      });\n    }\n  };\n  /**\n   * 销毁布局，changeData 时不会再使用原来的布局方法对新数据进行布局\n   */\n  AbstractGraph.prototype.destroyLayout = function () {\n    var layoutController = this.get('layoutController');\n    layoutController === null || layoutController === void 0 ? void 0 : layoutController.destroyLayout();\n  };\n  /**\n   * 重新以当前示例中配置的属性进行一次布局\n   */\n  AbstractGraph.prototype.layout = function () {\n    var _a;\n    var layoutController = this.get('layoutController');\n    var layoutCfg = this.get('layout');\n    if (!layoutCfg || !layoutController) return;\n    if (layoutCfg.workerEnabled) {\n      // 如果使用web worker布局\n      layoutController.layout();\n      return;\n    }\n    if ((_a = layoutController.layoutMethods) === null || _a === void 0 ? void 0 : _a.length) {\n      layoutController.relayout(true);\n    } else {\n      layoutController.layout();\n    }\n  };\n  /**\n   * 收起指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n  AbstractGraph.prototype.collapseCombo = function (combo, stack) {\n    var _this = this;\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (this.destroyed) return;\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n    if (!combo) {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n    this.emit('beforecollapseexpandcombo', {\n      action: 'collapse',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.collapseCombo(combo, stack);\n    comboModel.collapsed = true;\n    // add virtual edges\n    var edges = this.getEdges().concat(this.get('vedges'));\n    // find all the descendant nodes and combos\n    var cNodesCombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate the forEach\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false;\n        // if the combo is found\n        if (comboModel.id === subTree.id) found = true;\n        if (found) {\n          // if the combo is found, concat the descendant nodes and combos\n          var item = _this.findById(subTree.id);\n          if (item && item.getType && item.getType() === 'combo') {\n            cNodesCombos = cNodesCombos.concat(item.getNodes());\n            cNodesCombos = cNodesCombos.concat(item.getCombos());\n          }\n        }\n        return true;\n      });\n    });\n    var addedVEdgeMap = {};\n    edges.forEach(function (edge) {\n      var _a = edge.getModel(),\n        isVEdge = _a.isVEdge,\n        _b = _a.size,\n        size = _b === void 0 ? 1 : _b;\n      if (edge.isVisible() && !isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n      var otherEnd = null;\n      var otherEndIsSource;\n      if (source.getModel().id === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {\n        // source is the current combo, or descent node/combo is the source but not the target)\n        otherEnd = target;\n        otherEndIsSource = false;\n      } else if (target.getModel().id === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // target is the current combo, or descent node/combo is the target but not the source)\n        otherEnd = source;\n        otherEndIsSource = true;\n      }\n      if (otherEnd) {\n        if (isVEdge) {\n          _this.removeItem(edge, false);\n          return;\n        }\n        var otherEndModel = otherEnd.getModel();\n        while (!otherEnd.isVisible()) {\n          var otherEndPId = otherEndModel.parentId,\n            otherEndCId = otherEndModel.comboId;\n          var otherEndParentId = otherEndPId || otherEndCId;\n          otherEnd = _this.findById(otherEndParentId);\n          if (!otherEnd || !otherEndParentId) return; // all the ancestors are hidden, then ignore the edge\n          otherEndModel = otherEnd.getModel();\n        }\n        var otherEndId = otherEndModel.id;\n        var vEdgeInfo = otherEndIsSource ? {\n          source: otherEndId,\n          target: comboModel.id,\n          size: size,\n          isVEdge: true\n        } : {\n          source: comboModel.id,\n          target: otherEndId,\n          size: size,\n          isVEdge: true\n        };\n        var key = \"\".concat(vEdgeInfo.source, \"-\").concat(vEdgeInfo.target);\n        if (addedVEdgeMap[key]) {\n          addedVEdgeMap[key].size += size;\n          return;\n        }\n        addedVEdgeMap[key] = vEdgeInfo;\n      }\n    });\n    // update the width of the virtual edges, which is the sum of merged actual edges\n    // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n    this.addItems(Object.values(addedVEdgeMap).map(function (edgeInfo) {\n      return {\n        type: 'vedge',\n        model: edgeInfo\n      };\n    }), false);\n    this.emit('aftercollapseexpandcombo', {\n      action: 'collapse',\n      item: combo\n    });\n  };\n  /**\n   * 展开指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n  AbstractGraph.prototype.expandCombo = function (combo, stack) {\n    var _this = this;\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.expandCombo(combo, stack);\n    comboModel.collapsed = false;\n    // add virtual edges\n    var edges = this.getEdges().concat(this.get('vedges'));\n    // find all the descendant nodes and combos\n    var cNodesCombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false;\n        if (comboModel.id === subTree.id) found = true;\n        if (found) {\n          var item = _this.findById(subTree.id);\n          if (item && item.getType && item.getType() === 'combo') {\n            cNodesCombos = cNodesCombos.concat(item.getNodes());\n            cNodesCombos = cNodesCombos.concat(item.getCombos());\n          }\n        }\n        return true;\n      });\n    });\n    var addedVEdgeMap = {};\n    edges.forEach(function (edge) {\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n      var sourceId = source.get('id');\n      var targetId = target.get('id');\n      var otherEnd = null;\n      var otherEndIsSource;\n      if (sourceId === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {\n        // the source is in the combo, the target is not\n        otherEnd = target;\n        otherEndIsSource = false;\n      } else if (targetId === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // the target is in the combo, the source is not\n        otherEnd = source;\n        otherEndIsSource = true;\n      } else if (cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // both source and target are in the combo, if the target and source are both visible, show the edge\n        if (source.isVisible() && target.isVisible()) {\n          edge.show();\n        }\n      }\n      if (otherEnd) {\n        var _a = edge.getModel(),\n          isVEdge = _a.isVEdge,\n          _b = _a.size,\n          size = _b === void 0 ? 1 : _b;\n        // ignore the virtual edges\n        if (isVEdge) {\n          _this.removeItem(edge, false);\n          return;\n        }\n        var otherEndModel = otherEnd.getModel();\n        // find the nearest visible ancestor\n        while (!otherEnd.isVisible()) {\n          var otherEndPId = otherEndModel.parentId,\n            otherEndCId = otherEndModel.comboId;\n          var otherEndParentId = otherEndPId || otherEndCId;\n          otherEnd = _this.findById(otherEndParentId);\n          if (!otherEnd || !otherEndParentId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          otherEndModel = otherEnd.getModel();\n        }\n        var otherEndId = otherEndModel.id;\n        var selfEnd = otherEndIsSource ? target : source;\n        var selfEndModel = selfEnd.getModel();\n        // find the nearest visible ancestor\n        while (!selfEnd.isVisible()) {\n          var selfEndPId = selfEndModel.parentId,\n            selfEndCId = selfEndModel.comboId;\n          var selfEndParentId = selfEndPId || selfEndCId;\n          selfEnd = _this.findById(selfEndParentId);\n          if (!selfEnd || !selfEndParentId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          if (selfEndModel.comboId === comboModel.id || selfEndModel.parentId === comboModel.id) {\n            break; // if the next ancestor is the combo, break the while\n          }\n\n          selfEndModel = selfEnd.getModel();\n        }\n        var selfEndId = selfEndModel.id;\n        if (otherEndId) {\n          var vEdgeInfo = otherEndIsSource ? {\n            source: otherEndId,\n            target: selfEndId,\n            isVEdge: true,\n            size: size\n          } : {\n            source: selfEndId,\n            target: otherEndId,\n            isVEdge: true,\n            size: size\n          };\n          var vedgeId = \"\".concat(vEdgeInfo.source, \"-\").concat(vEdgeInfo.target);\n          // update the width of the virtual edges, which is the sum of merged actual edges\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n          if (addedVEdgeMap[vedgeId]) {\n            addedVEdgeMap[vedgeId].size += size;\n            return;\n          }\n          addedVEdgeMap[vedgeId] = vEdgeInfo;\n        }\n      }\n    });\n    this.addItems(Object.values(addedVEdgeMap).map(function (edgeInfo) {\n      return {\n        type: 'vedge',\n        model: edgeInfo\n      };\n    }), false);\n    this.emit('aftercollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n  };\n  AbstractGraph.prototype.collapseExpandCombo = function (combo, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n    if (!combo || combo.getType && combo.getType() !== 'combo') return;\n    var comboModel = combo.getModel();\n    // if one ancestor combo of the combo is collapsed, it should not be collapsed or expanded\n    var parentItem = this.findById(comboModel.parentId);\n    while (parentItem) {\n      var parentModel = parentItem.getModel();\n      if (parentModel.collapsed) {\n        console.warn(\"Fail to expand the combo since it's ancestor combo is collapsed.\");\n        parentItem = undefined;\n        return;\n      }\n      parentItem = this.findById(parentModel.parentId);\n    }\n    var collapsed = comboModel.collapsed;\n    // 该群组已经处于收起状态，需要展开\n    if (collapsed) {\n      this.expandCombo(combo, stack);\n    } else {\n      this.collapseCombo(combo, stack);\n    }\n    this.updateCombo(combo);\n  };\n  /**\n   * 获取节点所有的邻居节点\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @returns {INode[]}\n   * @memberof IAbstractGraph\n   */\n  AbstractGraph.prototype.getNeighbors = function (node, type) {\n    var item = node;\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n    return item.getNeighbors(type);\n  };\n  /**\n   * 获取 node 的度数\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @param {('in' | 'out' | 'total' | 'all' | undefined)} 度数类型，in 入度，out 出度，total 总度数，all 返回三种类型度数的对象\n   * @returns {Number | Object} 该节点的度数\n   * @memberof IAbstractGraph\n   */\n  AbstractGraph.prototype.getNodeDegree = function (node, type, refresh) {\n    if (type === void 0) {\n      type = undefined;\n    }\n    if (refresh === void 0) {\n      refresh = false;\n    }\n    var item = node;\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n    var degrees = this.get('degrees');\n    if (!degrees || refresh) {\n      degrees = getDegree(this.save());\n      this.set('degrees', degrees);\n    }\n    var nodeDegrees = degrees[item.getID()];\n    var res = 0;\n    // 如果是通过 addItem 后面新增加的节点，此时它的所有度数都为 0\n    if (!nodeDegrees) {\n      return 0;\n    }\n    switch (type) {\n      case 'in':\n        res = nodeDegrees.inDegree;\n        break;\n      case 'out':\n        res = nodeDegrees.outDegree;\n        break;\n      case 'all':\n        res = nodeDegrees;\n        break;\n      default:\n        res = nodeDegrees.degree;\n        break;\n    }\n    return res;\n  };\n  AbstractGraph.prototype.getUndoStack = function () {\n    return this.undoStack;\n  };\n  AbstractGraph.prototype.getRedoStack = function () {\n    return this.redoStack;\n  };\n  /**\n   * 获取 undo 和 redo 栈的数据\n   */\n  AbstractGraph.prototype.getStackData = function () {\n    if (!this.get('enabledStack')) {\n      return null;\n    }\n    return {\n      undoStack: this.undoStack.toArray(),\n      redoStack: this.redoStack.toArray()\n    };\n  };\n  /**\n   * 清空 undo stack & redo stack\n   */\n  AbstractGraph.prototype.clearStack = function () {\n    if (this.get('enabledStack')) {\n      this.undoStack.clear();\n      this.redoStack.clear();\n      this.emit('stackchange', {\n        undoStack: this.undoStack,\n        redoStack: this.redoStack\n      });\n    }\n  };\n  /**\n   * 将操作类型和操作数据入栈\n   * @param action 操作类型\n   * @param data 入栈的数据\n   * @param stackType 栈的类型\n   */\n  AbstractGraph.prototype.pushStack = function (action, data, stackType) {\n    if (action === void 0) {\n      action = 'update';\n    }\n    if (stackType === void 0) {\n      stackType = 'undo';\n    }\n    if (!this.get('enabledStack')) {\n      console.warn('请先启用 undo & redo 功能，在实例化 Graph 时候配置 enabledStack: true !');\n      return;\n    }\n    var stackData = data ? clone(data) : {\n      before: {},\n      after: clone(this.save())\n    };\n    if (stackType === 'redo') {\n      this.redoStack.push({\n        action: action,\n        data: stackData\n      });\n    } else {\n      this.undoStack.push({\n        action: action,\n        data: stackData\n      });\n    }\n    this.emit('stackchange', {\n      action: action,\n      stackType: stackType,\n      undoStack: this.undoStack,\n      redoStack: this.redoStack\n    });\n  };\n  /**\n   * 获取邻接矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 邻接矩阵\n   * @memberof IAbstractGraph\n   */\n  AbstractGraph.prototype.getAdjMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n    return currentAdjMatrix;\n  };\n  /**\n   * 获取最短路径矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 最短路径矩阵\n   * @memberof IAbstractGraph\n   */\n  AbstractGraph.prototype.getShortestPathMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n    var currentShourtestPathMatrix = this.get('shortestPathMatrix');\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n    if (!currentShourtestPathMatrix || !cache) {\n      currentShourtestPathMatrix = floydWarshall(this.save(), directed);\n      this.set('shortestPathMatrix', currentShourtestPathMatrix);\n    }\n    return currentShourtestPathMatrix;\n  };\n  /**\n   * 重新定义监听函数，复写参数类型\n   */\n  AbstractGraph.prototype.on = function (eventName, callback, once) {\n    return _super.prototype.on.call(this, eventName, callback, once);\n  };\n  /**\n   * 销毁画布\n   */\n  AbstractGraph.prototype.destroy = function () {\n    var _a, _b, _c, _d, _e;\n    this.emit('beforedestroy');\n    this.clear();\n    // 清空栈数据\n    this.clearStack();\n    (_a = this.get('itemController')) === null || _a === void 0 ? void 0 : _a.destroy();\n    (_b = this.get('modeController')) === null || _b === void 0 ? void 0 : _b.destroy();\n    (_c = this.get('viewController')) === null || _c === void 0 ? void 0 : _c.destroy();\n    (_d = this.get('stateController')) === null || _d === void 0 ? void 0 : _d.destroy();\n    (_e = this.get('canvas')) === null || _e === void 0 ? void 0 : _e.destroy();\n    this.cfg = null;\n    this.destroyed = true;\n    this.redoStack = null;\n    this.undoStack = null;\n    this.emit('afterdestroy');\n  };\n  /**\n   * 创建凸包或凹包轮廓\n   * @param cfg HullCfg 轮廓配置项\n   */\n  AbstractGraph.prototype.createHull = function (cfg) {\n    if (!cfg.members || cfg.members.length < 1) {\n      console.warn('Create hull failed! The members is empty.');\n      return;\n    }\n    var parent = this.get('hullGroup');\n    var hullMap = this.get('hullMap');\n    if (!hullMap) {\n      hullMap = {};\n      this.set('hullMap', hullMap);\n    }\n    if (!parent || parent.get('destroyed')) {\n      parent = this.get('group').addGroup({\n        id: 'hullGroup'\n      });\n      parent.toBack();\n      this.set('hullGroup', parent);\n    }\n    if (hullMap[cfg.id]) {\n      console.warn('Existed hull id.');\n      return hullMap[cfg.id];\n    }\n    var group = parent.addGroup({\n      id: \"\".concat(cfg.id, \"-container\")\n    });\n    var hull = new Hull(this, __assign(__assign({}, cfg), {\n      group: group\n    }));\n    var hullId = hull.id;\n    hullMap[hullId] = hull;\n    return hull;\n  };\n  /**\n   * 获取当前 graph 中存在的包裹轮廓\n   * @return {[key: string]: Hull} Hull 的 map，hullId 对应的 hull 实例\n   */\n  AbstractGraph.prototype.getHulls = function () {\n    return this.get('hullMap');\n  };\n  /**\n   * 根据 hullId 获取对应的 hull\n   * @return Hull\n   */\n  AbstractGraph.prototype.getHullById = function (hullId) {\n    return this.get('hullMap')[hullId];\n  };\n  AbstractGraph.prototype.removeHull = function (hull) {\n    var _a;\n    var hullInstance;\n    if (isString(hull)) {\n      hullInstance = this.getHullById(hull);\n    } else {\n      hullInstance = hull;\n    }\n    (_a = this.get('hullMap')) === null || _a === void 0 ? true : delete _a[hullInstance.id];\n    hullInstance.destroy();\n  };\n  AbstractGraph.prototype.removeHulls = function () {\n    var hulls = this.getHulls();\n    if (!hulls || !Object.keys(hulls).length) return;\n    Object.keys(hulls).forEach(function (key) {\n      var hull = hulls[key];\n      hull.destroy();\n    });\n    this.set('hullMap', {});\n  };\n  return AbstractGraph;\n}(EventEmitter);\nexport default AbstractGraph;"],"mappings":"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A;IACjB,CAAC,CAAC;IACF,IAAI,CAAC3D,GAAG,CAAC,OAAO,EAAEgD,KAAK,CAAC;EAC1B,CAAC;EACD;EACAzD,aAAa,CAAC4C,SAAS,CAACP,aAAa,GAAG,YAAY;IAClD,OAAO;MACL;AACN;AACA;MACMiC,SAAS,EAAEC,SAAS;MACpB;AACN;AACA;AACA;MACMC,KAAK,EAAED,SAAS;MAChB;AACN;AACA;AACA;MACME,MAAM,EAAEF,SAAS;MACjB;AACN;AACA;AACA;MACMG,QAAQ,EAAE,QAAQ;MAClB;AACN;AACA;MACMC,KAAK,EAAE,CAAC,CAAC;MACT;AACN;AACA;MACMC,OAAO,EAAE,EAAE;MACX;AACN;AACA;MACMC,IAAI,EAAE,CAAC,CAAC;MACR;AACN;AACA;MACMC,cAAc,EAAE,EAAE;MAClB;AACN;AACA;MACMC,OAAO,EAAE,IAAI;MACb;AACN;AACA;MACMC,OAAO,EAAE,EAAE;MACX;AACN;AACA;MACMC,KAAK,EAAE,IAAI;MACX;AACN;AACA;MACMC,YAAY,EAAE,IAAI;MAClB;AACN;AACA;MACMC,QAAQ,EAAE,KAAK;MACf;AACN;AACA;MACMC,SAAS,EAAE,IAAI;MACf;AACN;AACA;MACMC,KAAK,EAAE,EAAE;MACT;AACN;AACA;MACMlE,KAAK,EAAE,EAAE;MACT;AACN;AACA;MACMmE,MAAM,EAAE,EAAE;MACV;AACN;AACA;MACMC,MAAM,EAAE,EAAE;MACV;AACN;AACA;MACMC,OAAO,EAAE,CAAC,CAAC;MACX;AACN;AACA;MACMC,UAAU,EAAE,KAAK;MACjB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACMC,WAAW,EAAE,CAAC,CAAC;MACf;AACN;AACA;MACMC,WAAW,EAAE,CAAC,CAAC;MACf;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACMC,eAAe,EAAE,CAAC,CAAC;MACnB;AACN;AACA;MACMC,eAAe,EAAE,CAAC,CAAC;MACnB;AACN;AACA;MACMC,MAAM,EAAE,C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"},"metadata":{},"sourceType":"module","externalDependencies":[]}