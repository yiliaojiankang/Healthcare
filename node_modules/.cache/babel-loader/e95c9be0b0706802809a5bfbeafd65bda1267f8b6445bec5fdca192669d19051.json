{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { getCoords } from '@turf/invariant';\nimport { flattenEach } from '@turf/meta';\nimport { geojsonRewind } from \"../utils/util\";\nfunction djb2hash(field) {\n  var str = field.toString();\n  var hash = 5381;\n  var i = str.length;\n  while (i) {\n    hash = hash * 33 ^ str.charCodeAt(--i);\n  }\n\n  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */\n  return hash >>> 0;\n}\nfunction getFeatureID(feature, key) {\n  if (key === undefined) {\n    return null;\n  }\n\n  // @ts-ignore\n  if (_typeof(feature.properties[key]) * 1 === 'number') {\n    // @ts-ignore\n    return feature.properties[key] * 1;\n  }\n  if (feature.properties && feature.properties[key]) {\n    // 根据 properties 要素的属性进行编码\n    return djb2hash(feature.properties[key] + '') % 1000019;\n  }\n  return null;\n}\nexport default function geoJSON(data, cfg) {\n  var resultData = [];\n  var featureKeys = {};\n  if (!data.features) {\n    data.features = [];\n    return {\n      dataArray: []\n    };\n  }\n  data.features = data.features.filter(function (item) {\n    var geometry = item.geometry;\n    return item != null && geometry && geometry.type && geometry.coordinates && geometry.coordinates.length > 0;\n  });\n  data = geojsonRewind(data);\n  if (data.features.length === 0) {\n    return {\n      dataArray: [],\n      featureKeys: featureKeys\n    };\n  }\n\n  // multi feature 情况拆分\n  flattenEach(data, function (currentFeature, featureIndex) {\n    var featureId = getFeatureID(currentFeature, cfg === null || cfg === void 0 ? void 0 : cfg.featureId);\n    if (featureId === null) {\n      featureId = featureIndex;\n    }\n    var sortedID = featureId;\n    var coord = getCoords(currentFeature);\n    var dataItem = _objectSpread(_objectSpread({}, currentFeature.properties), {}, {\n      coordinates: coord,\n      _id: sortedID\n    });\n    resultData.push(dataItem);\n  });\n  return {\n    dataArray: resultData,\n    featureKeys: featureKeys\n  };\n}","map":{"version":3,"names":["_objectSpread","_typeof","getCoords","flattenEach","geojsonRewind","djb2hash","field","str","toString","hash","i","length","charCodeAt","getFeatureID","feature","key","undefined","properties","geoJSON","data","cfg","resultData","featureKeys","features","dataArray","filter","item","geometry","type","coordinates","currentFeature","featureIndex","featureId","sortedID","coord","dataItem","_id","push"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-source/es/parser/geojson.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { getCoords } from '@turf/invariant';\nimport { flattenEach } from '@turf/meta';\nimport { geojsonRewind } from \"../utils/util\";\nfunction djb2hash(field) {\n  var str = field.toString();\n  var hash = 5381;\n  var i = str.length;\n  while (i) {\n    hash = hash * 33 ^ str.charCodeAt(--i);\n  }\n\n  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */\n  return hash >>> 0;\n}\nfunction getFeatureID(feature, key) {\n  if (key === undefined) {\n    return null;\n  }\n\n  // @ts-ignore\n  if (_typeof(feature.properties[key]) * 1 === 'number') {\n    // @ts-ignore\n    return feature.properties[key] * 1;\n  }\n  if (feature.properties && feature.properties[key]) {\n    // 根据 properties 要素的属性进行编码\n    return djb2hash(feature.properties[key] + '') % 1000019;\n  }\n  return null;\n}\nexport default function geoJSON(data, cfg) {\n  var resultData = [];\n  var featureKeys = {};\n  if (!data.features) {\n    data.features = [];\n    return {\n      dataArray: []\n    };\n  }\n  data.features = data.features.filter(function (item) {\n    var geometry = item.geometry;\n    return item != null && geometry && geometry.type && geometry.coordinates && geometry.coordinates.length > 0;\n  });\n  data = geojsonRewind(data);\n  if (data.features.length === 0) {\n    return {\n      dataArray: [],\n      featureKeys: featureKeys\n    };\n  }\n\n  // multi feature 情况拆分\n  flattenEach(data, function (currentFeature, featureIndex) {\n    var featureId = getFeatureID(currentFeature, cfg === null || cfg === void 0 ? void 0 : cfg.featureId);\n    if (featureId === null) {\n      featureId = featureIndex;\n    }\n    var sortedID = featureId;\n    var coord = getCoords(currentFeature);\n    var dataItem = _objectSpread(_objectSpread({}, currentFeature.properties), {}, {\n      coordinates: coord,\n      _id: sortedID\n    });\n    resultData.push(dataItem);\n  });\n  return {\n    dataArray: resultData,\n    featureKeys: featureKeys\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}