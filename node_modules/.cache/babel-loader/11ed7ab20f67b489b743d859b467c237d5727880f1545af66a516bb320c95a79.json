{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { each, get, isArray, map, isNumber, isString } from '@antv/util';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nvar HALF_PI = Math.PI / 2;\n/**\n * 极坐标下的图形 label\n */\nvar PolarLabel = /** @class */function (_super) {\n  __extends(PolarLabel, _super);\n  function PolarLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @override\n   * @desc 获取 label offset\n   * polar & theta coordinate support「string」type, should transform to 「number」\n   */\n  PolarLabel.prototype.getLabelOffset = function (offset) {\n    var coordinate = this.getCoordinate();\n    var actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } else if (isString(offset) && offset.indexOf('%') !== -1) {\n      var r = coordinate.getRadius();\n      if (coordinate.innerRadius > 0) {\n        r = r * (1 - coordinate.innerRadius);\n      }\n      actualOffset = parseFloat(offset) * 0.01 * r;\n    }\n    return actualOffset;\n  };\n  /**\n   * @override\n   * 获取 labelItems, 增加切片 percent\n   * @param mapppingArray\n   */\n  PolarLabel.prototype.getLabelItems = function (mapppingArray) {\n    var items = _super.prototype.getLabelItems.call(this, mapppingArray);\n    var yScale = this.geometry.getYScale();\n    return map(items, function (item) {\n      if (item && yScale) {\n        var percent = yScale.scale(get(item.data, yScale.field));\n        return __assign(__assign({}, item), {\n          percent: percent\n        });\n      }\n      return item;\n    });\n  };\n  /**\n   * @override\n   * 获取文本的对齐方式\n   * @param point\n   */\n  PolarLabel.prototype.getLabelAlign = function (point) {\n    var coordinate = this.getCoordinate();\n    var align;\n    if (point.labelEmit) {\n      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n    } else if (!coordinate.isTransposed) {\n      align = 'center';\n    } else {\n      var center = coordinate.getCenter();\n      var offset = point.offset;\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        align = offset > 0 ? 'left' : 'right';\n      } else {\n        align = offset > 0 ? 'right' : 'left';\n      }\n    }\n    return align;\n  };\n  /**\n   * @override\n   * 获取 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   */\n  PolarLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n    var factor = 1;\n    var arcPoint;\n    var content = labelCfg.content[index];\n    if (this.isToMiddle(mappingData)) {\n      arcPoint = this.getMiddlePoint(mappingData.points);\n    } else {\n      if (labelCfg.content.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n      arcPoint = this.getArcPoint(mappingData, index);\n    }\n    var offset = labelCfg.offset * factor;\n    var middleAngle = this.getPointAngle(arcPoint);\n    var isLabelEmit = labelCfg.labelEmit;\n    var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n    if (labelPositionCfg.r === 0) {\n      // 如果文本位置位于圆心，则不展示\n      labelPositionCfg.content = '';\n    } else {\n      labelPositionCfg.content = content;\n      labelPositionCfg.angle = middleAngle;\n      labelPositionCfg.color = mappingData.color;\n    }\n    labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;\n    labelPositionCfg.start = {\n      x: arcPoint.x,\n      y: arcPoint.y\n    };\n    return labelPositionCfg;\n  };\n  /**\n   * 获取圆弧的位置\n   */\n  PolarLabel.prototype.getArcPoint = function (mappingData, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n    if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n      return {\n        x: mappingData.x,\n        y: mappingData.y\n      };\n    }\n    return {\n      x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n      y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y\n    };\n  };\n  /**\n   * 计算坐标线点在极坐标系下角度\n   * @param point\n   */\n  PolarLabel.prototype.getPointAngle = function (point) {\n    return getAngleByPoint(this.getCoordinate(), point);\n  };\n  /**\n   * 获取坐标点与圆心形成的圆的位置信息\n   * @param angle\n   * @param offset\n   * @param point\n   * @param isLabelEmit\n   */\n  PolarLabel.prototype.getCirclePoint = function (angle, offset, point, isLabelEmit) {\n    var coordinate = this.getCoordinate();\n    var center = coordinate.getCenter();\n    var r = getDistanceToCenter(coordinate, point);\n    if (r === 0) {\n      return __assign(__assign({}, center), {\n        r: r\n      });\n    }\n    var labelAngle = angle;\n    if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n      var appendAngle = Math.asin(offset / (2 * r));\n      labelAngle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n    return {\n      x: center.x + r * Math.cos(labelAngle),\n      y: center.y + r * Math.sin(labelAngle),\n      r: r\n    };\n  };\n  /**\n   * 获取 label 的旋转角度\n   * @param angle\n   * @param offset\n   * @param isLabelEmit\n   */\n  PolarLabel.prototype.getLabelRotate = function (angle, offset, isLabelEmit) {\n    var rotate = angle + HALF_PI;\n    if (isLabelEmit) {\n      rotate -= HALF_PI;\n    }\n    if (rotate) {\n      if (rotate > HALF_PI) {\n        rotate = rotate - Math.PI;\n      } else if (rotate < -HALF_PI) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  };\n  // 获取中心的位置\n  PolarLabel.prototype.getMiddlePoint = function (points) {\n    var coordinate = this.getCoordinate();\n    var count = points.length;\n    var middlePoint = {\n      x: 0,\n      y: 0\n    };\n    each(points, function (point) {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n    middlePoint = coordinate.convert(middlePoint);\n    return middlePoint;\n  };\n  // 是否居中\n  PolarLabel.prototype.isToMiddle = function (mappingData) {\n    return mappingData.x.length > 2;\n  };\n  return PolarLabel;\n}(GeometryLabel);\nexport default PolarLabel;","map":{"version":3,"names":["each","get","isArray","map","isNumber","isString","getDistanceToCenter","getAngleByPoint","GeometryLabel","HALF_PI","Math","PI","PolarLabel","_super","__extends","prototype","getLabelOffset","offset","coordinate","getCoordinate","actualOffset","indexOf","r","getRadius","innerRadius","parseFloat","getLabelItems","mapppingArray","items","call","yScale","geometry","getYScale","item","percent","scale","data","field","__assign","getLabelAlign","point","align","labelEmit","angle","isTransposed","center","getCenter","abs","x","getLabelPoint","labelCfg","mappingData","index","factor","arcPoint","content","isToMiddle","getMiddlePoint","points","length","getArcPoint","middleAngle","getPointAngle","isLabelEmit","labelPositionCfg","getCirclePoint","color","rotate","autoRotate","getLabelRotate","start","y","labelAngle","appendAngle","asin","cos","sin","count","middlePoint","convert"],"sources":["../../../src/geometry/label/polar.ts"],"sourcesContent":["import { each, get, isArray, map, isNumber, isString } from '@antv/util';\nimport { MappingDatum, Point } from '../../interface';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nimport { LabelCfg, LabelItem, PolarLabelItem, LabelPointCfg, Writeable } from './interface';\n\nconst HALF_PI = Math.PI / 2;\n\n/**\n * 极坐标下的图形 label\n */\nexport default class PolarLabel extends GeometryLabel {\n  /**\n   * @override\n   * @desc 获取 label offset\n   * polar & theta coordinate support「string」type, should transform to 「number」\n   */\n  protected getLabelOffset(offset: number | string): number {\n    const coordinate = this.getCoordinate();\n    let actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } else if (isString(offset) && offset.indexOf('%') !== -1) {\n      let r = coordinate.getRadius();\n      if (coordinate.innerRadius > 0) {\n        r = r * (1 - coordinate.innerRadius);\n      }\n      actualOffset = parseFloat(offset) * 0.01 * r;\n    }\n\n    return actualOffset;\n  }\n\n  /**\n   * @override\n   * 获取 labelItems, 增加切片 percent\n   * @param mapppingArray\n   */\n  public getLabelItems(mapppingArray: MappingDatum[]): PolarLabelItem[] {\n    const items = super.getLabelItems(mapppingArray);\n    const yScale = this.geometry.getYScale();\n\n    return map(items, (item) => {\n      if (item && yScale) {\n        const percent = yScale.scale(get(item.data, yScale.field));\n        return { ...item, percent };\n      }\n      return item;\n    });\n  }\n  /**\n   * @override\n   * 获取文本的对齐方式\n   * @param point\n   */\n  protected getLabelAlign(point: LabelItem) {\n    const coordinate = this.getCoordinate();\n    let align;\n    if (point.labelEmit) {\n      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n    } else if (!coordinate.isTransposed) {\n      align = 'center';\n    } else {\n      const center = coordinate.getCenter();\n      const offset = point.offset;\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        align = offset > 0 ? 'left' : 'right';\n      } else {\n        align = offset > 0 ? 'right' : 'left';\n      }\n    }\n    return align;\n  }\n\n  /**\n   * @override\n   * 获取 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    let factor = 1;\n    let arcPoint;\n    const content = labelCfg.content[index];\n    if (this.isToMiddle(mappingData)) {\n      arcPoint = this.getMiddlePoint(mappingData.points as Point[]);\n    } else {\n      if (labelCfg.content.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n      arcPoint = this.getArcPoint(mappingData, index);\n    }\n\n    const offset = labelCfg.offset * factor;\n    const middleAngle = this.getPointAngle(arcPoint);\n    const isLabelEmit = labelCfg.labelEmit;\n    const labelPositionCfg: Writeable<LabelPointCfg> = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n    if (labelPositionCfg.r === 0) {\n      // 如果文本位置位于圆心，则不展示\n      labelPositionCfg.content = '';\n    } else {\n      labelPositionCfg.content = content;\n      labelPositionCfg.angle = middleAngle;\n      labelPositionCfg.color = mappingData.color;\n    }\n\n    labelPositionCfg.rotate = labelCfg.autoRotate\n      ? this.getLabelRotate(middleAngle, offset, isLabelEmit)\n      : labelCfg.rotate;\n    labelPositionCfg.start = {\n      x: arcPoint.x,\n      y: arcPoint.y,\n    };\n    return labelPositionCfg;\n  }\n\n  /**\n   * 获取圆弧的位置\n   */\n  protected getArcPoint(mappingData: MappingDatum, index: number = 0): Point {\n    if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n      return {\n        x: mappingData.x,\n        y: mappingData.y,\n      };\n    }\n\n    return {\n      x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n      y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y,\n    };\n  }\n\n  /**\n   * 计算坐标线点在极坐标系下角度\n   * @param point\n   */\n  protected getPointAngle(point: Point): number {\n    return getAngleByPoint(this.getCoordinate(), point);\n  }\n\n  /**\n   * 获取坐标点与圆心形成的圆的位置信息\n   * @param angle\n   * @param offset\n   * @param point\n   * @param isLabelEmit\n   */\n  protected getCirclePoint(angle: number, offset: number, point: Point, isLabelEmit: boolean) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n    let r = getDistanceToCenter(coordinate, point);\n    if (r === 0) {\n      return {\n        ...center,\n        r,\n      };\n    }\n\n    let labelAngle = angle;\n    if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n      const appendAngle = Math.asin(offset / (2 * r));\n      labelAngle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n\n    return {\n      x: center.x + r * Math.cos(labelAngle),\n      y: center.y + r * Math.sin(labelAngle),\n      r,\n    };\n  }\n\n  /**\n   * 获取 label 的旋转角度\n   * @param angle\n   * @param offset\n   * @param isLabelEmit\n   */\n  protected getLabelRotate(angle: number, offset: number, isLabelEmit: boolean) {\n    let rotate = angle + HALF_PI;\n    if (isLabelEmit) {\n      rotate -= HALF_PI;\n    }\n    if (rotate) {\n      if (rotate > HALF_PI) {\n        rotate = rotate - Math.PI;\n      } else if (rotate < -HALF_PI) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  }\n\n  // 获取中心的位置\n  private getMiddlePoint(points: Point[]) {\n    const coordinate = this.getCoordinate();\n    const count = points.length;\n    let middlePoint = {\n      x: 0,\n      y: 0,\n    };\n    each(points, (point: Point) => {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n\n    middlePoint = coordinate.convert(middlePoint);\n    return middlePoint;\n  }\n\n  // 是否居中\n  private isToMiddle(mappingData: MappingDatum) {\n    return (mappingData.x as number[]).length > 2;\n  }\n}\n"],"mappings":";AAAA,SAASA,IAAI,EAAEC,GAAG,EAAEC,OAAO,EAAEC,GAAG,EAAEC,QAAQ,EAAEC,QAAQ,QAAQ,YAAY;AAExE,SAASC,mBAAmB,QAAQ,uBAAuB;AAC3D,SAASC,eAAe,QAAQ,uBAAuB;AACvD,OAAOC,aAAa,MAAM,QAAQ;AAGlC,IAAMC,OAAO,GAAGC,IAAI,CAACC,EAAE,GAAG,CAAC;AAE3B;;;AAGA,IAAAC,UAAA,0BAAAC,MAAA;EAAwCC,SAAA,CAAAF,UAAA,EAAAC,MAAA;EAAxC,SAAAD,WAAA;;EAoNA;EAnNE;;;;;EAKUA,UAAA,CAAAG,SAAA,CAAAC,cAAc,GAAxB,UAAyBC,MAAuB;IAC9C,IAAMC,UAAU,GAAG,IAAI,CAACC,aAAa,EAAE;IACvC,IAAIC,YAAY,GAAG,CAAC;IACpB,IAAIhB,QAAQ,CAACa,MAAM,CAAC,EAAE;MACpBG,YAAY,GAAGH,MAAM;KACtB,MAAM,IAAIZ,QAAQ,CAACY,MAAM,CAAC,IAAIA,MAAM,CAACI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;MACzD,IAAIC,CAAC,GAAGJ,UAAU,CAACK,SAAS,EAAE;MAC9B,IAAIL,UAAU,CAACM,WAAW,GAAG,CAAC,EAAE;QAC9BF,CAAC,GAAGA,CAAC,IAAI,CAAC,GAAGJ,UAAU,CAACM,WAAW,CAAC;;MAEtCJ,YAAY,GAAGK,UAAU,CAACR,MAAM,CAAC,GAAG,IAAI,GAAGK,CAAC;;IAG9C,OAAOF,YAAY;EACrB,CAAC;EAED;;;;;EAKOR,UAAA,CAAAG,SAAA,CAAAW,aAAa,GAApB,UAAqBC,aAA6B;IAChD,IAAMC,KAAK,GAAGf,MAAA,CAAAE,SAAA,CAAMW,aAAa,CAAAG,IAAA,OAACF,aAAa,CAAC;IAChD,IAAMG,MAAM,GAAG,IAAI,CAACC,QAAQ,CAACC,SAAS,EAAE;IAExC,OAAO7B,GAAG,CAACyB,KAAK,EAAE,UAACK,IAAI;MACrB,IAAIA,IAAI,IAAIH,MAAM,EAAE;QAClB,IAAMI,OAAO,GAAGJ,MAAM,CAACK,KAAK,CAAClC,GAAG,CAACgC,IAAI,CAACG,IAAI,EAAEN,MAAM,CAACO,KAAK,CAAC,CAAC;QAC1D,OAAAC,QAAA,CAAAA,QAAA,KAAYL,IAAI;UAAEC,OAAO,EAAAA;QAAA;;MAE3B,OAAOD,IAAI;IACb,CAAC,CAAC;EACJ,CAAC;EACD;;;;;EAKUrB,UAAA,CAAAG,SAAA,CAAAwB,aAAa,GAAvB,UAAwBC,KAAgB;IACtC,IAAMtB,UAAU,GAAG,IAAI,CAACC,aAAa,EAAE;IACvC,IAAIsB,KAAK;IACT,IAAID,KAAK,CAACE,SAAS,EAAE;MACnBD,KAAK,GAAGD,KAAK,CAACG,KAAK,IAAIjC,IAAI,CAACC,EAAE,GAAG,CAAC,IAAI6B,KAAK,CAACG,KAAK,IAAI,CAACjC,IAAI,CAACC,EAAE,GAAG,CAAC,GAAG,MAAM,GAAG,OAAO;KACrF,MAAM,IAAI,CAACO,UAAU,CAAC0B,YAAY,EAAE;MACnCH,KAAK,GAAG,QAAQ;KACjB,MAAM;MACL,IAAMI,MAAM,GAAG3B,UAAU,CAAC4B,SAAS,EAAE;MACrC,IAAM7B,MAAM,GAAGuB,KAAK,CAACvB,MAAM;MAC3B,IAAIP,IAAI,CAACqC,GAAG,CAACP,KAAK,CAACQ,CAAC,GAAGH,MAAM,CAACG,CAAC,CAAC,GAAG,CAAC,EAAE;QACpCP,KAAK,GAAG,QAAQ;OACjB,MAAM,IAAID,KAAK,CAACG,KAAK,GAAGjC,IAAI,CAACC,EAAE,IAAI6B,KAAK,CAACG,KAAK,IAAI,CAAC,EAAE;QACpDF,KAAK,GAAGxB,MAAM,GAAG,CAAC,GAAG,MAAM,GAAG,OAAO;OACtC,MAAM;QACLwB,KAAK,GAAGxB,MAAM,GAAG,CAAC,GAAG,OAAO,GAAG,MAAM;;;IAGzC,OAAOwB,KAAK;EACd,CAAC;EAED;;;;;;;EAOU7B,UAAA,CAAAG,SAAA,CAAAkC,aAAa,GAAvB,UAAwBC,QAAkB,EAAEC,WAAyB,EAAEC,KAAa;IAClF,IAAIC,MAAM,GAAG,CAAC;IACd,IAAIC,QAAQ;IACZ,IAAMC,OAAO,GAAGL,QAAQ,CAACK,OAAO,CAACH,KAAK,CAAC;IACvC,IAAI,IAAI,CAACI,UAAU,CAACL,WAAW,CAAC,EAAE;MAChCG,QAAQ,GAAG,IAAI,CAACG,cAAc,CAACN,WAAW,CAACO,MAAiB,CAAC;KAC9D,MAAM;MACL,IAAIR,QAAQ,CAACK,OAAO,CAACI,MAAM,KAAK,CAAC,IAAIP,KAAK,KAAK,CAAC,EAAE;QAChDA,KAAK,GAAG,CAAC;OACV,MAAM,IAAIA,KAAK,KAAK,CAAC,EAAE;QACtBC,MAAM,GAAG,CAAC,CAAC;;MAEbC,QAAQ,GAAG,IAAI,CAACM,WAAW,CAACT,WAAW,EAAEC,KAAK,CAAC;;IAGjD,IAAMnC,MAAM,GAAGiC,QAAQ,CAACjC,MAAM,GAAGoC,MAAM;IACvC,IAAMQ,WAAW,GAAG,IAAI,CAACC,aAAa,CAACR,QAAQ,CAAC;IAChD,IAAMS,WAAW,GAAGb,QAAQ,CAACR,SAAS;IACtC,IAAMsB,gBAAgB,GAA6B,IAAI,CAACC,cAAc,CAACJ,WAAW,EAAE5C,MAAM,EAAEqC,QAAQ,EAAES,WAAW,CAAC;IAClH,IAAIC,gBAAgB,CAAC1C,CAAC,KAAK,CAAC,EAAE;MAC5B;MACA0C,gBAAgB,CAACT,OAAO,GAAG,EAAE;KAC9B,MAAM;MACLS,gBAAgB,CAACT,OAAO,GAAGA,OAAO;MAClCS,gBAAgB,CAACrB,KAAK,GAAGkB,WAAW;MACpCG,gBAAgB,CAACE,KAAK,GAAGf,WAAW,CAACe,KAAK;;IAG5CF,gBAAgB,CAACG,MAAM,GAAGjB,QAAQ,CAACkB,UAAU,GACzC,IAAI,CAACC,cAAc,CAACR,WAAW,EAAE5C,MAAM,EAAE8C,WAAW,CAAC,GACrDb,QAAQ,CAACiB,MAAM;IACnBH,gBAAgB,CAACM,KAAK,GAAG;MACvBtB,CAAC,EAAEM,QAAQ,CAACN,CAAC;MACbuB,CAAC,EAAEjB,QAAQ,CAACiB;KACb;IACD,OAAOP,gBAAgB;EACzB,CAAC;EAED;;;EAGUpD,UAAA,CAAAG,SAAA,CAAA6C,WAAW,GAArB,UAAsBT,WAAyB,EAAEC,KAAiB;IAAjB,IAAAA,KAAA;MAAAA,KAAA,IAAiB;IAAA;IAChE,IAAI,CAAClD,OAAO,CAACiD,WAAW,CAACH,CAAC,CAAC,IAAI,CAAC9C,OAAO,CAACiD,WAAW,CAACoB,CAAC,CAAC,EAAE;MACtD,OAAO;QACLvB,CAAC,EAAEG,WAAW,CAACH,CAAC;QAChBuB,CAAC,EAAEpB,WAAW,CAACoB;OAChB;;IAGH,OAAO;MACLvB,CAAC,EAAE9C,OAAO,CAACiD,WAAW,CAACH,CAAC,CAAC,GAAGG,WAAW,CAACH,CAAC,CAACI,KAAK,CAAC,GAAGD,WAAW,CAACH,CAAC;MAChEuB,CAAC,EAAErE,OAAO,CAACiD,WAAW,CAACoB,CAAC,CAAC,GAAGpB,WAAW,CAACoB,CAAC,CAACnB,KAAK,CAAC,GAAGD,WAAW,CAACoB;KAChE;EACH,CAAC;EAED;;;;EAIU3D,UAAA,CAAAG,SAAA,CAAA+C,aAAa,GAAvB,UAAwBtB,KAAY;IAClC,OAAOjC,eAAe,CAAC,IAAI,CAACY,aAAa,EAAE,EAAEqB,KAAK,CAAC;EACrD,CAAC;EAED;;;;;;;EAOU5B,UAAA,CAAAG,SAAA,CAAAkD,cAAc,GAAxB,UAAyBtB,KAAa,EAAE1B,MAAc,EAAEuB,KAAY,EAAEuB,WAAoB;IACxF,IAAM7C,UAAU,GAAG,IAAI,CAACC,aAAa,EAAE;IACvC,IAAM0B,MAAM,GAAG3B,UAAU,CAAC4B,SAAS,EAAE;IACrC,IAAIxB,CAAC,GAAGhB,mBAAmB,CAACY,UAAU,EAAEsB,KAAK,CAAC;IAC9C,IAAIlB,CAAC,KAAK,CAAC,EAAE;MACX,OAAAgB,QAAA,CAAAA,QAAA,KACKO,MAAM;QACTvB,CAAC,EAAAA;MAAA;;IAIL,IAAIkD,UAAU,GAAG7B,KAAK;IACtB,IAAIzB,UAAU,CAAC0B,YAAY,IAAItB,CAAC,GAAGL,MAAM,IAAI,CAAC8C,WAAW,EAAE;MACzD,IAAMU,WAAW,GAAG/D,IAAI,CAACgE,IAAI,CAACzD,MAAM,IAAI,CAAC,GAAGK,CAAC,CAAC,CAAC;MAC/CkD,UAAU,GAAG7B,KAAK,GAAG8B,WAAW,GAAG,CAAC;KACrC,MAAM;MACLnD,CAAC,GAAGA,CAAC,GAAGL,MAAM;;IAGhB,OAAO;MACL+B,CAAC,EAAEH,MAAM,CAACG,CAAC,GAAG1B,CAAC,GAAGZ,IAAI,CAACiE,GAAG,CAACH,UAAU,CAAC;MACtCD,CAAC,EAAE1B,MAAM,CAAC0B,CAAC,GAAGjD,CAAC,GAAGZ,IAAI,CAACkE,GAAG,CAACJ,UAAU,CAAC;MACtClD,CAAC,EAAAA;KACF;EACH,CAAC;EAED;;;;;;EAMUV,UAAA,CAAAG,SAAA,CAAAsD,cAAc,GAAxB,UAAyB1B,KAAa,EAAE1B,MAAc,EAAE8C,WAAoB;IAC1E,IAAII,MAAM,GAAGxB,KAAK,GAAGlC,OAAO;IAC5B,IAAIsD,WAAW,EAAE;MACfI,MAAM,IAAI1D,OAAO;;IAEnB,IAAI0D,MAAM,EAAE;MACV,IAAIA,MAAM,GAAG1D,OAAO,EAAE;QACpB0D,MAAM,GAAGA,MAAM,GAAGzD,IAAI,CAACC,EAAE;OAC1B,MAAM,IAAIwD,MAAM,GAAG,CAAC1D,OAAO,EAAE;QAC5B0D,MAAM,GAAGA,MAAM,GAAGzD,IAAI,CAACC,EAAE;;;IAG7B,OAAOwD,MAAM;EACf,CAAC;EAED;EACQvD,UAAA,CAAAG,SAAA,CAAA0C,cAAc,GAAtB,UAAuBC,MAAe;IACpC,IAAMxC,UAAU,GAAG,IAAI,CAACC,aAAa,EAAE;IACvC,IAAM0D,KAAK,GAAGnB,MAAM,CAACC,MAAM;IAC3B,IAAImB,WAAW,GAAG;MAChB9B,CAAC,EAAE,CAAC;MACJuB,CAAC,EAAE;KACJ;IACDvE,IAAI,CAAC0D,MAAM,EAAE,UAAClB,KAAY;MACxBsC,WAAW,CAAC9B,CAAC,IAAIR,KAAK,CAACQ,CAAC;MACxB8B,WAAW,CAACP,CAAC,IAAI/B,KAAK,CAAC+B,CAAC;IAC1B,CAAC,CAAC;IACFO,WAAW,CAAC9B,CAAC,IAAI6B,KAAK;IACtBC,WAAW,CAACP,CAAC,IAAIM,KAAK;IAEtBC,WAAW,GAAG5D,UAAU,CAAC6D,OAAO,CAACD,WAAW,CAAC;IAC7C,OAAOA,WAAW;EACpB,CAAC;EAED;EACQlE,UAAA,CAAAG,SAAA,CAAAyC,UAAU,GAAlB,UAAmBL,WAAyB;IAC1C,OAAQA,WAAW,CAACH,CAAc,CAACW,MAAM,GAAG,CAAC;EAC/C,CAAC;EACH,OAAA/C,UAAC;AAAD,CAAC,CApNuCJ,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}