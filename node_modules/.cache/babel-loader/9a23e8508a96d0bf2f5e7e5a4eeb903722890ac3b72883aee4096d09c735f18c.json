{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { nelderMead } from 'fmin';\nimport { distance, getCenter, intersectionArea } from './circleintersection';\nfunction circleMargin(current, interior, exterior) {\n  var margin = interior[0].radius - distance(interior[0], current),\n    i,\n    m;\n  for (i = 1; i < interior.length; ++i) {\n    m = interior[i].radius - distance(interior[i], current);\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  for (i = 0; i < exterior.length; ++i) {\n    m = distance(exterior[i], current) - exterior[i].radius;\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  return margin;\n}\n// compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\nexport function computeTextCentre(interior, exterior) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  var points = [];\n  var i;\n  for (i = 0; i < interior.length; ++i) {\n    var c = interior[i];\n    points.push({\n      x: c.x,\n      y: c.y\n    });\n    points.push({\n      x: c.x + c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x - c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x,\n      y: c.y + c.radius / 2\n    });\n    points.push({\n      x: c.x,\n      y: c.y - c.radius / 2\n    });\n  }\n  var initial = points[0],\n    margin = circleMargin(points[0], interior, exterior);\n  for (i = 1; i < points.length; ++i) {\n    var m = circleMargin(points[i], interior, exterior);\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  }\n  // maximize the margin numerically\n  var solution = nelderMead(function (p) {\n    return -1 * circleMargin({\n      x: p[0],\n      y: p[1]\n    }, interior, exterior);\n  }, [initial.x, initial.y], {\n    maxIterations: 500,\n    minErrorDelta: 1e-10\n  }).x;\n  var ret = {\n    x: solution[0],\n    y: solution[1]\n  };\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  var valid = true;\n  for (i = 0; i < interior.length; ++i) {\n    if (distance(ret, interior[i]) > interior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n  for (i = 0; i < exterior.length; ++i) {\n    if (distance(ret, exterior[i]) < exterior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n  if (!valid) {\n    if (interior.length == 1) {\n      ret = {\n        x: interior[0].x,\n        y: interior[0].y\n      };\n    } else {\n      var areaStats = {};\n      intersectionArea(interior, areaStats);\n      if (areaStats.arcs.length === 0) {\n        ret = {\n          x: 0,\n          y: -1000,\n          disjoint: true\n        };\n      } else if (areaStats.arcs.length == 1) {\n        ret = {\n          x: areaStats.arcs[0].circle.x,\n          y: areaStats.arcs[0].circle.y\n        };\n      } else if (exterior.length) {\n        // try again without other circles\n        ret = computeTextCentre(interior, []);\n      } else {\n        // take average of all the points in the intersection\n        // polygon. this should basically never happen\n        // and has some issues:\n        // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n        ret = getCenter(areaStats.arcs.map(function (a) {\n          return a.p1;\n        }));\n      }\n    }\n  }\n  return ret;\n}\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n  var ret = {},\n    circleids = [];\n  for (var circleid in circles) {\n    circleids.push(circleid);\n    ret[circleid] = [];\n  }\n  for (var i = 0; i < circleids.length; i++) {\n    var a = circles[circleids[i]];\n    for (var j = i + 1; j < circleids.length; ++j) {\n      var b = circles[circleids[j]],\n        d = distance(a, b);\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[circleids[j]].push(circleids[i]);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[circleids[i]].push(circleids[j]);\n      }\n    }\n  }\n  return ret;\n}\nexport function computeTextCentres(circles, areas) {\n  var ret = {},\n    overlapped = getOverlappingCircles(circles);\n  for (var i = 0; i < areas.length; ++i) {\n    var area = areas[i].sets,\n      areaids = {},\n      exclude = {};\n    for (var j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      var overlaps = overlapped[area[j]];\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (var k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n    var interior = [],\n      exterior = [];\n    for (var setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n    var centre = computeTextCentre(interior, exterior);\n    ret[area] = centre;\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n  return ret;\n}\n/**\n * 根据圆心(x, y) 半径 r 返回圆的绘制 path\n * @param x 圆心点 x\n * @param y 圆心点 y\n * @param r 圆的半径\n * @returns 圆的 path\n */\nexport function circlePath(x, y, r) {\n  var ret = [];\n  // ret.push('\\nM', x, y);\n  // ret.push('\\nm', -r, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n  var x0 = x - r;\n  var y0 = y;\n  ret.push('M', x0, y0);\n  ret.push('A', r, r, 0, 1, 0, x0 + 2 * r, y0);\n  ret.push('A', r, r, 0, 1, 0, x0, y0);\n  return ret.join(' ');\n}\n// inverse of the circlePath function, returns a circle object from an svg path\nexport function circleFromPath(path) {\n  var tokens = path.split(' ');\n  return {\n    x: parseFloat(tokens[1]),\n    y: parseFloat(tokens[2]),\n    radius: -parseFloat(tokens[4])\n  };\n}\n/** returns a svg path of the intersection area of a bunch of circles */\nexport function intersectionAreaPath(circles) {\n  var stats = {};\n  intersectionArea(circles, stats);\n  var arcs = stats.arcs;\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  } else if (arcs.length == 1) {\n    var circle = arcs[0].circle;\n    return circlePath(circle.x, circle.y, circle.radius);\n  } else {\n    // draw path around arcs\n    var ret = ['\\nM', arcs[0].p2.x, arcs[0].p2.y];\n    for (var i = 0; i < arcs.length; ++i) {\n      var arc = arcs[i],\n        r = arc.circle.radius,\n        wide = arc.width > r;\n      ret.push('\\nA', r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);\n    }\n    return ret.join(' ');\n  }\n}","map":{"version":3,"names":["nelderMead","distance","getCenter","intersectionArea","circleMargin","current","interior","exterior","margin","radius","i","m","length","computeTextCentre","points","c","push","x","y","initial","solution","p","maxIterations","minErrorDelta","ret","valid","areaStats","arcs","disjoint","circle","map","a","p1","getOverlappingCircles","circles","circleids","circleid","j","b","d","computeTextCentres","areas","overlapped","area","sets","areaids","exclude","overlaps","k","setid","centre","size","console","log","circlePath","r","x0","y0","join","circleFromPath","path","tokens","split","parseFloat","intersectionAreaPath","stats","p2","arc","wide","width"],"sources":["../../../../src/plots/venn/layout/diagram.ts"],"sourcesContent":["import { nelderMead } from 'fmin';\nimport { distance, getCenter, intersectionArea } from './circleintersection';\n\nfunction circleMargin(current, interior, exterior) {\n  let margin = interior[0].radius - distance(interior[0], current),\n    i,\n    m;\n  for (i = 1; i < interior.length; ++i) {\n    m = interior[i].radius - distance(interior[i], current);\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    m = distance(exterior[i], current) - exterior[i].radius;\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  return margin;\n}\n\n// compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\nexport function computeTextCentre(interior, exterior) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  const points = [];\n  let i;\n  for (i = 0; i < interior.length; ++i) {\n    const c = interior[i];\n    points.push({ x: c.x, y: c.y });\n    points.push({ x: c.x + c.radius / 2, y: c.y });\n    points.push({ x: c.x - c.radius / 2, y: c.y });\n    points.push({ x: c.x, y: c.y + c.radius / 2 });\n    points.push({ x: c.x, y: c.y - c.radius / 2 });\n  }\n  let initial = points[0],\n    margin = circleMargin(points[0], interior, exterior);\n  for (i = 1; i < points.length; ++i) {\n    const m = circleMargin(points[i], interior, exterior);\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  }\n\n  // maximize the margin numerically\n  const solution = nelderMead(\n    function (p) {\n      return -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior);\n    },\n    [initial.x, initial.y],\n    { maxIterations: 500, minErrorDelta: 1e-10 }\n  ).x;\n  let ret: any = { x: solution[0], y: solution[1] };\n\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  let valid = true;\n  for (i = 0; i < interior.length; ++i) {\n    if (distance(ret, interior[i]) > interior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    if (distance(ret, exterior[i]) < exterior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  if (!valid) {\n    if (interior.length == 1) {\n      ret = { x: interior[0].x, y: interior[0].y };\n    } else {\n      const areaStats: any = {};\n      intersectionArea(interior, areaStats);\n\n      if (areaStats.arcs.length === 0) {\n        ret = { x: 0, y: -1000, disjoint: true };\n      } else if (areaStats.arcs.length == 1) {\n        ret = { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };\n      } else if (exterior.length) {\n        // try again without other circles\n        ret = computeTextCentre(interior, []);\n      } else {\n        // take average of all the points in the intersection\n        // polygon. this should basically never happen\n        // and has some issues:\n        // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n        ret = getCenter(\n          areaStats.arcs.map(function (a) {\n            return a.p1;\n          })\n        );\n      }\n    }\n  }\n\n  return ret;\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n  const ret = {},\n    circleids = [];\n  for (const circleid in circles) {\n    circleids.push(circleid);\n    ret[circleid] = [];\n  }\n  for (let i = 0; i < circleids.length; i++) {\n    const a = circles[circleids[i]];\n    for (let j = i + 1; j < circleids.length; ++j) {\n      const b = circles[circleids[j]],\n        d = distance(a, b);\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[circleids[j]].push(circleids[i]);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[circleids[i]].push(circleids[j]);\n      }\n    }\n  }\n  return ret;\n}\n\nexport function computeTextCentres(circles, areas) {\n  const ret = {},\n    overlapped = getOverlappingCircles(circles);\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i].sets,\n      areaids = {},\n      exclude = {};\n    for (let j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      const overlaps = overlapped[area[j]];\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (let k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n\n    const interior = [],\n      exterior = [];\n    for (const setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n    const centre = computeTextCentre(interior, exterior);\n    ret[area] = centre;\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n  return ret;\n}\n\n/**\n * 根据圆心(x, y) 半径 r 返回圆的绘制 path\n * @param x 圆心点 x\n * @param y 圆心点 y\n * @param r 圆的半径\n * @returns 圆的 path\n */\nexport function circlePath(x, y, r) {\n  const ret = [];\n  // ret.push('\\nM', x, y);\n  // ret.push('\\nm', -r, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n  const x0 = x - r;\n  const y0 = y;\n  ret.push('M', x0, y0);\n  ret.push('A', r, r, 0, 1, 0, x0 + 2 * r, y0);\n  ret.push('A', r, r, 0, 1, 0, x0, y0);\n\n  return ret.join(' ');\n}\n\n// inverse of the circlePath function, returns a circle object from an svg path\nexport function circleFromPath(path) {\n  const tokens = path.split(' ');\n  return { x: parseFloat(tokens[1]), y: parseFloat(tokens[2]), radius: -parseFloat(tokens[4]) };\n}\n\n/** returns a svg path of the intersection area of a bunch of circles */\nexport function intersectionAreaPath(circles) {\n  const stats: any = {};\n  intersectionArea(circles, stats);\n  const arcs = stats.arcs;\n\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  } else if (arcs.length == 1) {\n    const circle = arcs[0].circle;\n    return circlePath(circle.x, circle.y, circle.radius);\n  } else {\n    // draw path around arcs\n    const ret = ['\\nM', arcs[0].p2.x, arcs[0].p2.y];\n    for (let i = 0; i < arcs.length; ++i) {\n      const arc = arcs[i],\n        r = arc.circle.radius,\n        wide = arc.width > r;\n      ret.push('\\nA', r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);\n    }\n    return ret.join(' ');\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}