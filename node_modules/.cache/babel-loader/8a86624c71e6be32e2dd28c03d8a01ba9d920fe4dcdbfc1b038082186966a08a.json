{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport * as pathUtil from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { map, each, isEqual, head, isArray } from '@antv/util';\n/**\n * 点数组转 path\n * @param points\n */\nfunction pointsToPath(points) {\n  return map(points, function (p, idx) {\n    var command = idx === 0 ? 'M' : 'L';\n    var x = p[0],\n      y = p[1];\n    return [command, x, y];\n  });\n}\n/**\n * 将点连接成路径 path\n * @param points\n */\nexport function getLinePath(points) {\n  return pointsToPath(points);\n}\n/**\n * 将点连成平滑的曲线\n * @param points\n */\nexport function getSmoothLinePath(points) {\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points);\n  }\n  var data = [];\n  each(points, function (p) {\n    // 当前点和上一个点一样的时候，忽略掉\n    if (!isEqual(p, data.slice(data.length - 2))) {\n      data.push(p[0], p[1]);\n    }\n  });\n  var path = pathUtil.catmullRom2Bezier(data, false);\n  var _a = head(points),\n    x = _a[0],\n    y = _a[1];\n  path.unshift(['M', x, y]);\n  return path;\n}\n/**\n * 将数据转成 path，利用 scale 的归一化能力\n * @param data\n * @param width\n * @param height\n * @param smooth\n */\nexport function dataToPath(data, width, height, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  }\n  // 利用 scale 来获取 y 上的映射\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\nexport function dataToRectPath(data, width, height, barWidth) {\n  if (barWidth === void 0) {\n    barWidth = 5;\n  }\n  // 利用 scale 来获取 y 上的映射\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  var rectPoints = [];\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    var param = {\n      x: point[0],\n      y: point[1],\n      y0: height,\n      size: barWidth\n    };\n    var rectPoint = getRectPoints(param);\n    rectPoints.push.apply(rectPoints, rectPoint);\n  }\n  return getRectPath(rectPoints);\n}\n/**\n * 获得 area 面积的横向连接线的 px 位置\n * @param data\n * @param width\n * @param height\n */\nexport function getAreaLineY(data, height) {\n  var y = new Linear({\n    values: data\n  });\n  var lineY = Math.max(0, y.min);\n  return height - y.scale(lineY) * height;\n}\n/**\n * 线 path 转 area path\n * @param path\n * @param width\n * @param height\n */\nexport function linePathToAreaPath(path, width, height, data) {\n  var areaPath = __spreadArray([], path, true);\n  var lineYPx = getAreaLineY(data, height);\n  areaPath.push(['L', width, lineYPx]);\n  areaPath.push(['L', 0, lineYPx]);\n  areaPath.push(['Z']);\n  return areaPath;\n}\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @returns rect points 返回矩形四个顶点信息\n */\nexport function getRectPoints(pointInfo) {\n  var x = pointInfo.x,\n    y = pointInfo.y,\n    y0 = pointInfo.y0,\n    size = pointInfo.size;\n  // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n  var yMin;\n  var yMax;\n  if (isArray(y)) {\n    yMin = y[0], yMax = y[1];\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n  var xMin;\n  var xMax;\n  if (isArray(x)) {\n    xMin = x[0], xMax = x[1];\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n  var points = [{\n    x: xMin,\n    y: yMin\n  }, {\n    x: xMin,\n    y: yMax\n  }];\n  // 矩形的四个关键点，结构如下（左下角顺时针连接）\n  // 1 ---- 2\n  // |      |\n  // 0 ---- 3\n  points.push({\n    x: xMax,\n    y: yMax\n  }, {\n    x: xMax,\n    y: yMin\n  });\n  return points;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\nexport function getRectPath(points, isClosed) {\n  if (isClosed === void 0) {\n    isClosed = true;\n  }\n  var path = [];\n  var firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n  for (var i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  }\n  // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n    path.push(['z']);\n  }\n  return path;\n}","map":{"version":3,"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","pathUtil","Category","Linear","map","each","isEqual","head","isArray","pointsToPath","points","p","idx","command","x","y","getLinePath","getSmoothLinePath","data","push","path","catmullRom2Bezier","_a","unshift","dataToPath","width","height","smooth","values","v","scale","dataToRectPath","barWidth","rectPoints","point","param","y0","size","rectPoint","getRectPoints","apply","getRectPath","getAreaLineY","lineY","Math","max","min","linePathToAreaPath","areaPath","lineYPx","pointInfo","yMin","yMax","xMin","xMax","isClosed","firstPoint","len"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/g6-plugin/es/timeBar/path.js"],"sourcesContent":["var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport * as pathUtil from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { map, each, isEqual, head, isArray } from '@antv/util';\n/**\n * 点数组转 path\n * @param points\n */\nfunction pointsToPath(points) {\n  return map(points, function (p, idx) {\n    var command = idx === 0 ? 'M' : 'L';\n    var x = p[0],\n      y = p[1];\n    return [command, x, y];\n  });\n}\n/**\n * 将点连接成路径 path\n * @param points\n */\nexport function getLinePath(points) {\n  return pointsToPath(points);\n}\n/**\n * 将点连成平滑的曲线\n * @param points\n */\nexport function getSmoothLinePath(points) {\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points);\n  }\n  var data = [];\n  each(points, function (p) {\n    // 当前点和上一个点一样的时候，忽略掉\n    if (!isEqual(p, data.slice(data.length - 2))) {\n      data.push(p[0], p[1]);\n    }\n  });\n  var path = pathUtil.catmullRom2Bezier(data, false);\n  var _a = head(points),\n    x = _a[0],\n    y = _a[1];\n  path.unshift(['M', x, y]);\n  return path;\n}\n/**\n * 将数据转成 path，利用 scale 的归一化能力\n * @param data\n * @param width\n * @param height\n * @param smooth\n */\nexport function dataToPath(data, width, height, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  }\n  // 利用 scale 来获取 y 上的映射\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\nexport function dataToRectPath(data, width, height, barWidth) {\n  if (barWidth === void 0) {\n    barWidth = 5;\n  }\n  // 利用 scale 来获取 y 上的映射\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  var rectPoints = [];\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    var param = {\n      x: point[0],\n      y: point[1],\n      y0: height,\n      size: barWidth\n    };\n    var rectPoint = getRectPoints(param);\n    rectPoints.push.apply(rectPoints, rectPoint);\n  }\n  return getRectPath(rectPoints);\n}\n/**\n * 获得 area 面积的横向连接线的 px 位置\n * @param data\n * @param width\n * @param height\n */\nexport function getAreaLineY(data, height) {\n  var y = new Linear({\n    values: data\n  });\n  var lineY = Math.max(0, y.min);\n  return height - y.scale(lineY) * height;\n}\n/**\n * 线 path 转 area path\n * @param path\n * @param width\n * @param height\n */\nexport function linePathToAreaPath(path, width, height, data) {\n  var areaPath = __spreadArray([], path, true);\n  var lineYPx = getAreaLineY(data, height);\n  areaPath.push(['L', width, lineYPx]);\n  areaPath.push(['L', 0, lineYPx]);\n  areaPath.push(['Z']);\n  return areaPath;\n}\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @returns rect points 返回矩形四个顶点信息\n */\nexport function getRectPoints(pointInfo) {\n  var x = pointInfo.x,\n    y = pointInfo.y,\n    y0 = pointInfo.y0,\n    size = pointInfo.size;\n  // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n  var yMin;\n  var yMax;\n  if (isArray(y)) {\n    yMin = y[0], yMax = y[1];\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n  var xMin;\n  var xMax;\n  if (isArray(x)) {\n    xMin = x[0], xMax = x[1];\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n  var points = [{\n    x: xMin,\n    y: yMin\n  }, {\n    x: xMin,\n    y: yMax\n  }];\n  // 矩形的四个关键点，结构如下（左下角顺时针连接）\n  // 1 ---- 2\n  // |      |\n  // 0 ---- 3\n  points.push({\n    x: xMax,\n    y: yMax\n  }, {\n    x: xMax,\n    y: yMin\n  });\n  return points;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\nexport function getRectPath(points, isClosed) {\n  if (isClosed === void 0) {\n    isClosed = true;\n  }\n  var path = [];\n  var firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n  for (var i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  }\n  // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n    path.push(['z']);\n  }\n  return path;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}