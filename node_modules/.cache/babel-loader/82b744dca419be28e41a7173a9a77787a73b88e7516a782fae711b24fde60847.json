{"ast":null,"code":"import { each } from '@antv/util';\nvar MAX_TIMES = 100;\n/**\n * @ignore\n * Greedy 贪婪算法\n */\nvar Greedy = /** @class */function () {\n  function Greedy(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    this.bitmap = {};\n    var _a = cfg.xGap,\n      xGap = _a === void 0 ? 1 : _a,\n      _b = cfg.yGap,\n      yGap = _b === void 0 ? 8 : _b;\n    this.xGap = xGap;\n    this.yGap = yGap;\n  }\n  Greedy.prototype.hasGap = function (bbox) {\n    var hasGap = true;\n    var bitmap = this.bitmap;\n    var minX = Math.round(bbox.minX);\n    var maxX = Math.round(bbox.maxX);\n    var minY = Math.round(bbox.minY);\n    var maxY = Math.round(bbox.maxY);\n    for (var i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n        continue;\n      }\n      if (i === minX || i === maxX) {\n        for (var j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n    return hasGap;\n  };\n  Greedy.prototype.fillGap = function (bbox) {\n    var bitmap = this.bitmap;\n    var minX = Math.round(bbox.minX);\n    var maxX = Math.round(bbox.maxX);\n    var minY = Math.round(bbox.minY);\n    var maxY = Math.round(bbox.maxY);\n    // filling grid\n    for (var i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n      }\n    }\n    for (var i = minX; i <= maxX; i += this.xGap) {\n      for (var j = minY; j <= maxY; j += this.yGap) {\n        bitmap[i][j] = true;\n      }\n      bitmap[i][maxY] = true;\n    }\n    // filling y edges\n    if (this.yGap !== 1) {\n      for (var i = minY; i <= maxY; i += 1) {\n        bitmap[minX][i] = true;\n        bitmap[maxX][i] = true;\n      }\n    }\n    // filling x edges\n    if (this.xGap !== 1) {\n      for (var i = minX; i <= maxX; i += 1) {\n        bitmap[i][minY] = true;\n        bitmap[i][maxY] = true;\n      }\n    }\n  };\n  Greedy.prototype.destroy = function () {\n    this.bitmap = {};\n  };\n  return Greedy;\n}();\nfunction spiralFill(label, greedy, maxTimes) {\n  if (maxTimes === void 0) {\n    maxTimes = MAX_TIMES;\n  }\n  var dt = -1;\n  var _a = label.attr(),\n    x = _a.x,\n    y = _a.y;\n  var bbox = label.getCanvasBBox();\n  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  var dxdy;\n  var t = -dt;\n  var dx = 0;\n  var dy = 0;\n  var f = function (param) {\n    var nt = param * 0.1;\n    return [nt * Math.cos(nt), nt * Math.sin(nt)];\n  };\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n  var canFill = false;\n  var times = 0;\n  var accessedCache = {};\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {\n    dxdy = f(t += dt);\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n    if (!dx && !dy || accessedCache[\"\".concat(dx, \"-\").concat(dy)]) {\n      continue;\n    }\n    label.attr({\n      x: x + dx,\n      y: y + dy\n    });\n    if (dx + dy < 0) {\n      label.attr('textAlign', 'right');\n    }\n    times++;\n    if (greedy.hasGap(label.getCanvasBBox())) {\n      greedy.fillGap(label.getCanvasBBox());\n      canFill = true;\n      accessedCache[\"\".concat(dx, \"-\").concat(dy)] = true;\n      break;\n    }\n  }\n  return canFill;\n}\n/*\n *  根据如下规则尝试放置label\n *                5\n *        ------------------\n *        |    1   |   0   |\n *    8   —————————4————————   7\n *        |    2   |   3   |\n *        ——————————————————\n *                 6\n */\nfunction adjustLabelPosition(label, x, y, index) {\n  var _a = label.getCanvasBBox(),\n    width = _a.width,\n    height = _a.height;\n  var attrs = {\n    x: x,\n    y: y,\n    textAlign: 'center'\n  };\n  switch (index) {\n    case 0:\n      attrs.y -= height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 1:\n      attrs.y -= height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 2:\n      attrs.y += height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 3:\n      attrs.y += height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 5:\n      attrs.y -= height * 2 + 2;\n      break;\n    case 6:\n      attrs.y += height * 2 + 2;\n      break;\n    case 7:\n      attrs.x += width + 1;\n      attrs.textAlign = 'left';\n      break;\n    case 8:\n      attrs.x -= width + 1;\n      attrs.textAlign = 'right';\n      break;\n    default:\n      break;\n  }\n  label.attr(attrs);\n  return label.getCanvasBBox();\n}\n/**\n * @ignore\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function fixedOverlap(items, labels, shapes, region) {\n  var greedy = new Greedy();\n  each(labels, function (label) {\n    var labelShape = label.find(function (shape) {\n      return shape.get('type') === 'text';\n    });\n    if (!spiralFill(labelShape, greedy)) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}\n/**\n * @ignore\n * label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function overlap(items, labels, shapes, region) {\n  var greedy = new Greedy();\n  each(labels, function (label) {\n    var labelShape = label.find(function (shape) {\n      return shape.get('type') === 'text';\n    });\n    var _a = labelShape.attr(),\n      x = _a.x,\n      y = _a.y;\n    var canFill = false;\n    for (var i = 0; i <= 8; i++) {\n      var bbox = adjustLabelPosition(labelShape, x, y, i);\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n    if (!canFill) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}","map":{"version":3,"names":["each","MAX_TIMES","Greedy","cfg","bitmap","_a","xGap","_b","yGap","prototype","hasGap","bbox","minX","Math","round","maxX","minY","maxY","i","j","fillGap","destroy","spiralFill","label","greedy","maxTimes","dt","attr","x","y","getCanvasBBox","maxDelta","sqrt","width","height","dxdy","t","dx","dy","f","param","nt","cos","sin","canFill","times","accessedCache","min","abs","concat","adjustLabelPosition","index","attrs","textAlign","fixedOverlap","items","labels","shapes","region","labelShape","find","shape","get","remove","overlap"],"sources":["../../../../src/geometry/label/layout/overlap.ts"],"sourcesContent":["import { each } from '@antv/util';\nimport { BBox, IGroup, IShape } from '../../../dependents';\nimport { LabelItem } from '../interface';\n\nconst MAX_TIMES = 100;\n\n/** @ignore */\ninterface Bitmap {\n  [key: number]: {\n    [key: number]: boolean;\n  };\n}\n\n/** @ignore */\ninterface GreedyCfg {\n  readonly xGap?: number;\n  readonly yGap?: number;\n}\n\n/**\n * @ignore\n * Greedy 贪婪算法\n */\nclass Greedy {\n  public readonly xGap: number;\n  /** optimizing for text overlapping detection: use a min text height as gap */\n  public readonly yGap: number;\n\n  private bitmap: Bitmap = {};\n\n  constructor(cfg: GreedyCfg = {}) {\n    const { xGap = 1, yGap = 8 } = cfg;\n    this.xGap = xGap;\n    this.yGap = yGap;\n  }\n\n  public hasGap(bbox: BBox): boolean {\n    let hasGap = true;\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n        continue;\n      }\n      if (i === minX || i === maxX) {\n        for (let j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n    return hasGap;\n  }\n\n  public fillGap(bbox: BBox): void {\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    // filling grid\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n      }\n    }\n    for (let i = minX; i <= maxX; i += this.xGap) {\n      for (let j = minY; j <= maxY; j += this.yGap) {\n        bitmap[i][j] = true;\n      }\n      bitmap[i][maxY] = true;\n    }\n\n    // filling y edges\n    if (this.yGap !== 1) {\n      for (let i = minY; i <= maxY; i += 1) {\n        bitmap[minX][i] = true;\n        bitmap[maxX][i] = true;\n      }\n    }\n\n    // filling x edges\n    if (this.xGap !== 1) {\n      for (let i = minX; i <= maxX; i += 1) {\n        bitmap[i][minY] = true;\n        bitmap[i][maxY] = true;\n      }\n    }\n  }\n\n  public destroy(): void {\n    this.bitmap = {};\n  }\n}\n\nfunction spiralFill(label: IShape, greedy: Greedy, maxTimes: number = MAX_TIMES) {\n  const dt = -1;\n  const { x, y } = label.attr();\n  const bbox = label.getCanvasBBox();\n  const maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  let dxdy;\n  let t = -dt;\n  let dx = 0;\n  let dy = 0;\n  const f = (param: number) => {\n    const nt = param * 0.1;\n    return [nt * Math.cos(nt), nt * Math.sin(nt)];\n  };\n\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n  let canFill = false;\n  let times = 0;\n  const accessedCache = {};\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {\n    dxdy = f((t += dt));\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n    if ((!dx && !dy) || accessedCache[`${dx}-${dy}`]) {\n      continue;\n    }\n    label.attr({ x: x + dx, y: y + dy });\n    if (dx + dy < 0) {\n      label.attr('textAlign', 'right');\n    }\n    times++;\n    if (greedy.hasGap(label.getCanvasBBox())) {\n      greedy.fillGap(label.getCanvasBBox());\n      canFill = true;\n      accessedCache[`${dx}-${dy}`] = true;\n      break;\n    }\n  }\n  return canFill;\n}\n\n/*\n *  根据如下规则尝试放置label\n *                5\n *        ------------------\n *        |    1   |   0   |\n *    8   —————————4————————   7\n *        |    2   |   3   |\n *        ——————————————————\n *                 6\n */\nfunction adjustLabelPosition(label: IShape, x: number, y: number, index: number) {\n  const { width, height } = label.getCanvasBBox();\n  const attrs = {\n    x,\n    y,\n    textAlign: 'center',\n  };\n  switch (index) {\n    case 0:\n      attrs.y -= height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 1:\n      attrs.y -= height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 2:\n      attrs.y += height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 3:\n      attrs.y += height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 5:\n      attrs.y -= height * 2 + 2;\n      break;\n    case 6:\n      attrs.y += height * 2 + 2;\n      break;\n    case 7:\n      attrs.x += width + 1;\n      attrs.textAlign = 'left';\n      break;\n    case 8:\n      attrs.x -= width + 1;\n      attrs.textAlign = 'right';\n      break;\n    default:\n      break;\n  }\n  label.attr(attrs);\n  return label.getCanvasBBox();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function fixedOverlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    if (!spiralFill(labelShape, greedy)) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function overlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    const { x, y } = labelShape.attr();\n    let canFill = false;\n    for (let i = 0; i <= 8; i++) {\n      const bbox = adjustLabelPosition(labelShape, x, y, i);\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n    if (!canFill) {\n      label.remove(true);\n    }\n  });\n\n  greedy.destroy();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}