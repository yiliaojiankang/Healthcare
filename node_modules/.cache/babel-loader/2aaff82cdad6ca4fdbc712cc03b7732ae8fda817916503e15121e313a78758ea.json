{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @description Tarjan's algorithm for finding the strongly connected components of a graph.\n * @description https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @description.zh-CN Tarjan 算法用于找到图的强连通子图。\n * @param graph\n * @returns\n */\nvar tarjan = function tarjan(graph) {\n  var index = 0;\n  var stack = [];\n  var visited = new Map(); // node id -> { onStack, lowlink, index }\n\n  var results = [];\n  function dfs(v) {\n    var _graph$successors;\n    var entry = {\n      onStack: true,\n      lowlink: index,\n      index: index\n    };\n    visited.set(v, entry);\n    index += 1;\n    stack.push(v);\n    (_graph$successors = graph.successors(v)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function (w) {\n      var _visited$get;\n\n      // 如果 w 没有被访问过，则继续访问 w\n      if (!visited.has(w)) {\n        dfs(w);\n        var wEntry = visited.get(w);\n        entry.lowlink = Math.min(entry.lowlink, wEntry.lowlink); // 如果 w 在栈顶，则说明 w 和 v 不是强连通的\n      } else if ((_visited$get = visited.get(w)) === null || _visited$get === void 0 ? void 0 : _visited$get.onStack) {\n        var _wEntry = visited.get(w); // 如果 w 在栈中，则说明 w 在当前访问的路径上\n\n        entry.lowlink = Math.min(entry.lowlink, _wEntry.index);\n      }\n    }); // 如果 v 的 lowlink 不等于 v 的 index，则说明 v 和 v 的 lowlink 不是强连通的\n\n    if (entry.lowlink === entry.index) {\n      var cmpt = [];\n      var w;\n      do {\n        // 将 w 出栈，并将 w 的所有邻接点加入强连通子图\n        w = stack.pop();\n        var wEntry = visited.get(w);\n        wEntry.onStack = false;\n        cmpt.push(w);\n      } while (v !== w);\n      results.push(cmpt);\n    }\n  }\n  graph.nodes().forEach(function (v) {\n    if (!visited.has(v)) {\n      dfs(v);\n    }\n  });\n  return results;\n};\nexport default tarjan;","map":{"version":3,"names":["tarjan","graph","index","stack","visited","Map","results","dfs","v","_graph$successors","entry","onStack","lowlink","set","push","successors","forEach","w","_visited$get","has","wEntry","get","Math","min","_wEntry","cmpt","pop","nodes"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/graphlib/es/algorithm/tarjan.js"],"sourcesContent":["/**\n * @description Tarjan's algorithm for finding the strongly connected components of a graph.\n * @description https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @description.zh-CN Tarjan 算法用于找到图的强连通子图。\n * @param graph\n * @returns\n */\nvar tarjan = function tarjan(graph) {\n  var index = 0;\n  var stack = [];\n  var visited = new Map(); // node id -> { onStack, lowlink, index }\n\n  var results = [];\n\n  function dfs(v) {\n    var _graph$successors;\n\n    var entry = {\n      onStack: true,\n      lowlink: index,\n      index: index\n    };\n    visited.set(v, entry);\n    index += 1;\n    stack.push(v);\n    (_graph$successors = graph.successors(v)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function (w) {\n      var _visited$get;\n\n      // 如果 w 没有被访问过，则继续访问 w\n      if (!visited.has(w)) {\n        dfs(w);\n        var wEntry = visited.get(w);\n        entry.lowlink = Math.min(entry.lowlink, wEntry.lowlink); // 如果 w 在栈顶，则说明 w 和 v 不是强连通的\n      } else if ((_visited$get = visited.get(w)) === null || _visited$get === void 0 ? void 0 : _visited$get.onStack) {\n        var _wEntry = visited.get(w); // 如果 w 在栈中，则说明 w 在当前访问的路径上\n\n\n        entry.lowlink = Math.min(entry.lowlink, _wEntry.index);\n      }\n    }); // 如果 v 的 lowlink 不等于 v 的 index，则说明 v 和 v 的 lowlink 不是强连通的\n\n    if (entry.lowlink === entry.index) {\n      var cmpt = [];\n      var w;\n\n      do {\n        // 将 w 出栈，并将 w 的所有邻接点加入强连通子图\n        w = stack.pop();\n        var wEntry = visited.get(w);\n        wEntry.onStack = false;\n        cmpt.push(w);\n      } while (v !== w);\n\n      results.push(cmpt);\n    }\n  }\n\n  graph.nodes().forEach(function (v) {\n    if (!visited.has(v)) {\n      dfs(v);\n    }\n  });\n  return results;\n};\n\nexport default tarjan;"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,MAAM,GAAG,SAASA,MAAMA,CAACC,KAAK,EAAE;EAClC,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,KAAK,GAAG,EAAE;EACd,IAAIC,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC,CAAC,CAAC;;EAEzB,IAAIC,OAAO,GAAG,EAAE;EAEhB,SAASC,GAAGA,CAACC,CAAC,EAAE;IACd,IAAIC,iBAAiB;IAErB,IAAIC,KAAK,GAAG;MACVC,OAAO,EAAE,IAAI;MACbC,OAAO,EAAEV,KAAK;MACdA,KAAK,EAAEA;IACT,CAAC;IACDE,OAAO,CAACS,GAAG,CAACL,CAAC,EAAEE,KAAK,CAAC;IACrBR,KAAK,IAAI,CAAC;IACVC,KAAK,CAACW,IAAI,CAACN,CAAC,CAAC;IACb,CAACC,iBAAiB,GAAGR,KAAK,CAACc,UAAU,CAACP,CAAC,CAAC,MAAM,IAAI,IAAIC,iBAAiB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,iBAAiB,CAACO,OAAO,CAAC,UAAUC,CAAC,EAAE;MACnI,IAAIC,YAAY;;MAEhB;MACA,IAAI,CAACd,OAAO,CAACe,GAAG,CAACF,CAAC,CAAC,EAAE;QACnBV,GAAG,CAACU,CAAC,CAAC;QACN,IAAIG,MAAM,GAAGhB,OAAO,CAACiB,GAAG,CAACJ,CAAC,CAAC;QAC3BP,KAAK,CAACE,OAAO,GAAGU,IAAI,CAACC,GAAG,CAACb,KAAK,CAACE,OAAO,EAAEQ,MAAM,CAACR,OAAO,CAAC,CAAC,CAAC;MAC3D,CAAC,MAAM,IAAI,CAACM,YAAY,GAAGd,OAAO,CAACiB,GAAG,CAACJ,CAAC,CAAC,MAAM,IAAI,IAAIC,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACP,OAAO,EAAE;QAC9G,IAAIa,OAAO,GAAGpB,OAAO,CAACiB,GAAG,CAACJ,CAAC,CAAC,CAAC,CAAC;;QAG9BP,KAAK,CAACE,OAAO,GAAGU,IAAI,CAACC,GAAG,CAACb,KAAK,CAACE,OAAO,EAAEY,OAAO,CAACtB,KAAK,CAAC;MACxD;IACF,CAAC,CAAC,CAAC,CAAC;;IAEJ,IAAIQ,KAAK,CAACE,OAAO,KAAKF,KAAK,CAACR,KAAK,EAAE;MACjC,IAAIuB,IAAI,GAAG,EAAE;MACb,IAAIR,CAAC;MAEL,GAAG;QACD;QACAA,CAAC,GAAGd,KAAK,CAACuB,GAAG,CAAC,CAAC;QACf,IAAIN,MAAM,GAAGhB,OAAO,CAACiB,GAAG,CAACJ,CAAC,CAAC;QAC3BG,MAAM,CAACT,OAAO,GAAG,KAAK;QACtBc,IAAI,CAACX,IAAI,CAACG,CAAC,CAAC;MACd,CAAC,QAAQT,CAAC,KAAKS,CAAC;MAEhBX,OAAO,CAACQ,IAAI,CAACW,IAAI,CAAC;IACpB;EACF;EAEAxB,KAAK,CAAC0B,KAAK,CAAC,CAAC,CAACX,OAAO,CAAC,UAAUR,CAAC,EAAE;IACjC,IAAI,CAACJ,OAAO,CAACe,GAAG,CAACX,CAAC,CAAC,EAAE;MACnBD,GAAG,CAACC,CAAC,CAAC;IACR;EACF,CAAC,CAAC;EACF,OAAOF,OAAO;AAChB,CAAC;AAED,eAAeN,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}