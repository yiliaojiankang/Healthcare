{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _dec, _class;\nimport { lodashUtil } from '@antv/l7-utils';\nimport { injectable } from 'inversify';\nimport 'reflect-metadata';\nimport { extractUniforms } from \"../../utils/shader-module\";\nvar uniq = lodashUtil.uniq;\n/* babel-plugin-inline-import '../../shaders/common.glsl' */\nvar common = \"#define PI 3.14159265359\";\n/* babel-plugin-inline-import '../../shaders/decode.glsl' */\nvar decode = \"#define SHIFT_RIGHT17 1.0 / 131072.0\\n#define SHIFT_RIGHT18 1.0 / 262144.0\\n#define SHIFT_RIGHT19 1.0 / 524288.0\\n#define SHIFT_RIGHT20 1.0 / 1048576.0\\n#define SHIFT_RIGHT21 1.0 / 2097152.0\\n#define SHIFT_RIGHT22 1.0 / 4194304.0\\n#define SHIFT_RIGHT23 1.0 / 8388608.0\\n#define SHIFT_RIGHT24 1.0 / 16777216.0\\n\\n#define SHIFT_LEFT17 131072.0\\n#define SHIFT_LEFT18 262144.0\\n#define SHIFT_LEFT19 524288.0\\n#define SHIFT_LEFT20 1048576.0\\n#define SHIFT_LEFT21 2097152.0\\n#define SHIFT_LEFT22 4194304.0\\n#define SHIFT_LEFT23 8388608.0\\n#define SHIFT_LEFT24 16777216.0\\n\\nvec2 unpack_float(float packedValue) {\\n  int packedIntValue = int(packedValue);\\n  int v0 = packedIntValue / 256;\\n  return vec2(v0, packedIntValue - v0 * 256);\\n}\\n\\nvec4 decode_color(vec2 encodedColor) {\\n  return vec4(\\n    unpack_float(encodedColor[0]) / 255.0,\\n    unpack_float(encodedColor[1]) / 255.0\\n  );\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/scene_uniforms.glsl' */\nvar scene_uniforms = \"layout(std140) uniform SceneUniforms {\\n  mat4 u_ViewMatrix;\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewProjectionMatrix;\\n  mat4 u_ModelMatrix;\\n  vec4 u_ViewportCenterProjection;\\n  vec3 u_PixelsPerDegree;\\n  float u_Zoom;\\n  vec3 u_PixelsPerDegree2;\\n  float u_ZoomScale;\\n  vec3 u_PixelsPerMeter;\\n  float u_CoordinateSystem;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_ViewportCenter;\\n  vec2 u_ViewportSize;\\n  float u_FocalDistance;\\n};\\n\\nlayout(std140) uniform LayerUniforms {\\n  mat4 u_Mvp;\\n  vec2 u_sceneCenterMercator;\\n};\\n\";\n/* babel-plugin-inline-import '../../shaders/picking_uniforms.glsl' */\nvar picking_uniforms = \"layout(std140) uniform PickingUniforms {\\n  vec4 u_HighlightColor;\\n  vec4 u_SelectColor;\\n  vec3 u_PickingColor;\\n  float u_PickingStage;\\n  vec3 u_CurrentSelectedId;\\n  float u_PickingThreshold;\\n  float u_PickingBuffer;\\n  float u_shaderPick;\\n  float u_EnableSelect;\\n  float u_activeMix;\\n};\";\n/* babel-plugin-inline-import '../../shaders/common_light.glsl' */\nvar light = \"#define ambientRatio 0.5\\n#define diffuseRatio 0.3\\n#define specularRatio 0.2\\n\\n\\nfloat calc_lighting(vec4 pos) {\\n\\n    vec3 worldPos = vec3(pos * u_ModelMatrix);\\n\\n    vec3 worldNormal = a_Normal;\\n      // //cal light weight\\n    vec3 viewDir = normalize(u_CameraPosition - worldPos);\\n\\n    vec3 lightDir = normalize(vec3(1, -10.5, 12));\\n\\n    vec3 halfDir = normalize(viewDir+lightDir);\\n      // //lambert\\n    float lambert = dot(worldNormal, lightDir);\\n        //specular\\n    float specular = pow(max(0.0, dot(worldNormal, halfDir)), 32.0);\\n        //sum to light weight\\n    float lightWeight = ambientRatio + diffuseRatio * lambert + specularRatio * specular;\\n\\n    return lightWeight;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/lighting.glsl' */\nvar lighting = \"// Blinn-Phong model\\n// apply lighting in vertex shader instead of fragment shader\\n// @see https://learnopengl.com/Advanced-Lighting/Advanced-Lighting\\nuniform float u_Ambient : 1.0;\\nuniform float u_Diffuse : 1.0;\\nuniform float u_Specular : 1.0;\\nuniform int u_NumOfDirectionalLights : 1;\\nuniform int u_NumOfSpotLights : 0;\\n\\n#define SHININESS 32.0\\n#define MAX_NUM_OF_DIRECTIONAL_LIGHTS 3\\n#define MAX_NUM_OF_SPOT_LIGHTS 3\\n\\nstruct DirectionalLight {\\n  vec3 direction;\\n  vec3 ambient;\\n  vec3 diffuse;\\n  vec3 specular;\\n};\\n\\nstruct SpotLight {\\n  vec3 position;\\n  vec3 direction;\\n  vec3 ambient;\\n  vec3 diffuse;\\n  vec3 specular;\\n  float constant;\\n  float linear;\\n  float quadratic;\\n  float angle;\\n  float blur;\\n  float exponent;\\n};\\n\\nuniform DirectionalLight u_DirectionalLights[MAX_NUM_OF_DIRECTIONAL_LIGHTS];\\nuniform SpotLight u_SpotLights[MAX_NUM_OF_SPOT_LIGHTS];\\n\\nvec3 calc_directional_light(DirectionalLight light, vec3 normal, vec3 viewDir) {\\n  vec3 lightDir = normalize(light.direction);\\n  // diffuse shading\\n  float diff = max(dot(normal, lightDir), 0.0);\\n  // Blinn-Phong specular shading\\n  vec3 halfwayDir = normalize(lightDir + viewDir);\\n  float spec = pow(max(dot(normal, halfwayDir), 0.0), SHININESS);\\n\\n  vec3 ambient = light.ambient * u_Ambient;\\n  vec3 diffuse = light.diffuse * diff * u_Diffuse;\\n  vec3 specular = light.specular * spec * u_Specular;\\n\\n  return ambient + diffuse + specular;\\n}\\n\\n\\nvec3 calc_lighting(vec3 position, vec3 normal, vec3 viewDir) {\\n  vec3 weight = vec3(0.0);\\n  for (int i = 0; i < MAX_NUM_OF_DIRECTIONAL_LIGHTS; i++) {\\n    if (i >= u_NumOfDirectionalLights) {\\n      break;\\n    }\\n    weight += calc_directional_light(u_DirectionalLights[i], normal, viewDir);\\n  }\\n  return weight;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/picking.frag.glsl' */\nvar pickingFrag = \"\\nin vec4 v_PickingResult;\\n\\n#pragma include \\\"picking_uniforms\\\"\\n\\n#define PICKING_NONE 0.0\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\n#define HIGHLIGHT 1.0\\n#define SELECT 2.0\\n\\n/*\\n * Returns highlight color if this item is selected.\\n */\\nvec4 filterHighlightColor(vec4 color, float weight) {\\n  // float selected = v_PickingResult.a;\\n  bool selected = bool(v_PickingResult.a);\\n\\n  // if (selected == SELECT) {\\n  if (selected) {\\n  //   // \\u70B9\\u51FB\\u9009\\u4E2D\\u72B6\\u6001\\n  //   vec4 selectColor = u_SelectColor * COLOR_SCALE;\\n  //   return selectColor;\\n  // } else if (selected == HIGHLIGHT) {\\n  //   // hover \\u9AD8\\u4EAE\\u72B6\\u6001\\n    vec4 highLightColor = u_HighlightColor * COLOR_SCALE;\\n\\n    float highLightAlpha = highLightColor.a;\\n    float highLightRatio = highLightAlpha / (highLightAlpha + color.a * (1.0 - highLightAlpha));\\n\\n    vec3 resultRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\\n    return vec4(mix(resultRGB * weight, color.rgb, u_activeMix), color.a);\\n  } else {\\n    return color;\\n  }\\n}\\n\\n/*\\n * Returns picking color if picking enabled else unmodified argument.\\n */\\nvec4 filterPickingColor(vec4 color) {\\n  vec3 pickingColor = v_PickingResult.rgb;\\n  if (u_PickingStage == PICKING_ENCODE && length(pickingColor) < 0.001) {\\n    discard;\\n  }\\n  return u_PickingStage == PICKING_ENCODE ? vec4(pickingColor, step(0.001,color.a)): color;\\n}\\n\\n/*\\n * Returns picking color if picking is enabled if not\\n * highlight color if this item is selected, otherwise unmodified argument.\\n */\\nvec4 filterColor(vec4 color) {\\n  // \\u8FC7\\u6EE4\\u591A\\u4F59\\u7684 shader \\u8BA1\\u7B97\\n  // return color;\\n  if(u_shaderPick < 0.5) {\\n    return color; // \\u6682\\u65F6\\u53BB\\u9664 \\u76F4\\u63A5\\u53D6\\u6D88\\u8BA1\\u7B97\\u5728\\u9009\\u4E2D\\u65F6\\u62D6\\u62FD\\u5730\\u56FE\\u4F1A\\u6709\\u95EE\\u9898\\n  } else {\\n    return filterPickingColor(filterHighlightColor(color, 1.0));\\n  }\\n  \\n}\\n\\nvec4 filterColorAlpha(vec4 color, float alpha) {\\n  // \\u8FC7\\u6EE4\\u591A\\u4F59\\u7684 shader \\u8BA1\\u7B97\\n  // return color;\\n  if(u_shaderPick < 0.5) {\\n    return color; // \\u6682\\u65F6\\u53BB\\u9664 \\u76F4\\u63A5\\u53D6\\u6D88\\u8BA1\\u7B97\\u5728\\u9009\\u4E2D\\u65F6\\u62D6\\u62FD\\u5730\\u56FE\\u4F1A\\u6709\\u95EE\\u9898\\n  } else {\\n    return filterPickingColor(filterHighlightColor(color, alpha));\\n  }\\n}\\n\\n\";\n/* babel-plugin-inline-import '../../shaders/picking.vert.glsl' */\nvar pickingVert = \"layout(location = 3) in vec3 a_PickingColor;\\nout vec4 v_PickingResult;\\n\\n#pragma include \\\"picking_uniforms\\\"\\n\\n#define PICKING_NONE 0.0\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\n#define NORMAL 0.0\\n#define HIGHLIGHT 1.0\\n#define SELECT 2.0\\n\\nbool isVertexPicked(vec3 vertexColor) {\\n  return distance(vertexColor,u_PickingColor.rgb) < 0.01;\\n}\\n\\n// \\u5224\\u65AD\\u5F53\\u524D\\u70B9\\u662F\\u5426\\u5DF2\\u7ECF\\u88AB select \\u9009\\u4E2D\\nbool isVertexSelected(vec3 vertexColor) {\\n  return distance(vertexColor,u_CurrentSelectedId.rgb) < 0.01;\\n}\\n\\nvoid setPickingColor(vec3 pickingColor) {\\n  if(u_shaderPick < 0.5) {\\n    return;\\n  }\\n  // compares only in highlight stage\\n\\n  v_PickingResult.a = float((u_PickingStage == PICKING_HIGHLIGHT) && isVertexPicked(pickingColor));\\n\\n  // Stores the picking color so that the fragment shader can render it during picking\\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nfloat setPickingSize(float x) {\\n   return u_PickingStage == PICKING_ENCODE ? x + u_PickingBuffer : x;\\n}\\n\\nfloat setPickingOrder(float z) {\\n   bool selected = bool(v_PickingResult.a);\\n   return selected ? z + 1. : 0.;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/project.glsl' */\nvar project = \"\\n#define E 2.718281828459045\\nvec2 ProjectFlat(vec2 lnglat){\\n  float maxs=85.0511287798;\\n  float lat=max(min(maxs,lnglat.y),-maxs);\\n  float scale= 268435456.;\\n  float d=PI/180.;\\n  float x=lnglat.x*d;\\n  float y=lat*d;\\n  y=log(tan((PI/4.)+(y/2.)));\\n\\n  float a=.5/PI,\\n  b=.5,\\n  c=-.5/PI;\\n  d=.5;\\n  x=scale*(a*x+b);\\n  y=scale*(c*y+d);\\n  return vec2(x,y);\\n}\\n\\nvec2 unProjectFlat(vec2 px){\\n  float a=.5/PI;\\n  float b=.5;\\n  float c=-.5/PI;\\n  float d=.5;\\n  float scale = 268435456.;\\n  float x=(px.x/scale-b)/a;\\n  float y=(px.y/scale-d)/c;\\n  y=(atan(pow(E,y))-(PI/4.))*2.;\\n  d=PI/180.;\\n  float lat=y/d;\\n  float lng=x/d;\\n  return vec2(lng,lat);\\n}\\n\\nfloat pixelDistance(vec2 from, vec2 to) {\\n vec2 a1 = ProjectFlat(from);\\n vec2 b1 = ProjectFlat(to);\\n return distance(a1, b1);\\n}\\n\\n// gaode2.0\\nvec2 customProject(vec2 lnglat) { // \\u7ECF\\u7EAC\\u5EA6 => \\u5E73\\u9762\\u5750\\u6807\\n  float t = lnglat.x;\\n  float e = lnglat.y;\\n  float Sm = 180.0 / PI;\\n  float Tm = 6378137.0;\\n  float Rm = PI / 180.0;\\n  float r = 85.0511287798;\\n  e = max(min(r, e), -r);\\n  t *= Rm;\\n  e *= Rm;\\n  e = log(tan(PI / 4.0 + e / 2.0));\\n  return vec2(t * Tm, e * Tm);\\n}\\n\\nvec2 unProjCustomCoord(vec2 point) { // \\u5E73\\u9762\\u5750\\u6807 => \\u7ECF\\u7EAC\\u5EA6\\n  float Sm = 57.29577951308232; //180 / Math.PI\\n  float Tm = 6378137.0;\\n  float t = point.x;\\n  float e = point.y;\\n  return vec2(t / Tm * Sm, (2.0 * atan(exp(e / Tm)) - PI / 2.0) * Sm);\\n}\\n\\n\\nfloat customPixelDistance(vec2 from, vec2 to) {\\n vec2 a1 = ProjectFlat(from);\\n vec2 b1 = ProjectFlat(to);\\n return distance(a1, b1);\\n}\";\n/* babel-plugin-inline-import '../../shaders/projection.glsl' */\nvar projection = \"#define TILE_SIZE 512.0\\n#define PI 3.1415926536\\n#define WORLD_SCALE TILE_SIZE / (PI * 2.0)\\n#define EARTH_CIRCUMFERENCE 40.03e6\\n\\n#define COORDINATE_SYSTEM_LNGLAT 1.0        // mapbox\\n#define COORDINATE_SYSTEM_LNGLAT_OFFSET 2.0 // mapbox offset\\n#define COORDINATE_SYSTEM_VECTOR_TILE 3.0\\n#define COORDINATE_SYSTEM_IDENTITY 4.0\\n#define COORDINATE_SYSTEM_P20 5.0           // amap\\n#define COORDINATE_SYSTEM_P20_OFFSET 6.0    // amap offset\\n#define COORDINATE_SYSTEM_METER_OFFSET 7.0\\n\\n#define COORDINATE_SYSTEM_P20_2 8.0         // amap2.0\\n#pragma include \\\"scene_uniforms\\\"\\n\\n\\n// web mercator coords -> world coords\\nvec2 project_mercator(vec2 lnglat) {\\n   if (u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.0\\n    return lnglat;\\n  }\\n  float x = lnglat.x;\\n  return vec2(\\n    radians(x) + PI,\\n    PI - log(tan(PI * 0.25 + radians(lnglat.y) * 0.5))\\n  );\\n}\\n\\nfloat project_scale(float meters) {\\n  return meters * u_PixelsPerMeter.z;\\n}\\n\\n\\n// offset coords -> world coords\\nvec4 project_offset(vec4 offset) {\\n  float dy = offset.y;\\n  dy = clamp(dy, -1., 1.);\\n  vec3 pixels_per_unit = u_PixelsPerDegree + u_PixelsPerDegree2 * dy;\\n  return vec4(offset.xyz * pixels_per_unit, offset.w);\\n}\\n\\nvec3 project_normal(vec3 normal) {\\n  vec4 normal_modelspace = u_ModelMatrix * vec4(normal, 0.0);\\n  return normalize(normal_modelspace.xyz * u_PixelsPerMeter);\\n}\\n\\nvec3 project_offset_normal(vec3 vector) {\\n  if (u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_LNGLAT - 0.01\\n    || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\\n    return normalize(vector * u_PixelsPerDegree);\\n  }\\n  return project_normal(vector);\\n}\\n// || u_CoordinateSystem < COORDINATE_SYSTEM_P20_OFFSET + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_P20_OFFSET - 0.01\\n// reverse Y\\nvec3 reverse_offset_normal(vec3 vector) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 ||u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET ) {\\n    return vector * vec3(1.0, -1.0, 1.0);\\n  }\\n\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.0\\n    return vector;\\n  }\\n  return vector;\\n}\\n\\nvec4 project_mvt_offset_position(vec4 position) {\\n  float a = COORDINATE_SYSTEM_LNGLAT_OFFSET;\\n  float b = COORDINATE_SYSTEM_P20_OFFSET;\\n  float c = COORDINATE_SYSTEM_LNGLAT;\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    return project_offset(vec4(0.0, 0.0, position.z, position.w));\\n  }\\n  if (u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_LNGLAT - 0.01) {\\n    return vec4(\\n      project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale,\\n      project_scale(position.z),\\n      position.w\\n    );\\n  }\\n  return position;\\n}\\n\\nvec4 project_position(vec4 position) {\\n  float a = COORDINATE_SYSTEM_LNGLAT_OFFSET;\\n  float b = COORDINATE_SYSTEM_P20_OFFSET;\\n  float c = COORDINATE_SYSTEM_LNGLAT;\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n    || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    float X = position.x - u_ViewportCenter.x;\\n    float Y = position.y - u_ViewportCenter.y;\\n    return project_offset(vec4(X, Y, position.z, position.w));\\n  }\\n  if (u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_LNGLAT - 0.01) {\\n    return vec4(\\n      project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale,\\n      project_scale(position.z),\\n      position.w\\n    );\\n  }\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20) {\\n    return vec4(\\n      (project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale - vec2(215440491., 106744817.)) * vec2(1., -1.),\\n      project_scale(position.z),\\n      position.w\\n    );\\n  }\\n\\n  // if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n \\n\\n  //    return vec4(\\n  //     position.xy,\\n  //     project_scale(position.z),\\n  //     position.w);\\n  // }\\n  return position;\\n\\n  // TODO: \\u74E6\\u7247\\u5750\\u6807\\u7CFB & \\u5E38\\u89C4\\u4E16\\u754C\\u5750\\u6807\\u7CFB\\n}\\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\\n  vec2 offset = pixels / u_ViewportSize * u_DevicePixelRatio * 2.0;\\n  return offset * u_FocalDistance;\\n}\\n\\n\\n\\nfloat project_pixel_allmap(float pixel) {\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\\n    return pixel * pow(2.0, u_Zoom);\\n  }\\n  return pixel * u_FocalDistance ;\\n}\\n\\n// \\u9002\\u914D\\u7EB9\\u7406\\u8D34\\u56FE\\u7684\\u7B49\\u50CF\\u7D20\\u5927\\u5C0F\\nfloat project_pixel_texture(float pixel) {\\n  // mapbox zoom > 12\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    return pixel * pow(0.5, u_Zoom) * u_FocalDistance ;\\n  }\\n\\n  // amap2 zoom > 12\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom))* u_FocalDistance ;\\n  }\\n\\n  // amap zoom > 12\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    return pixel * pow(0.5, u_Zoom)* u_FocalDistance ;\\n  }\\n\\n  // amap zoom < 12\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20) {\\n    return pixel * pow(2.0, (20.0 - u_Zoom))* u_FocalDistance ;\\n  }\\n  return pixel * 2.0 *  u_FocalDistance;;\\n}\\n\\n// \\u5728\\u4E0D\\u8BBA\\u4EC0\\u4E48\\u5E95\\u56FE\\u4E0B\\u9700\\u8981\\u7EDF\\u4E00\\u5904\\u7406\\u7684\\u65F6\\u5019\\u4F7F\\u7528\\nfloat project_float_pixel(float pixel) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // mapbox P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom))  * u_FocalDistance ;\\n  }\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    // amap P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom));\\n  }\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    // amap2 P20_2 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF3\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom))* u_FocalDistance ;\\n  }\\n  return pixel * u_FocalDistance;\\n}\\n\\n// Project meter into the unit of pixel which used in the camera world space\\nfloat project_float_meter(float meter) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // Since the zoom level uniform is updated by mapservice and it's alread been subtracted by 1\\n    // Not sure if we are supposed to do that again\\n   return meter;\\n  } else  {\\n    return project_float_pixel(meter);\\n  }\\n\\n  // TODO: change the following code to make adaptations for amap\\n  // return u_FocalDistance * TILE_SIZE * pow(2.0, u_Zoom) * meter / EARTH_CIRCUMFERENCE;\\n}\\n\\nfloat project_pixel(float pixel) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    // amap P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom)) * u_FocalDistance ;\\n  }\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    // amap2 P20_2 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF3\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom)) * u_FocalDistance ;\\n  }\\n  return pixel * u_FocalDistance;\\n}\\nvec2 project_pixel(vec2 pixel) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    // P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom)) * u_FocalDistance ;\\n  }\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    // P20_2 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF3\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom)) * u_FocalDistance ;\\n  }\\n  return pixel * -1. * u_FocalDistance;\\n}\\nvec3 project_pixel(vec3 pixel) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    // P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom)) *  u_FocalDistance ;\\n  }\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    // P20_2 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF3\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom))  * u_FocalDistance ;\\n  }\\n  return pixel * -1. * u_FocalDistance;\\n}\\n\\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // Needs to be divided with project_uCommonUnitsPerMeter\\n    position.w *= u_PixelsPerMeter.z;\\n  }\\n\\n  return viewProjectionMatrix * position + center;\\n}\\n\\n// Projects from common space coordinates to clip space\\nvec4 project_common_position_to_clipspace(vec4 position) {\\n  return project_common_position_to_clipspace(\\n    position,\\n    u_ViewProjectionMatrix,\\n    u_ViewportCenterProjection\\n  );\\n}\\n\\nvec4 unproject_clipspace_to_position(vec4 clipspacePos, mat4 u_InverseViewProjectionMatrix) {\\n  vec4 pos = u_InverseViewProjectionMatrix * (clipspacePos - u_ViewportCenterProjection);\\n\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // Needs to be divided with project_uCommonUnitsPerMeter\\n     pos.w = pos.w / u_PixelsPerMeter.z;\\n  }\\n  return pos;\\n}\\n\\n\\nbool isEqual( float a,  float b) {\\n    return  a< b + 0.001 && a > b - 0.001;\\n}\\n\\n// \\u652F\\u6301 GaodeV2\\u3001Mapbox\\nvec4 project_common_position_to_clipspace_v2(vec4 position) {\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\\n    return u_Mvp * position;\\n  } else {\\n    return project_common_position_to_clipspace(position);\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/rotation_2d.glsl' */\nvar rotation_2d = \"vec2 rotate_matrix(vec2 v, float a) {\\n    float b = a / 180.0 * 3.1415926535897932384626433832795;\\n    float s = sin(b);\\n    float c = cos(b);\\n    mat2 m = mat2(c, s, -s, c);\\n    return m * v;\\n}\";\n/* babel-plugin-inline-import '../../shaders/sdf_2d.glsl' */\nvar sdf2d = \"/**\\n * 2D signed distance field functions\\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\\n */\\n\\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\\n\\nfloat sdCircle(vec2 p, float r) {\\n  return length(p) - r;\\n}\\n\\nfloat sdEquilateralTriangle(vec2 p) {\\n  float k = sqrt(3.0);\\n  p.x = abs(p.x) - 1.0;\\n  p.y = p.y + 1.0/k;\\n  if( p.x + k*p.y > 0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\\n  p.x -= clamp( p.x, -2.0, 0.0 );\\n  return -length(p)*sign(p.y);\\n}\\n\\nfloat sdBox(vec2 p, vec2 b) {\\n  vec2 d = abs(p)-b;\\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\\n}\\n\\nfloat sdPentagon(vec2 p, float r) {\\n  vec3 k = vec3(0.809016994,0.587785252,0.726542528);\\n  p.x = abs(p.x);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagon(vec2 p, float r) {\\n  vec3 k = vec3(-0.866025404,0.5,0.577350269);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdOctogon(vec2 p, float r) {\\n  vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\\n  p = abs(p);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagram(vec2 p, float r) {\\n  vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\\n  p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdRhombus(vec2 p, vec2 b) {\\n  vec2 q = abs(p);\\n  float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\\n  float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\\n  return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\\n}\\n\\nfloat sdVesica(vec2 p, float r, float d) {\\n  p = abs(p);\\n  float b = sqrt(r*r-d*d); // can delay this sqrt\\n  return ((p.y-b)*d>p.x*b)\\n          ? length(p-vec2(0.0,b))\\n          : length(p-vec2(-d,0.0))-r;\\n}\\n\";\nvar precisionRegExp = /precision\\s+(high|low|medium)p\\s+float/;\nvar globalDefaultprecision = '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif\\n';\nvar includeRegExp = /#pragma include ([\"^+\"]?[\"[a-zA-Z_0-9](.*)\"]*?)/g;\nvar REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nvar REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nvar ShaderModuleService = (_dec = injectable(), _dec(_class = /*#__PURE__*/function () {\n  function ShaderModuleService() {\n    _classCallCheck(this, ShaderModuleService);\n    _defineProperty(this, \"moduleCache\", {});\n    _defineProperty(this, \"rawContentCache\", {});\n  }\n  _createClass(ShaderModuleService, [{\n    key: \"registerBuiltinModules\",\n    value: function registerBuiltinModules() {\n      this.destroy();\n      this.registerModule('common', {\n        vs: common,\n        fs: common\n      });\n      this.registerModule('decode', {\n        vs: decode,\n        fs: ''\n      });\n      this.registerModule('scene_uniforms', {\n        vs: scene_uniforms,\n        fs: scene_uniforms\n      });\n      this.registerModule('picking_uniforms', {\n        vs: picking_uniforms,\n        fs: picking_uniforms\n      });\n      this.registerModule('projection', {\n        vs: projection,\n        fs: projection\n      });\n      this.registerModule('project', {\n        vs: project,\n        fs: ''\n      });\n      this.registerModule('sdf_2d', {\n        vs: '',\n        fs: sdf2d\n      });\n      this.registerModule('lighting', {\n        vs: lighting,\n        fs: ''\n      });\n      this.registerModule('light', {\n        vs: light,\n        fs: ''\n      });\n      this.registerModule('picking', {\n        vs: pickingVert,\n        fs: pickingFrag\n      });\n      this.registerModule('rotation_2d', {\n        vs: rotation_2d,\n        fs: ''\n      });\n    }\n  }, {\n    key: \"registerModule\",\n    value: function registerModule(moduleName, moduleParams) {\n      // prevent registering the same module multiple times\n      // if (this.rawContentCache[moduleName]) {\n      //   return;\n      // }\n\n      moduleParams.vs = moduleParams.vs.replace(/\\r\\n/g, '\\n'); // 将所有的\\r\\n替换为\\n\n      moduleParams.fs = moduleParams.fs.replace(/\\r\\n/g, '\\n'); // 将所有的\\r\\n替换为\\n\n      var vs = moduleParams.vs,\n        fs = moduleParams.fs,\n        declaredUniforms = moduleParams.uniforms,\n        inject = moduleParams.inject;\n      var _extractUniforms = extractUniforms(vs),\n        extractedVS = _extractUniforms.content,\n        vsUniforms = _extractUniforms.uniforms;\n      var _extractUniforms2 = extractUniforms(fs),\n        extractedFS = _extractUniforms2.content,\n        fsUniforms = _extractUniforms2.uniforms;\n      this.rawContentCache[moduleName] = {\n        fs: extractedFS,\n        inject: inject,\n        uniforms: _objectSpread(_objectSpread(_objectSpread({}, vsUniforms), fsUniforms), declaredUniforms),\n        vs: extractedVS\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.moduleCache = {};\n      this.rawContentCache = {};\n    }\n  }, {\n    key: \"getModule\",\n    value: function getModule(moduleName) {\n      var _this = this;\n      // TODO: cache module\n      // if (this.moduleCache[moduleName]) {\n      //   return this.moduleCache[moduleName];\n      // }\n\n      var rawVS = this.rawContentCache[moduleName].vs;\n      var rawFS = this.rawContentCache[moduleName].fs;\n      var inject = this.rawContentCache[moduleName].inject;\n      var declaredUniforms = {};\n      if (inject !== null && inject !== void 0 && inject['vs:#decl']) {\n        // 头部注入\n        rawVS = (inject === null || inject === void 0 ? void 0 : inject['vs:#decl']) + rawVS;\n        declaredUniforms = extractUniforms(inject === null || inject === void 0 ? void 0 : inject['vs:#decl']).uniforms;\n      }\n      if (inject !== null && inject !== void 0 && inject['vs:#main-start']) {\n        // main\n        rawVS = rawVS.replace(REGEX_START_OF_MAIN, function (match) {\n          return match + (inject === null || inject === void 0 ? void 0 : inject['vs:#main-start']);\n        });\n      }\n      if (inject !== null && inject !== void 0 && inject['fs:#decl']) {\n        // 头部注入\n        rawFS = (inject === null || inject === void 0 ? void 0 : inject['fs:#decl']) + rawFS;\n      }\n      var _this$processModule = this.processModule(rawVS, [], 'vs'),\n        vs = _this$processModule.content,\n        vsIncludeList = _this$processModule.includeList;\n      var _this$processModule2 = this.processModule(rawFS, [], 'fs'),\n        fs = _this$processModule2.content,\n        fsIncludeList = _this$processModule2.includeList;\n      var compiledFs = '';\n      // TODO: extract uniforms and their default values from GLSL\n      var uniforms = uniq(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce(function (prev, cur) {\n        return _objectSpread(_objectSpread({}, prev), _this.rawContentCache[cur].uniforms);\n      }, _objectSpread({}, declaredUniforms));\n\n      /**\n       * set default precision for fragment shader\n       * https://stackoverflow.com/questions/28540290/why-it-is-necessary-to-set-precision-for-the-fragment-shader\n       */\n      if (!precisionRegExp.test(fs)) {\n        compiledFs = compiledFs + globalDefaultprecision;\n      }\n      compiledFs = compiledFs + fs;\n      var compiledVs = '';\n      if (!precisionRegExp.test(vs)) {\n        compiledVs = compiledVs + globalDefaultprecision;\n      }\n      compiledVs = compiledVs + vs;\n      this.moduleCache[moduleName] = {\n        fs: compiledFs.trim(),\n        uniforms: uniforms,\n        vs: compiledVs.trim()\n      };\n      return this.moduleCache[moduleName];\n    }\n  }, {\n    key: \"processModule\",\n    value: function processModule(rawContent, includeList, type) {\n      var _this2 = this;\n      var compiled = rawContent.replace(includeRegExp, function (_, strMatch) {\n        var includeOpt = strMatch.split(' ');\n        var includeName = includeOpt[0].replace(/\"/g, '');\n        if (includeList.indexOf(includeName) > -1) {\n          return '';\n        }\n        var txt = _this2.rawContentCache[includeName][type];\n        includeList.push(includeName);\n        var _this2$processModule = _this2.processModule(txt, includeList, type),\n          content = _this2$processModule.content;\n        return content;\n      });\n      return {\n        content: compiled,\n        includeList: includeList\n      };\n    }\n  }, {\n    key: \"injectDefines\",\n    value: function injectDefines(defines) {\n      var defineStr = Object.keys(defines).reduce(function (prev, cur) {\n        return prev + \"#define \".concat(cur.toUpperCase(), \" \").concat(defines[cur], \";\\n\");\n      }, '\\n');\n      return defineStr;\n    }\n  }]);\n  return ShaderModuleService;\n}()) || _class);\nexport { ShaderModuleService as default };","map":{"version":3,"names":["_objectSpread","_classCallCheck","_createClass","_defineProperty","_dec","_class","lodashUtil","injectable","extractUniforms","uniq","common","decode","scene_uniforms","picking_uniforms","light","lighting","pickingFrag","pickingVert","project","projection","rotation_2d","sdf2d","precisionRegExp","globalDefaultprecision","includeRegExp","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","ShaderModuleService","key","value","registerBuiltinModules","destroy","registerModule","vs","fs","moduleName","moduleParams","replace","declaredUniforms","uniforms","inject","_extractUniforms","extractedVS","content","vsUniforms","_extractUniforms2","extractedFS","fsUniforms","rawContentCache","moduleCache","getModule","_this","rawVS","rawFS","match","_this$processModule","processModule","vsIncludeList","includeList","_this$processModule2","fsIncludeList","compiledFs","concat","reduce","prev","cur","test","compiledVs","trim","rawContent","type","_this2","compiled","_","strMatch","includeOpt","split","includeName","indexOf","txt","push","_this2$processModule","injectDefines","defines","defineStr","Object","keys","toUpperCase","default"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-core/es/services/shader/ShaderModuleService.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _dec, _class;\nimport { lodashUtil } from '@antv/l7-utils';\nimport { injectable } from 'inversify';\nimport 'reflect-metadata';\nimport { extractUniforms } from \"../../utils/shader-module\";\nvar uniq = lodashUtil.uniq;\n/* babel-plugin-inline-import '../../shaders/common.glsl' */\nvar common = \"#define PI 3.14159265359\";\n/* babel-plugin-inline-import '../../shaders/decode.glsl' */\nvar decode = \"#define SHIFT_RIGHT17 1.0 / 131072.0\\n#define SHIFT_RIGHT18 1.0 / 262144.0\\n#define SHIFT_RIGHT19 1.0 / 524288.0\\n#define SHIFT_RIGHT20 1.0 / 1048576.0\\n#define SHIFT_RIGHT21 1.0 / 2097152.0\\n#define SHIFT_RIGHT22 1.0 / 4194304.0\\n#define SHIFT_RIGHT23 1.0 / 8388608.0\\n#define SHIFT_RIGHT24 1.0 / 16777216.0\\n\\n#define SHIFT_LEFT17 131072.0\\n#define SHIFT_LEFT18 262144.0\\n#define SHIFT_LEFT19 524288.0\\n#define SHIFT_LEFT20 1048576.0\\n#define SHIFT_LEFT21 2097152.0\\n#define SHIFT_LEFT22 4194304.0\\n#define SHIFT_LEFT23 8388608.0\\n#define SHIFT_LEFT24 16777216.0\\n\\nvec2 unpack_float(float packedValue) {\\n  int packedIntValue = int(packedValue);\\n  int v0 = packedIntValue / 256;\\n  return vec2(v0, packedIntValue - v0 * 256);\\n}\\n\\nvec4 decode_color(vec2 encodedColor) {\\n  return vec4(\\n    unpack_float(encodedColor[0]) / 255.0,\\n    unpack_float(encodedColor[1]) / 255.0\\n  );\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/scene_uniforms.glsl' */\nvar scene_uniforms = \"layout(std140) uniform SceneUniforms {\\n  mat4 u_ViewMatrix;\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewProjectionMatrix;\\n  mat4 u_ModelMatrix;\\n  vec4 u_ViewportCenterProjection;\\n  vec3 u_PixelsPerDegree;\\n  float u_Zoom;\\n  vec3 u_PixelsPerDegree2;\\n  float u_ZoomScale;\\n  vec3 u_PixelsPerMeter;\\n  float u_CoordinateSystem;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_ViewportCenter;\\n  vec2 u_ViewportSize;\\n  float u_FocalDistance;\\n};\\n\\nlayout(std140) uniform LayerUniforms {\\n  mat4 u_Mvp;\\n  vec2 u_sceneCenterMercator;\\n};\\n\";\n/* babel-plugin-inline-import '../../shaders/picking_uniforms.glsl' */\nvar picking_uniforms = \"layout(std140) uniform PickingUniforms {\\n  vec4 u_HighlightColor;\\n  vec4 u_SelectColor;\\n  vec3 u_PickingColor;\\n  float u_PickingStage;\\n  vec3 u_CurrentSelectedId;\\n  float u_PickingThreshold;\\n  float u_PickingBuffer;\\n  float u_shaderPick;\\n  float u_EnableSelect;\\n  float u_activeMix;\\n};\";\n/* babel-plugin-inline-import '../../shaders/common_light.glsl' */\nvar light = \"#define ambientRatio 0.5\\n#define diffuseRatio 0.3\\n#define specularRatio 0.2\\n\\n\\nfloat calc_lighting(vec4 pos) {\\n\\n    vec3 worldPos = vec3(pos * u_ModelMatrix);\\n\\n    vec3 worldNormal = a_Normal;\\n      // //cal light weight\\n    vec3 viewDir = normalize(u_CameraPosition - worldPos);\\n\\n    vec3 lightDir = normalize(vec3(1, -10.5, 12));\\n\\n    vec3 halfDir = normalize(viewDir+lightDir);\\n      // //lambert\\n    float lambert = dot(worldNormal, lightDir);\\n        //specular\\n    float specular = pow(max(0.0, dot(worldNormal, halfDir)), 32.0);\\n        //sum to light weight\\n    float lightWeight = ambientRatio + diffuseRatio * lambert + specularRatio * specular;\\n\\n    return lightWeight;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/lighting.glsl' */\nvar lighting = \"// Blinn-Phong model\\n// apply lighting in vertex shader instead of fragment shader\\n// @see https://learnopengl.com/Advanced-Lighting/Advanced-Lighting\\nuniform float u_Ambient : 1.0;\\nuniform float u_Diffuse : 1.0;\\nuniform float u_Specular : 1.0;\\nuniform int u_NumOfDirectionalLights : 1;\\nuniform int u_NumOfSpotLights : 0;\\n\\n#define SHININESS 32.0\\n#define MAX_NUM_OF_DIRECTIONAL_LIGHTS 3\\n#define MAX_NUM_OF_SPOT_LIGHTS 3\\n\\nstruct DirectionalLight {\\n  vec3 direction;\\n  vec3 ambient;\\n  vec3 diffuse;\\n  vec3 specular;\\n};\\n\\nstruct SpotLight {\\n  vec3 position;\\n  vec3 direction;\\n  vec3 ambient;\\n  vec3 diffuse;\\n  vec3 specular;\\n  float constant;\\n  float linear;\\n  float quadratic;\\n  float angle;\\n  float blur;\\n  float exponent;\\n};\\n\\nuniform DirectionalLight u_DirectionalLights[MAX_NUM_OF_DIRECTIONAL_LIGHTS];\\nuniform SpotLight u_SpotLights[MAX_NUM_OF_SPOT_LIGHTS];\\n\\nvec3 calc_directional_light(DirectionalLight light, vec3 normal, vec3 viewDir) {\\n  vec3 lightDir = normalize(light.direction);\\n  // diffuse shading\\n  float diff = max(dot(normal, lightDir), 0.0);\\n  // Blinn-Phong specular shading\\n  vec3 halfwayDir = normalize(lightDir + viewDir);\\n  float spec = pow(max(dot(normal, halfwayDir), 0.0), SHININESS);\\n\\n  vec3 ambient = light.ambient * u_Ambient;\\n  vec3 diffuse = light.diffuse * diff * u_Diffuse;\\n  vec3 specular = light.specular * spec * u_Specular;\\n\\n  return ambient + diffuse + specular;\\n}\\n\\n\\nvec3 calc_lighting(vec3 position, vec3 normal, vec3 viewDir) {\\n  vec3 weight = vec3(0.0);\\n  for (int i = 0; i < MAX_NUM_OF_DIRECTIONAL_LIGHTS; i++) {\\n    if (i >= u_NumOfDirectionalLights) {\\n      break;\\n    }\\n    weight += calc_directional_light(u_DirectionalLights[i], normal, viewDir);\\n  }\\n  return weight;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/picking.frag.glsl' */\nvar pickingFrag = \"\\nin vec4 v_PickingResult;\\n\\n#pragma include \\\"picking_uniforms\\\"\\n\\n#define PICKING_NONE 0.0\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\n#define HIGHLIGHT 1.0\\n#define SELECT 2.0\\n\\n/*\\n * Returns highlight color if this item is selected.\\n */\\nvec4 filterHighlightColor(vec4 color, float weight) {\\n  // float selected = v_PickingResult.a;\\n  bool selected = bool(v_PickingResult.a);\\n\\n  // if (selected == SELECT) {\\n  if (selected) {\\n  //   // \\u70B9\\u51FB\\u9009\\u4E2D\\u72B6\\u6001\\n  //   vec4 selectColor = u_SelectColor * COLOR_SCALE;\\n  //   return selectColor;\\n  // } else if (selected == HIGHLIGHT) {\\n  //   // hover \\u9AD8\\u4EAE\\u72B6\\u6001\\n    vec4 highLightColor = u_HighlightColor * COLOR_SCALE;\\n\\n    float highLightAlpha = highLightColor.a;\\n    float highLightRatio = highLightAlpha / (highLightAlpha + color.a * (1.0 - highLightAlpha));\\n\\n    vec3 resultRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\\n    return vec4(mix(resultRGB * weight, color.rgb, u_activeMix), color.a);\\n  } else {\\n    return color;\\n  }\\n}\\n\\n/*\\n * Returns picking color if picking enabled else unmodified argument.\\n */\\nvec4 filterPickingColor(vec4 color) {\\n  vec3 pickingColor = v_PickingResult.rgb;\\n  if (u_PickingStage == PICKING_ENCODE && length(pickingColor) < 0.001) {\\n    discard;\\n  }\\n  return u_PickingStage == PICKING_ENCODE ? vec4(pickingColor, step(0.001,color.a)): color;\\n}\\n\\n/*\\n * Returns picking color if picking is enabled if not\\n * highlight color if this item is selected, otherwise unmodified argument.\\n */\\nvec4 filterColor(vec4 color) {\\n  // \\u8FC7\\u6EE4\\u591A\\u4F59\\u7684 shader \\u8BA1\\u7B97\\n  // return color;\\n  if(u_shaderPick < 0.5) {\\n    return color; // \\u6682\\u65F6\\u53BB\\u9664 \\u76F4\\u63A5\\u53D6\\u6D88\\u8BA1\\u7B97\\u5728\\u9009\\u4E2D\\u65F6\\u62D6\\u62FD\\u5730\\u56FE\\u4F1A\\u6709\\u95EE\\u9898\\n  } else {\\n    return filterPickingColor(filterHighlightColor(color, 1.0));\\n  }\\n  \\n}\\n\\nvec4 filterColorAlpha(vec4 color, float alpha) {\\n  // \\u8FC7\\u6EE4\\u591A\\u4F59\\u7684 shader \\u8BA1\\u7B97\\n  // return color;\\n  if(u_shaderPick < 0.5) {\\n    return color; // \\u6682\\u65F6\\u53BB\\u9664 \\u76F4\\u63A5\\u53D6\\u6D88\\u8BA1\\u7B97\\u5728\\u9009\\u4E2D\\u65F6\\u62D6\\u62FD\\u5730\\u56FE\\u4F1A\\u6709\\u95EE\\u9898\\n  } else {\\n    return filterPickingColor(filterHighlightColor(color, alpha));\\n  }\\n}\\n\\n\";\n/* babel-plugin-inline-import '../../shaders/picking.vert.glsl' */\nvar pickingVert = \"layout(location = 3) in vec3 a_PickingColor;\\nout vec4 v_PickingResult;\\n\\n#pragma include \\\"picking_uniforms\\\"\\n\\n#define PICKING_NONE 0.0\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\n#define NORMAL 0.0\\n#define HIGHLIGHT 1.0\\n#define SELECT 2.0\\n\\nbool isVertexPicked(vec3 vertexColor) {\\n  return distance(vertexColor,u_PickingColor.rgb) < 0.01;\\n}\\n\\n// \\u5224\\u65AD\\u5F53\\u524D\\u70B9\\u662F\\u5426\\u5DF2\\u7ECF\\u88AB select \\u9009\\u4E2D\\nbool isVertexSelected(vec3 vertexColor) {\\n  return distance(vertexColor,u_CurrentSelectedId.rgb) < 0.01;\\n}\\n\\nvoid setPickingColor(vec3 pickingColor) {\\n  if(u_shaderPick < 0.5) {\\n    return;\\n  }\\n  // compares only in highlight stage\\n\\n  v_PickingResult.a = float((u_PickingStage == PICKING_HIGHLIGHT) && isVertexPicked(pickingColor));\\n\\n  // Stores the picking color so that the fragment shader can render it during picking\\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nfloat setPickingSize(float x) {\\n   return u_PickingStage == PICKING_ENCODE ? x + u_PickingBuffer : x;\\n}\\n\\nfloat setPickingOrder(float z) {\\n   bool selected = bool(v_PickingResult.a);\\n   return selected ? z + 1. : 0.;\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/project.glsl' */\nvar project = \"\\n#define E 2.718281828459045\\nvec2 ProjectFlat(vec2 lnglat){\\n  float maxs=85.0511287798;\\n  float lat=max(min(maxs,lnglat.y),-maxs);\\n  float scale= 268435456.;\\n  float d=PI/180.;\\n  float x=lnglat.x*d;\\n  float y=lat*d;\\n  y=log(tan((PI/4.)+(y/2.)));\\n\\n  float a=.5/PI,\\n  b=.5,\\n  c=-.5/PI;\\n  d=.5;\\n  x=scale*(a*x+b);\\n  y=scale*(c*y+d);\\n  return vec2(x,y);\\n}\\n\\nvec2 unProjectFlat(vec2 px){\\n  float a=.5/PI;\\n  float b=.5;\\n  float c=-.5/PI;\\n  float d=.5;\\n  float scale = 268435456.;\\n  float x=(px.x/scale-b)/a;\\n  float y=(px.y/scale-d)/c;\\n  y=(atan(pow(E,y))-(PI/4.))*2.;\\n  d=PI/180.;\\n  float lat=y/d;\\n  float lng=x/d;\\n  return vec2(lng,lat);\\n}\\n\\nfloat pixelDistance(vec2 from, vec2 to) {\\n vec2 a1 = ProjectFlat(from);\\n vec2 b1 = ProjectFlat(to);\\n return distance(a1, b1);\\n}\\n\\n// gaode2.0\\nvec2 customProject(vec2 lnglat) { // \\u7ECF\\u7EAC\\u5EA6 => \\u5E73\\u9762\\u5750\\u6807\\n  float t = lnglat.x;\\n  float e = lnglat.y;\\n  float Sm = 180.0 / PI;\\n  float Tm = 6378137.0;\\n  float Rm = PI / 180.0;\\n  float r = 85.0511287798;\\n  e = max(min(r, e), -r);\\n  t *= Rm;\\n  e *= Rm;\\n  e = log(tan(PI / 4.0 + e / 2.0));\\n  return vec2(t * Tm, e * Tm);\\n}\\n\\nvec2 unProjCustomCoord(vec2 point) { // \\u5E73\\u9762\\u5750\\u6807 => \\u7ECF\\u7EAC\\u5EA6\\n  float Sm = 57.29577951308232; //180 / Math.PI\\n  float Tm = 6378137.0;\\n  float t = point.x;\\n  float e = point.y;\\n  return vec2(t / Tm * Sm, (2.0 * atan(exp(e / Tm)) - PI / 2.0) * Sm);\\n}\\n\\n\\nfloat customPixelDistance(vec2 from, vec2 to) {\\n vec2 a1 = ProjectFlat(from);\\n vec2 b1 = ProjectFlat(to);\\n return distance(a1, b1);\\n}\";\n/* babel-plugin-inline-import '../../shaders/projection.glsl' */\nvar projection = \"#define TILE_SIZE 512.0\\n#define PI 3.1415926536\\n#define WORLD_SCALE TILE_SIZE / (PI * 2.0)\\n#define EARTH_CIRCUMFERENCE 40.03e6\\n\\n#define COORDINATE_SYSTEM_LNGLAT 1.0        // mapbox\\n#define COORDINATE_SYSTEM_LNGLAT_OFFSET 2.0 // mapbox offset\\n#define COORDINATE_SYSTEM_VECTOR_TILE 3.0\\n#define COORDINATE_SYSTEM_IDENTITY 4.0\\n#define COORDINATE_SYSTEM_P20 5.0           // amap\\n#define COORDINATE_SYSTEM_P20_OFFSET 6.0    // amap offset\\n#define COORDINATE_SYSTEM_METER_OFFSET 7.0\\n\\n#define COORDINATE_SYSTEM_P20_2 8.0         // amap2.0\\n#pragma include \\\"scene_uniforms\\\"\\n\\n\\n// web mercator coords -> world coords\\nvec2 project_mercator(vec2 lnglat) {\\n   if (u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.0\\n    return lnglat;\\n  }\\n  float x = lnglat.x;\\n  return vec2(\\n    radians(x) + PI,\\n    PI - log(tan(PI * 0.25 + radians(lnglat.y) * 0.5))\\n  );\\n}\\n\\nfloat project_scale(float meters) {\\n  return meters * u_PixelsPerMeter.z;\\n}\\n\\n\\n// offset coords -> world coords\\nvec4 project_offset(vec4 offset) {\\n  float dy = offset.y;\\n  dy = clamp(dy, -1., 1.);\\n  vec3 pixels_per_unit = u_PixelsPerDegree + u_PixelsPerDegree2 * dy;\\n  return vec4(offset.xyz * pixels_per_unit, offset.w);\\n}\\n\\nvec3 project_normal(vec3 normal) {\\n  vec4 normal_modelspace = u_ModelMatrix * vec4(normal, 0.0);\\n  return normalize(normal_modelspace.xyz * u_PixelsPerMeter);\\n}\\n\\nvec3 project_offset_normal(vec3 vector) {\\n  if (u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_LNGLAT - 0.01\\n    || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\\n    return normalize(vector * u_PixelsPerDegree);\\n  }\\n  return project_normal(vector);\\n}\\n// || u_CoordinateSystem < COORDINATE_SYSTEM_P20_OFFSET + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_P20_OFFSET - 0.01\\n// reverse Y\\nvec3 reverse_offset_normal(vec3 vector) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 ||u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET ) {\\n    return vector * vec3(1.0, -1.0, 1.0);\\n  }\\n\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.0\\n    return vector;\\n  }\\n  return vector;\\n}\\n\\nvec4 project_mvt_offset_position(vec4 position) {\\n  float a = COORDINATE_SYSTEM_LNGLAT_OFFSET;\\n  float b = COORDINATE_SYSTEM_P20_OFFSET;\\n  float c = COORDINATE_SYSTEM_LNGLAT;\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    return project_offset(vec4(0.0, 0.0, position.z, position.w));\\n  }\\n  if (u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_LNGLAT - 0.01) {\\n    return vec4(\\n      project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale,\\n      project_scale(position.z),\\n      position.w\\n    );\\n  }\\n  return position;\\n}\\n\\nvec4 project_position(vec4 position) {\\n  float a = COORDINATE_SYSTEM_LNGLAT_OFFSET;\\n  float b = COORDINATE_SYSTEM_P20_OFFSET;\\n  float c = COORDINATE_SYSTEM_LNGLAT;\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n    || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    float X = position.x - u_ViewportCenter.x;\\n    float Y = position.y - u_ViewportCenter.y;\\n    return project_offset(vec4(X, Y, position.z, position.w));\\n  }\\n  if (u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_LNGLAT - 0.01) {\\n    return vec4(\\n      project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale,\\n      project_scale(position.z),\\n      position.w\\n    );\\n  }\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20) {\\n    return vec4(\\n      (project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale - vec2(215440491., 106744817.)) * vec2(1., -1.),\\n      project_scale(position.z),\\n      position.w\\n    );\\n  }\\n\\n  // if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n \\n\\n  //    return vec4(\\n  //     position.xy,\\n  //     project_scale(position.z),\\n  //     position.w);\\n  // }\\n  return position;\\n\\n  // TODO: \\u74E6\\u7247\\u5750\\u6807\\u7CFB & \\u5E38\\u89C4\\u4E16\\u754C\\u5750\\u6807\\u7CFB\\n}\\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\\n  vec2 offset = pixels / u_ViewportSize * u_DevicePixelRatio * 2.0;\\n  return offset * u_FocalDistance;\\n}\\n\\n\\n\\nfloat project_pixel_allmap(float pixel) {\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\\n    return pixel * pow(2.0, u_Zoom);\\n  }\\n  return pixel * u_FocalDistance ;\\n}\\n\\n// \\u9002\\u914D\\u7EB9\\u7406\\u8D34\\u56FE\\u7684\\u7B49\\u50CF\\u7D20\\u5927\\u5C0F\\nfloat project_pixel_texture(float pixel) {\\n  // mapbox zoom > 12\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    return pixel * pow(0.5, u_Zoom) * u_FocalDistance ;\\n  }\\n\\n  // amap2 zoom > 12\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom))* u_FocalDistance ;\\n  }\\n\\n  // amap zoom > 12\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    return pixel * pow(0.5, u_Zoom)* u_FocalDistance ;\\n  }\\n\\n  // amap zoom < 12\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20) {\\n    return pixel * pow(2.0, (20.0 - u_Zoom))* u_FocalDistance ;\\n  }\\n  return pixel * 2.0 *  u_FocalDistance;;\\n}\\n\\n// \\u5728\\u4E0D\\u8BBA\\u4EC0\\u4E48\\u5E95\\u56FE\\u4E0B\\u9700\\u8981\\u7EDF\\u4E00\\u5904\\u7406\\u7684\\u65F6\\u5019\\u4F7F\\u7528\\nfloat project_float_pixel(float pixel) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // mapbox P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom))  * u_FocalDistance ;\\n  }\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    // amap P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom));\\n  }\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    // amap2 P20_2 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF3\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom))* u_FocalDistance ;\\n  }\\n  return pixel * u_FocalDistance;\\n}\\n\\n// Project meter into the unit of pixel which used in the camera world space\\nfloat project_float_meter(float meter) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // Since the zoom level uniform is updated by mapservice and it's alread been subtracted by 1\\n    // Not sure if we are supposed to do that again\\n   return meter;\\n  } else  {\\n    return project_float_pixel(meter);\\n  }\\n\\n  // TODO: change the following code to make adaptations for amap\\n  // return u_FocalDistance * TILE_SIZE * pow(2.0, u_Zoom) * meter / EARTH_CIRCUMFERENCE;\\n}\\n\\nfloat project_pixel(float pixel) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    // amap P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom)) * u_FocalDistance ;\\n  }\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    // amap2 P20_2 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF3\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom)) * u_FocalDistance ;\\n  }\\n  return pixel * u_FocalDistance;\\n}\\nvec2 project_pixel(vec2 pixel) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    // P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom)) * u_FocalDistance ;\\n  }\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    // P20_2 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF3\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom)) * u_FocalDistance ;\\n  }\\n  return pixel * -1. * u_FocalDistance;\\n}\\nvec3 project_pixel(vec3 pixel) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    // P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom)) *  u_FocalDistance ;\\n  }\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    // P20_2 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF3\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom))  * u_FocalDistance ;\\n  }\\n  return pixel * -1. * u_FocalDistance;\\n}\\n\\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // Needs to be divided with project_uCommonUnitsPerMeter\\n    position.w *= u_PixelsPerMeter.z;\\n  }\\n\\n  return viewProjectionMatrix * position + center;\\n}\\n\\n// Projects from common space coordinates to clip space\\nvec4 project_common_position_to_clipspace(vec4 position) {\\n  return project_common_position_to_clipspace(\\n    position,\\n    u_ViewProjectionMatrix,\\n    u_ViewportCenterProjection\\n  );\\n}\\n\\nvec4 unproject_clipspace_to_position(vec4 clipspacePos, mat4 u_InverseViewProjectionMatrix) {\\n  vec4 pos = u_InverseViewProjectionMatrix * (clipspacePos - u_ViewportCenterProjection);\\n\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // Needs to be divided with project_uCommonUnitsPerMeter\\n     pos.w = pos.w / u_PixelsPerMeter.z;\\n  }\\n  return pos;\\n}\\n\\n\\nbool isEqual( float a,  float b) {\\n    return  a< b + 0.001 && a > b - 0.001;\\n}\\n\\n// \\u652F\\u6301 GaodeV2\\u3001Mapbox\\nvec4 project_common_position_to_clipspace_v2(vec4 position) {\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\\n    return u_Mvp * position;\\n  } else {\\n    return project_common_position_to_clipspace(position);\\n  }\\n}\\n\";\n/* babel-plugin-inline-import '../../shaders/rotation_2d.glsl' */\nvar rotation_2d = \"vec2 rotate_matrix(vec2 v, float a) {\\n    float b = a / 180.0 * 3.1415926535897932384626433832795;\\n    float s = sin(b);\\n    float c = cos(b);\\n    mat2 m = mat2(c, s, -s, c);\\n    return m * v;\\n}\";\n/* babel-plugin-inline-import '../../shaders/sdf_2d.glsl' */\nvar sdf2d = \"/**\\n * 2D signed distance field functions\\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\\n */\\n\\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\\n\\nfloat sdCircle(vec2 p, float r) {\\n  return length(p) - r;\\n}\\n\\nfloat sdEquilateralTriangle(vec2 p) {\\n  float k = sqrt(3.0);\\n  p.x = abs(p.x) - 1.0;\\n  p.y = p.y + 1.0/k;\\n  if( p.x + k*p.y > 0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\\n  p.x -= clamp( p.x, -2.0, 0.0 );\\n  return -length(p)*sign(p.y);\\n}\\n\\nfloat sdBox(vec2 p, vec2 b) {\\n  vec2 d = abs(p)-b;\\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\\n}\\n\\nfloat sdPentagon(vec2 p, float r) {\\n  vec3 k = vec3(0.809016994,0.587785252,0.726542528);\\n  p.x = abs(p.x);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagon(vec2 p, float r) {\\n  vec3 k = vec3(-0.866025404,0.5,0.577350269);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdOctogon(vec2 p, float r) {\\n  vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\\n  p = abs(p);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagram(vec2 p, float r) {\\n  vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\\n  p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdRhombus(vec2 p, vec2 b) {\\n  vec2 q = abs(p);\\n  float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\\n  float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\\n  return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\\n}\\n\\nfloat sdVesica(vec2 p, float r, float d) {\\n  p = abs(p);\\n  float b = sqrt(r*r-d*d); // can delay this sqrt\\n  return ((p.y-b)*d>p.x*b)\\n          ? length(p-vec2(0.0,b))\\n          : length(p-vec2(-d,0.0))-r;\\n}\\n\";\nvar precisionRegExp = /precision\\s+(high|low|medium)p\\s+float/;\nvar globalDefaultprecision = '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif\\n';\nvar includeRegExp = /#pragma include ([\"^+\"]?[\"[a-zA-Z_0-9](.*)\"]*?)/g;\nvar REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nvar REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nvar ShaderModuleService = (_dec = injectable(), _dec(_class = /*#__PURE__*/function () {\n  function ShaderModuleService() {\n    _classCallCheck(this, ShaderModuleService);\n    _defineProperty(this, \"moduleCache\", {});\n    _defineProperty(this, \"rawContentCache\", {});\n  }\n  _createClass(ShaderModuleService, [{\n    key: \"registerBuiltinModules\",\n    value: function registerBuiltinModules() {\n      this.destroy();\n      this.registerModule('common', {\n        vs: common,\n        fs: common\n      });\n      this.registerModule('decode', {\n        vs: decode,\n        fs: ''\n      });\n      this.registerModule('scene_uniforms', {\n        vs: scene_uniforms,\n        fs: scene_uniforms\n      });\n      this.registerModule('picking_uniforms', {\n        vs: picking_uniforms,\n        fs: picking_uniforms\n      });\n      this.registerModule('projection', {\n        vs: projection,\n        fs: projection\n      });\n      this.registerModule('project', {\n        vs: project,\n        fs: ''\n      });\n      this.registerModule('sdf_2d', {\n        vs: '',\n        fs: sdf2d\n      });\n      this.registerModule('lighting', {\n        vs: lighting,\n        fs: ''\n      });\n      this.registerModule('light', {\n        vs: light,\n        fs: ''\n      });\n      this.registerModule('picking', {\n        vs: pickingVert,\n        fs: pickingFrag\n      });\n      this.registerModule('rotation_2d', {\n        vs: rotation_2d,\n        fs: ''\n      });\n    }\n  }, {\n    key: \"registerModule\",\n    value: function registerModule(moduleName, moduleParams) {\n      // prevent registering the same module multiple times\n      // if (this.rawContentCache[moduleName]) {\n      //   return;\n      // }\n\n      moduleParams.vs = moduleParams.vs.replace(/\\r\\n/g, '\\n'); // 将所有的\\r\\n替换为\\n\n      moduleParams.fs = moduleParams.fs.replace(/\\r\\n/g, '\\n'); // 将所有的\\r\\n替换为\\n\n      var vs = moduleParams.vs,\n        fs = moduleParams.fs,\n        declaredUniforms = moduleParams.uniforms,\n        inject = moduleParams.inject;\n      var _extractUniforms = extractUniforms(vs),\n        extractedVS = _extractUniforms.content,\n        vsUniforms = _extractUniforms.uniforms;\n      var _extractUniforms2 = extractUniforms(fs),\n        extractedFS = _extractUniforms2.content,\n        fsUniforms = _extractUniforms2.uniforms;\n      this.rawContentCache[moduleName] = {\n        fs: extractedFS,\n        inject: inject,\n        uniforms: _objectSpread(_objectSpread(_objectSpread({}, vsUniforms), fsUniforms), declaredUniforms),\n        vs: extractedVS\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.moduleCache = {};\n      this.rawContentCache = {};\n    }\n  }, {\n    key: \"getModule\",\n    value: function getModule(moduleName) {\n      var _this = this;\n      // TODO: cache module\n      // if (this.moduleCache[moduleName]) {\n      //   return this.moduleCache[moduleName];\n      // }\n\n      var rawVS = this.rawContentCache[moduleName].vs;\n      var rawFS = this.rawContentCache[moduleName].fs;\n      var inject = this.rawContentCache[moduleName].inject;\n      var declaredUniforms = {};\n      if (inject !== null && inject !== void 0 && inject['vs:#decl']) {\n        // 头部注入\n        rawVS = (inject === null || inject === void 0 ? void 0 : inject['vs:#decl']) + rawVS;\n        declaredUniforms = extractUniforms(inject === null || inject === void 0 ? void 0 : inject['vs:#decl']).uniforms;\n      }\n      if (inject !== null && inject !== void 0 && inject['vs:#main-start']) {\n        // main\n        rawVS = rawVS.replace(REGEX_START_OF_MAIN, function (match) {\n          return match + (inject === null || inject === void 0 ? void 0 : inject['vs:#main-start']);\n        });\n      }\n      if (inject !== null && inject !== void 0 && inject['fs:#decl']) {\n        // 头部注入\n        rawFS = (inject === null || inject === void 0 ? void 0 : inject['fs:#decl']) + rawFS;\n      }\n      var _this$processModule = this.processModule(rawVS, [], 'vs'),\n        vs = _this$processModule.content,\n        vsIncludeList = _this$processModule.includeList;\n      var _this$processModule2 = this.processModule(rawFS, [], 'fs'),\n        fs = _this$processModule2.content,\n        fsIncludeList = _this$processModule2.includeList;\n      var compiledFs = '';\n      // TODO: extract uniforms and their default values from GLSL\n      var uniforms = uniq(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce(function (prev, cur) {\n        return _objectSpread(_objectSpread({}, prev), _this.rawContentCache[cur].uniforms);\n      }, _objectSpread({}, declaredUniforms));\n\n      /**\n       * set default precision for fragment shader\n       * https://stackoverflow.com/questions/28540290/why-it-is-necessary-to-set-precision-for-the-fragment-shader\n       */\n      if (!precisionRegExp.test(fs)) {\n        compiledFs = compiledFs + globalDefaultprecision;\n      }\n      compiledFs = compiledFs + fs;\n      var compiledVs = '';\n      if (!precisionRegExp.test(vs)) {\n        compiledVs = compiledVs + globalDefaultprecision;\n      }\n      compiledVs = compiledVs + vs;\n      this.moduleCache[moduleName] = {\n        fs: compiledFs.trim(),\n        uniforms: uniforms,\n        vs: compiledVs.trim()\n      };\n      return this.moduleCache[moduleName];\n    }\n  }, {\n    key: \"processModule\",\n    value: function processModule(rawContent, includeList, type) {\n      var _this2 = this;\n      var compiled = rawContent.replace(includeRegExp, function (_, strMatch) {\n        var includeOpt = strMatch.split(' ');\n        var includeName = includeOpt[0].replace(/\"/g, '');\n        if (includeList.indexOf(includeName) > -1) {\n          return '';\n        }\n        var txt = _this2.rawContentCache[includeName][type];\n        includeList.push(includeName);\n        var _this2$processModule = _this2.processModule(txt, includeList, type),\n          content = _this2$processModule.content;\n        return content;\n      });\n      return {\n        content: compiled,\n        includeList: includeList\n      };\n    }\n  }, {\n    key: \"injectDefines\",\n    value: function injectDefines(defines) {\n      var defineStr = Object.keys(defines).reduce(function (prev, cur) {\n        return prev + \"#define \".concat(cur.toUpperCase(), \" \").concat(defines[cur], \";\\n\");\n      }, '\\n');\n      return defineStr;\n    }\n  }]);\n  return ShaderModuleService;\n}()) || _class);\nexport { ShaderModuleService as default };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}