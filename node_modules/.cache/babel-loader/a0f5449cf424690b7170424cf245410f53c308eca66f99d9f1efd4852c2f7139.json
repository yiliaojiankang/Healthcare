{"ast":null,"code":"function max(x) {\n  if (x.length === 0) {\n    throw new Error('max requires at least one data point');\n  }\n  var value = x[0];\n  for (var i = 1; i < x.length; i++) {\n    // On the first iteration of this loop, max is\n    // undefined and is thus made the maximum element in the array\n    if (x[i] > value) {\n      value = x[i];\n    }\n  }\n  return value * 1;\n}\nfunction min(x) {\n  if (x.length === 0) {\n    throw new Error('min requires at least one data point');\n  }\n  var value = x[0];\n  for (var i = 1; i < x.length; i++) {\n    // On the first iteration of this loop, min is\n    // undefined and is thus made the minimum element in the array\n    if (x[i] < value) {\n      value = x[i];\n    }\n  }\n  return value * 1;\n}\nfunction sum(x) {\n  // If the array is empty, we needn't bother computing its sum\n  if (x.length === 0) {\n    return 0;\n  }\n\n  // Initializing the sum as the first number in the array\n  var sumNum = x[0] * 1;\n  for (var i = 1; i < x.length; i++) {\n    sumNum += x[i] * 1;\n  }\n\n  // Returning the corrected sum\n  return sumNum;\n}\nfunction mean(x) {\n  if (x.length === 0) {\n    throw new Error('mean requires at least one data point');\n  }\n  return sum(x) / x.length;\n}\nfunction mode(x) {\n  if (x.length === 0) {\n    throw new Error('mean requires at least one data point');\n  }\n  if (x.length < 3) {\n    return x[0];\n  }\n  x.sort();\n  var last = x[0];\n  var value = NaN;\n  var maxSeen = 0;\n  var seenThis = 1;\n  for (var i = 1; i < x.length + 1; i++) {\n    if (x[i] !== last) {\n      if (seenThis > maxSeen) {\n        maxSeen = seenThis;\n        value = last;\n      }\n      seenThis = 1;\n      last = x[i];\n    } else {\n      seenThis++;\n    }\n  }\n  return value * 1;\n}\nexport { max, mean, min, mode, sum };\nexport var statMap = {\n  min: min,\n  max: max,\n  mean: mean,\n  sum: sum,\n  mode: mode\n};\nexport function getColumn(data, columnName) {\n  return data.map(function (item) {\n    return item[columnName];\n  });\n}\nexport function getSatByColumn(type, column) {\n  return statMap[type](column);\n}","map":{"version":3,"names":["max","x","length","Error","value","i","min","sum","sumNum","mean","mode","sort","last","NaN","maxSeen","seenThis","statMap","getColumn","data","columnName","map","item","getSatByColumn","type","column"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/l7-utils/es/statistics.js"],"sourcesContent":["function max(x) {\n  if (x.length === 0) {\n    throw new Error('max requires at least one data point');\n  }\n  var value = x[0];\n  for (var i = 1; i < x.length; i++) {\n    // On the first iteration of this loop, max is\n    // undefined and is thus made the maximum element in the array\n    if (x[i] > value) {\n      value = x[i];\n    }\n  }\n  return value * 1;\n}\nfunction min(x) {\n  if (x.length === 0) {\n    throw new Error('min requires at least one data point');\n  }\n  var value = x[0];\n  for (var i = 1; i < x.length; i++) {\n    // On the first iteration of this loop, min is\n    // undefined and is thus made the minimum element in the array\n    if (x[i] < value) {\n      value = x[i];\n    }\n  }\n  return value * 1;\n}\nfunction sum(x) {\n  // If the array is empty, we needn't bother computing its sum\n  if (x.length === 0) {\n    return 0;\n  }\n\n  // Initializing the sum as the first number in the array\n  var sumNum = x[0] * 1;\n  for (var i = 1; i < x.length; i++) {\n    sumNum += x[i] * 1;\n  }\n\n  // Returning the corrected sum\n  return sumNum;\n}\nfunction mean(x) {\n  if (x.length === 0) {\n    throw new Error('mean requires at least one data point');\n  }\n  return sum(x) / x.length;\n}\nfunction mode(x) {\n  if (x.length === 0) {\n    throw new Error('mean requires at least one data point');\n  }\n  if (x.length < 3) {\n    return x[0];\n  }\n  x.sort();\n  var last = x[0];\n  var value = NaN;\n  var maxSeen = 0;\n  var seenThis = 1;\n  for (var i = 1; i < x.length + 1; i++) {\n    if (x[i] !== last) {\n      if (seenThis > maxSeen) {\n        maxSeen = seenThis;\n        value = last;\n      }\n      seenThis = 1;\n      last = x[i];\n    } else {\n      seenThis++;\n    }\n  }\n  return value * 1;\n}\nexport { max, mean, min, mode, sum };\nexport var statMap = {\n  min: min,\n  max: max,\n  mean: mean,\n  sum: sum,\n  mode: mode\n};\nexport function getColumn(data, columnName) {\n  return data.map(function (item) {\n    return item[columnName];\n  });\n}\nexport function getSatByColumn(type, column) {\n  return statMap[type](column);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}