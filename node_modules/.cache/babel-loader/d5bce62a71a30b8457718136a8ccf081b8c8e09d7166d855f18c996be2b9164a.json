{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.polygonClipping = factory());\n})(this, function () {\n  'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  /**\n   * splaytree v3.1.0\n   * Fast Splay tree for Node and browser\n   *\n   * @author Alexander Milevski <info@w8r.name>\n   * @license MIT\n   * @preserve\n   */\n  var Node = /** @class */\n  function () {\n    function Node(key, data) {\n      this.next = null;\n      this.key = key;\n      this.data = data;\n      this.left = null;\n      this.right = null;\n    }\n    return Node;\n  }();\n  /* follows \"An implementation of top-down splaying\"\r\n   * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n   */\n\n  function DEFAULT_COMPARE(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n  /**\r\n   * Simple top down splay, not requiring i to be in the tree t.\r\n   */\n\n  function splay(i, t, comparator) {\n    var N = new Node(null, null);\n    var l = N;\n    var r = N;\n    while (true) {\n      var cmp = comparator(i, t.key); //if (i < t.key) {\n\n      if (cmp < 0) {\n        if (t.left === null) break; //if (i < t.left.key) {\n\n        if (comparator(i, t.left.key) < 0) {\n          var y = t.left;\n          /* rotate right */\n\n          t.left = y.right;\n          y.right = t;\n          t = y;\n          if (t.left === null) break;\n        }\n        r.left = t;\n        /* link right */\n\n        r = t;\n        t = t.left; //} else if (i > t.key) {\n      } else if (cmp > 0) {\n        if (t.right === null) break; //if (i > t.right.key) {\n\n        if (comparator(i, t.right.key) > 0) {\n          var y = t.right;\n          /* rotate left */\n\n          t.right = y.left;\n          y.left = t;\n          t = y;\n          if (t.right === null) break;\n        }\n        l.right = t;\n        /* link left */\n\n        l = t;\n        t = t.right;\n      } else break;\n    }\n    /* assemble */\n\n    l.right = t.left;\n    r.left = t.right;\n    t.left = N.right;\n    t.right = N.left;\n    return t;\n  }\n  function insert(i, data, t, comparator) {\n    var node = new Node(i, data);\n    if (t === null) {\n      node.left = node.right = null;\n      return node;\n    }\n    t = splay(i, t, comparator);\n    var cmp = comparator(i, t.key);\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp >= 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n    return node;\n  }\n  function split(key, v, comparator) {\n    var left = null;\n    var right = null;\n    if (v) {\n      v = splay(key, v, comparator);\n      var cmp = comparator(v.key, key);\n      if (cmp === 0) {\n        left = v.left;\n        right = v.right;\n      } else if (cmp < 0) {\n        right = v.right;\n        v.right = null;\n        left = v;\n      } else {\n        left = v.left;\n        v.left = null;\n        right = v;\n      }\n    }\n    return {\n      left: left,\n      right: right\n    };\n  }\n  function merge(left, right, comparator) {\n    if (right === null) return left;\n    if (left === null) return right;\n    right = splay(left.key, right, comparator);\n    right.left = left;\n    return right;\n  }\n  /**\r\n   * Prints level of the tree\r\n   */\n\n  function printRow(root, prefix, isTail, out, printNode) {\n    if (root) {\n      out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\n      var indent = prefix + (isTail ? '    ' : '│   ');\n      if (root.left) printRow(root.left, indent, false, out, printNode);\n      if (root.right) printRow(root.right, indent, true, out, printNode);\n    }\n  }\n  var Tree = /** @class */\n  function () {\n    function Tree(comparator) {\n      if (comparator === void 0) {\n        comparator = DEFAULT_COMPARE;\n      }\n      this._root = null;\n      this._size = 0;\n      this._comparator = comparator;\n    }\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\n\n    Tree.prototype.insert = function (key, data) {\n      this._size++;\n      return this._root = insert(key, data, this._root, this._comparator);\n    };\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\n\n    Tree.prototype.add = function (key, data) {\n      var node = new Node(key, data);\n      if (this._root === null) {\n        node.left = node.right = null;\n        this._size++;\n        this._root = node;\n      }\n      var comparator = this._comparator;\n      var t = splay(key, this._root, comparator);\n      var cmp = comparator(key, t.key);\n      if (cmp === 0) this._root = t;else {\n        if (cmp < 0) {\n          node.left = t.left;\n          node.right = t;\n          t.left = null;\n        } else if (cmp > 0) {\n          node.right = t.right;\n          node.left = t;\n          t.right = null;\n        }\n        this._size++;\n        this._root = node;\n      }\n      return this._root;\n    };\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\n\n    Tree.prototype.remove = function (key) {\n      this._root = this._remove(key, this._root, this._comparator);\n    };\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\n\n    Tree.prototype._remove = function (i, t, comparator) {\n      var x;\n      if (t === null) return null;\n      t = splay(i, t, comparator);\n      var cmp = comparator(i, t.key);\n      if (cmp === 0) {\n        /* found it */\n        if (t.left === null) {\n          x = t.right;\n        } else {\n          x = splay(i, t.left, comparator);\n          x.right = t.right;\n        }\n        this._size--;\n        return x;\n      }\n      return t;\n      /* It wasn't there */\n    };\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\n\n    Tree.prototype.pop = function () {\n      var node = this._root;\n      if (node) {\n        while (node.left) {\n          node = node.left;\n        }\n        this._root = splay(node.key, this._root, this._comparator);\n        this._root = this._remove(node.key, this._root, this._comparator);\n        return {\n          key: node.key,\n          data: node.data\n        };\n      }\n      return null;\n    };\n    /**\r\n     * Find without splaying\r\n     */\n\n    Tree.prototype.findStatic = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n      return null;\n    };\n    Tree.prototype.find = function (key) {\n      if (this._root) {\n        this._root = splay(key, this._root, this._comparator);\n        if (this._comparator(key, this._root.key) !== 0) return null;\n      }\n      return this._root;\n    };\n    Tree.prototype.contains = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n      return false;\n    };\n    Tree.prototype.forEach = function (visitor, ctx) {\n      var current = this._root;\n      var Q = [];\n      /* Initialize stack s */\n\n      var done = false;\n      while (!done) {\n        if (current !== null) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length !== 0) {\n            current = Q.pop();\n            visitor.call(ctx, current);\n            current = current.right;\n          } else done = true;\n        }\n      }\n      return this;\n    };\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\n\n    Tree.prototype.range = function (low, high, fn, ctx) {\n      var Q = [];\n      var compare = this._comparator;\n      var node = this._root;\n      var cmp;\n      while (Q.length !== 0 || node) {\n        if (node) {\n          Q.push(node);\n          node = node.left;\n        } else {\n          node = Q.pop();\n          cmp = compare(node.key, high);\n          if (cmp > 0) {\n            break;\n          } else if (compare(node.key, low) >= 0) {\n            if (fn.call(ctx, node)) return this; // stop if smth is returned\n          }\n\n          node = node.right;\n        }\n      }\n      return this;\n    };\n    /**\r\n     * Returns array of keys\r\n     */\n\n    Tree.prototype.keys = function () {\n      var keys = [];\n      this.forEach(function (_a) {\n        var key = _a.key;\n        return keys.push(key);\n      });\n      return keys;\n    };\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\n\n    Tree.prototype.values = function () {\n      var values = [];\n      this.forEach(function (_a) {\n        var data = _a.data;\n        return values.push(data);\n      });\n      return values;\n    };\n    Tree.prototype.min = function () {\n      if (this._root) return this.minNode(this._root).key;\n      return null;\n    };\n    Tree.prototype.max = function () {\n      if (this._root) return this.maxNode(this._root).key;\n      return null;\n    };\n    Tree.prototype.minNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n      if (t) while (t.left) {\n        t = t.left;\n      }\n      return t;\n    };\n    Tree.prototype.maxNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n      if (t) while (t.right) {\n        t = t.right;\n      }\n      return t;\n    };\n    /**\r\n     * Returns node at given index\r\n     */\n\n    Tree.prototype.at = function (index) {\n      var current = this._root;\n      var done = false;\n      var i = 0;\n      var Q = [];\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length > 0) {\n            current = Q.pop();\n            if (i === index) return current;\n            i++;\n            current = current.right;\n          } else done = true;\n        }\n      }\n      return null;\n    };\n    Tree.prototype.next = function (d) {\n      var root = this._root;\n      var successor = null;\n      if (d.right) {\n        successor = d.right;\n        while (successor.left) {\n          successor = successor.left;\n        }\n        return successor;\n      }\n      var comparator = this._comparator;\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) {\n          successor = root;\n          root = root.left;\n        } else root = root.right;\n      }\n      return successor;\n    };\n    Tree.prototype.prev = function (d) {\n      var root = this._root;\n      var predecessor = null;\n      if (d.left !== null) {\n        predecessor = d.left;\n        while (predecessor.right) {\n          predecessor = predecessor.right;\n        }\n        return predecessor;\n      }\n      var comparator = this._comparator;\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {\n          predecessor = root;\n          root = root.right;\n        }\n      }\n      return predecessor;\n    };\n    Tree.prototype.clear = function () {\n      this._root = null;\n      this._size = 0;\n      return this;\n    };\n    Tree.prototype.toList = function () {\n      return toList(this._root);\n    };\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\n\n    Tree.prototype.load = function (keys, values, presort) {\n      if (values === void 0) {\n        values = [];\n      }\n      if (presort === void 0) {\n        presort = false;\n      }\n      var size = keys.length;\n      var comparator = this._comparator; // sort if needed\n\n      if (presort) sort(keys, values, 0, size - 1, comparator);\n      if (this._root === null) {\n        // empty tree\n        this._root = loadRecursive(keys, values, 0, size);\n        this._size = size;\n      } else {\n        // that re-builds the whole tree from two in-order traversals\n        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n        size = this._size + size;\n        this._root = sortedListToBST({\n          head: mergedList\n        }, 0, size);\n      }\n      return this;\n    };\n    Tree.prototype.isEmpty = function () {\n      return this._root === null;\n    };\n    Object.defineProperty(Tree.prototype, \"size\", {\n      get: function get() {\n        return this._size;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(Tree.prototype, \"root\", {\n      get: function get() {\n        return this._root;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Tree.prototype.toString = function (printNode) {\n      if (printNode === void 0) {\n        printNode = function printNode(n) {\n          return String(n.key);\n        };\n      }\n      var out = [];\n      printRow(this._root, '', true, function (v) {\n        return out.push(v);\n      }, printNode);\n      return out.join('');\n    };\n    Tree.prototype.update = function (key, newKey, newData) {\n      var comparator = this._comparator;\n      var _a = split(key, this._root, comparator),\n        left = _a.left,\n        right = _a.right;\n      if (comparator(key, newKey) < 0) {\n        right = insert(newKey, newData, right, comparator);\n      } else {\n        left = insert(newKey, newData, left, comparator);\n      }\n      this._root = merge(left, right, comparator);\n    };\n    Tree.prototype.split = function (key) {\n      return split(key, this._root, this._comparator);\n    };\n    return Tree;\n  }();\n  function loadRecursive(keys, values, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key = keys[middle];\n      var data = values[middle];\n      var node = new Node(key, data);\n      node.left = loadRecursive(keys, values, start, middle);\n      node.right = loadRecursive(keys, values, middle + 1, end);\n      return node;\n    }\n    return null;\n  }\n  function createList(keys, values) {\n    var head = new Node(null, null);\n    var p = head;\n    for (var i = 0; i < keys.length; i++) {\n      p = p.next = new Node(keys[i], values[i]);\n    }\n    p.next = null;\n    return head.next;\n  }\n  function toList(root) {\n    var current = root;\n    var Q = [];\n    var done = false;\n    var head = new Node(null, null);\n    var p = head;\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = p = p.next = Q.pop();\n          current = current.right;\n        } else done = true;\n      }\n    }\n    p.next = null; // that'll work even if the tree was empty\n\n    return head.next;\n  }\n  function sortedListToBST(list, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var left = sortedListToBST(list, start, middle);\n      var root = list.head;\n      root.left = left;\n      list.head = list.head.next;\n      root.right = sortedListToBST(list, middle + 1, end);\n      return root;\n    }\n    return null;\n  }\n  function mergeLists(l1, l2, compare) {\n    var head = new Node(null, null); // dummy\n\n    var p = head;\n    var p1 = l1;\n    var p2 = l2;\n    while (p1 !== null && p2 !== null) {\n      if (compare(p1.key, p2.key) < 0) {\n        p.next = p1;\n        p1 = p1.next;\n      } else {\n        p.next = p2;\n        p2 = p2.next;\n      }\n      p = p.next;\n    }\n    if (p1 !== null) {\n      p.next = p1;\n    } else if (p2 !== null) {\n      p.next = p2;\n    }\n    return head.next;\n  }\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) return;\n    var pivot = keys[left + right >> 1];\n    var i = left - 1;\n    var j = right + 1;\n    while (true) {\n      do {\n        i++;\n      } while (compare(keys[i], pivot) < 0);\n      do {\n        j--;\n      } while (compare(keys[j], pivot) > 0);\n      if (i >= j) break;\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n    sort(keys, values, left, j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  /**\n   * A bounding box has the format:\n   *\n   *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n   *\n   */\n  var isInBbox = function isInBbox(bbox, point) {\n    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n  };\n  /* Returns either null, or a bbox (aka an ordered pair of points)\n   * If there is only one point of overlap, a bbox with identical points\n   * will be returned */\n\n  var getBboxOverlap = function getBboxOverlap(b1, b2) {\n    // check if the bboxes overlap at all\n    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n    var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n    var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n    var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n    var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n    return {\n      ll: {\n        x: lowerX,\n        y: lowerY\n      },\n      ur: {\n        x: upperX,\n        y: upperY\n      }\n    };\n  };\n\n  /* Javascript doesn't do integer math. Everything is\n   * floating point with percision Number.EPSILON.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n   */\n  var epsilon = Number.EPSILON; // IE Polyfill\n\n  if (epsilon === undefined) epsilon = Math.pow(2, -52);\n  var EPSILON_SQ = epsilon * epsilon;\n  /* FLP comparator */\n\n  var cmp = function cmp(a, b) {\n    // check if they're both 0\n    if (-epsilon < a && a < epsilon) {\n      if (-epsilon < b && b < epsilon) {\n        return 0;\n      }\n    } // check if they're flp equal\n\n    var ab = a - b;\n    if (ab * ab < EPSILON_SQ * a * b) {\n      return 0;\n    } // normal comparison\n\n    return a < b ? -1 : 1;\n  };\n\n  /**\n   * This class rounds incoming values sufficiently so that\n   * floating points problems are, for the most part, avoided.\n   *\n   * Incoming points are have their x & y values tested against\n   * all previously seen x & y values. If either is 'too close'\n   * to a previously seen value, it's value is 'snapped' to the\n   * previously seen value.\n   *\n   * All points should be rounded by this class before being\n   * stored in any data structures in the rest of this algorithm.\n   */\n\n  var PtRounder = /*#__PURE__*/function () {\n    function PtRounder() {\n      _classCallCheck(this, PtRounder);\n      this.reset();\n    }\n    _createClass(PtRounder, [{\n      key: \"reset\",\n      value: function reset() {\n        this.xRounder = new CoordRounder();\n        this.yRounder = new CoordRounder();\n      }\n    }, {\n      key: \"round\",\n      value: function round(x, y) {\n        return {\n          x: this.xRounder.round(x),\n          y: this.yRounder.round(y)\n        };\n      }\n    }]);\n    return PtRounder;\n  }();\n  var CoordRounder = /*#__PURE__*/function () {\n    function CoordRounder() {\n      _classCallCheck(this, CoordRounder);\n      this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n      this.round(0);\n    } // Note: this can rounds input values backwards or forwards.\n    //       You might ask, why not restrict this to just rounding\n    //       forwards? Wouldn't that allow left endpoints to always\n    //       remain left endpoints during splitting (never change to\n    //       right). No - it wouldn't, because we snap intersections\n    //       to endpoints (to establish independence from the segment\n    //       angle for t-intersections).\n\n    _createClass(CoordRounder, [{\n      key: \"round\",\n      value: function round(coord) {\n        var node = this.tree.add(coord);\n        var prevNode = this.tree.prev(node);\n        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n          this.tree.remove(coord);\n          return prevNode.key;\n        }\n        var nextNode = this.tree.next(node);\n        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n          this.tree.remove(coord);\n          return nextNode.key;\n        }\n        return coord;\n      }\n    }]);\n    return CoordRounder;\n  }(); // singleton available by import\n\n  var rounder = new PtRounder();\n\n  /* Cross Product of two vectors with first point at origin */\n\n  var crossProduct = function crossProduct(a, b) {\n    return a.x * b.y - a.y * b.x;\n  };\n  /* Dot Product of two vectors with first point at origin */\n\n  var dotProduct = function dotProduct(a, b) {\n    return a.x * b.x + a.y * b.y;\n  };\n  /* Comparator for two vectors with same starting point */\n\n  var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n    var v1 = {\n      x: endPt1.x - basePt.x,\n      y: endPt1.y - basePt.y\n    };\n    var v2 = {\n      x: endPt2.x - basePt.x,\n      y: endPt2.y - basePt.y\n    };\n    var kross = crossProduct(v1, v2);\n    return cmp(kross, 0);\n  };\n  var length = function length(v) {\n    return Math.sqrt(dotProduct(v, v));\n  };\n  /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n  var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n  var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the x coordinate where the given line (defined by a point and vector)\n   * crosses the horizontal line with the given y coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var horizontalIntersection = function horizontalIntersection(pt, v, y) {\n    if (v.y === 0) return null;\n    return {\n      x: pt.x + v.x / v.y * (y - pt.y),\n      y: y\n    };\n  };\n  /* Get the y coordinate where the given line (defined by a point and vector)\n   * crosses the vertical line with the given x coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var verticalIntersection = function verticalIntersection(pt, v, x) {\n    if (v.x === 0) return null;\n    return {\n      x: x,\n      y: pt.y + v.y / v.x * (x - pt.x)\n    };\n  };\n  /* Get the intersection of two lines, each defined by a base point and a vector.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var intersection = function intersection(pt1, v1, pt2, v2) {\n    // take some shortcuts for vertical and horizontal lines\n    // this also ensures we don't calculate an intersection and then discover\n    // it's actually outside the bounding box of the line\n    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n    // This algorithm is based on Schneider and Eberly.\n    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n    var kross = crossProduct(v1, v2);\n    if (kross == 0) return null;\n    var ve = {\n      x: pt2.x - pt1.x,\n      y: pt2.y - pt1.y\n    };\n    var d1 = crossProduct(ve, v1) / kross;\n    var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n    var x1 = pt1.x + d2 * v1.x,\n      x2 = pt2.x + d1 * v2.x;\n    var y1 = pt1.y + d2 * v1.y,\n      y2 = pt2.y + d1 * v2.y;\n    var x = (x1 + x2) / 2;\n    var y = (y1 + y2) / 2;\n    return {\n      x: x,\n      y: y\n    };\n  };\n  var SweepEvent = /*#__PURE__*/function () {\n    _createClass(SweepEvent, null, [{\n      key: \"compare\",\n      // for ordering sweep events in the sweep event queue\n      value: function compare(a, b) {\n        // favor event with a point that the sweep line hits first\n        var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n        if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n        if (a.point !== b.point) a.link(b); // favor right events over left\n\n        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n        // ordering of this case is the same as for their segments\n\n        return Segment.compare(a.segment, b.segment);\n      } // for ordering points in sweep line order\n    }, {\n      key: \"comparePoints\",\n      value: function comparePoints(aPt, bPt) {\n        if (aPt.x < bPt.x) return -1;\n        if (aPt.x > bPt.x) return 1;\n        if (aPt.y < bPt.y) return -1;\n        if (aPt.y > bPt.y) return 1;\n        return 0;\n      } // Warning: 'point' input will be modified and re-used (for performance)\n    }]);\n\n    function SweepEvent(point, isLeft) {\n      _classCallCheck(this, SweepEvent);\n      if (point.events === undefined) point.events = [this];else point.events.push(this);\n      this.point = point;\n      this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n    }\n\n    _createClass(SweepEvent, [{\n      key: \"link\",\n      value: function link(other) {\n        if (other.point === this.point) {\n          throw new Error('Tried to link already linked events');\n        }\n        var otherEvents = other.point.events;\n        for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n          var evt = otherEvents[i];\n          this.point.events.push(evt);\n          evt.point = this.point;\n        }\n        this.checkForConsuming();\n      }\n      /* Do a pass over our linked events and check to see if any pair\n       * of segments match, and should be consumed. */\n    }, {\n      key: \"checkForConsuming\",\n      value: function checkForConsuming() {\n        // FIXME: The loops in this method run O(n^2) => no good.\n        //        Maintain little ordered sweep event trees?\n        //        Can we maintaining an ordering that avoids the need\n        //        for the re-sorting with getLeftmostComparator in geom-out?\n        // Compare each pair of events to see if other events also match\n        var numEvents = this.point.events.length;\n        for (var i = 0; i < numEvents; i++) {\n          var evt1 = this.point.events[i];\n          if (evt1.segment.consumedBy !== undefined) continue;\n          for (var j = i + 1; j < numEvents; j++) {\n            var evt2 = this.point.events[j];\n            if (evt2.consumedBy !== undefined) continue;\n            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n            evt1.segment.consume(evt2.segment);\n          }\n        }\n      }\n    }, {\n      key: \"getAvailableLinkedEvents\",\n      value: function getAvailableLinkedEvents() {\n        // point.events is always of length 2 or greater\n        var events = [];\n        for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n          var evt = this.point.events[i];\n          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n            events.push(evt);\n          }\n        }\n        return events;\n      }\n      /**\n       * Returns a comparator function for sorting linked events that will\n       * favor the event that will give us the smallest left-side angle.\n       * All ring construction starts as low as possible heading to the right,\n       * so by always turning left as sharp as possible we'll get polygons\n       * without uncessary loops & holes.\n       *\n       * The comparator function has a compute cache such that it avoids\n       * re-computing already-computed values.\n       */\n    }, {\n      key: \"getLeftmostComparator\",\n      value: function getLeftmostComparator(baseEvent) {\n        var _this = this;\n        var cache = new Map();\n        var fillCache = function fillCache(linkedEvent) {\n          var nextEvent = linkedEvent.otherSE;\n          cache.set(linkedEvent, {\n            sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n            cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n          });\n        };\n        return function (a, b) {\n          if (!cache.has(a)) fillCache(a);\n          if (!cache.has(b)) fillCache(b);\n          var _cache$get = cache.get(a),\n            asine = _cache$get.sine,\n            acosine = _cache$get.cosine;\n          var _cache$get2 = cache.get(b),\n            bsine = _cache$get2.sine,\n            bcosine = _cache$get2.cosine; // both on or above x-axis\n\n          if (asine >= 0 && bsine >= 0) {\n            if (acosine < bcosine) return 1;\n            if (acosine > bcosine) return -1;\n            return 0;\n          } // both below x-axis\n\n          if (asine < 0 && bsine < 0) {\n            if (acosine < bcosine) return -1;\n            if (acosine > bcosine) return 1;\n            return 0;\n          } // one above x-axis, one below\n\n          if (bsine < asine) return -1;\n          if (bsine > asine) return 1;\n          return 0;\n        };\n      }\n    }]);\n    return SweepEvent;\n  }();\n\n  // segments and sweep events when all else is identical\n\n  var segmentId = 0;\n  var Segment = /*#__PURE__*/function () {\n    _createClass(Segment, null, [{\n      key: \"compare\",\n      /* This compare() function is for ordering segments in the sweep\n       * line tree, and does so according to the following criteria:\n       *\n       * Consider the vertical line that lies an infinestimal step to the\n       * right of the right-more of the two left endpoints of the input\n       * segments. Imagine slowly moving a point up from negative infinity\n       * in the increasing y direction. Which of the two segments will that\n       * point intersect first? That segment comes 'before' the other one.\n       *\n       * If neither segment would be intersected by such a line, (if one\n       * or more of the segments are vertical) then the line to be considered\n       * is directly on the right-more of the two left inputs.\n       */\n      value: function compare(a, b) {\n        var alx = a.leftSE.point.x;\n        var blx = b.leftSE.point.x;\n        var arx = a.rightSE.point.x;\n        var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n        if (brx < alx) return 1;\n        if (arx < blx) return -1;\n        var aly = a.leftSE.point.y;\n        var bly = b.leftSE.point.y;\n        var ary = a.rightSE.point.y;\n        var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n        if (alx < blx) {\n          // are the two segments in the same horizontal plane?\n          if (bly < aly && bly < ary) return 1;\n          if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n          var aCmpBLeft = a.comparePoint(b.leftSE.point);\n          if (aCmpBLeft < 0) return 1;\n          if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n          var bCmpARight = b.comparePoint(a.rightSE.point);\n          if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return -1;\n        } // is left endpoint of segment A the right-more?\n\n        if (alx > blx) {\n          if (aly < bly && aly < bry) return -1;\n          if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n          var bCmpALeft = b.comparePoint(a.leftSE.point);\n          if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n          var aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (aCmpBRight < 0) return 1;\n          if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return 1;\n        } // if we get here, the two left endpoints are in the same\n        // vertical plane, ie alx === blx\n        // consider the lower left-endpoint to come first\n\n        if (aly < bly) return -1;\n        if (aly > bly) return 1; // left endpoints are identical\n        // check for colinearity by using the left-more right endpoint\n        // is the A right endpoint more left-more?\n\n        if (arx < brx) {\n          var _bCmpARight = b.comparePoint(a.rightSE.point);\n          if (_bCmpARight !== 0) return _bCmpARight;\n        } // is the B right endpoint more left-more?\n\n        if (arx > brx) {\n          var _aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (_aCmpBRight < 0) return 1;\n          if (_aCmpBRight > 0) return -1;\n        }\n        if (arx !== brx) {\n          // are these two [almost] vertical segments with opposite orientation?\n          // if so, the one with the lower right endpoint comes first\n          var ay = ary - aly;\n          var ax = arx - alx;\n          var by = bry - bly;\n          var bx = brx - blx;\n          if (ay > ax && by < bx) return 1;\n          if (ay < ax && by > bx) return -1;\n        } // we have colinear segments with matching orientation\n        // consider the one with more left-more right endpoint to be first\n\n        if (arx > brx) return 1;\n        if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n        // vertical plane, ie arx === brx\n        // consider the lower right-endpoint to come first\n\n        if (ary < bry) return -1;\n        if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n        // fall back on creation order as consistent tie-breaker\n\n        if (a.id < b.id) return -1;\n        if (a.id > b.id) return 1; // identical segment, ie a === b\n\n        return 0;\n      }\n      /* Warning: a reference to ringWindings input will be stored,\n       *  and possibly will be later modified */\n    }]);\n\n    function Segment(leftSE, rightSE, rings, windings) {\n      _classCallCheck(this, Segment);\n      this.id = ++segmentId;\n      this.leftSE = leftSE;\n      leftSE.segment = this;\n      leftSE.otherSE = rightSE;\n      this.rightSE = rightSE;\n      rightSE.segment = this;\n      rightSE.otherSE = leftSE;\n      this.rings = rings;\n      this.windings = windings; // left unset for performance, set later in algorithm\n      // this.ringOut, this.consumedBy, this.prev\n    }\n\n    _createClass(Segment, [{\n      key: \"replaceRightSE\",\n      /* When a segment is split, the rightSE is replaced with a new sweep event */\n      value: function replaceRightSE(newRightSE) {\n        this.rightSE = newRightSE;\n        this.rightSE.segment = this;\n        this.rightSE.otherSE = this.leftSE;\n        this.leftSE.otherSE = this.rightSE;\n      }\n    }, {\n      key: \"bbox\",\n      value: function bbox() {\n        var y1 = this.leftSE.point.y;\n        var y2 = this.rightSE.point.y;\n        return {\n          ll: {\n            x: this.leftSE.point.x,\n            y: y1 < y2 ? y1 : y2\n          },\n          ur: {\n            x: this.rightSE.point.x,\n            y: y1 > y2 ? y1 : y2\n          }\n        };\n      }\n      /* A vector from the left point to the right */\n    }, {\n      key: \"vector\",\n      value: function vector() {\n        return {\n          x: this.rightSE.point.x - this.leftSE.point.x,\n          y: this.rightSE.point.y - this.leftSE.point.y\n        };\n      }\n    }, {\n      key: \"isAnEndpoint\",\n      value: function isAnEndpoint(pt) {\n        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n      }\n      /* Compare this segment with a point.\n       *\n       * A point P is considered to be colinear to a segment if there\n       * exists a distance D such that if we travel along the segment\n       * from one * endpoint towards the other a distance D, we find\n       * ourselves at point P.\n       *\n       * Return value indicates:\n       *\n       *   1: point lies above the segment (to the left of vertical)\n       *   0: point is colinear to segment\n       *  -1: point lies below the segment (to the right of vertical)\n       */\n    }, {\n      key: \"comparePoint\",\n      value: function comparePoint(point) {\n        if (this.isAnEndpoint(point)) return 0;\n        var lPt = this.leftSE.point;\n        var rPt = this.rightSE.point;\n        var v = this.vector(); // Exactly vertical segments.\n\n        if (lPt.x === rPt.x) {\n          if (point.x === lPt.x) return 0;\n          return point.x < lPt.x ? 1 : -1;\n        } // Nearly vertical segments with an intersection.\n        // Check to see where a point on the line with matching Y coordinate is.\n\n        var yDist = (point.y - lPt.y) / v.y;\n        var xFromYDist = lPt.x + yDist * v.x;\n        if (point.x === xFromYDist) return 0; // General case.\n        // Check to see where a point on the line with matching X coordinate is.\n\n        var xDist = (point.x - lPt.x) / v.x;\n        var yFromXDist = lPt.y + xDist * v.y;\n        if (point.y === yFromXDist) return 0;\n        return point.y < yFromXDist ? -1 : 1;\n      }\n      /**\n       * Given another segment, returns the first non-trivial intersection\n       * between the two segments (in terms of sweep line ordering), if it exists.\n       *\n       * A 'non-trivial' intersection is one that will cause one or both of the\n       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n       *\n       *   * endpoint of segA with endpoint of segB --> trivial\n       *   * endpoint of segA with point along segB --> non-trivial\n       *   * endpoint of segB with point along segA --> non-trivial\n       *   * point along segA with point along segB --> non-trivial\n       *\n       * If no non-trivial intersection exists, return null\n       * Else, return null.\n       */\n    }, {\n      key: \"getIntersection\",\n      value: function getIntersection(other) {\n        // If bboxes don't overlap, there can't be any intersections\n        var tBbox = this.bbox();\n        var oBbox = other.bbox();\n        var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n        if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n        // This will 'snap' intersections to endpoints if possible, and will\n        // handle cases of colinearity.\n\n        var tlp = this.leftSE.point;\n        var trp = this.rightSE.point;\n        var olp = other.leftSE.point;\n        var orp = other.rightSE.point; // does each endpoint touch the other segment?\n        // note that we restrict the 'touching' definition to only allow segments\n        // to touch endpoints that lie forward from where we are in the sweep line pass\n\n        var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n        var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n        var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n        var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n        if (touchesThisLSE && touchesOtherLSE) {\n          // these two cases are for colinear segments with matching left\n          // endpoints, and one segment being longer than the other\n          if (touchesThisRSE && !touchesOtherRSE) return trp;\n          if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n          // or just on their left endpoint (one trivial intersection\n\n          return null;\n        } // does this left endpoint matches (other doesn't)\n\n        if (touchesThisLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesOtherRSE) {\n            if (tlp.x === orp.x && tlp.y === orp.y) return null;\n          } // t-intersection on left endpoint\n\n          return tlp;\n        } // does other left endpoint matches (this doesn't)\n\n        if (touchesOtherLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesThisRSE) {\n            if (trp.x === olp.x && trp.y === olp.y) return null;\n          } // t-intersection on left endpoint\n\n          return olp;\n        } // trivial intersection on right endpoints\n\n        if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n        if (touchesThisRSE) return trp;\n        if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n        // infinite lines laid over the segments\n\n        var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n        // they would have an endpoint intersection and that case was already handled above\n\n        if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n        if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n        return rounder.round(pt.x, pt.y);\n      }\n      /**\n       * Split the given segment into multiple segments on the given points.\n       *  * Each existing segment will retain its leftSE and a new rightSE will be\n       *    generated for it.\n       *  * A new segment will be generated which will adopt the original segment's\n       *    rightSE, and a new leftSE will be generated for it.\n       *  * If there are more than two points given to split on, new segments\n       *    in the middle will be generated with new leftSE and rightSE's.\n       *  * An array of the newly generated SweepEvents will be returned.\n       *\n       * Warning: input array of points is modified\n       */\n    }, {\n      key: \"split\",\n      value: function split(point) {\n        var newEvents = [];\n        var alreadyLinked = point.events !== undefined;\n        var newLeftSE = new SweepEvent(point, true);\n        var newRightSE = new SweepEvent(point, false);\n        var oldRightSE = this.rightSE;\n        this.replaceRightSE(newRightSE);\n        newEvents.push(newRightSE);\n        newEvents.push(newLeftSE);\n        var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n        // sometimes one of the resulting new segments is vertical, in which\n        // case its left and right events may need to be swapped\n\n        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n          newSeg.swapEvents();\n        }\n        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n          this.swapEvents();\n        } // in the point we just used to create new sweep events with was already\n        // linked to other events, we need to check if either of the affected\n        // segments should be consumed\n\n        if (alreadyLinked) {\n          newLeftSE.checkForConsuming();\n          newRightSE.checkForConsuming();\n        }\n        return newEvents;\n      }\n      /* Swap which event is left and right */\n    }, {\n      key: \"swapEvents\",\n      value: function swapEvents() {\n        var tmpEvt = this.rightSE;\n        this.rightSE = this.leftSE;\n        this.leftSE = tmpEvt;\n        this.leftSE.isLeft = true;\n        this.rightSE.isLeft = false;\n        for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n          this.windings[i] *= -1;\n        }\n      }\n      /* Consume another segment. We take their rings under our wing\n       * and mark them as consumed. Use for perfectly overlapping segments */\n    }, {\n      key: \"consume\",\n      value: function consume(other) {\n        var consumer = this;\n        var consumee = other;\n        while (consumer.consumedBy) {\n          consumer = consumer.consumedBy;\n        }\n        while (consumee.consumedBy) {\n          consumee = consumee.consumedBy;\n        }\n        var cmp = Segment.compare(consumer, consumee);\n        if (cmp === 0) return; // already consumed\n        // the winner of the consumption is the earlier segment\n        // according to sweep line ordering\n\n        if (cmp > 0) {\n          var tmp = consumer;\n          consumer = consumee;\n          consumee = tmp;\n        } // make sure a segment doesn't consume it's prev\n\n        if (consumer.prev === consumee) {\n          var _tmp = consumer;\n          consumer = consumee;\n          consumee = _tmp;\n        }\n        for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n          var ring = consumee.rings[i];\n          var winding = consumee.windings[i];\n          var index = consumer.rings.indexOf(ring);\n          if (index === -1) {\n            consumer.rings.push(ring);\n            consumer.windings.push(winding);\n          } else consumer.windings[index] += winding;\n        }\n        consumee.rings = null;\n        consumee.windings = null;\n        consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n        consumee.leftSE.consumedBy = consumer.leftSE;\n        consumee.rightSE.consumedBy = consumer.rightSE;\n      }\n      /* The first segment previous segment chain that is in the result */\n    }, {\n      key: \"prevInResult\",\n      value: function prevInResult() {\n        if (this._prevInResult !== undefined) return this._prevInResult;\n        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n        return this._prevInResult;\n      }\n    }, {\n      key: \"beforeState\",\n      value: function beforeState() {\n        if (this._beforeState !== undefined) return this._beforeState;\n        if (!this.prev) this._beforeState = {\n          rings: [],\n          windings: [],\n          multiPolys: []\n        };else {\n          var seg = this.prev.consumedBy || this.prev;\n          this._beforeState = seg.afterState();\n        }\n        return this._beforeState;\n      }\n    }, {\n      key: \"afterState\",\n      value: function afterState() {\n        if (this._afterState !== undefined) return this._afterState;\n        var beforeState = this.beforeState();\n        this._afterState = {\n          rings: beforeState.rings.slice(0),\n          windings: beforeState.windings.slice(0),\n          multiPolys: []\n        };\n        var ringsAfter = this._afterState.rings;\n        var windingsAfter = this._afterState.windings;\n        var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n        for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n          var ring = this.rings[i];\n          var winding = this.windings[i];\n          var index = ringsAfter.indexOf(ring);\n          if (index === -1) {\n            ringsAfter.push(ring);\n            windingsAfter.push(winding);\n          } else windingsAfter[index] += winding;\n        } // calcualte polysAfter\n\n        var polysAfter = [];\n        var polysExclude = [];\n        for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n          if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n          var _ring = ringsAfter[_i];\n          var poly = _ring.poly;\n          if (polysExclude.indexOf(poly) !== -1) continue;\n          if (_ring.isExterior) polysAfter.push(poly);else {\n            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n            var _index = polysAfter.indexOf(_ring.poly);\n            if (_index !== -1) polysAfter.splice(_index, 1);\n          }\n        } // calculate multiPolysAfter\n\n        for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n          var mp = polysAfter[_i2].multiPoly;\n          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n        }\n        return this._afterState;\n      }\n      /* Is this segment part of the final result? */\n    }, {\n      key: \"isInResult\",\n      value: function isInResult() {\n        // if we've been consumed, we're not in the result\n        if (this.consumedBy) return false;\n        if (this._isInResult !== undefined) return this._isInResult;\n        var mpsBefore = this.beforeState().multiPolys;\n        var mpsAfter = this.afterState().multiPolys;\n        switch (operation.type) {\n          case 'union':\n            {\n              // UNION - included iff:\n              //  * On one side of us there is 0 poly interiors AND\n              //  * On the other side there is 1 or more.\n              var noBefores = mpsBefore.length === 0;\n              var noAfters = mpsAfter.length === 0;\n              this._isInResult = noBefores !== noAfters;\n              break;\n            }\n          case 'intersection':\n            {\n              // INTERSECTION - included iff:\n              //  * on one side of us all multipolys are rep. with poly interiors AND\n              //  * on the other side of us, not all multipolys are repsented\n              //    with poly interiors\n              var least;\n              var most;\n              if (mpsBefore.length < mpsAfter.length) {\n                least = mpsBefore.length;\n                most = mpsAfter.length;\n              } else {\n                least = mpsAfter.length;\n                most = mpsBefore.length;\n              }\n              this._isInResult = most === operation.numMultiPolys && least < most;\n              break;\n            }\n          case 'xor':\n            {\n              // XOR - included iff:\n              //  * the difference between the number of multipolys represented\n              //    with poly interiors on our two sides is an odd number\n              var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n              this._isInResult = diff % 2 === 1;\n              break;\n            }\n          case 'difference':\n            {\n              // DIFFERENCE included iff:\n              //  * on exactly one side, we have just the subject\n              var isJustSubject = function isJustSubject(mps) {\n                return mps.length === 1 && mps[0].isSubject;\n              };\n              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n              break;\n            }\n          default:\n            throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n        }\n        return this._isInResult;\n      }\n    }], [{\n      key: \"fromRing\",\n      value: function fromRing(pt1, pt2, ring) {\n        var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n        var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n        if (cmpPts < 0) {\n          leftPt = pt1;\n          rightPt = pt2;\n          winding = 1;\n        } else if (cmpPts > 0) {\n          leftPt = pt2;\n          rightPt = pt1;\n          winding = -1;\n        } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n        var leftSE = new SweepEvent(leftPt, true);\n        var rightSE = new SweepEvent(rightPt, false);\n        return new Segment(leftSE, rightSE, [ring], [winding]);\n      }\n    }]);\n    return Segment;\n  }();\n  var RingIn = /*#__PURE__*/function () {\n    function RingIn(geomRing, poly, isExterior) {\n      _classCallCheck(this, RingIn);\n      if (!Array.isArray(geomRing) || geomRing.length === 0) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n      this.poly = poly;\n      this.isExterior = isExterior;\n      this.segments = [];\n      if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n      var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n      this.bbox = {\n        ll: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        },\n        ur: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        }\n      };\n      var prevPoint = firstPoint;\n      for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n        if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n        }\n        var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n        if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n        this.segments.push(Segment.fromRing(prevPoint, point, this));\n        if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n        if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n        if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n        if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n        prevPoint = point;\n      } // add segment from last to first if last is not the same as first\n\n      if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n      }\n    }\n    _createClass(RingIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n        for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n          var segment = this.segments[i];\n          sweepEvents.push(segment.leftSE);\n          sweepEvents.push(segment.rightSE);\n        }\n        return sweepEvents;\n      }\n    }]);\n    return RingIn;\n  }();\n  var PolyIn = /*#__PURE__*/function () {\n    function PolyIn(geomPoly, multiPoly) {\n      _classCallCheck(this, PolyIn);\n      if (!Array.isArray(geomPoly)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n      this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n      this.bbox = {\n        ll: {\n          x: this.exteriorRing.bbox.ll.x,\n          y: this.exteriorRing.bbox.ll.y\n        },\n        ur: {\n          x: this.exteriorRing.bbox.ur.x,\n          y: this.exteriorRing.bbox.ur.y\n        }\n      };\n      this.interiorRings = [];\n      for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n        var ring = new RingIn(geomPoly[i], this, false);\n        if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n        if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n        if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n        if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n        this.interiorRings.push(ring);\n      }\n      this.multiPoly = multiPoly;\n    }\n    _createClass(PolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = this.exteriorRing.getSweepEvents();\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n          for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(ringSweepEvents[j]);\n          }\n        }\n        return sweepEvents;\n      }\n    }]);\n    return PolyIn;\n  }();\n  var MultiPolyIn = /*#__PURE__*/function () {\n    function MultiPolyIn(geom, isSubject) {\n      _classCallCheck(this, MultiPolyIn);\n      if (!Array.isArray(geom)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n      try {\n        // if the input looks like a polygon, convert it to a multipolygon\n        if (typeof geom[0][0][0] === 'number') geom = [geom];\n      } catch (ex) {// The input is either malformed or has empty arrays.\n        // In either case, it will be handled later on.\n      }\n      this.polys = [];\n      this.bbox = {\n        ll: {\n          x: Number.POSITIVE_INFINITY,\n          y: Number.POSITIVE_INFINITY\n        },\n        ur: {\n          x: Number.NEGATIVE_INFINITY,\n          y: Number.NEGATIVE_INFINITY\n        }\n      };\n      for (var i = 0, iMax = geom.length; i < iMax; i++) {\n        var poly = new PolyIn(geom[i], this);\n        if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n        if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n        if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n        if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n        this.polys.push(poly);\n      }\n      this.isSubject = isSubject;\n    }\n    _createClass(MultiPolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polySweepEvents = this.polys[i].getSweepEvents();\n          for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(polySweepEvents[j]);\n          }\n        }\n        return sweepEvents;\n      }\n    }]);\n    return MultiPolyIn;\n  }();\n  var RingOut = /*#__PURE__*/function () {\n    _createClass(RingOut, null, [{\n      key: \"factory\",\n      /* Given the segments from the sweep line pass, compute & return a series\n       * of closed rings from all the segments marked to be part of the result */\n      value: function factory(allSegments) {\n        var ringsOut = [];\n        for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n          var segment = allSegments[i];\n          if (!segment.isInResult() || segment.ringOut) continue;\n          var prevEvent = null;\n          var event = segment.leftSE;\n          var nextEvent = segment.rightSE;\n          var events = [event];\n          var startingPoint = event.point;\n          var intersectionLEs = [];\n          /* Walk the chain of linked events to form a closed ring */\n\n          while (true) {\n            prevEvent = event;\n            event = nextEvent;\n            events.push(event);\n            /* Is the ring complete? */\n\n            if (event.point === startingPoint) break;\n            while (true) {\n              var availableLEs = event.getAvailableLinkedEvents();\n              /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n               * part of the algorithm malfunctioned... please file a bug report. */\n\n              if (availableLEs.length === 0) {\n                var firstPt = events[0].point;\n                var lastPt = events[events.length - 1].point;\n                throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n              }\n              /* Only one way to go, so cotinue on the path */\n\n              if (availableLEs.length === 1) {\n                nextEvent = availableLEs[0].otherSE;\n                break;\n              }\n              /* We must have an intersection. Check for a completed loop */\n\n              var indexLE = null;\n              for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n                if (intersectionLEs[j].point === event.point) {\n                  indexLE = j;\n                  break;\n                }\n              }\n              /* Found a completed loop. Cut that off and make a ring */\n\n              if (indexLE !== null) {\n                var intersectionLE = intersectionLEs.splice(indexLE)[0];\n                var ringEvents = events.splice(intersectionLE.index);\n                ringEvents.unshift(ringEvents[0].otherSE);\n                ringsOut.push(new RingOut(ringEvents.reverse()));\n                continue;\n              }\n              /* register the intersection */\n\n              intersectionLEs.push({\n                index: events.length,\n                point: event.point\n              });\n              /* Choose the left-most option to continue the walk */\n\n              var comparator = event.getLeftmostComparator(prevEvent);\n              nextEvent = availableLEs.sort(comparator)[0].otherSE;\n              break;\n            }\n          }\n          ringsOut.push(new RingOut(events));\n        }\n        return ringsOut;\n      }\n    }]);\n    function RingOut(events) {\n      _classCallCheck(this, RingOut);\n      this.events = events;\n      for (var i = 0, iMax = events.length; i < iMax; i++) {\n        events[i].segment.ringOut = this;\n      }\n      this.poly = null;\n    }\n    _createClass(RingOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        // Remove superfluous points (ie extra points along a straight line),\n        var prevPt = this.events[0].point;\n        var points = [prevPt];\n        for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n          var _pt = this.events[i].point;\n          var _nextPt = this.events[i + 1].point;\n          if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n          points.push(_pt);\n          prevPt = _pt;\n        } // ring was all (within rounding error of angle calc) colinear points\n\n        if (points.length === 1) return null; // check if the starting point is necessary\n\n        var pt = points[0];\n        var nextPt = points[1];\n        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n        points.push(points[0]);\n        var step = this.isExteriorRing() ? 1 : -1;\n        var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n        var iEnd = this.isExteriorRing() ? points.length : -1;\n        var orderedPoints = [];\n        for (var _i = iStart; _i != iEnd; _i += step) {\n          orderedPoints.push([points[_i].x, points[_i].y]);\n        }\n        return orderedPoints;\n      }\n    }, {\n      key: \"isExteriorRing\",\n      value: function isExteriorRing() {\n        if (this._isExteriorRing === undefined) {\n          var enclosing = this.enclosingRing();\n          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n        }\n        return this._isExteriorRing;\n      }\n    }, {\n      key: \"enclosingRing\",\n      value: function enclosingRing() {\n        if (this._enclosingRing === undefined) {\n          this._enclosingRing = this._calcEnclosingRing();\n        }\n        return this._enclosingRing;\n      }\n      /* Returns the ring that encloses this one, if any */\n    }, {\n      key: \"_calcEnclosingRing\",\n      value: function _calcEnclosingRing() {\n        // start with the ealier sweep line event so that the prevSeg\n        // chain doesn't lead us inside of a loop of ours\n        var leftMostEvt = this.events[0];\n        for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n          var evt = this.events[i];\n          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n        }\n        var prevSeg = leftMostEvt.segment.prevInResult();\n        var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        while (true) {\n          // no segment found, thus no ring can enclose us\n          if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n          // segment must loop back around and enclose us\n\n          if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n          // segment must either loop around us or the ring of the prev prev\n          // seg, which would make us and the ring of the prev peers\n\n          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n              return prevSeg.ringOut;\n            } else return prevSeg.ringOut.enclosingRing();\n          } // two segments are from the same ring, so this was a penisula\n          // of that ring. iterate downward, keep searching\n\n          prevSeg = prevPrevSeg.prevInResult();\n          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        }\n      }\n    }]);\n    return RingOut;\n  }();\n  var PolyOut = /*#__PURE__*/function () {\n    function PolyOut(exteriorRing) {\n      _classCallCheck(this, PolyOut);\n      this.exteriorRing = exteriorRing;\n      exteriorRing.poly = this;\n      this.interiorRings = [];\n    }\n    _createClass(PolyOut, [{\n      key: \"addInterior\",\n      value: function addInterior(ring) {\n        this.interiorRings.push(ring);\n        ring.poly = this;\n      }\n    }, {\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (geom[0] === null) return null;\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n          if (ringGeom === null) continue;\n          geom.push(ringGeom);\n        }\n        return geom;\n      }\n    }]);\n    return PolyOut;\n  }();\n  var MultiPolyOut = /*#__PURE__*/function () {\n    function MultiPolyOut(rings) {\n      _classCallCheck(this, MultiPolyOut);\n      this.rings = rings;\n      this.polys = this._composePolys(rings);\n    }\n    _createClass(MultiPolyOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [];\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n          if (polyGeom === null) continue;\n          geom.push(polyGeom);\n        }\n        return geom;\n      }\n    }, {\n      key: \"_composePolys\",\n      value: function _composePolys(rings) {\n        var polys = [];\n        for (var i = 0, iMax = rings.length; i < iMax; i++) {\n          var ring = rings[i];\n          if (ring.poly) continue;\n          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n            var enclosingRing = ring.enclosingRing();\n            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n            enclosingRing.poly.addInterior(ring);\n          }\n        }\n        return polys;\n      }\n    }]);\n    return MultiPolyOut;\n  }();\n\n  /**\n   * NOTE:  We must be careful not to change any segments while\n   *        they are in the SplayTree. AFAIK, there's no way to tell\n   *        the tree to rebalance itself - thus before splitting\n   *        a segment that's in the tree, we remove it from the tree,\n   *        do the split, then re-insert it. (Even though splitting a\n   *        segment *shouldn't* change its correct position in the\n   *        sweep line tree, the reality is because of rounding errors,\n   *        it sometimes does.)\n   */\n\n  var SweepLine = /*#__PURE__*/function () {\n    function SweepLine(queue) {\n      var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n      _classCallCheck(this, SweepLine);\n      this.queue = queue;\n      this.tree = new Tree(comparator);\n      this.segments = [];\n    }\n    _createClass(SweepLine, [{\n      key: \"process\",\n      value: function process(event) {\n        var segment = event.segment;\n        var newEvents = []; // if we've already been consumed by another segment,\n        // clean up our body parts and get out\n\n        if (event.consumedBy) {\n          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n          return newEvents;\n        }\n        var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n        if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n        var prevNode = node;\n        var nextNode = node;\n        var prevSeg = undefined;\n        var nextSeg = undefined; // skip consumed segments still in tree\n\n        while (prevSeg === undefined) {\n          prevNode = this.tree.prev(prevNode);\n          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n        } // skip consumed segments still in tree\n\n        while (nextSeg === undefined) {\n          nextNode = this.tree.next(nextNode);\n          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n        }\n        if (event.isLeft) {\n          // Check for intersections against the previous segment in the sweep line\n          var prevMySplitter = null;\n          if (prevSeg) {\n            var prevInter = prevSeg.getIntersection(segment);\n            if (prevInter !== null) {\n              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n              if (!prevSeg.isAnEndpoint(prevInter)) {\n                var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n                for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          } // Check for intersections against the next segment in the sweep line\n\n          var nextMySplitter = null;\n          if (nextSeg) {\n            var nextInter = nextSeg.getIntersection(segment);\n            if (nextInter !== null) {\n              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n              if (!nextSeg.isAnEndpoint(nextInter)) {\n                var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n                for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                  newEvents.push(_newEventsFromSplit[_i]);\n                }\n              }\n            }\n          } // For simplicity, even if we find more than one intersection we only\n          // spilt on the 'earliest' (sweep-line style) of the intersections.\n          // The other intersection will be handled in a future process().\n\n          if (prevMySplitter !== null || nextMySplitter !== null) {\n            var mySplitter = null;\n            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n              var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n            } // Rounding errors can cause changes in ordering,\n            // so remove afected segments and right sweep events before splitting\n\n            this.queue.remove(segment.rightSE);\n            newEvents.push(segment.rightSE);\n            var _newEventsFromSplit2 = segment.split(mySplitter);\n            for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n              newEvents.push(_newEventsFromSplit2[_i2]);\n            }\n          }\n          if (newEvents.length > 0) {\n            // We found some intersections, so re-do the current event to\n            // make sure sweep line ordering is totally consistent for later\n            // use with the segment 'prev' pointers\n            this.tree.remove(segment);\n            newEvents.push(event);\n          } else {\n            // done with left event\n            this.segments.push(segment);\n            segment.prev = prevSeg;\n          }\n        } else {\n          // event.isRight\n          // since we're about to be removed from the sweep line, check for\n          // intersections between our previous and next segments\n          if (prevSeg && nextSeg) {\n            var inter = prevSeg.getIntersection(nextSeg);\n            if (inter !== null) {\n              if (!prevSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n                for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                  newEvents.push(_newEventsFromSplit3[_i3]);\n                }\n              }\n              if (!nextSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n                for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                  newEvents.push(_newEventsFromSplit4[_i4]);\n                }\n              }\n            }\n          }\n          this.tree.remove(segment);\n        }\n        return newEvents;\n      }\n      /* Safely split a segment that is currently in the datastructures\n       * IE - a segment other than the one that is currently being processed. */\n    }, {\n      key: \"_splitSafely\",\n      value: function _splitSafely(seg, pt) {\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        // removeNode() doesn't work, so have re-find the seg\n        // https://github.com/w8r/splay-tree/pull/5\n        this.tree.remove(seg);\n        var rightSE = seg.rightSE;\n        this.queue.remove(rightSE);\n        var newEvents = seg.split(pt);\n        newEvents.push(rightSE); // splitting can trigger consumption\n\n        if (seg.consumedBy === undefined) this.tree.insert(seg);\n        return newEvents;\n      }\n    }]);\n    return SweepLine;\n  }();\n  var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\n  var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\n  var Operation = /*#__PURE__*/function () {\n    function Operation() {\n      _classCallCheck(this, Operation);\n    }\n    _createClass(Operation, [{\n      key: \"run\",\n      value: function run(type, geom, moreGeoms) {\n        operation.type = type;\n        rounder.reset();\n        /* Convert inputs to MultiPoly objects */\n\n        var multipolys = [new MultiPolyIn(geom, true)];\n        for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n          multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n        }\n        operation.numMultiPolys = multipolys.length;\n        /* BBox optimization for difference operation\n         * If the bbox of a multipolygon that's part of the clipping doesn't\n         * intersect the bbox of the subject at all, we can just drop that\n         * multiploygon. */\n\n        if (operation.type === 'difference') {\n          // in place removal\n          var subject = multipolys[0];\n          var _i = 1;\n          while (_i < multipolys.length) {\n            if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n          }\n        }\n        /* BBox optimization for intersection operation\n         * If we can find any pair of multipolygons whose bbox does not overlap,\n         * then the result will be empty. */\n\n        if (operation.type === 'intersection') {\n          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n          //       it could be optimized to O(n * ln(n))\n          for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n            var mpA = multipolys[_i2];\n            for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n            }\n          }\n        }\n        /* Put segment endpoints in a priority queue */\n\n        var queue = new Tree(SweepEvent.compare);\n        for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n          var sweepEvents = multipolys[_i3].getSweepEvents();\n          for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n            queue.insert(sweepEvents[_j]);\n            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n              // prevents an infinite loop, an otherwise common manifestation of bugs\n              throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n            }\n          }\n        }\n        /* Pass the sweep line over those endpoints */\n\n        var sweepLine = new SweepLine(queue);\n        var prevQueueSize = queue.size;\n        var node = queue.pop();\n        while (node) {\n          var evt = node.key;\n          if (queue.size === prevQueueSize) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            var seg = evt.segment;\n            throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n          }\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n          }\n          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n          }\n          var newEvents = sweepLine.process(evt);\n          for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n            var _evt = newEvents[_i4];\n            if (_evt.consumedBy === undefined) queue.insert(_evt);\n          }\n          prevQueueSize = queue.size;\n          node = queue.pop();\n        } // free some memory we don't need anymore\n\n        rounder.reset();\n        /* Collect and compile segments we're keeping into a multipolygon */\n\n        var ringsOut = RingOut.factory(sweepLine.segments);\n        var result = new MultiPolyOut(ringsOut);\n        return result.getGeom();\n      }\n    }]);\n    return Operation;\n  }(); // singleton available by import\n\n  var operation = new Operation();\n  var union = function union(geom) {\n    for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      moreGeoms[_key - 1] = arguments[_key];\n    }\n    return operation.run('union', geom, moreGeoms);\n  };\n  var intersection$1 = function intersection(geom) {\n    for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      moreGeoms[_key2 - 1] = arguments[_key2];\n    }\n    return operation.run('intersection', geom, moreGeoms);\n  };\n  var xor = function xor(geom) {\n    for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      moreGeoms[_key3 - 1] = arguments[_key3];\n    }\n    return operation.run('xor', geom, moreGeoms);\n  };\n  var difference = function difference(subjectGeom) {\n    for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      clippingGeoms[_key4 - 1] = arguments[_key4];\n    }\n    return operation.run('difference', subjectGeom, clippingGeoms);\n  };\n  var index = {\n    union: union,\n    intersection: intersection$1,\n    xor: xor,\n    difference: difference\n  };\n  return index;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","polygonClipping","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","Node","data","next","left","right","DEFAULT_COMPARE","a","b","splay","t","comparator","N","l","r","cmp","y","insert","node","split","v","merge","printRow","root","prefix","isTail","out","printNode","indent","Tree","_root","_size","_comparator","add","remove","_remove","x","pop","findStatic","current","compare","find","contains","forEach","visitor","ctx","Q","done","push","call","range","low","high","fn","keys","_a","values","min","minNode","max","maxNode","at","index","d","successor","prev","predecessor","clear","toList","load","presort","size","sort","loadRecursive","mergedList","mergeLists","createList","sortedListToBST","head","isEmpty","get","toString","n","String","join","update","newKey","newData","start","end","middle","Math","floor","p","list","l1","l2","p1","p2","pivot","j","tmp","isInBbox","bbox","point","ll","ur","getBboxOverlap","b1","b2","lowerX","upperX","lowerY","upperY","epsilon","Number","EPSILON","undefined","pow","EPSILON_SQ","ab","PtRounder","reset","value","xRounder","CoordRounder","yRounder","round","tree","coord","prevNode","nextNode","rounder","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","v1","v2","kross","sqrt","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","pt","verticalIntersection","intersection","pt1","pt2","ve","d1","d2","x1","x2","y1","y2","SweepEvent","ptCmp","comparePoints","link","isLeft","Segment","segment","aPt","bPt","events","other","Error","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","consumedBy","evt2","otherSE","consume","getAvailableLinkedEvents","ringOut","isInResult","getLeftmostComparator","baseEvent","_this","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","cosine","has","_cache$get","asine","acosine","_cache$get2","bsine","bcosine","segmentId","alx","leftSE","blx","arx","rightSE","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","_bCmpARight","_aCmpBRight","ay","ax","by","bx","id","rings","windings","replaceRightSE","newRightSE","vector","isAnEndpoint","lPt","rPt","yDist","xFromYDist","xDist","yFromXDist","getIntersection","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","newEvents","alreadyLinked","newLeftSE","oldRightSE","newSeg","slice","swapEvents","tmpEvt","consumer","consumee","_tmp","ring","winding","indexOf","prevInResult","_prevInResult","beforeState","_beforeState","multiPolys","seg","afterState","_afterState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","_i","_iMax","_ring","poly","isExterior","_index","splice","_i2","_iMax2","mp","multiPoly","_isInResult","mpsBefore","operation","type","noBefores","noAfters","least","most","numMultiPolys","diff","abs","isJustSubject","mps","isSubject","concat","fromRing","leftPt","rightPt","cmpPts","RingIn","geomRing","Array","isArray","segments","firstPoint","prevPoint","getSweepEvents","sweepEvents","PolyIn","geomPoly","exteriorRing","interiorRings","ringSweepEvents","jMax","MultiPolyIn","geom","ex","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","firstPt","lastPt","indexLE","intersectionLE","ringEvents","unshift","reverse","getGeom","prevPt","points","_pt","_nextPt","nextPt","shift","step","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","addInterior","ringGeom","MultiPolyOut","_composePolys","polyGeom","SweepLine","queue","arguments","process","nextSeg","prevMySplitter","prevInter","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","_newEventsFromSplit","mySplitter","cmpSplitters","_newEventsFromSplit2","inter","_newEventsFromSplit3","_i3","_iMax3","_newEventsFromSplit4","_i4","_iMax4","POLYGON_CLIPPING_MAX_QUEUE_SIZE","env","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","Operation","run","moreGeoms","multipolys","subject","mpA","_j","_jMax","sweepLine","prevQueueSize","_evt","result","union","_len","_key","intersection$1","_len2","_key2","xor","_len3","_key3","difference","subjectGeom","_len4","clippingGeoms","_key4"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/polygon-clipping/dist/polygon-clipping.umd.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.polygonClipping = factory());\n}(this, (function () { 'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  /**\n   * splaytree v3.1.0\n   * Fast Splay tree for Node and browser\n   *\n   * @author Alexander Milevski <info@w8r.name>\n   * @license MIT\n   * @preserve\n   */\n  var Node =\n  /** @class */\n  function () {\n    function Node(key, data) {\n      this.next = null;\n      this.key = key;\n      this.data = data;\n      this.left = null;\n      this.right = null;\n    }\n\n    return Node;\n  }();\n  /* follows \"An implementation of top-down splaying\"\r\n   * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n   */\n\n\n  function DEFAULT_COMPARE(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n  /**\r\n   * Simple top down splay, not requiring i to be in the tree t.\r\n   */\n\n\n  function splay(i, t, comparator) {\n    var N = new Node(null, null);\n    var l = N;\n    var r = N;\n\n    while (true) {\n      var cmp = comparator(i, t.key); //if (i < t.key) {\n\n      if (cmp < 0) {\n        if (t.left === null) break; //if (i < t.left.key) {\n\n        if (comparator(i, t.left.key) < 0) {\n          var y = t.left;\n          /* rotate right */\n\n          t.left = y.right;\n          y.right = t;\n          t = y;\n          if (t.left === null) break;\n        }\n\n        r.left = t;\n        /* link right */\n\n        r = t;\n        t = t.left; //} else if (i > t.key) {\n      } else if (cmp > 0) {\n        if (t.right === null) break; //if (i > t.right.key) {\n\n        if (comparator(i, t.right.key) > 0) {\n          var y = t.right;\n          /* rotate left */\n\n          t.right = y.left;\n          y.left = t;\n          t = y;\n          if (t.right === null) break;\n        }\n\n        l.right = t;\n        /* link left */\n\n        l = t;\n        t = t.right;\n      } else break;\n    }\n    /* assemble */\n\n\n    l.right = t.left;\n    r.left = t.right;\n    t.left = N.right;\n    t.right = N.left;\n    return t;\n  }\n\n  function insert(i, data, t, comparator) {\n    var node = new Node(i, data);\n\n    if (t === null) {\n      node.left = node.right = null;\n      return node;\n    }\n\n    t = splay(i, t, comparator);\n    var cmp = comparator(i, t.key);\n\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp >= 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n\n    return node;\n  }\n\n  function split(key, v, comparator) {\n    var left = null;\n    var right = null;\n\n    if (v) {\n      v = splay(key, v, comparator);\n      var cmp = comparator(v.key, key);\n\n      if (cmp === 0) {\n        left = v.left;\n        right = v.right;\n      } else if (cmp < 0) {\n        right = v.right;\n        v.right = null;\n        left = v;\n      } else {\n        left = v.left;\n        v.left = null;\n        right = v;\n      }\n    }\n\n    return {\n      left: left,\n      right: right\n    };\n  }\n\n  function merge(left, right, comparator) {\n    if (right === null) return left;\n    if (left === null) return right;\n    right = splay(left.key, right, comparator);\n    right.left = left;\n    return right;\n  }\n  /**\r\n   * Prints level of the tree\r\n   */\n\n\n  function printRow(root, prefix, isTail, out, printNode) {\n    if (root) {\n      out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\n      var indent = prefix + (isTail ? '    ' : '│   ');\n      if (root.left) printRow(root.left, indent, false, out, printNode);\n      if (root.right) printRow(root.right, indent, true, out, printNode);\n    }\n  }\n\n  var Tree =\n  /** @class */\n  function () {\n    function Tree(comparator) {\n      if (comparator === void 0) {\n        comparator = DEFAULT_COMPARE;\n      }\n\n      this._root = null;\n      this._size = 0;\n      this._comparator = comparator;\n    }\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\n\n\n    Tree.prototype.insert = function (key, data) {\n      this._size++;\n      return this._root = insert(key, data, this._root, this._comparator);\n    };\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\n\n\n    Tree.prototype.add = function (key, data) {\n      var node = new Node(key, data);\n\n      if (this._root === null) {\n        node.left = node.right = null;\n        this._size++;\n        this._root = node;\n      }\n\n      var comparator = this._comparator;\n      var t = splay(key, this._root, comparator);\n      var cmp = comparator(key, t.key);\n      if (cmp === 0) this._root = t;else {\n        if (cmp < 0) {\n          node.left = t.left;\n          node.right = t;\n          t.left = null;\n        } else if (cmp > 0) {\n          node.right = t.right;\n          node.left = t;\n          t.right = null;\n        }\n\n        this._size++;\n        this._root = node;\n      }\n      return this._root;\n    };\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\n\n\n    Tree.prototype.remove = function (key) {\n      this._root = this._remove(key, this._root, this._comparator);\n    };\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\n\n\n    Tree.prototype._remove = function (i, t, comparator) {\n      var x;\n      if (t === null) return null;\n      t = splay(i, t, comparator);\n      var cmp = comparator(i, t.key);\n\n      if (cmp === 0) {\n        /* found it */\n        if (t.left === null) {\n          x = t.right;\n        } else {\n          x = splay(i, t.left, comparator);\n          x.right = t.right;\n        }\n\n        this._size--;\n        return x;\n      }\n\n      return t;\n      /* It wasn't there */\n    };\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\n\n\n    Tree.prototype.pop = function () {\n      var node = this._root;\n\n      if (node) {\n        while (node.left) {\n          node = node.left;\n        }\n\n        this._root = splay(node.key, this._root, this._comparator);\n        this._root = this._remove(node.key, this._root, this._comparator);\n        return {\n          key: node.key,\n          data: node.data\n        };\n      }\n\n      return null;\n    };\n    /**\r\n     * Find without splaying\r\n     */\n\n\n    Tree.prototype.findStatic = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return null;\n    };\n\n    Tree.prototype.find = function (key) {\n      if (this._root) {\n        this._root = splay(key, this._root, this._comparator);\n        if (this._comparator(key, this._root.key) !== 0) return null;\n      }\n\n      return this._root;\n    };\n\n    Tree.prototype.contains = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return false;\n    };\n\n    Tree.prototype.forEach = function (visitor, ctx) {\n      var current = this._root;\n      var Q = [];\n      /* Initialize stack s */\n\n      var done = false;\n\n      while (!done) {\n        if (current !== null) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length !== 0) {\n            current = Q.pop();\n            visitor.call(ctx, current);\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\n\n\n    Tree.prototype.range = function (low, high, fn, ctx) {\n      var Q = [];\n      var compare = this._comparator;\n      var node = this._root;\n      var cmp;\n\n      while (Q.length !== 0 || node) {\n        if (node) {\n          Q.push(node);\n          node = node.left;\n        } else {\n          node = Q.pop();\n          cmp = compare(node.key, high);\n\n          if (cmp > 0) {\n            break;\n          } else if (compare(node.key, low) >= 0) {\n            if (fn.call(ctx, node)) return this; // stop if smth is returned\n          }\n\n          node = node.right;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Returns array of keys\r\n     */\n\n\n    Tree.prototype.keys = function () {\n      var keys = [];\n      this.forEach(function (_a) {\n        var key = _a.key;\n        return keys.push(key);\n      });\n      return keys;\n    };\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\n\n\n    Tree.prototype.values = function () {\n      var values = [];\n      this.forEach(function (_a) {\n        var data = _a.data;\n        return values.push(data);\n      });\n      return values;\n    };\n\n    Tree.prototype.min = function () {\n      if (this._root) return this.minNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.max = function () {\n      if (this._root) return this.maxNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.minNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.left) {\n        t = t.left;\n      }\n      return t;\n    };\n\n    Tree.prototype.maxNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.right) {\n        t = t.right;\n      }\n      return t;\n    };\n    /**\r\n     * Returns node at given index\r\n     */\n\n\n    Tree.prototype.at = function (index) {\n      var current = this._root;\n      var done = false;\n      var i = 0;\n      var Q = [];\n\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length > 0) {\n            current = Q.pop();\n            if (i === index) return current;\n            i++;\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return null;\n    };\n\n    Tree.prototype.next = function (d) {\n      var root = this._root;\n      var successor = null;\n\n      if (d.right) {\n        successor = d.right;\n\n        while (successor.left) {\n          successor = successor.left;\n        }\n\n        return successor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) {\n          successor = root;\n          root = root.left;\n        } else root = root.right;\n      }\n\n      return successor;\n    };\n\n    Tree.prototype.prev = function (d) {\n      var root = this._root;\n      var predecessor = null;\n\n      if (d.left !== null) {\n        predecessor = d.left;\n\n        while (predecessor.right) {\n          predecessor = predecessor.right;\n        }\n\n        return predecessor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {\n          predecessor = root;\n          root = root.right;\n        }\n      }\n\n      return predecessor;\n    };\n\n    Tree.prototype.clear = function () {\n      this._root = null;\n      this._size = 0;\n      return this;\n    };\n\n    Tree.prototype.toList = function () {\n      return toList(this._root);\n    };\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\n\n\n    Tree.prototype.load = function (keys, values, presort) {\n      if (values === void 0) {\n        values = [];\n      }\n\n      if (presort === void 0) {\n        presort = false;\n      }\n\n      var size = keys.length;\n      var comparator = this._comparator; // sort if needed\n\n      if (presort) sort(keys, values, 0, size - 1, comparator);\n\n      if (this._root === null) {\n        // empty tree\n        this._root = loadRecursive(keys, values, 0, size);\n        this._size = size;\n      } else {\n        // that re-builds the whole tree from two in-order traversals\n        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n        size = this._size + size;\n        this._root = sortedListToBST({\n          head: mergedList\n        }, 0, size);\n      }\n\n      return this;\n    };\n\n    Tree.prototype.isEmpty = function () {\n      return this._root === null;\n    };\n\n    Object.defineProperty(Tree.prototype, \"size\", {\n      get: function get() {\n        return this._size;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(Tree.prototype, \"root\", {\n      get: function get() {\n        return this._root;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    Tree.prototype.toString = function (printNode) {\n      if (printNode === void 0) {\n        printNode = function printNode(n) {\n          return String(n.key);\n        };\n      }\n\n      var out = [];\n      printRow(this._root, '', true, function (v) {\n        return out.push(v);\n      }, printNode);\n      return out.join('');\n    };\n\n    Tree.prototype.update = function (key, newKey, newData) {\n      var comparator = this._comparator;\n\n      var _a = split(key, this._root, comparator),\n          left = _a.left,\n          right = _a.right;\n\n      if (comparator(key, newKey) < 0) {\n        right = insert(newKey, newData, right, comparator);\n      } else {\n        left = insert(newKey, newData, left, comparator);\n      }\n\n      this._root = merge(left, right, comparator);\n    };\n\n    Tree.prototype.split = function (key) {\n      return split(key, this._root, this._comparator);\n    };\n\n    return Tree;\n  }();\n\n  function loadRecursive(keys, values, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key = keys[middle];\n      var data = values[middle];\n      var node = new Node(key, data);\n      node.left = loadRecursive(keys, values, start, middle);\n      node.right = loadRecursive(keys, values, middle + 1, end);\n      return node;\n    }\n\n    return null;\n  }\n\n  function createList(keys, values) {\n    var head = new Node(null, null);\n    var p = head;\n\n    for (var i = 0; i < keys.length; i++) {\n      p = p.next = new Node(keys[i], values[i]);\n    }\n\n    p.next = null;\n    return head.next;\n  }\n\n  function toList(root) {\n    var current = root;\n    var Q = [];\n    var done = false;\n    var head = new Node(null, null);\n    var p = head;\n\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = p = p.next = Q.pop();\n          current = current.right;\n        } else done = true;\n      }\n    }\n\n    p.next = null; // that'll work even if the tree was empty\n\n    return head.next;\n  }\n\n  function sortedListToBST(list, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var left = sortedListToBST(list, start, middle);\n      var root = list.head;\n      root.left = left;\n      list.head = list.head.next;\n      root.right = sortedListToBST(list, middle + 1, end);\n      return root;\n    }\n\n    return null;\n  }\n\n  function mergeLists(l1, l2, compare) {\n    var head = new Node(null, null); // dummy\n\n    var p = head;\n    var p1 = l1;\n    var p2 = l2;\n\n    while (p1 !== null && p2 !== null) {\n      if (compare(p1.key, p2.key) < 0) {\n        p.next = p1;\n        p1 = p1.next;\n      } else {\n        p.next = p2;\n        p2 = p2.next;\n      }\n\n      p = p.next;\n    }\n\n    if (p1 !== null) {\n      p.next = p1;\n    } else if (p2 !== null) {\n      p.next = p2;\n    }\n\n    return head.next;\n  }\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) return;\n    var pivot = keys[left + right >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do {\n        i++;\n      } while (compare(keys[i], pivot) < 0);\n\n      do {\n        j--;\n      } while (compare(keys[j], pivot) > 0);\n\n      if (i >= j) break;\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values, left, j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  /**\n   * A bounding box has the format:\n   *\n   *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n   *\n   */\n  var isInBbox = function isInBbox(bbox, point) {\n    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n  };\n  /* Returns either null, or a bbox (aka an ordered pair of points)\n   * If there is only one point of overlap, a bbox with identical points\n   * will be returned */\n\n  var getBboxOverlap = function getBboxOverlap(b1, b2) {\n    // check if the bboxes overlap at all\n    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n    var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n    var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n    var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n    var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n    return {\n      ll: {\n        x: lowerX,\n        y: lowerY\n      },\n      ur: {\n        x: upperX,\n        y: upperY\n      }\n    };\n  };\n\n  /* Javascript doesn't do integer math. Everything is\n   * floating point with percision Number.EPSILON.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n   */\n  var epsilon = Number.EPSILON; // IE Polyfill\n\n  if (epsilon === undefined) epsilon = Math.pow(2, -52);\n  var EPSILON_SQ = epsilon * epsilon;\n  /* FLP comparator */\n\n  var cmp = function cmp(a, b) {\n    // check if they're both 0\n    if (-epsilon < a && a < epsilon) {\n      if (-epsilon < b && b < epsilon) {\n        return 0;\n      }\n    } // check if they're flp equal\n\n\n    var ab = a - b;\n\n    if (ab * ab < EPSILON_SQ * a * b) {\n      return 0;\n    } // normal comparison\n\n\n    return a < b ? -1 : 1;\n  };\n\n  /**\n   * This class rounds incoming values sufficiently so that\n   * floating points problems are, for the most part, avoided.\n   *\n   * Incoming points are have their x & y values tested against\n   * all previously seen x & y values. If either is 'too close'\n   * to a previously seen value, it's value is 'snapped' to the\n   * previously seen value.\n   *\n   * All points should be rounded by this class before being\n   * stored in any data structures in the rest of this algorithm.\n   */\n\n  var PtRounder = /*#__PURE__*/function () {\n    function PtRounder() {\n      _classCallCheck(this, PtRounder);\n\n      this.reset();\n    }\n\n    _createClass(PtRounder, [{\n      key: \"reset\",\n      value: function reset() {\n        this.xRounder = new CoordRounder();\n        this.yRounder = new CoordRounder();\n      }\n    }, {\n      key: \"round\",\n      value: function round(x, y) {\n        return {\n          x: this.xRounder.round(x),\n          y: this.yRounder.round(y)\n        };\n      }\n    }]);\n\n    return PtRounder;\n  }();\n\n  var CoordRounder = /*#__PURE__*/function () {\n    function CoordRounder() {\n      _classCallCheck(this, CoordRounder);\n\n      this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n      this.round(0);\n    } // Note: this can rounds input values backwards or forwards.\n    //       You might ask, why not restrict this to just rounding\n    //       forwards? Wouldn't that allow left endpoints to always\n    //       remain left endpoints during splitting (never change to\n    //       right). No - it wouldn't, because we snap intersections\n    //       to endpoints (to establish independence from the segment\n    //       angle for t-intersections).\n\n\n    _createClass(CoordRounder, [{\n      key: \"round\",\n      value: function round(coord) {\n        var node = this.tree.add(coord);\n        var prevNode = this.tree.prev(node);\n\n        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n          this.tree.remove(coord);\n          return prevNode.key;\n        }\n\n        var nextNode = this.tree.next(node);\n\n        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n          this.tree.remove(coord);\n          return nextNode.key;\n        }\n\n        return coord;\n      }\n    }]);\n\n    return CoordRounder;\n  }(); // singleton available by import\n\n\n  var rounder = new PtRounder();\n\n  /* Cross Product of two vectors with first point at origin */\n\n  var crossProduct = function crossProduct(a, b) {\n    return a.x * b.y - a.y * b.x;\n  };\n  /* Dot Product of two vectors with first point at origin */\n\n  var dotProduct = function dotProduct(a, b) {\n    return a.x * b.x + a.y * b.y;\n  };\n  /* Comparator for two vectors with same starting point */\n\n  var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n    var v1 = {\n      x: endPt1.x - basePt.x,\n      y: endPt1.y - basePt.y\n    };\n    var v2 = {\n      x: endPt2.x - basePt.x,\n      y: endPt2.y - basePt.y\n    };\n    var kross = crossProduct(v1, v2);\n    return cmp(kross, 0);\n  };\n  var length = function length(v) {\n    return Math.sqrt(dotProduct(v, v));\n  };\n  /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n  var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n  var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the x coordinate where the given line (defined by a point and vector)\n   * crosses the horizontal line with the given y coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var horizontalIntersection = function horizontalIntersection(pt, v, y) {\n    if (v.y === 0) return null;\n    return {\n      x: pt.x + v.x / v.y * (y - pt.y),\n      y: y\n    };\n  };\n  /* Get the y coordinate where the given line (defined by a point and vector)\n   * crosses the vertical line with the given x coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var verticalIntersection = function verticalIntersection(pt, v, x) {\n    if (v.x === 0) return null;\n    return {\n      x: x,\n      y: pt.y + v.y / v.x * (x - pt.x)\n    };\n  };\n  /* Get the intersection of two lines, each defined by a base point and a vector.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var intersection = function intersection(pt1, v1, pt2, v2) {\n    // take some shortcuts for vertical and horizontal lines\n    // this also ensures we don't calculate an intersection and then discover\n    // it's actually outside the bounding box of the line\n    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n    // This algorithm is based on Schneider and Eberly.\n    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n    var kross = crossProduct(v1, v2);\n    if (kross == 0) return null;\n    var ve = {\n      x: pt2.x - pt1.x,\n      y: pt2.y - pt1.y\n    };\n    var d1 = crossProduct(ve, v1) / kross;\n    var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n    var x1 = pt1.x + d2 * v1.x,\n        x2 = pt2.x + d1 * v2.x;\n    var y1 = pt1.y + d2 * v1.y,\n        y2 = pt2.y + d1 * v2.y;\n    var x = (x1 + x2) / 2;\n    var y = (y1 + y2) / 2;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  var SweepEvent = /*#__PURE__*/function () {\n    _createClass(SweepEvent, null, [{\n      key: \"compare\",\n      // for ordering sweep events in the sweep event queue\n      value: function compare(a, b) {\n        // favor event with a point that the sweep line hits first\n        var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n        if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n        if (a.point !== b.point) a.link(b); // favor right events over left\n\n        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n        // ordering of this case is the same as for their segments\n\n        return Segment.compare(a.segment, b.segment);\n      } // for ordering points in sweep line order\n\n    }, {\n      key: \"comparePoints\",\n      value: function comparePoints(aPt, bPt) {\n        if (aPt.x < bPt.x) return -1;\n        if (aPt.x > bPt.x) return 1;\n        if (aPt.y < bPt.y) return -1;\n        if (aPt.y > bPt.y) return 1;\n        return 0;\n      } // Warning: 'point' input will be modified and re-used (for performance)\n\n    }]);\n\n    function SweepEvent(point, isLeft) {\n      _classCallCheck(this, SweepEvent);\n\n      if (point.events === undefined) point.events = [this];else point.events.push(this);\n      this.point = point;\n      this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n    }\n\n    _createClass(SweepEvent, [{\n      key: \"link\",\n      value: function link(other) {\n        if (other.point === this.point) {\n          throw new Error('Tried to link already linked events');\n        }\n\n        var otherEvents = other.point.events;\n\n        for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n          var evt = otherEvents[i];\n          this.point.events.push(evt);\n          evt.point = this.point;\n        }\n\n        this.checkForConsuming();\n      }\n      /* Do a pass over our linked events and check to see if any pair\n       * of segments match, and should be consumed. */\n\n    }, {\n      key: \"checkForConsuming\",\n      value: function checkForConsuming() {\n        // FIXME: The loops in this method run O(n^2) => no good.\n        //        Maintain little ordered sweep event trees?\n        //        Can we maintaining an ordering that avoids the need\n        //        for the re-sorting with getLeftmostComparator in geom-out?\n        // Compare each pair of events to see if other events also match\n        var numEvents = this.point.events.length;\n\n        for (var i = 0; i < numEvents; i++) {\n          var evt1 = this.point.events[i];\n          if (evt1.segment.consumedBy !== undefined) continue;\n\n          for (var j = i + 1; j < numEvents; j++) {\n            var evt2 = this.point.events[j];\n            if (evt2.consumedBy !== undefined) continue;\n            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n            evt1.segment.consume(evt2.segment);\n          }\n        }\n      }\n    }, {\n      key: \"getAvailableLinkedEvents\",\n      value: function getAvailableLinkedEvents() {\n        // point.events is always of length 2 or greater\n        var events = [];\n\n        for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n          var evt = this.point.events[i];\n\n          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n            events.push(evt);\n          }\n        }\n\n        return events;\n      }\n      /**\n       * Returns a comparator function for sorting linked events that will\n       * favor the event that will give us the smallest left-side angle.\n       * All ring construction starts as low as possible heading to the right,\n       * so by always turning left as sharp as possible we'll get polygons\n       * without uncessary loops & holes.\n       *\n       * The comparator function has a compute cache such that it avoids\n       * re-computing already-computed values.\n       */\n\n    }, {\n      key: \"getLeftmostComparator\",\n      value: function getLeftmostComparator(baseEvent) {\n        var _this = this;\n\n        var cache = new Map();\n\n        var fillCache = function fillCache(linkedEvent) {\n          var nextEvent = linkedEvent.otherSE;\n          cache.set(linkedEvent, {\n            sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n            cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n          });\n        };\n\n        return function (a, b) {\n          if (!cache.has(a)) fillCache(a);\n          if (!cache.has(b)) fillCache(b);\n\n          var _cache$get = cache.get(a),\n              asine = _cache$get.sine,\n              acosine = _cache$get.cosine;\n\n          var _cache$get2 = cache.get(b),\n              bsine = _cache$get2.sine,\n              bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n          if (asine >= 0 && bsine >= 0) {\n            if (acosine < bcosine) return 1;\n            if (acosine > bcosine) return -1;\n            return 0;\n          } // both below x-axis\n\n\n          if (asine < 0 && bsine < 0) {\n            if (acosine < bcosine) return -1;\n            if (acosine > bcosine) return 1;\n            return 0;\n          } // one above x-axis, one below\n\n\n          if (bsine < asine) return -1;\n          if (bsine > asine) return 1;\n          return 0;\n        };\n      }\n    }]);\n\n    return SweepEvent;\n  }();\n\n  // segments and sweep events when all else is identical\n\n  var segmentId = 0;\n\n  var Segment = /*#__PURE__*/function () {\n    _createClass(Segment, null, [{\n      key: \"compare\",\n\n      /* This compare() function is for ordering segments in the sweep\n       * line tree, and does so according to the following criteria:\n       *\n       * Consider the vertical line that lies an infinestimal step to the\n       * right of the right-more of the two left endpoints of the input\n       * segments. Imagine slowly moving a point up from negative infinity\n       * in the increasing y direction. Which of the two segments will that\n       * point intersect first? That segment comes 'before' the other one.\n       *\n       * If neither segment would be intersected by such a line, (if one\n       * or more of the segments are vertical) then the line to be considered\n       * is directly on the right-more of the two left inputs.\n       */\n      value: function compare(a, b) {\n        var alx = a.leftSE.point.x;\n        var blx = b.leftSE.point.x;\n        var arx = a.rightSE.point.x;\n        var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n        if (brx < alx) return 1;\n        if (arx < blx) return -1;\n        var aly = a.leftSE.point.y;\n        var bly = b.leftSE.point.y;\n        var ary = a.rightSE.point.y;\n        var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n        if (alx < blx) {\n          // are the two segments in the same horizontal plane?\n          if (bly < aly && bly < ary) return 1;\n          if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n          var aCmpBLeft = a.comparePoint(b.leftSE.point);\n          if (aCmpBLeft < 0) return 1;\n          if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n          var bCmpARight = b.comparePoint(a.rightSE.point);\n          if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return -1;\n        } // is left endpoint of segment A the right-more?\n\n\n        if (alx > blx) {\n          if (aly < bly && aly < bry) return -1;\n          if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n          var bCmpALeft = b.comparePoint(a.leftSE.point);\n          if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n          var aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (aCmpBRight < 0) return 1;\n          if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return 1;\n        } // if we get here, the two left endpoints are in the same\n        // vertical plane, ie alx === blx\n        // consider the lower left-endpoint to come first\n\n\n        if (aly < bly) return -1;\n        if (aly > bly) return 1; // left endpoints are identical\n        // check for colinearity by using the left-more right endpoint\n        // is the A right endpoint more left-more?\n\n        if (arx < brx) {\n          var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n          if (_bCmpARight !== 0) return _bCmpARight;\n        } // is the B right endpoint more left-more?\n\n\n        if (arx > brx) {\n          var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n          if (_aCmpBRight < 0) return 1;\n          if (_aCmpBRight > 0) return -1;\n        }\n\n        if (arx !== brx) {\n          // are these two [almost] vertical segments with opposite orientation?\n          // if so, the one with the lower right endpoint comes first\n          var ay = ary - aly;\n          var ax = arx - alx;\n          var by = bry - bly;\n          var bx = brx - blx;\n          if (ay > ax && by < bx) return 1;\n          if (ay < ax && by > bx) return -1;\n        } // we have colinear segments with matching orientation\n        // consider the one with more left-more right endpoint to be first\n\n\n        if (arx > brx) return 1;\n        if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n        // vertical plane, ie arx === brx\n        // consider the lower right-endpoint to come first\n\n        if (ary < bry) return -1;\n        if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n        // fall back on creation order as consistent tie-breaker\n\n        if (a.id < b.id) return -1;\n        if (a.id > b.id) return 1; // identical segment, ie a === b\n\n        return 0;\n      }\n      /* Warning: a reference to ringWindings input will be stored,\n       *  and possibly will be later modified */\n\n    }]);\n\n    function Segment(leftSE, rightSE, rings, windings) {\n      _classCallCheck(this, Segment);\n\n      this.id = ++segmentId;\n      this.leftSE = leftSE;\n      leftSE.segment = this;\n      leftSE.otherSE = rightSE;\n      this.rightSE = rightSE;\n      rightSE.segment = this;\n      rightSE.otherSE = leftSE;\n      this.rings = rings;\n      this.windings = windings; // left unset for performance, set later in algorithm\n      // this.ringOut, this.consumedBy, this.prev\n    }\n\n    _createClass(Segment, [{\n      key: \"replaceRightSE\",\n\n      /* When a segment is split, the rightSE is replaced with a new sweep event */\n      value: function replaceRightSE(newRightSE) {\n        this.rightSE = newRightSE;\n        this.rightSE.segment = this;\n        this.rightSE.otherSE = this.leftSE;\n        this.leftSE.otherSE = this.rightSE;\n      }\n    }, {\n      key: \"bbox\",\n      value: function bbox() {\n        var y1 = this.leftSE.point.y;\n        var y2 = this.rightSE.point.y;\n        return {\n          ll: {\n            x: this.leftSE.point.x,\n            y: y1 < y2 ? y1 : y2\n          },\n          ur: {\n            x: this.rightSE.point.x,\n            y: y1 > y2 ? y1 : y2\n          }\n        };\n      }\n      /* A vector from the left point to the right */\n\n    }, {\n      key: \"vector\",\n      value: function vector() {\n        return {\n          x: this.rightSE.point.x - this.leftSE.point.x,\n          y: this.rightSE.point.y - this.leftSE.point.y\n        };\n      }\n    }, {\n      key: \"isAnEndpoint\",\n      value: function isAnEndpoint(pt) {\n        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n      }\n      /* Compare this segment with a point.\n       *\n       * A point P is considered to be colinear to a segment if there\n       * exists a distance D such that if we travel along the segment\n       * from one * endpoint towards the other a distance D, we find\n       * ourselves at point P.\n       *\n       * Return value indicates:\n       *\n       *   1: point lies above the segment (to the left of vertical)\n       *   0: point is colinear to segment\n       *  -1: point lies below the segment (to the right of vertical)\n       */\n\n    }, {\n      key: \"comparePoint\",\n      value: function comparePoint(point) {\n        if (this.isAnEndpoint(point)) return 0;\n        var lPt = this.leftSE.point;\n        var rPt = this.rightSE.point;\n        var v = this.vector(); // Exactly vertical segments.\n\n        if (lPt.x === rPt.x) {\n          if (point.x === lPt.x) return 0;\n          return point.x < lPt.x ? 1 : -1;\n        } // Nearly vertical segments with an intersection.\n        // Check to see where a point on the line with matching Y coordinate is.\n\n\n        var yDist = (point.y - lPt.y) / v.y;\n        var xFromYDist = lPt.x + yDist * v.x;\n        if (point.x === xFromYDist) return 0; // General case.\n        // Check to see where a point on the line with matching X coordinate is.\n\n        var xDist = (point.x - lPt.x) / v.x;\n        var yFromXDist = lPt.y + xDist * v.y;\n        if (point.y === yFromXDist) return 0;\n        return point.y < yFromXDist ? -1 : 1;\n      }\n      /**\n       * Given another segment, returns the first non-trivial intersection\n       * between the two segments (in terms of sweep line ordering), if it exists.\n       *\n       * A 'non-trivial' intersection is one that will cause one or both of the\n       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n       *\n       *   * endpoint of segA with endpoint of segB --> trivial\n       *   * endpoint of segA with point along segB --> non-trivial\n       *   * endpoint of segB with point along segA --> non-trivial\n       *   * point along segA with point along segB --> non-trivial\n       *\n       * If no non-trivial intersection exists, return null\n       * Else, return null.\n       */\n\n    }, {\n      key: \"getIntersection\",\n      value: function getIntersection(other) {\n        // If bboxes don't overlap, there can't be any intersections\n        var tBbox = this.bbox();\n        var oBbox = other.bbox();\n        var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n        if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n        // This will 'snap' intersections to endpoints if possible, and will\n        // handle cases of colinearity.\n\n        var tlp = this.leftSE.point;\n        var trp = this.rightSE.point;\n        var olp = other.leftSE.point;\n        var orp = other.rightSE.point; // does each endpoint touch the other segment?\n        // note that we restrict the 'touching' definition to only allow segments\n        // to touch endpoints that lie forward from where we are in the sweep line pass\n\n        var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n        var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n        var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n        var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n        if (touchesThisLSE && touchesOtherLSE) {\n          // these two cases are for colinear segments with matching left\n          // endpoints, and one segment being longer than the other\n          if (touchesThisRSE && !touchesOtherRSE) return trp;\n          if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n          // or just on their left endpoint (one trivial intersection\n\n          return null;\n        } // does this left endpoint matches (other doesn't)\n\n\n        if (touchesThisLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesOtherRSE) {\n            if (tlp.x === orp.x && tlp.y === orp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return tlp;\n        } // does other left endpoint matches (this doesn't)\n\n\n        if (touchesOtherLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesThisRSE) {\n            if (trp.x === olp.x && trp.y === olp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return olp;\n        } // trivial intersection on right endpoints\n\n\n        if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n        if (touchesThisRSE) return trp;\n        if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n        // infinite lines laid over the segments\n\n        var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n        // they would have an endpoint intersection and that case was already handled above\n\n        if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n        if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n        return rounder.round(pt.x, pt.y);\n      }\n      /**\n       * Split the given segment into multiple segments on the given points.\n       *  * Each existing segment will retain its leftSE and a new rightSE will be\n       *    generated for it.\n       *  * A new segment will be generated which will adopt the original segment's\n       *    rightSE, and a new leftSE will be generated for it.\n       *  * If there are more than two points given to split on, new segments\n       *    in the middle will be generated with new leftSE and rightSE's.\n       *  * An array of the newly generated SweepEvents will be returned.\n       *\n       * Warning: input array of points is modified\n       */\n\n    }, {\n      key: \"split\",\n      value: function split(point) {\n        var newEvents = [];\n        var alreadyLinked = point.events !== undefined;\n        var newLeftSE = new SweepEvent(point, true);\n        var newRightSE = new SweepEvent(point, false);\n        var oldRightSE = this.rightSE;\n        this.replaceRightSE(newRightSE);\n        newEvents.push(newRightSE);\n        newEvents.push(newLeftSE);\n        var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n        // sometimes one of the resulting new segments is vertical, in which\n        // case its left and right events may need to be swapped\n\n        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n          newSeg.swapEvents();\n        }\n\n        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n          this.swapEvents();\n        } // in the point we just used to create new sweep events with was already\n        // linked to other events, we need to check if either of the affected\n        // segments should be consumed\n\n\n        if (alreadyLinked) {\n          newLeftSE.checkForConsuming();\n          newRightSE.checkForConsuming();\n        }\n\n        return newEvents;\n      }\n      /* Swap which event is left and right */\n\n    }, {\n      key: \"swapEvents\",\n      value: function swapEvents() {\n        var tmpEvt = this.rightSE;\n        this.rightSE = this.leftSE;\n        this.leftSE = tmpEvt;\n        this.leftSE.isLeft = true;\n        this.rightSE.isLeft = false;\n\n        for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n          this.windings[i] *= -1;\n        }\n      }\n      /* Consume another segment. We take their rings under our wing\n       * and mark them as consumed. Use for perfectly overlapping segments */\n\n    }, {\n      key: \"consume\",\n      value: function consume(other) {\n        var consumer = this;\n        var consumee = other;\n\n        while (consumer.consumedBy) {\n          consumer = consumer.consumedBy;\n        }\n\n        while (consumee.consumedBy) {\n          consumee = consumee.consumedBy;\n        }\n\n        var cmp = Segment.compare(consumer, consumee);\n        if (cmp === 0) return; // already consumed\n        // the winner of the consumption is the earlier segment\n        // according to sweep line ordering\n\n        if (cmp > 0) {\n          var tmp = consumer;\n          consumer = consumee;\n          consumee = tmp;\n        } // make sure a segment doesn't consume it's prev\n\n\n        if (consumer.prev === consumee) {\n          var _tmp = consumer;\n          consumer = consumee;\n          consumee = _tmp;\n        }\n\n        for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n          var ring = consumee.rings[i];\n          var winding = consumee.windings[i];\n          var index = consumer.rings.indexOf(ring);\n\n          if (index === -1) {\n            consumer.rings.push(ring);\n            consumer.windings.push(winding);\n          } else consumer.windings[index] += winding;\n        }\n\n        consumee.rings = null;\n        consumee.windings = null;\n        consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n        consumee.leftSE.consumedBy = consumer.leftSE;\n        consumee.rightSE.consumedBy = consumer.rightSE;\n      }\n      /* The first segment previous segment chain that is in the result */\n\n    }, {\n      key: \"prevInResult\",\n      value: function prevInResult() {\n        if (this._prevInResult !== undefined) return this._prevInResult;\n        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n        return this._prevInResult;\n      }\n    }, {\n      key: \"beforeState\",\n      value: function beforeState() {\n        if (this._beforeState !== undefined) return this._beforeState;\n        if (!this.prev) this._beforeState = {\n          rings: [],\n          windings: [],\n          multiPolys: []\n        };else {\n          var seg = this.prev.consumedBy || this.prev;\n          this._beforeState = seg.afterState();\n        }\n        return this._beforeState;\n      }\n    }, {\n      key: \"afterState\",\n      value: function afterState() {\n        if (this._afterState !== undefined) return this._afterState;\n        var beforeState = this.beforeState();\n        this._afterState = {\n          rings: beforeState.rings.slice(0),\n          windings: beforeState.windings.slice(0),\n          multiPolys: []\n        };\n        var ringsAfter = this._afterState.rings;\n        var windingsAfter = this._afterState.windings;\n        var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n        for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n          var ring = this.rings[i];\n          var winding = this.windings[i];\n          var index = ringsAfter.indexOf(ring);\n\n          if (index === -1) {\n            ringsAfter.push(ring);\n            windingsAfter.push(winding);\n          } else windingsAfter[index] += winding;\n        } // calcualte polysAfter\n\n\n        var polysAfter = [];\n        var polysExclude = [];\n\n        for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n          if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n          var _ring = ringsAfter[_i];\n          var poly = _ring.poly;\n          if (polysExclude.indexOf(poly) !== -1) continue;\n          if (_ring.isExterior) polysAfter.push(poly);else {\n            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n            var _index = polysAfter.indexOf(_ring.poly);\n\n            if (_index !== -1) polysAfter.splice(_index, 1);\n          }\n        } // calculate multiPolysAfter\n\n\n        for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n          var mp = polysAfter[_i2].multiPoly;\n          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n        }\n\n        return this._afterState;\n      }\n      /* Is this segment part of the final result? */\n\n    }, {\n      key: \"isInResult\",\n      value: function isInResult() {\n        // if we've been consumed, we're not in the result\n        if (this.consumedBy) return false;\n        if (this._isInResult !== undefined) return this._isInResult;\n        var mpsBefore = this.beforeState().multiPolys;\n        var mpsAfter = this.afterState().multiPolys;\n\n        switch (operation.type) {\n          case 'union':\n            {\n              // UNION - included iff:\n              //  * On one side of us there is 0 poly interiors AND\n              //  * On the other side there is 1 or more.\n              var noBefores = mpsBefore.length === 0;\n              var noAfters = mpsAfter.length === 0;\n              this._isInResult = noBefores !== noAfters;\n              break;\n            }\n\n          case 'intersection':\n            {\n              // INTERSECTION - included iff:\n              //  * on one side of us all multipolys are rep. with poly interiors AND\n              //  * on the other side of us, not all multipolys are repsented\n              //    with poly interiors\n              var least;\n              var most;\n\n              if (mpsBefore.length < mpsAfter.length) {\n                least = mpsBefore.length;\n                most = mpsAfter.length;\n              } else {\n                least = mpsAfter.length;\n                most = mpsBefore.length;\n              }\n\n              this._isInResult = most === operation.numMultiPolys && least < most;\n              break;\n            }\n\n          case 'xor':\n            {\n              // XOR - included iff:\n              //  * the difference between the number of multipolys represented\n              //    with poly interiors on our two sides is an odd number\n              var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n              this._isInResult = diff % 2 === 1;\n              break;\n            }\n\n          case 'difference':\n            {\n              // DIFFERENCE included iff:\n              //  * on exactly one side, we have just the subject\n              var isJustSubject = function isJustSubject(mps) {\n                return mps.length === 1 && mps[0].isSubject;\n              };\n\n              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n              break;\n            }\n\n          default:\n            throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n        }\n\n        return this._isInResult;\n      }\n    }], [{\n      key: \"fromRing\",\n      value: function fromRing(pt1, pt2, ring) {\n        var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n        var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n        if (cmpPts < 0) {\n          leftPt = pt1;\n          rightPt = pt2;\n          winding = 1;\n        } else if (cmpPts > 0) {\n          leftPt = pt2;\n          rightPt = pt1;\n          winding = -1;\n        } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n        var leftSE = new SweepEvent(leftPt, true);\n        var rightSE = new SweepEvent(rightPt, false);\n        return new Segment(leftSE, rightSE, [ring], [winding]);\n      }\n    }]);\n\n    return Segment;\n  }();\n\n  var RingIn = /*#__PURE__*/function () {\n    function RingIn(geomRing, poly, isExterior) {\n      _classCallCheck(this, RingIn);\n\n      if (!Array.isArray(geomRing) || geomRing.length === 0) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.poly = poly;\n      this.isExterior = isExterior;\n      this.segments = [];\n\n      if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n      this.bbox = {\n        ll: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        },\n        ur: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        }\n      };\n      var prevPoint = firstPoint;\n\n      for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n        if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n        }\n\n        var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n        if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n        this.segments.push(Segment.fromRing(prevPoint, point, this));\n        if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n        if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n        if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n        if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n        prevPoint = point;\n      } // add segment from last to first if last is not the same as first\n\n\n      if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n      }\n    }\n\n    _createClass(RingIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n          var segment = this.segments[i];\n          sweepEvents.push(segment.leftSE);\n          sweepEvents.push(segment.rightSE);\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return RingIn;\n  }();\n  var PolyIn = /*#__PURE__*/function () {\n    function PolyIn(geomPoly, multiPoly) {\n      _classCallCheck(this, PolyIn);\n\n      if (!Array.isArray(geomPoly)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n      this.bbox = {\n        ll: {\n          x: this.exteriorRing.bbox.ll.x,\n          y: this.exteriorRing.bbox.ll.y\n        },\n        ur: {\n          x: this.exteriorRing.bbox.ur.x,\n          y: this.exteriorRing.bbox.ur.y\n        }\n      };\n      this.interiorRings = [];\n\n      for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n        var ring = new RingIn(geomPoly[i], this, false);\n        if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n        if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n        if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n        if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n        this.interiorRings.push(ring);\n      }\n\n      this.multiPoly = multiPoly;\n    }\n\n    _createClass(PolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = this.exteriorRing.getSweepEvents();\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n          for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(ringSweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return PolyIn;\n  }();\n  var MultiPolyIn = /*#__PURE__*/function () {\n    function MultiPolyIn(geom, isSubject) {\n      _classCallCheck(this, MultiPolyIn);\n\n      if (!Array.isArray(geom)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      try {\n        // if the input looks like a polygon, convert it to a multipolygon\n        if (typeof geom[0][0][0] === 'number') geom = [geom];\n      } catch (ex) {// The input is either malformed or has empty arrays.\n        // In either case, it will be handled later on.\n      }\n\n      this.polys = [];\n      this.bbox = {\n        ll: {\n          x: Number.POSITIVE_INFINITY,\n          y: Number.POSITIVE_INFINITY\n        },\n        ur: {\n          x: Number.NEGATIVE_INFINITY,\n          y: Number.NEGATIVE_INFINITY\n        }\n      };\n\n      for (var i = 0, iMax = geom.length; i < iMax; i++) {\n        var poly = new PolyIn(geom[i], this);\n        if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n        if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n        if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n        if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n        this.polys.push(poly);\n      }\n\n      this.isSubject = isSubject;\n    }\n\n    _createClass(MultiPolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polySweepEvents = this.polys[i].getSweepEvents();\n\n          for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(polySweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return MultiPolyIn;\n  }();\n\n  var RingOut = /*#__PURE__*/function () {\n    _createClass(RingOut, null, [{\n      key: \"factory\",\n\n      /* Given the segments from the sweep line pass, compute & return a series\n       * of closed rings from all the segments marked to be part of the result */\n      value: function factory(allSegments) {\n        var ringsOut = [];\n\n        for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n          var segment = allSegments[i];\n          if (!segment.isInResult() || segment.ringOut) continue;\n          var prevEvent = null;\n          var event = segment.leftSE;\n          var nextEvent = segment.rightSE;\n          var events = [event];\n          var startingPoint = event.point;\n          var intersectionLEs = [];\n          /* Walk the chain of linked events to form a closed ring */\n\n          while (true) {\n            prevEvent = event;\n            event = nextEvent;\n            events.push(event);\n            /* Is the ring complete? */\n\n            if (event.point === startingPoint) break;\n\n            while (true) {\n              var availableLEs = event.getAvailableLinkedEvents();\n              /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n               * part of the algorithm malfunctioned... please file a bug report. */\n\n              if (availableLEs.length === 0) {\n                var firstPt = events[0].point;\n                var lastPt = events[events.length - 1].point;\n                throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n              }\n              /* Only one way to go, so cotinue on the path */\n\n\n              if (availableLEs.length === 1) {\n                nextEvent = availableLEs[0].otherSE;\n                break;\n              }\n              /* We must have an intersection. Check for a completed loop */\n\n\n              var indexLE = null;\n\n              for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n                if (intersectionLEs[j].point === event.point) {\n                  indexLE = j;\n                  break;\n                }\n              }\n              /* Found a completed loop. Cut that off and make a ring */\n\n\n              if (indexLE !== null) {\n                var intersectionLE = intersectionLEs.splice(indexLE)[0];\n                var ringEvents = events.splice(intersectionLE.index);\n                ringEvents.unshift(ringEvents[0].otherSE);\n                ringsOut.push(new RingOut(ringEvents.reverse()));\n                continue;\n              }\n              /* register the intersection */\n\n\n              intersectionLEs.push({\n                index: events.length,\n                point: event.point\n              });\n              /* Choose the left-most option to continue the walk */\n\n              var comparator = event.getLeftmostComparator(prevEvent);\n              nextEvent = availableLEs.sort(comparator)[0].otherSE;\n              break;\n            }\n          }\n\n          ringsOut.push(new RingOut(events));\n        }\n\n        return ringsOut;\n      }\n    }]);\n\n    function RingOut(events) {\n      _classCallCheck(this, RingOut);\n\n      this.events = events;\n\n      for (var i = 0, iMax = events.length; i < iMax; i++) {\n        events[i].segment.ringOut = this;\n      }\n\n      this.poly = null;\n    }\n\n    _createClass(RingOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        // Remove superfluous points (ie extra points along a straight line),\n        var prevPt = this.events[0].point;\n        var points = [prevPt];\n\n        for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n          var _pt = this.events[i].point;\n          var _nextPt = this.events[i + 1].point;\n          if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n          points.push(_pt);\n          prevPt = _pt;\n        } // ring was all (within rounding error of angle calc) colinear points\n\n\n        if (points.length === 1) return null; // check if the starting point is necessary\n\n        var pt = points[0];\n        var nextPt = points[1];\n        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n        points.push(points[0]);\n        var step = this.isExteriorRing() ? 1 : -1;\n        var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n        var iEnd = this.isExteriorRing() ? points.length : -1;\n        var orderedPoints = [];\n\n        for (var _i = iStart; _i != iEnd; _i += step) {\n          orderedPoints.push([points[_i].x, points[_i].y]);\n        }\n\n        return orderedPoints;\n      }\n    }, {\n      key: \"isExteriorRing\",\n      value: function isExteriorRing() {\n        if (this._isExteriorRing === undefined) {\n          var enclosing = this.enclosingRing();\n          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n        }\n\n        return this._isExteriorRing;\n      }\n    }, {\n      key: \"enclosingRing\",\n      value: function enclosingRing() {\n        if (this._enclosingRing === undefined) {\n          this._enclosingRing = this._calcEnclosingRing();\n        }\n\n        return this._enclosingRing;\n      }\n      /* Returns the ring that encloses this one, if any */\n\n    }, {\n      key: \"_calcEnclosingRing\",\n      value: function _calcEnclosingRing() {\n        // start with the ealier sweep line event so that the prevSeg\n        // chain doesn't lead us inside of a loop of ours\n        var leftMostEvt = this.events[0];\n\n        for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n          var evt = this.events[i];\n          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n        }\n\n        var prevSeg = leftMostEvt.segment.prevInResult();\n        var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n        while (true) {\n          // no segment found, thus no ring can enclose us\n          if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n          // segment must loop back around and enclose us\n\n          if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n          // segment must either loop around us or the ring of the prev prev\n          // seg, which would make us and the ring of the prev peers\n\n          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n              return prevSeg.ringOut;\n            } else return prevSeg.ringOut.enclosingRing();\n          } // two segments are from the same ring, so this was a penisula\n          // of that ring. iterate downward, keep searching\n\n\n          prevSeg = prevPrevSeg.prevInResult();\n          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        }\n      }\n    }]);\n\n    return RingOut;\n  }();\n  var PolyOut = /*#__PURE__*/function () {\n    function PolyOut(exteriorRing) {\n      _classCallCheck(this, PolyOut);\n\n      this.exteriorRing = exteriorRing;\n      exteriorRing.poly = this;\n      this.interiorRings = [];\n    }\n\n    _createClass(PolyOut, [{\n      key: \"addInterior\",\n      value: function addInterior(ring) {\n        this.interiorRings.push(ring);\n        ring.poly = this;\n      }\n    }, {\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (geom[0] === null) return null;\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n          if (ringGeom === null) continue;\n          geom.push(ringGeom);\n        }\n\n        return geom;\n      }\n    }]);\n\n    return PolyOut;\n  }();\n  var MultiPolyOut = /*#__PURE__*/function () {\n    function MultiPolyOut(rings) {\n      _classCallCheck(this, MultiPolyOut);\n\n      this.rings = rings;\n      this.polys = this._composePolys(rings);\n    }\n\n    _createClass(MultiPolyOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n          if (polyGeom === null) continue;\n          geom.push(polyGeom);\n        }\n\n        return geom;\n      }\n    }, {\n      key: \"_composePolys\",\n      value: function _composePolys(rings) {\n        var polys = [];\n\n        for (var i = 0, iMax = rings.length; i < iMax; i++) {\n          var ring = rings[i];\n          if (ring.poly) continue;\n          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n            var enclosingRing = ring.enclosingRing();\n            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n            enclosingRing.poly.addInterior(ring);\n          }\n        }\n\n        return polys;\n      }\n    }]);\n\n    return MultiPolyOut;\n  }();\n\n  /**\n   * NOTE:  We must be careful not to change any segments while\n   *        they are in the SplayTree. AFAIK, there's no way to tell\n   *        the tree to rebalance itself - thus before splitting\n   *        a segment that's in the tree, we remove it from the tree,\n   *        do the split, then re-insert it. (Even though splitting a\n   *        segment *shouldn't* change its correct position in the\n   *        sweep line tree, the reality is because of rounding errors,\n   *        it sometimes does.)\n   */\n\n  var SweepLine = /*#__PURE__*/function () {\n    function SweepLine(queue) {\n      var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n      _classCallCheck(this, SweepLine);\n\n      this.queue = queue;\n      this.tree = new Tree(comparator);\n      this.segments = [];\n    }\n\n    _createClass(SweepLine, [{\n      key: \"process\",\n      value: function process(event) {\n        var segment = event.segment;\n        var newEvents = []; // if we've already been consumed by another segment,\n        // clean up our body parts and get out\n\n        if (event.consumedBy) {\n          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n          return newEvents;\n        }\n\n        var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n        if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n        var prevNode = node;\n        var nextNode = node;\n        var prevSeg = undefined;\n        var nextSeg = undefined; // skip consumed segments still in tree\n\n        while (prevSeg === undefined) {\n          prevNode = this.tree.prev(prevNode);\n          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n        } // skip consumed segments still in tree\n\n\n        while (nextSeg === undefined) {\n          nextNode = this.tree.next(nextNode);\n          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n        }\n\n        if (event.isLeft) {\n          // Check for intersections against the previous segment in the sweep line\n          var prevMySplitter = null;\n\n          if (prevSeg) {\n            var prevInter = prevSeg.getIntersection(segment);\n\n            if (prevInter !== null) {\n              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n              if (!prevSeg.isAnEndpoint(prevInter)) {\n                var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n                for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          } // Check for intersections against the next segment in the sweep line\n\n\n          var nextMySplitter = null;\n\n          if (nextSeg) {\n            var nextInter = nextSeg.getIntersection(segment);\n\n            if (nextInter !== null) {\n              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n              if (!nextSeg.isAnEndpoint(nextInter)) {\n                var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n                for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                  newEvents.push(_newEventsFromSplit[_i]);\n                }\n              }\n            }\n          } // For simplicity, even if we find more than one intersection we only\n          // spilt on the 'earliest' (sweep-line style) of the intersections.\n          // The other intersection will be handled in a future process().\n\n\n          if (prevMySplitter !== null || nextMySplitter !== null) {\n            var mySplitter = null;\n            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n              var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n            } // Rounding errors can cause changes in ordering,\n            // so remove afected segments and right sweep events before splitting\n\n            this.queue.remove(segment.rightSE);\n            newEvents.push(segment.rightSE);\n\n            var _newEventsFromSplit2 = segment.split(mySplitter);\n\n            for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n              newEvents.push(_newEventsFromSplit2[_i2]);\n            }\n          }\n\n          if (newEvents.length > 0) {\n            // We found some intersections, so re-do the current event to\n            // make sure sweep line ordering is totally consistent for later\n            // use with the segment 'prev' pointers\n            this.tree.remove(segment);\n            newEvents.push(event);\n          } else {\n            // done with left event\n            this.segments.push(segment);\n            segment.prev = prevSeg;\n          }\n        } else {\n          // event.isRight\n          // since we're about to be removed from the sweep line, check for\n          // intersections between our previous and next segments\n          if (prevSeg && nextSeg) {\n            var inter = prevSeg.getIntersection(nextSeg);\n\n            if (inter !== null) {\n              if (!prevSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n                for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                  newEvents.push(_newEventsFromSplit3[_i3]);\n                }\n              }\n\n              if (!nextSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n                for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                  newEvents.push(_newEventsFromSplit4[_i4]);\n                }\n              }\n            }\n          }\n\n          this.tree.remove(segment);\n        }\n\n        return newEvents;\n      }\n      /* Safely split a segment that is currently in the datastructures\n       * IE - a segment other than the one that is currently being processed. */\n\n    }, {\n      key: \"_splitSafely\",\n      value: function _splitSafely(seg, pt) {\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        // removeNode() doesn't work, so have re-find the seg\n        // https://github.com/w8r/splay-tree/pull/5\n        this.tree.remove(seg);\n        var rightSE = seg.rightSE;\n        this.queue.remove(rightSE);\n        var newEvents = seg.split(pt);\n        newEvents.push(rightSE); // splitting can trigger consumption\n\n        if (seg.consumedBy === undefined) this.tree.insert(seg);\n        return newEvents;\n      }\n    }]);\n\n    return SweepLine;\n  }();\n\n  var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\n  var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\n  var Operation = /*#__PURE__*/function () {\n    function Operation() {\n      _classCallCheck(this, Operation);\n    }\n\n    _createClass(Operation, [{\n      key: \"run\",\n      value: function run(type, geom, moreGeoms) {\n        operation.type = type;\n        rounder.reset();\n        /* Convert inputs to MultiPoly objects */\n\n        var multipolys = [new MultiPolyIn(geom, true)];\n\n        for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n          multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n        }\n\n        operation.numMultiPolys = multipolys.length;\n        /* BBox optimization for difference operation\n         * If the bbox of a multipolygon that's part of the clipping doesn't\n         * intersect the bbox of the subject at all, we can just drop that\n         * multiploygon. */\n\n        if (operation.type === 'difference') {\n          // in place removal\n          var subject = multipolys[0];\n          var _i = 1;\n\n          while (_i < multipolys.length) {\n            if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n          }\n        }\n        /* BBox optimization for intersection operation\n         * If we can find any pair of multipolygons whose bbox does not overlap,\n         * then the result will be empty. */\n\n\n        if (operation.type === 'intersection') {\n          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n          //       it could be optimized to O(n * ln(n))\n          for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n            var mpA = multipolys[_i2];\n\n            for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n            }\n          }\n        }\n        /* Put segment endpoints in a priority queue */\n\n\n        var queue = new Tree(SweepEvent.compare);\n\n        for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n          var sweepEvents = multipolys[_i3].getSweepEvents();\n\n          for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n            queue.insert(sweepEvents[_j]);\n\n            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n              // prevents an infinite loop, an otherwise common manifestation of bugs\n              throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n            }\n          }\n        }\n        /* Pass the sweep line over those endpoints */\n\n\n        var sweepLine = new SweepLine(queue);\n        var prevQueueSize = queue.size;\n        var node = queue.pop();\n\n        while (node) {\n          var evt = node.key;\n\n          if (queue.size === prevQueueSize) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            var seg = evt.segment;\n            throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n          }\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n          }\n\n          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n          }\n\n          var newEvents = sweepLine.process(evt);\n\n          for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n            var _evt = newEvents[_i4];\n            if (_evt.consumedBy === undefined) queue.insert(_evt);\n          }\n\n          prevQueueSize = queue.size;\n          node = queue.pop();\n        } // free some memory we don't need anymore\n\n\n        rounder.reset();\n        /* Collect and compile segments we're keeping into a multipolygon */\n\n        var ringsOut = RingOut.factory(sweepLine.segments);\n        var result = new MultiPolyOut(ringsOut);\n        return result.getGeom();\n      }\n    }]);\n\n    return Operation;\n  }(); // singleton available by import\n\n  var operation = new Operation();\n\n  var union = function union(geom) {\n    for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      moreGeoms[_key - 1] = arguments[_key];\n    }\n\n    return operation.run('union', geom, moreGeoms);\n  };\n\n  var intersection$1 = function intersection(geom) {\n    for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      moreGeoms[_key2 - 1] = arguments[_key2];\n    }\n\n    return operation.run('intersection', geom, moreGeoms);\n  };\n\n  var xor = function xor(geom) {\n    for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      moreGeoms[_key3 - 1] = arguments[_key3];\n    }\n\n    return operation.run('xor', geom, moreGeoms);\n  };\n\n  var difference = function difference(subjectGeom) {\n    for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      clippingGeoms[_key4 - 1] = arguments[_key4];\n    }\n\n    return operation.run('difference', subjectGeom, clippingGeoms);\n  };\n\n  var index = {\n    union: union,\n    intersection: intersection$1,\n    xor: xor,\n    difference: difference\n  };\n\n  return index;\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}