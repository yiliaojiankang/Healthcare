{"ast":null,"code":"import LuDecomposition from './dc/lu';\nimport QrDecomposition from './dc/qr';\nimport SingularValueDecomposition from './dc/svd';\nimport Matrix from './matrix';\nimport WrapperMatrix2D from './wrap/WrapperMatrix2D';\nexport function inverse(matrix, useSVD = false) {\n  matrix = WrapperMatrix2D.checkMatrix(matrix);\n  if (useSVD) {\n    return new SingularValueDecomposition(matrix).inverse();\n  } else {\n    return solve(matrix, Matrix.eye(matrix.rows));\n  }\n}\nexport function solve(leftHandSide, rightHandSide, useSVD = false) {\n  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);\n  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);\n  if (useSVD) {\n    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);\n  } else {\n    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n  }\n}","map":{"version":3,"names":["LuDecomposition","QrDecomposition","SingularValueDecomposition","Matrix","WrapperMatrix2D","inverse","matrix","useSVD","checkMatrix","solve","eye","rows","leftHandSide","rightHandSide","isSquare"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/layout/node_modules/ml-matrix/src/decompositions.js"],"sourcesContent":["import LuDecomposition from './dc/lu';\nimport QrDecomposition from './dc/qr';\nimport SingularValueDecomposition from './dc/svd';\nimport Matrix from './matrix';\nimport WrapperMatrix2D from './wrap/WrapperMatrix2D';\n\nexport function inverse(matrix, useSVD = false) {\n  matrix = WrapperMatrix2D.checkMatrix(matrix);\n  if (useSVD) {\n    return new SingularValueDecomposition(matrix).inverse();\n  } else {\n    return solve(matrix, Matrix.eye(matrix.rows));\n  }\n}\n\nexport function solve(leftHandSide, rightHandSide, useSVD = false) {\n  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);\n  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);\n  if (useSVD) {\n    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);\n  } else {\n    return leftHandSide.isSquare()\n      ? new LuDecomposition(leftHandSide).solve(rightHandSide)\n      : new QrDecomposition(leftHandSide).solve(rightHandSide);\n  }\n}\n"],"mappings":"AAAA,OAAOA,eAAe,MAAM,SAAS;AACrC,OAAOC,eAAe,MAAM,SAAS;AACrC,OAAOC,0BAA0B,MAAM,UAAU;AACjD,OAAOC,MAAM,MAAM,UAAU;AAC7B,OAAOC,eAAe,MAAM,wBAAwB;AAEpD,OAAO,SAASC,OAAOA,CAACC,MAAM,EAAEC,MAAM,GAAG,KAAK,EAAE;EAC9CD,MAAM,GAAGF,eAAe,CAACI,WAAW,CAACF,MAAM,CAAC;EAC5C,IAAIC,MAAM,EAAE;IACV,OAAO,IAAIL,0BAA0B,CAACI,MAAM,CAAC,CAACD,OAAO,CAAC,CAAC;EACzD,CAAC,MAAM;IACL,OAAOI,KAAK,CAACH,MAAM,EAAEH,MAAM,CAACO,GAAG,CAACJ,MAAM,CAACK,IAAI,CAAC,CAAC;EAC/C;AACF;AAEA,OAAO,SAASF,KAAKA,CAACG,YAAY,EAAEC,aAAa,EAAEN,MAAM,GAAG,KAAK,EAAE;EACjEK,YAAY,GAAGR,eAAe,CAACI,WAAW,CAACI,YAAY,CAAC;EACxDC,aAAa,GAAGT,eAAe,CAACI,WAAW,CAACK,aAAa,CAAC;EAC1D,IAAIN,MAAM,EAAE;IACV,OAAO,IAAIL,0BAA0B,CAACU,YAAY,CAAC,CAACH,KAAK,CAACI,aAAa,CAAC;EAC1E,CAAC,MAAM;IACL,OAAOD,YAAY,CAACE,QAAQ,CAAC,CAAC,GAC1B,IAAId,eAAe,CAACY,YAAY,CAAC,CAACH,KAAK,CAACI,aAAa,CAAC,GACtD,IAAIZ,eAAe,CAACW,YAAY,CAAC,CAACH,KAAK,CAACI,aAAa,CAAC;EAC5D;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}