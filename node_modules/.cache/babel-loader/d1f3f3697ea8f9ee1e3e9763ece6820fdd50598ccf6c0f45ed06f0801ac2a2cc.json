{"ast":null,"code":"import { getSectorPath } from './graphics';\nimport { isBetween } from './helper';\nimport { BBox } from './bbox';\n/**\n * @ignore\n * Gets x dimension length\n * @param coordinate\n * @returns x dimension length\n */\nexport function getXDimensionLength(coordinate) {\n  if (coordinate.isPolar && !coordinate.isTransposed) {\n    // 极坐标系下 width 为弧长\n    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();\n  }\n  // 直角坐标系\n  var start = coordinate.convert({\n    x: 0,\n    y: 0\n  });\n  var end = coordinate.convert({\n    x: 1,\n    y: 0\n  });\n  // 坐标系有可能发生 transpose 等变换，所有通过两点之间的距离进行计算\n  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n}\n/**\n * @ignore\n * Determines whether full circle is\n * @param coordinate\n * @returns true if full circle\n */\nexport function isFullCircle(coordinate) {\n  if (coordinate.isPolar) {\n    var startAngle = coordinate.startAngle,\n      endAngle = coordinate.endAngle;\n    return endAngle - startAngle === Math.PI * 2;\n  }\n  return false;\n}\n/**\n * @ignore\n * 获取当前点到坐标系圆心的距离\n * @param coordinate 坐标系\n * @param point 当前点\n * @returns distance to center\n */\nexport function getDistanceToCenter(coordinate, point) {\n  var center = coordinate.getCenter();\n  return Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\n}\n/**\n * @ignore\n * 坐标点是否在坐标系中\n * @param coordinate\n * @param point\n */\nexport function isPointInCoordinate(coordinate, point) {\n  var result = false;\n  if (coordinate) {\n    if (coordinate.type === 'theta') {\n      var start = coordinate.start,\n        end = coordinate.end;\n      result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);\n    } else {\n      var invertPoint = coordinate.invert(point);\n      result = isBetween(invertPoint.x, 0, 1) && isBetween(invertPoint.y, 0, 1);\n    }\n  }\n  return result;\n}\n/**\n * @ignore\n * 获取点到圆心的连线与水平方向的夹角\n */\nexport function getAngleByPoint(coordinate, point) {\n  var center = coordinate.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n/**\n * @ignore\n * 获取同坐标系范围相同的剪切区域\n * @param coordinate\n * @returns\n */\nexport function getCoordinateClipCfg(coordinate, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n  var start = coordinate.start,\n    end = coordinate.end;\n  var width = coordinate.getWidth();\n  var height = coordinate.getHeight();\n  if (coordinate.isPolar) {\n    var startAngle_1 = coordinate.startAngle,\n      endAngle_1 = coordinate.endAngle;\n    var center_1 = coordinate.getCenter();\n    var radius_1 = coordinate.getRadius();\n    return {\n      type: 'path',\n      startState: {\n        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)\n      },\n      endState: function (ratio) {\n        var diff = (endAngle_1 - startAngle_1) * ratio + startAngle_1;\n        var path = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff);\n        return {\n          path: path\n        };\n      },\n      attrs: {\n        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)\n      }\n    };\n  }\n  var endState;\n  if (coordinate.isTransposed) {\n    endState = {\n      height: height + margin * 2\n    };\n  } else {\n    endState = {\n      width: width + margin * 2\n    };\n  }\n  return {\n    type: 'rect',\n    startState: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: coordinate.isTransposed ? width + margin * 2 : 0,\n      height: coordinate.isTransposed ? 0 : height + margin * 2\n    },\n    endState: endState,\n    attrs: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: width + margin * 2,\n      height: height + margin * 2\n    }\n  };\n}\n/**\n * 获取坐标系范围的 BBox\n * @param coordinate\n * @param margin\n */\nexport function getCoordinateBBox(coordinate, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n  var start = coordinate.start,\n    end = coordinate.end;\n  var width = coordinate.getWidth();\n  var height = coordinate.getHeight();\n  var minX = Math.min(start.x, end.x);\n  var minY = Math.min(start.y, end.y);\n  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);\n}","map":{"version":3,"names":["getSectorPath","isBetween","BBox","getXDimensionLength","coordinate","isPolar","isTransposed","endAngle","startAngle","getRadius","start","convert","x","y","end","Math","sqrt","pow","isFullCircle","PI","getDistanceToCenter","point","center","getCenter","isPointInCoordinate","result","type","invertPoint","invert","getAngleByPoint","atan2","getCoordinateClipCfg","margin","width","getWidth","height","getHeight","startAngle_1","endAngle_1","center_1","radius_1","startState","path","endState","ratio","diff","attrs","getCoordinateBBox","minX","min","minY","fromRange"],"sources":["../../src/util/coordinate.ts"],"sourcesContent":["import { Coordinate } from '../dependents';\nimport { Point } from '../interface';\nimport { getSectorPath } from './graphics';\nimport { isBetween } from './helper';\nimport { BBox } from './bbox';\n\n/**\n * @ignore\n * Gets x dimension length\n * @param coordinate\n * @returns x dimension length\n */\nexport function getXDimensionLength(coordinate): number {\n  if (coordinate.isPolar && !coordinate.isTransposed) {\n    // 极坐标系下 width 为弧长\n    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();\n  }\n\n  // 直角坐标系\n  const start = coordinate.convert({ x: 0, y: 0 });\n  const end = coordinate.convert({ x: 1, y: 0 });\n  // 坐标系有可能发生 transpose 等变换，所有通过两点之间的距离进行计算\n  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n}\n\n/**\n * @ignore\n * Determines whether full circle is\n * @param coordinate\n * @returns true if full circle\n */\nexport function isFullCircle(coordinate: Coordinate): boolean {\n  if (coordinate.isPolar) {\n    const { startAngle, endAngle } = coordinate;\n    return endAngle - startAngle === Math.PI * 2;\n  }\n  return false;\n}\n\n/**\n * @ignore\n * 获取当前点到坐标系圆心的距离\n * @param coordinate 坐标系\n * @param point 当前点\n * @returns distance to center\n */\nexport function getDistanceToCenter(coordinate: Coordinate, point: Point): number {\n  const center = coordinate.getCenter() as Point;\n  return Math.sqrt((point.x - center.x) ** 2 + (point.y - center.y) ** 2);\n}\n\n/**\n * @ignore\n * 坐标点是否在坐标系中\n * @param coordinate\n * @param point\n */\nexport function isPointInCoordinate(coordinate: Coordinate, point: Point) {\n  let result = false;\n\n  if (coordinate) {\n    if (coordinate.type === 'theta') {\n      const { start, end } = coordinate;\n      result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);\n    } else {\n      const invertPoint = coordinate.invert(point);\n    \n      result = isBetween(invertPoint.x, 0, 1) && isBetween(invertPoint.y, 0, 1);\n    }\n  }\n\n  return result;\n}\n\n/**\n * @ignore\n * 获取点到圆心的连线与水平方向的夹角\n */\nexport function getAngleByPoint(coordinate: Coordinate, point: Point): number {\n  const center = coordinate.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n\n/**\n * @ignore\n * 获取同坐标系范围相同的剪切区域\n * @param coordinate\n * @returns\n */\nexport function getCoordinateClipCfg(coordinate: Coordinate, margin: number = 0) {\n  const { start, end } = coordinate;\n  const width = coordinate.getWidth();\n  const height = coordinate.getHeight();\n\n  if (coordinate.isPolar) {\n    const { startAngle, endAngle } = coordinate;\n    const center = coordinate.getCenter();\n    const radius = coordinate.getRadius();\n\n    return {\n      type: 'path',\n      startState: {\n        path: getSectorPath(center.x, center.y, radius + margin, startAngle, startAngle),\n      },\n      endState: (ratio) => {\n        const diff = (endAngle - startAngle) * ratio + startAngle;\n        const path = getSectorPath(center.x, center.y, radius + margin, startAngle, diff);\n        return {\n          path,\n        };\n      },\n      attrs: {\n        path: getSectorPath(center.x, center.y, radius + margin, startAngle, endAngle),\n      },\n    };\n  }\n\n  let endState;\n  if (coordinate.isTransposed) {\n    endState = {\n      height: height + margin * 2,\n    };\n  } else {\n    endState = {\n      width: width + margin * 2,\n    };\n  }\n\n  return {\n    type: 'rect',\n    startState: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: coordinate.isTransposed ? width + margin * 2 : 0,\n      height: coordinate.isTransposed ? 0 : height + margin * 2,\n    },\n    endState,\n    attrs: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: width + margin * 2,\n      height: height + margin * 2,\n    },\n  };\n}\n\n/**\n * 获取坐标系范围的 BBox\n * @param coordinate\n * @param margin\n */\nexport function getCoordinateBBox(coordinate: Coordinate, margin = 0) {\n  const { start, end } = coordinate;\n  const width = coordinate.getWidth();\n  const height = coordinate.getHeight();\n  const minX = Math.min(start.x, end.x);\n  const minY = Math.min(start.y, end.y);\n\n  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}