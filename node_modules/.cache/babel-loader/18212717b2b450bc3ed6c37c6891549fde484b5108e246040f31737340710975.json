{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport { deepMix, each, get, isArray, isFunction, isNil, isNumber, isUndefined } from '@antv/util';\nimport { FIELD_ORIGIN } from '../../constant';\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\nimport Labels from '../../component/labels';\nfunction avg(arr) {\n  var sum = 0;\n  each(arr, function (value) {\n    sum += value;\n  });\n  return sum / arr.length;\n}\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\nvar GeometryLabel = /** @class */function () {\n  function GeometryLabel(geometry) {\n    this.geometry = geometry;\n  }\n  GeometryLabel.prototype.getLabelItems = function (mapppingArray) {\n    var _this = this;\n    var items = [];\n    var labelCfgs = this.getLabelCfgs(mapppingArray);\n    // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n    each(mapppingArray, function (mappingData, index) {\n      var labelCfg = labelCfgs[index];\n      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n        items.push(null);\n        return;\n      }\n      var labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n      labelCfg.content = labelContent;\n      var total = labelContent.length;\n      each(labelContent, function (content, subIndex) {\n        if (isNil(content) || content === '') {\n          items.push(null);\n          return;\n        }\n        var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));\n        if (!item.textAlign) {\n          item.textAlign = _this.getLabelAlign(item, subIndex, total);\n        }\n        if (item.offset <= 0) {\n          item.labelLine = null;\n        }\n        items.push(item);\n      });\n    });\n    return items;\n  };\n  GeometryLabel.prototype.render = function (mappingArray, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var labelItems, labelsRenderer, shapes;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            labelItems = this.getLabelItems(mappingArray);\n            labelsRenderer = this.getLabelsRenderer();\n            shapes = this.getGeometryShapes();\n            // 渲染文本\n            return [4 /*yield*/, labelsRenderer.render(labelItems, shapes, isUpdate)];\n          case 1:\n            // 渲染文本\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  GeometryLabel.prototype.clear = function () {\n    var labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.clear();\n    }\n  };\n  GeometryLabel.prototype.destroy = function () {\n    var labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.destroy();\n    }\n    this.labelsRenderer = null;\n  };\n  // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n  GeometryLabel.prototype.getCoordinate = function () {\n    return this.geometry.coordinate;\n  };\n  /**\n   * 获取 label 的默认配置\n   */\n  GeometryLabel.prototype.getDefaultLabelCfg = function (offset, position) {\n    var geometry = this.geometry;\n    var type = geometry.type,\n      theme = geometry.theme;\n    if (type === 'polygon' || type === 'interval' && position === 'middle' || offset < 0 && !['line', 'point', 'path'].includes(type)) {\n      // polygon 或者 (interval 且 middle) 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      return get(theme, 'innerLabels', {});\n    }\n    return get(theme, 'labels', {});\n  };\n  /**\n   * 获取当前 label 的最终配置\n   * @param labelCfg\n   */\n  GeometryLabel.prototype.getThemedLabelCfg = function (labelCfg) {\n    var geometry = this.geometry;\n    var defaultLabelCfg = this.getDefaultLabelCfg();\n    var type = geometry.type,\n      theme = geometry.theme;\n    var themedLabelCfg;\n    if (type === 'polygon' || labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type)) {\n      // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n    } else {\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n    }\n    return themedLabelCfg;\n  };\n  /**\n   * 设置 label 位置\n   * @param labelPointCfg\n   * @param mappingData\n   * @param index\n   * @param position\n   */\n  GeometryLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {};\n  /**\n   * @desc 获取 label offset\n   */\n  GeometryLabel.prototype.getLabelOffset = function (offset) {\n    var coordinate = this.getCoordinate();\n    var vector = this.getOffsetVector(offset);\n    return coordinate.isTransposed ? vector[0] : vector[1];\n  };\n  /**\n   * 获取每个 label 的偏移量 (矢量)\n   * @param labelCfg\n   * @param index\n   * @param total\n   * @return {Point} offsetPoint\n   */\n  GeometryLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total) {\n    var offset = labelCfg.offset;\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var dim = transposed ? 'x' : 'y';\n    var factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n    var offsetPoint = {\n      x: 0,\n      y: 0\n    };\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[dim] = offset * factor;\n    } else {\n      offsetPoint[dim] = offset * factor * -1;\n    }\n    return offsetPoint;\n  };\n  /**\n   * 获取每个 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   * @returns label point\n   */\n  GeometryLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n    var coordinate = this.getCoordinate();\n    var total = labelCfg.content.length;\n    function getDimValue(value, idx, isAvg) {\n      if (isAvg === void 0) {\n        isAvg = false;\n      }\n      var v = value;\n      if (isArray(v)) {\n        if (labelCfg.content.length === 1) {\n          if (isAvg) {\n            v = avg(v);\n          } else {\n            // 如果仅一个 label，多个 y, 取最后一个 y\n            if (v.length <= 2) {\n              v = v[value.length - 1];\n            } else {\n              v = avg(v);\n            }\n          }\n        } else {\n          v = v[idx];\n        }\n      }\n      return v;\n    }\n    var label = {\n      content: labelCfg.content[index],\n      x: 0,\n      y: 0,\n      start: {\n        x: 0,\n        y: 0\n      },\n      color: '#fff'\n    };\n    var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    var isFunnel = shape === 'funnel' || shape === 'pyramid';\n    // 多边形场景，多用于地图\n    if (this.geometry.type === 'polygon') {\n      var centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else if (this.geometry.type === 'interval' && !isFunnel) {\n      // 对直方图的label X 方向的位置居中\n      label.x = getDimValue(mappingData.x, index, true);\n      label.y = getDimValue(mappingData.y, index);\n    } else {\n      label.x = getDimValue(mappingData.x, index);\n      label.y = getDimValue(mappingData.y, index);\n    }\n    // 处理漏斗图文本位置\n    if (isFunnel) {\n      var nextPoints = get(mappingData, 'nextPoints');\n      var points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        var point1 = coordinate.convert(points[1]);\n        var point2 = coordinate.convert(nextPoints[1]);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      } else if (shape === 'pyramid') {\n        var point1 = coordinate.convert(points[1]);\n        var point2 = coordinate.convert(points[2]);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      }\n    }\n    if (labelCfg.position) {\n      // 如果 label 支持 position 属性\n      this.setLabelPosition(label, mappingData, index, labelCfg.position);\n    }\n    var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);\n    label.start = {\n      x: label.x,\n      y: label.y\n    };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = mappingData.color;\n    return label;\n  };\n  /**\n   * 获取文本的对齐方式\n   * @param item\n   * @param index\n   * @param total\n   * @returns\n   */\n  GeometryLabel.prototype.getLabelAlign = function (item, index, total) {\n    var align = 'center';\n    var coordinate = this.getCoordinate();\n    if (coordinate.isTransposed) {\n      var offset = item.offset;\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n    return align;\n  };\n  /**\n   * 获取每一个 label 的唯一 id\n   * @param mappingData label 对应的图形的绘制数据\n   */\n  GeometryLabel.prototype.getLabelId = function (mappingData) {\n    var geometry = this.geometry;\n    var type = geometry.type;\n    var xScale = geometry.getXScale();\n    var yScale = geometry.getYScale();\n    var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n    var labelId = geometry.getElementId(mappingData);\n    if (type === 'line' || type === 'area') {\n      // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n      labelId += \" \".concat(origin[xScale.field]);\n    } else if (type === 'path') {\n      // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n      labelId += \" \".concat(origin[xScale.field], \"-\").concat(origin[yScale.field]);\n    }\n    return labelId;\n  };\n  // 获取 labels 组件\n  GeometryLabel.prototype.getLabelsRenderer = function () {\n    var _a = this.geometry,\n      labelsContainer = _a.labelsContainer,\n      labelOption = _a.labelOption,\n      canvasRegion = _a.canvasRegion,\n      animateOption = _a.animateOption;\n    var coordinate = this.geometry.coordinate;\n    var labelsRenderer = this.labelsRenderer;\n    if (!labelsRenderer) {\n      labelsRenderer = new Labels({\n        container: labelsContainer,\n        layout: get(labelOption, ['cfg', 'layout'], {\n          type: this.defaultLayout\n        })\n      });\n      this.labelsRenderer = labelsRenderer;\n    }\n    labelsRenderer.region = canvasRegion;\n    // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n    return labelsRenderer;\n  };\n  GeometryLabel.prototype.getLabelCfgs = function (mapppingArray) {\n    var _this = this;\n    var geometry = this.geometry;\n    var labelOption = geometry.labelOption,\n      scales = geometry.scales,\n      coordinate = geometry.coordinate;\n    var _a = labelOption,\n      fields = _a.fields,\n      callback = _a.callback,\n      cfg = _a.cfg;\n    var labelScales = fields.map(function (field) {\n      return scales[field];\n    });\n    var labelCfgs = [];\n    each(mapppingArray, function (mappingData, index) {\n      var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n      var originText = _this.getLabelText(origin, labelScales);\n      var callbackCfg;\n      if (callback) {\n        // 当同时配置了 callback 和 cfg 时，以 callback 为准\n        var originValues = fields.map(function (field) {\n          return origin[field];\n        });\n        callbackCfg = callback.apply(void 0, __spreadArray([], __read(originValues), false));\n        if (isNil(callbackCfg)) {\n          labelCfgs.push(null);\n          return;\n        }\n      }\n      var labelCfg = __assign(__assign({\n        id: _this.getLabelId(mappingData),\n        elementId: _this.geometry.getElementId(mappingData),\n        data: origin,\n        // 存储原始数据\n        mappingData: mappingData,\n        // 存储映射后的数据,\n        coordinate: coordinate\n      }, cfg), callbackCfg);\n      if (isFunction(labelCfg.position)) {\n        labelCfg.position = labelCfg.position(origin, mappingData, index);\n      }\n      var offset = _this.getLabelOffset(labelCfg.offset || 0);\n      // defaultCfg 需要判断 innerLabels & labels\n      var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);\n      // labelCfg priority: defaultCfg < cfg < callbackCfg\n      labelCfg = deepMix({}, defaultLabelCfg, labelCfg);\n      // 获取最终的 offset\n      labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);\n      var content = labelCfg.content;\n      if (isFunction(content)) {\n        labelCfg.content = content(origin, mappingData, index);\n      } else if (isUndefined(content)) {\n        // 用户未配置 content，则默认为映射的第一个字段的值\n        labelCfg.content = originText[0];\n      }\n      labelCfgs.push(labelCfg);\n    });\n    return labelCfgs;\n  };\n  GeometryLabel.prototype.getLabelText = function (origin, scales) {\n    var labelTexts = [];\n    each(scales, function (scale) {\n      var value = origin[scale.field];\n      if (isArray(value)) {\n        value = value.map(function (subVal) {\n          return scale.getText(subVal);\n        });\n      } else {\n        value = scale.getText(value);\n      }\n      if (isNil(value) || value === '') {\n        labelTexts.push(null);\n      } else {\n        labelTexts.push(value);\n      }\n    });\n    return labelTexts;\n  };\n  GeometryLabel.prototype.getOffsetVector = function (offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    var coordinate = this.getCoordinate();\n    var actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    }\n    // 如果 x,y 翻转，则偏移 x，否则偏移 y\n    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);\n  };\n  GeometryLabel.prototype.getGeometryShapes = function () {\n    var geometry = this.geometry;\n    var shapes = {};\n    each(geometry.elementsMap, function (element, id) {\n      shapes[id] = element.shape;\n    });\n    // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n    each(geometry.getOffscreenGroup().getChildren(), function (child) {\n      var id = geometry.getElementId(child.get('origin').mappingData);\n      shapes[id] = child;\n    });\n    return shapes;\n  };\n  return GeometryLabel;\n}();\nexport default GeometryLabel;","map":{"version":3,"names":["deepMix","each","get","isArray","isFunction","isNil","isNumber","isUndefined","FIELD_ORIGIN","getDefaultAnimateCfg","getPolygonCentroid","Labels","avg","arr","sum","value","length","GeometryLabel","geometry","prototype","getLabelItems","mapppingArray","_this","items","labelCfgs","getLabelCfgs","mappingData","index","labelCfg","x","y","push","labelContent","content","total","subIndex","item","__assign","getLabelPoint","textAlign","getLabelAlign","offset","labelLine","render","mappingArray","isUpdate","labelItems","labelsRenderer","getLabelsRenderer","shapes","getGeometryShapes","_a","sent","clear","destroy","getCoordinate","coordinate","getDefaultLabelCfg","position","type","theme","includes","getThemedLabelCfg","defaultLabelCfg","themedLabelCfg","innerLabels","labels","setLabelPosition","labelPointCfg","getLabelOffset","vector","getOffsetVector","isTransposed","getLabelOffsetPoint","transposed","dim","factor","offsetPoint","getDimValue","idx","isAvg","v","label","start","color","shape","isFunnel","centroid","nextPoints","points","point1","convert","point2","align","getLabelId","xScale","getXScale","yScale","getYScale","origin","labelId","getElementId","concat","field","labelsContainer","labelOption","canvasRegion","animateOption","container","layout","defaultLayout","region","animate","scales","fields","callback","cfg","labelScales","map","originText","getLabelText","callbackCfg","originValues","apply","__spreadArray","__read","id","elementId","data","labelTexts","scale","subVal","getText","actualOffset","applyMatrix","elementsMap","element","getOffscreenGroup","getChildren","child"],"sources":["../../../src/geometry/label/base.ts"],"sourcesContent":["import { deepMix, each, get, isArray, isFunction, isNil, isNumber, isString, isUndefined } from '@antv/util';\n\nimport { FIELD_ORIGIN } from '../../constant';\nimport { Scale } from '../../dependents';\nimport { Datum, LabelOption, MappingDatum, Point } from '../../interface';\nimport { LabelCfg, LabelItem, LabelPointCfg, TextAlign } from './interface';\n\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\n\nimport Labels from '../../component/labels';\nimport Geometry from '../base';\nimport Element from '../element';\n\nexport type GeometryLabelConstructor = new (cfg: any) => GeometryLabel;\n\nfunction avg(arr: number[]) {\n  let sum = 0;\n  each(arr, (value: number) => {\n    sum += value;\n  });\n  return sum / arr.length;\n}\n\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\nexport default class GeometryLabel {\n  /** geometry 实例 */\n  public readonly geometry: Geometry;\n  public labelsRenderer: Labels;\n  /** 默认的布局 */\n  public defaultLayout: string;\n\n  constructor(geometry: Geometry) {\n    this.geometry = geometry;\n  }\n\n  public getLabelItems(mapppingArray: MappingDatum[]): LabelItem[] {\n    const items = [];\n    const labelCfgs = this.getLabelCfgs(mapppingArray);\n    // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const labelCfg = labelCfgs[index];\n      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n        items.push(null);\n        return;\n      }\n\n      const labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n      labelCfg.content = labelContent;\n      const total = labelContent.length;\n      each(labelContent, (content, subIndex) => {\n        if (isNil(content) || content === '') {\n          items.push(null);\n          return;\n        }\n\n        const item = {\n          ...labelCfg,\n          ...this.getLabelPoint(labelCfg, mappingData, subIndex),\n        };\n        if (!item.textAlign) {\n          item.textAlign = this.getLabelAlign(item, subIndex, total);\n        }\n\n        if (item.offset <= 0) {\n          item.labelLine = null;\n        }\n\n        items.push(item);\n      });\n    });\n    return items;\n  }\n\n  public async render(mappingArray: MappingDatum[], isUpdate: boolean = false) {\n    const labelItems = this.getLabelItems(mappingArray);\n    const labelsRenderer = this.getLabelsRenderer();\n    const shapes = this.getGeometryShapes();\n    // 渲染文本\n    await labelsRenderer.render(labelItems, shapes, isUpdate);\n  }\n\n  public clear() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.clear();\n    }\n  }\n\n  public destroy() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.destroy();\n    }\n    this.labelsRenderer = null;\n  }\n\n  // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n  public getCoordinate() {\n    return this.geometry.coordinate;\n  }\n\n  /**\n   * 获取 label 的默认配置\n   */\n  protected getDefaultLabelCfg(offset?: number, position?: string) {\n    const geometry = this.geometry;\n    const { type, theme } = geometry;\n\n    if (\n      type === 'polygon' ||\n      (type === 'interval' && position === 'middle') ||\n      (offset < 0 && !['line', 'point', 'path'].includes(type))\n    ) {\n      // polygon 或者 (interval 且 middle) 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      return get(theme, 'innerLabels', {});\n    }\n\n    return get(theme, 'labels', {});\n  }\n\n  /**\n   * 获取当前 label 的最终配置\n   * @param labelCfg\n   */\n  protected getThemedLabelCfg(labelCfg: LabelCfg) {\n    const geometry = this.geometry;\n    const defaultLabelCfg = this.getDefaultLabelCfg();\n    const { type, theme } = geometry;\n    let themedLabelCfg;\n\n    if (type === 'polygon' || (labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type))) {\n      // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n    } else {\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n    }\n\n    return themedLabelCfg;\n  }\n\n  /**\n   * 设置 label 位置\n   * @param labelPointCfg\n   * @param mappingData\n   * @param index\n   * @param position\n   */\n  protected setLabelPosition(\n    labelPointCfg: LabelPointCfg,\n    mappingData: MappingDatum,\n    index: number,\n    position: string\n  ) {}\n\n  /**\n   * @desc 获取 label offset\n   */\n  protected getLabelOffset(offset: number | string): number {\n    const coordinate = this.getCoordinate();\n    const vector = this.getOffsetVector(offset);\n    return coordinate.isTransposed ? vector[0] : vector[1];\n  }\n\n  /**\n   * 获取每个 label 的偏移量 (矢量)\n   * @param labelCfg\n   * @param index\n   * @param total\n   * @return {Point} offsetPoint\n   */\n  protected getLabelOffsetPoint(labelCfg: LabelCfg, index: number, total: number): Point {\n    const offset = labelCfg.offset;\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const dim = transposed ? 'x' : 'y';\n    const factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n    const offsetPoint = {\n      x: 0,\n      y: 0,\n    };\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[dim] = offset * factor;\n    } else {\n      offsetPoint[dim] = offset * factor * -1;\n    }\n    return offsetPoint;\n  }\n\n  /**\n   * 获取每个 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   * @returns label point\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    const coordinate = this.getCoordinate();\n    const total = labelCfg.content.length;\n\n    function getDimValue(value: number | number[], idx: number, isAvg = false) {\n      let v = value;\n      if (isArray(v)) {\n        if (labelCfg.content.length === 1) {\n          if (isAvg) {\n            v = avg(v);\n          } else {\n            // 如果仅一个 label，多个 y, 取最后一个 y\n            if (v.length <= 2) {\n              v = v[(value as number[]).length - 1];\n            } else {\n              v = avg(v);\n            }\n          }\n        } else {\n          v = v[idx];\n        }\n      }\n      return v;\n    }\n\n    const label = {\n      content: labelCfg.content[index],\n      x: 0,\n      y: 0,\n      start: { x: 0, y: 0 },\n      color: '#fff',\n    };\n    const shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    const isFunnel = shape === 'funnel' || shape === 'pyramid';\n\n    // 多边形场景，多用于地图\n    if (this.geometry.type === 'polygon') {\n      const centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else if (this.geometry.type === 'interval' && !isFunnel) {\n      // 对直方图的label X 方向的位置居中\n      label.x = getDimValue(mappingData.x, index, true);\n      label.y = getDimValue(mappingData.y, index);\n    } else {\n      label.x = getDimValue(mappingData.x, index);\n      label.y = getDimValue(mappingData.y, index);\n    }\n\n    // 处理漏斗图文本位置\n    if (isFunnel) {\n      const nextPoints = get(mappingData, 'nextPoints');\n      const points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(nextPoints[1] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      } else if (shape === 'pyramid') {\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(points[2] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      }\n    }\n\n    if (labelCfg.position) {\n      // 如果 label 支持 position 属性\n      this.setLabelPosition(label, mappingData, index, labelCfg.position);\n    }\n    const offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);\n    label.start = { x: label.x, y: label.y };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = mappingData.color;\n    return label;\n  }\n\n  /**\n   * 获取文本的对齐方式\n   * @param item\n   * @param index\n   * @param total\n   * @returns\n   */\n  protected getLabelAlign(item: LabelItem, index: number, total: number): TextAlign {\n    let align: TextAlign = 'center';\n    const coordinate = this.getCoordinate();\n    if (coordinate.isTransposed) {\n      const offset = item.offset;\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n    return align;\n  }\n\n  /**\n   * 获取每一个 label 的唯一 id\n   * @param mappingData label 对应的图形的绘制数据\n   */\n  protected getLabelId(mappingData: MappingDatum) {\n    const geometry = this.geometry;\n    const type = geometry.type;\n    const xScale = geometry.getXScale();\n    const yScale = geometry.getYScale();\n    const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n\n    let labelId = geometry.getElementId(mappingData);\n    if (type === 'line' || type === 'area') {\n      // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n      labelId += ` ${origin[xScale.field]}`;\n    } else if (type === 'path') {\n      // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n      labelId += ` ${origin[xScale.field]}-${origin[yScale.field]}`;\n    }\n\n    return labelId;\n  }\n\n  // 获取 labels 组件\n  private getLabelsRenderer() {\n    const { labelsContainer, labelOption, canvasRegion, animateOption } = this.geometry;\n    const coordinate = this.geometry.coordinate;\n\n    let labelsRenderer = this.labelsRenderer;\n    if (!labelsRenderer) {\n      labelsRenderer = new Labels({\n        container: labelsContainer,\n        layout: get(labelOption, ['cfg', 'layout'], {\n          type: this.defaultLayout,\n        }),\n      });\n      this.labelsRenderer = labelsRenderer;\n    }\n    labelsRenderer.region = canvasRegion;\n    // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n\n    return labelsRenderer;\n  }\n\n  private getLabelCfgs(mapppingArray: MappingDatum[]): LabelCfg[] {\n    const geometry = this.geometry;\n    const { labelOption, scales, coordinate } = geometry;\n    const { fields, callback, cfg } = labelOption as LabelOption;\n    const labelScales = fields.map((field: string) => {\n      return scales[field];\n    });\n\n    const labelCfgs: LabelCfg[] = [];\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n      const originText = this.getLabelText(origin, labelScales);\n      let callbackCfg;\n      if (callback) {\n        // 当同时配置了 callback 和 cfg 时，以 callback 为准\n        const originValues = fields.map((field: string) => origin[field]);\n        callbackCfg = callback(...originValues);\n        if (isNil(callbackCfg)) {\n          labelCfgs.push(null);\n          return;\n        }\n      }\n\n      let labelCfg = {\n        id: this.getLabelId(mappingData), // 进行 ID 标记\n        elementId: this.geometry.getElementId(mappingData), // label 对应 Element 的 ID\n        data: origin, // 存储原始数据\n        mappingData, // 存储映射后的数据,\n        coordinate, // 坐标系\n        ...cfg,\n        ...callbackCfg,\n      };\n\n      if (isFunction(labelCfg.position)) {\n        labelCfg.position = labelCfg.position(origin, mappingData, index);\n      }\n\n      const offset = this.getLabelOffset(labelCfg.offset || 0);\n      // defaultCfg 需要判断 innerLabels & labels\n      const defaultLabelCfg = this.getDefaultLabelCfg(offset, labelCfg.position);\n      // labelCfg priority: defaultCfg < cfg < callbackCfg\n      labelCfg = deepMix({}, defaultLabelCfg, labelCfg);\n      // 获取最终的 offset\n      labelCfg.offset = this.getLabelOffset(labelCfg.offset || 0);\n\n      const content = labelCfg.content;\n      if (isFunction(content)) {\n        labelCfg.content = content(origin, mappingData, index);\n      } else if (isUndefined(content)) {\n        // 用户未配置 content，则默认为映射的第一个字段的值\n        labelCfg.content = originText[0];\n      }\n\n      labelCfgs.push(labelCfg);\n    });\n\n    return labelCfgs;\n  }\n\n  private getLabelText(origin: Datum, scales: Scale[]) {\n    const labelTexts = [];\n    each(scales, (scale: Scale) => {\n      let value = origin[scale.field];\n      if (isArray(value)) {\n        value = value.map((subVal) => {\n          return scale.getText(subVal);\n        });\n      } else {\n        value = scale.getText(value);\n      }\n\n      if (isNil(value) || value === '') {\n        labelTexts.push(null);\n      } else {\n        labelTexts.push(value);\n      }\n    });\n    return labelTexts;\n  }\n\n  private getOffsetVector(offset: number | string = 0) {\n    const coordinate = this.getCoordinate();\n    let actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    }\n    // 如果 x,y 翻转，则偏移 x，否则偏移 y\n    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);\n  }\n\n  private getGeometryShapes() {\n    const geometry = this.geometry;\n    const shapes = {};\n    each(geometry.elementsMap, (element: Element, id: string) => {\n      shapes[id] = element.shape;\n    });\n    // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n    each(geometry.getOffscreenGroup().getChildren(), (child) => {\n      const id = geometry.getElementId(child.get('origin').mappingData);\n      shapes[id] = child;\n    });\n\n    return shapes;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}