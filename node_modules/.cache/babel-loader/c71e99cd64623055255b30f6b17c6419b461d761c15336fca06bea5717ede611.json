{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Util } from '@antv/g6-core';\nimport { isNumber } from '@antv/util';\nvar traverseTree = Util.traverseTree;\n/**\n * 将 number | Function 类型的参数转换为 return number 的 Function\n * @param  {number | Function}  value 需要被转换的值\n * @param  {number}  defaultV 返回函数的默认返回值\n * @return {Function} 转换后的函数\n */\nexport var proccessToFunc = function proccessToFunc(value, defaultV) {\n  var func;\n  if (!value) {\n    func = function func(d) {\n      return defaultV || 1;\n    };\n  } else if (isNumber(value)) {\n    func = function func(d) {\n      return value;\n    };\n  } else {\n    func = value;\n  }\n  return func;\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 需要被转换的值\n * @param  {EdgeConfig[]}  edges 返回函数的默认返回值\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\nexport var buildTextureData = function buildTextureData(nodes, edges) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n  }\n  var maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i];\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\nexport var buildTextureDataWithOneEdgeAttr = function buildTextureDataWithOneEdgeAttr(nodes, edges, attrs) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n  }\n\n  var maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = len / 2; // 第四位存储与该节点相关的所有节点个数\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 2);\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n  // 不是 4 的倍数，填充 0\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个以上属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\nexport var buildTextureDataWithTwoEdgeAttr = function buildTextureDataWithTwoEdgeAttr(nodes, edges, attrs1, attrs2) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs1(e));\n    nodeDict[mapIdPos[e.source]].push(attrs2(e));\n    nodeDict[mapIdPos[e.source]].push(0);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs1(e));\n    nodeDict[mapIdPos[e.target]].push(attrs2(e));\n    nodeDict[mapIdPos[e.target]].push(0);\n  }\n  var maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n    var len = dests.length;\n    // dataArray[i * 4 + 2] = offset;\n    // dataArray[i * 4 + 3] = len / 4; // 第四位存储与该节点相关的所有节点个数\n    // pack offset & length into float32: offset 20bit, length 12bit\n    dataArray[i * 4 + 2] = offset + 1048576 * len / 4;\n    dataArray[i * 4 + 3] = 0; // 第四位存储与上一次的距离差值\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 4);\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n  // 不是 4 的倍数，填充 0\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * transform the extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @param  {ModelConfig[]}  items the items to be read\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\nexport var attributesToTextureData = function attributesToTextureData(attributeNames, items) {\n  var dataArray = [];\n  var attributeNum = attributeNames.length;\n  var attributeStringMap = {};\n  items.forEach(function (item) {\n    attributeNames.forEach(function (name, i) {\n      if (attributeStringMap[item[name]] === undefined) {\n        attributeStringMap[item[name]] = Object.keys(attributeStringMap).length;\n      }\n      dataArray.push(attributeStringMap[item[name]]);\n      // insure each node's attributes take inter number of grids\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  });\n  return {\n    array: new Float32Array(dataArray),\n    count: Object.keys(attributeStringMap).length\n  };\n};\n/**\n * transform the number array format of extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\nexport var arrayToTextureData = function arrayToTextureData(valueArrays) {\n  var dataArray = [];\n  var attributeNum = valueArrays.length;\n  var itemNum = valueArrays[0].length;\n  var _loop_1 = function _loop_1(j) {\n    valueArrays.forEach(function (valueArray, i) {\n      dataArray.push(valueArray[j]);\n      // insure each node's attributes take inter number of grids\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  };\n  for (var j = 0; j < itemNum; j++) {\n    _loop_1(j);\n  }\n  return new Float32Array(dataArray);\n};\n/**\n *\n * @param data Tree graph data\n * @param layout\n */\nexport var radialLayout = function radialLayout(data, layout) {\n  // 布局方式有 H / V / LR / RL / TB / BT\n  var VERTICAL_LAYOUTS = ['V', 'TB', 'BT'];\n  var min = {\n    x: Infinity,\n    y: Infinity\n  };\n  var max = {\n    x: -Infinity,\n    y: -Infinity\n  };\n  // 默认布局是垂直布局TB，此时x对应rad，y对应r\n  var rScale = 'x';\n  var radScale = 'y';\n  if (layout && VERTICAL_LAYOUTS.indexOf(layout) >= 0) {\n    // 若是水平布局，y对应rad，x对应r\n    radScale = 'x';\n    rScale = 'y';\n  }\n  var count = 0;\n  traverseTree(data, function (node) {\n    count++;\n    if (node.x > max.x) {\n      max.x = node.x;\n    }\n    if (node.x < min.x) {\n      min.x = node.x;\n    }\n    if (node.y > max.y) {\n      max.y = node.y;\n    }\n    if (node.y < min.y) {\n      min.y = node.y;\n    }\n    return true;\n  });\n  var avgRad = Math.PI * 2 / count;\n  var radDiff = max[radScale] - min[radScale];\n  if (radDiff === 0) {\n    return data;\n  }\n  traverseTree(data, function (node) {\n    var radial = (node[radScale] - min[radScale]) / radDiff * (Math.PI * 2 - avgRad) + avgRad;\n    var r = Math.abs(rScale === 'x' ? node.x - data.x : node.y - data.y);\n    node.x = r * Math.cos(radial);\n    node.y = r * Math.sin(radial);\n    return true;\n  });\n  return data;\n};","map":{"version":3,"names":["Util","isNumber","traverseTree","proccessToFunc","value","defaultV","func","d","buildTextureData","nodes","edges","dataArray","nodeDict","mapIdPos","i","length","n","id","push","x","y","e","source","target","maxEdgePerVetex","offset","dests","len","Math","max","j","dest","array","Float32Array","buildTextureDataWithOneEdgeAttr","attrs","buildTextureDataWithTwoEdgeAttr","attrs1","attrs2","attributesToTextureData","attributeNames","items","attributeNum","attributeStringMap","forEach","item","name","undefined","Object","keys","count","arrayToTextureData","valueArrays","itemNum","_loop_1","valueArray","radialLayout","data","layout","VERTICAL_LAYOUTS","min","Infinity","rScale","radScale","indexOf","node","avgRad","PI","radDiff","radial","r","abs","cos","sin"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/@antv/g6-pc/es/util/layout.js"],"sourcesContent":["import { Util } from '@antv/g6-core';\nimport { isNumber } from '@antv/util';\nvar traverseTree = Util.traverseTree;\n/**\n * 将 number | Function 类型的参数转换为 return number 的 Function\n * @param  {number | Function}  value 需要被转换的值\n * @param  {number}  defaultV 返回函数的默认返回值\n * @return {Function} 转换后的函数\n */\nexport var proccessToFunc = function proccessToFunc(value, defaultV) {\n  var func;\n  if (!value) {\n    func = function func(d) {\n      return defaultV || 1;\n    };\n  } else if (isNumber(value)) {\n    func = function func(d) {\n      return value;\n    };\n  } else {\n    func = value;\n  }\n  return func;\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 需要被转换的值\n * @param  {EdgeConfig[]}  edges 返回函数的默认返回值\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\nexport var buildTextureData = function buildTextureData(nodes, edges) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n  }\n  var maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i];\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\nexport var buildTextureDataWithOneEdgeAttr = function buildTextureDataWithOneEdgeAttr(nodes, edges, attrs) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n  }\n\n  var maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = len / 2; // 第四位存储与该节点相关的所有节点个数\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 2);\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n  // 不是 4 的倍数，填充 0\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个以上属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\nexport var buildTextureDataWithTwoEdgeAttr = function buildTextureDataWithTwoEdgeAttr(nodes, edges, attrs1, attrs2) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs1(e));\n    nodeDict[mapIdPos[e.source]].push(attrs2(e));\n    nodeDict[mapIdPos[e.source]].push(0);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs1(e));\n    nodeDict[mapIdPos[e.target]].push(attrs2(e));\n    nodeDict[mapIdPos[e.target]].push(0);\n  }\n  var maxEdgePerVetex = 0;\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n    var len = dests.length;\n    // dataArray[i * 4 + 2] = offset;\n    // dataArray[i * 4 + 3] = len / 4; // 第四位存储与该节点相关的所有节点个数\n    // pack offset & length into float32: offset 20bit, length 12bit\n    dataArray[i * 4 + 2] = offset + 1048576 * len / 4;\n    dataArray[i * 4 + 3] = 0; // 第四位存储与上一次的距离差值\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 4);\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n  // 不是 4 的倍数，填充 0\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * transform the extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @param  {ModelConfig[]}  items the items to be read\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\nexport var attributesToTextureData = function attributesToTextureData(attributeNames, items) {\n  var dataArray = [];\n  var attributeNum = attributeNames.length;\n  var attributeStringMap = {};\n  items.forEach(function (item) {\n    attributeNames.forEach(function (name, i) {\n      if (attributeStringMap[item[name]] === undefined) {\n        attributeStringMap[item[name]] = Object.keys(attributeStringMap).length;\n      }\n      dataArray.push(attributeStringMap[item[name]]);\n      // insure each node's attributes take inter number of grids\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  });\n  return {\n    array: new Float32Array(dataArray),\n    count: Object.keys(attributeStringMap).length\n  };\n};\n/**\n * transform the number array format of extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\nexport var arrayToTextureData = function arrayToTextureData(valueArrays) {\n  var dataArray = [];\n  var attributeNum = valueArrays.length;\n  var itemNum = valueArrays[0].length;\n  var _loop_1 = function _loop_1(j) {\n    valueArrays.forEach(function (valueArray, i) {\n      dataArray.push(valueArray[j]);\n      // insure each node's attributes take inter number of grids\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  };\n  for (var j = 0; j < itemNum; j++) {\n    _loop_1(j);\n  }\n  return new Float32Array(dataArray);\n};\n/**\n *\n * @param data Tree graph data\n * @param layout\n */\nexport var radialLayout = function radialLayout(data, layout) {\n  // 布局方式有 H / V / LR / RL / TB / BT\n  var VERTICAL_LAYOUTS = ['V', 'TB', 'BT'];\n  var min = {\n    x: Infinity,\n    y: Infinity\n  };\n  var max = {\n    x: -Infinity,\n    y: -Infinity\n  };\n  // 默认布局是垂直布局TB，此时x对应rad，y对应r\n  var rScale = 'x';\n  var radScale = 'y';\n  if (layout && VERTICAL_LAYOUTS.indexOf(layout) >= 0) {\n    // 若是水平布局，y对应rad，x对应r\n    radScale = 'x';\n    rScale = 'y';\n  }\n  var count = 0;\n  traverseTree(data, function (node) {\n    count++;\n    if (node.x > max.x) {\n      max.x = node.x;\n    }\n    if (node.x < min.x) {\n      min.x = node.x;\n    }\n    if (node.y > max.y) {\n      max.y = node.y;\n    }\n    if (node.y < min.y) {\n      min.y = node.y;\n    }\n    return true;\n  });\n  var avgRad = Math.PI * 2 / count;\n  var radDiff = max[radScale] - min[radScale];\n  if (radDiff === 0) {\n    return data;\n  }\n  traverseTree(data, function (node) {\n    var radial = (node[radScale] - min[radScale]) / radDiff * (Math.PI * 2 - avgRad) + avgRad;\n    var r = Math.abs(rScale === 'x' ? node.x - data.x : node.y - data.y);\n    node.x = r * Math.cos(radial);\n    node.y = r * Math.sin(radial);\n    return true;\n  });\n  return data;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}