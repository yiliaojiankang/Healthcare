{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __assign, __awaiter, __generator, __rest, __values } from \"tslib\";\nimport { deepMix, each, get, isArray, isNull } from '@antv/util';\nimport { doAnimate } from '../animate';\nimport { getGeometryLabelLayout } from '../geometry/label';\nimport { getLabelBackgroundInfo } from '../geometry/label/util';\nimport { polarToCartesian } from '../util/graphics';\nimport { rotate, translate } from '../util/transform';\nimport { FIELD_ORIGIN } from '../constant';\nimport { updateLabel } from './update-label';\n/**\n * Geometry labels 渲染组件\n */\nvar Labels = /** @class */function () {\n  function Labels(cfg) {\n    /** 存储当前 shape 的映射表，键值为 shape id */\n    this.shapesMap = {};\n    var layout = cfg.layout,\n      container = cfg.container;\n    this.layout = layout;\n    this.container = container;\n  }\n  /**\n   * 渲染文本\n   */\n  Labels.prototype.render = function (items, shapes, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var shapesMap, offscreenGroup, items_1, items_1_1, item, lastShapesMap;\n      var e_1, _a;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            shapesMap = {};\n            offscreenGroup = this.createOffscreenGroup();\n            if (!items.length) return [3 /*break*/, 2];\n            try {\n              // 如果 items 空的话就不进行绘制调整操作\n              // step 1: 在虚拟 group 中创建 shapes\n              for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n                item = items_1_1.value;\n                if (item) {\n                  shapesMap[item.id] = this.renderLabel(item, offscreenGroup);\n                }\n              }\n            } catch (e_1_1) {\n              e_1 = {\n                error: e_1_1\n              };\n            } finally {\n              try {\n                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n              } finally {\n                if (e_1) throw e_1.error;\n              }\n            }\n            // [todo] Move layout into Worker.\n            // step 2: 根据布局，调整 labels\n            return [4 /*yield*/, this.doLayout(items, shapes, shapesMap)];\n          case 1:\n            // [todo] Move layout into Worker.\n            // step 2: 根据布局，调整 labels\n            _b.sent();\n            // step 3.1: 绘制 labelLine\n            this.renderLabelLine(items, shapesMap);\n            // step 3.2: 绘制 labelBackground\n            this.renderLabelBackground(items, shapesMap);\n            // step 4: 根据用户设置的偏移量调整 label\n            this.adjustLabel(items, shapesMap);\n            _b.label = 2;\n          case 2:\n            lastShapesMap = this.shapesMap;\n            each(shapesMap, function (shape, id) {\n              if (shape.destroyed) {\n                // label 在布局调整环节被删除了（doLayout）\n                delete shapesMap[id];\n              } else {\n                if (lastShapesMap[id]) {\n                  // 图形发生更新\n                  var data = shape.get('data');\n                  var origin_1 = shape.get('origin');\n                  var coordinate = shape.get('coordinate');\n                  var currentAnimateCfg = shape.get('animateCfg');\n                  var currentShape = lastShapesMap[id]; // 已经在渲染树上的 shape\n                  updateLabel(currentShape, shapesMap[id], {\n                    data: data,\n                    origin: origin_1,\n                    animateCfg: currentAnimateCfg,\n                    coordinate: coordinate\n                  });\n                  shapesMap[id] = currentShape; // 保存引用\n                } else {\n                  // 新生成的 shape\n                  // If container has been destroyed, no need to render labels.\n                  if (_this.container.destroyed) return;\n                  _this.container.add(shape);\n                  var animateCfg = get(shape.get('animateCfg'), isUpdate ? 'enter' : 'appear');\n                  if (animateCfg) {\n                    doAnimate(shape, animateCfg, {\n                      toAttrs: __assign({}, shape.attr()),\n                      coordinate: shape.get('coordinate')\n                    });\n                  }\n                }\n                delete lastShapesMap[id];\n              }\n            });\n            // 移除\n            each(lastShapesMap, function (deleteShape) {\n              var animateCfg = get(deleteShape.get('animateCfg'), 'leave');\n              if (animateCfg) {\n                doAnimate(deleteShape, animateCfg, {\n                  toAttrs: null,\n                  coordinate: deleteShape.get('coordinate')\n                });\n              } else {\n                deleteShape.remove(true); // 移除\n              }\n            });\n\n            this.shapesMap = shapesMap;\n            offscreenGroup.destroy();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /** 清除当前 labels */\n  Labels.prototype.clear = function () {\n    this.container.clear();\n    this.shapesMap = {};\n  };\n  /** 销毁 */\n  Labels.prototype.destroy = function () {\n    this.container.destroy();\n    this.shapesMap = null;\n  };\n  Labels.prototype.renderLabel = function (cfg, container) {\n    var id = cfg.id,\n      elementId = cfg.elementId,\n      data = cfg.data,\n      mappingData = cfg.mappingData,\n      coordinate = cfg.coordinate,\n      animate = cfg.animate,\n      content = cfg.content,\n      capture = cfg.capture;\n    var shapeAppendCfg = {\n      id: id,\n      elementId: elementId,\n      capture: capture,\n      data: data,\n      origin: __assign(__assign({}, mappingData), {\n        data: mappingData[FIELD_ORIGIN]\n      }),\n      coordinate: coordinate\n    };\n    var labelGroup = container.addGroup(__assign({\n      name: 'label',\n      // 如果 this.animate === false 或者 cfg.animate === false/null 则不进行动画，否则进行动画配置的合并\n      animateCfg: this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate)\n    }, shapeAppendCfg));\n    var labelShape;\n    if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {\n      // 如果 content 是 Group 或者 Shape，根据 textAlign 调整位置后，直接将其加入 labelGroup\n      var _a = content.getCanvasBBox(),\n        width = _a.width,\n        height = _a.height;\n      var textAlign = get(cfg, 'textAlign', 'left');\n      var x = cfg.x;\n      var y = cfg.y - height / 2;\n      if (textAlign === 'center') {\n        x = x - width / 2;\n      } else if (textAlign === 'right' || textAlign === 'end') {\n        x = x - width;\n      }\n      translate(content, x, y); // 将 label 平移至 x, y 指定的位置\n      labelShape = content;\n      labelGroup.add(content);\n    } else {\n      var fill = get(cfg, ['style', 'fill']);\n      labelShape = labelGroup.addShape('text', __assign({\n        attrs: __assign(__assign({\n          x: cfg.x,\n          y: cfg.y,\n          textAlign: cfg.textAlign,\n          textBaseline: get(cfg, 'textBaseline', 'middle'),\n          text: cfg.content\n        }, cfg.style), {\n          fill: isNull(fill) ? cfg.color : fill\n        })\n      }, shapeAppendCfg));\n    }\n    if (cfg.rotate) {\n      rotate(labelShape, cfg.rotate);\n    }\n    return labelGroup;\n  };\n  // 根据type对label布局\n  Labels.prototype.doLayout = function (items, shapes, shapesMap) {\n    return __awaiter(this, void 0, void 0, function () {\n      var layouts;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.layout) return [3 /*break*/, 2];\n            layouts = isArray(this.layout) ? this.layout : [this.layout];\n            return [4 /*yield*/, Promise.all(layouts.map(function (layout) {\n              var layoutFn = getGeometryLabelLayout(get(layout, 'type', ''));\n              if (!layoutFn) return;\n              var labelShapes = [];\n              var geometryShapes = [];\n              each(shapesMap, function (labelShape, id) {\n                labelShapes.push(labelShape);\n                geometryShapes.push(shapes[labelShape.get('elementId')]);\n              });\n              // [todo] Refactor more layout into Worker.\n              return layoutFn(items, labelShapes, geometryShapes, _this.region, layout.cfg);\n            }))];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Labels.prototype.renderLabelLine = function (labelItems, shapesMap) {\n    each(labelItems, function (labelItem) {\n      var coordinate = get(labelItem, 'coordinate');\n      if (!labelItem || !coordinate) {\n        return;\n      }\n      var center = coordinate.getCenter();\n      var radius = coordinate.getRadius();\n      if (!labelItem.labelLine) {\n        // labelLine: null | false，关闭 label 对应的 labelLine\n        return;\n      }\n      var labelLineCfg = get(labelItem, 'labelLine', {});\n      var id = labelItem.id;\n      var path = labelLineCfg.path;\n      if (!path) {\n        var start = polarToCartesian(center.x, center.y, radius, labelItem.angle);\n        path = [['M', start.x, start.y], ['L', labelItem.x, labelItem.y]];\n      }\n      var labelGroup = shapesMap[id];\n      if (!labelGroup.destroyed) {\n        labelGroup.addShape('path', {\n          capture: false,\n          attrs: __assign({\n            path: path,\n            stroke: labelItem.color ? labelItem.color : get(labelItem, ['style', 'fill'], '#000'),\n            fill: null\n          }, labelLineCfg.style),\n          id: id,\n          origin: labelItem.mappingData,\n          data: labelItem.data,\n          coordinate: labelItem.coordinate\n        });\n      }\n    });\n  };\n  /**\n   * 绘制标签背景\n   * @param labelItems\n   */\n  Labels.prototype.renderLabelBackground = function (labelItems, shapesMap) {\n    each(labelItems, function (labelItem) {\n      var coordinate = get(labelItem, 'coordinate');\n      var background = get(labelItem, 'background');\n      if (!background || !coordinate) {\n        return;\n      }\n      var id = labelItem.id;\n      var labelGroup = shapesMap[id];\n      if (!labelGroup.destroyed) {\n        var labelContentShape = labelGroup.getChildren()[0];\n        if (labelContentShape) {\n          var _a = getLabelBackgroundInfo(labelGroup, labelItem, background.padding),\n            rotation = _a.rotation,\n            box = __rest(_a, [\"rotation\"]);\n          var backgroundShape = labelGroup.addShape('rect', {\n            attrs: __assign(__assign({}, box), background.style || {}),\n            id: id,\n            origin: labelItem.mappingData,\n            data: labelItem.data,\n            coordinate: labelItem.coordinate\n          });\n          backgroundShape.setZIndex(-1);\n          if (rotation) {\n            var matrix = labelContentShape.getMatrix();\n            backgroundShape.setMatrix(matrix);\n          }\n        }\n      }\n    });\n  };\n  Labels.prototype.createOffscreenGroup = function () {\n    var container = this.container;\n    var GroupClass = container.getGroupBase(); // 获取分组的构造函数\n    var newGroup = new GroupClass({});\n    return newGroup;\n  };\n  Labels.prototype.adjustLabel = function (items, shapesMap) {\n    each(items, function (item) {\n      if (item) {\n        var id = item.id;\n        var labelGroup = shapesMap[id];\n        if (!labelGroup.destroyed) {\n          // fix: 如果说开发者的 label content 是一个 group，此处的偏移无法对 整个 content group 生效；场景类似 饼图 spider label 是一个含 2 个 textShape 的 gorup\n          var labelShapes = labelGroup.findAll(function (ele) {\n            return ele.get('type') !== 'path';\n          });\n          each(labelShapes, function (labelShape) {\n            if (labelShape) {\n              if (item.offsetX) {\n                labelShape.attr('x', labelShape.attr('x') + item.offsetX);\n              }\n              if (item.offsetY) {\n                labelShape.attr('y', labelShape.attr('y') + item.offsetY);\n              }\n            }\n          });\n        }\n      }\n    });\n  };\n  return Labels;\n}();\nexport default Labels;","map":{"version":3,"names":["deepMix","each","get","isArray","isNull","doAnimate","getGeometryLabelLayout","getLabelBackgroundInfo","polarToCartesian","rotate","translate","FIELD_ORIGIN","updateLabel","Labels","cfg","shapesMap","layout","container","prototype","render","items","shapes","isUpdate","offscreenGroup","createOffscreenGroup","length","items_1","__values","items_1_1","next","done","item","value","id","renderLabel","doLayout","_b","sent","renderLabelLine","renderLabelBackground","adjustLabel","lastShapesMap","shape","destroyed","data","origin_1","coordinate","currentAnimateCfg","currentShape","origin","animateCfg","_this","add","toAttrs","__assign","attr","deleteShape","remove","destroy","clear","elementId","mappingData","animate","content","capture","shapeAppendCfg","labelGroup","addGroup","name","labelShape","isGroup","isShape","_a","getCanvasBBox","width","height","textAlign","x","y","fill","addShape","attrs","textBaseline","text","style","color","layouts","Promise","all","map","layoutFn","labelShapes","geometryShapes","push","region","labelItems","labelItem","center","getCenter","radius","getRadius","labelLine","labelLineCfg","path","start","angle","stroke","background","labelContentShape","getChildren","padding","rotation","box","__rest","backgroundShape","setZIndex","matrix","getMatrix","setMatrix","GroupClass","getGroupBase","newGroup","findAll","ele","offsetX","offsetY"],"sources":["../../src/component/labels.ts"],"sourcesContent":["import { deepMix, each, get, isArray, isNull } from '@antv/util';\nimport { BBox, Coordinate, IGroup, IShape } from '../dependents';\nimport { LabelItem } from '../geometry/label/interface';\nimport { AnimateOption, GeometryLabelLayoutCfg } from '../interface';\nimport { doAnimate } from '../animate';\nimport { getGeometryLabelLayout } from '../geometry/label';\nimport { getLabelBackgroundInfo } from '../geometry/label/util';\nimport { polarToCartesian } from '../util/graphics';\nimport { rotate, translate } from '../util/transform';\nimport { FIELD_ORIGIN } from '../constant';\nimport { updateLabel } from './update-label';\n\n/**\n * Labels 实例创建时，传入构造函数的参数定义\n */\nexport interface LabelsGroupCfg {\n  /** label 容器 */\n  container: IGroup;\n  /** label 布局配置 */\n  layout?: GeometryLabelLayoutCfg | GeometryLabelLayoutCfg[];\n}\n\n/**\n * Geometry labels 渲染组件\n */\nexport default class Labels {\n  /** 用于指定 labels 布局的类型 */\n  public layout: GeometryLabelLayoutCfg | GeometryLabelLayoutCfg[];\n  /** 图形容器 */\n  public container: IGroup;\n  /** 动画配置 */\n  public animate: AnimateOption | false;\n  /** label 绘制的区域 */\n  public region: BBox;\n\n  /** 存储当前 shape 的映射表，键值为 shape id */\n  public shapesMap: Record<string, IGroup> = {};\n\n  constructor(cfg: LabelsGroupCfg) {\n    const { layout, container } = cfg;\n\n    this.layout = layout;\n    this.container = container;\n  }\n  /**\n   * 渲染文本\n   */\n  public async render(items: LabelItem[], shapes: Record<string, IShape | IGroup>, isUpdate: boolean = false) {\n    const shapesMap = {};\n    const offscreenGroup = this.createOffscreenGroup(); // 创建虚拟分组\n    if (items.length) {\n      // 如果 items 空的话就不进行绘制调整操作\n      // step 1: 在虚拟 group 中创建 shapes\n      for (const item of items) {\n        if (item) {\n          shapesMap[item.id] = this.renderLabel(item, offscreenGroup);\n        }\n      }\n      // [todo] Move layout into Worker.\n      // step 2: 根据布局，调整 labels\n      await this.doLayout(items, shapes, shapesMap);\n\n      // step 3.1: 绘制 labelLine\n      this.renderLabelLine(items, shapesMap);\n      // step 3.2: 绘制 labelBackground\n      this.renderLabelBackground(items, shapesMap);\n      // step 4: 根据用户设置的偏移量调整 label\n      this.adjustLabel(items, shapesMap);\n    }\n\n    // 进行添加、更新、销毁操作\n    const lastShapesMap = this.shapesMap;\n    each(shapesMap, (shape, id) => {\n      if (shape.destroyed) {\n        // label 在布局调整环节被删除了（doLayout）\n        delete shapesMap[id];\n      } else {\n        if (lastShapesMap[id]) {\n          // 图形发生更新\n          const data = shape.get('data');\n          const origin = shape.get('origin');\n          const coordinate = shape.get('coordinate');\n          const currentAnimateCfg = shape.get('animateCfg');\n\n          const currentShape = lastShapesMap[id]; // 已经在渲染树上的 shape\n          updateLabel(currentShape, shapesMap[id], {\n            data,\n            origin,\n            animateCfg: currentAnimateCfg,\n            coordinate,\n          });\n\n          shapesMap[id] = currentShape; // 保存引用\n        } else {\n          // 新生成的 shape\n          // If container has been destroyed, no need to render labels.\n          if (this.container.destroyed) return;\n          this.container.add(shape);\n          const animateCfg = get(shape.get('animateCfg'), isUpdate ? 'enter' : 'appear');\n          if (animateCfg) {\n            doAnimate(shape, animateCfg, {\n              toAttrs: {\n                ...shape.attr(),\n              },\n              coordinate: shape.get('coordinate'),\n            });\n          }\n        }\n        delete lastShapesMap[id];\n      }\n    });\n\n    // 移除\n    each(lastShapesMap, (deleteShape) => {\n      const animateCfg = get(deleteShape.get('animateCfg'), 'leave');\n      if (animateCfg) {\n        doAnimate(deleteShape, animateCfg, {\n          toAttrs: null,\n          coordinate: deleteShape.get('coordinate'),\n        });\n      } else {\n        deleteShape.remove(true); // 移除\n      }\n    });\n\n    this.shapesMap = shapesMap;\n    offscreenGroup.destroy();\n  }\n\n  /** 清除当前 labels */\n  public clear() {\n    this.container.clear();\n    this.shapesMap = {};\n  }\n\n  /** 销毁 */\n  public destroy() {\n    this.container.destroy();\n    this.shapesMap = null;\n  }\n\n  private renderLabel(cfg: LabelItem, container: IGroup): IGroup {\n    const { id, elementId, data, mappingData, coordinate, animate, content, capture } = cfg;\n    const shapeAppendCfg = {\n      id,\n      elementId,\n      capture,\n      data,\n      origin: {\n        ...mappingData,\n        data: mappingData[FIELD_ORIGIN],\n      },\n      coordinate,\n    };\n    const labelGroup = container.addGroup({\n      name: 'label',\n      // 如果 this.animate === false 或者 cfg.animate === false/null 则不进行动画，否则进行动画配置的合并\n      animateCfg:\n        this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate),\n      ...shapeAppendCfg,\n    });\n    let labelShape;\n    if ((content.isGroup && content.isGroup()) || (content.isShape && content.isShape())) {\n      // 如果 content 是 Group 或者 Shape，根据 textAlign 调整位置后，直接将其加入 labelGroup\n      const { width, height } = content.getCanvasBBox();\n      const textAlign = get(cfg, 'textAlign', 'left');\n\n      let x = cfg.x;\n      const y = cfg.y - height / 2;\n\n      if (textAlign === 'center') {\n        x = x - width / 2;\n      } else if (textAlign === 'right' || textAlign === 'end') {\n        x = x - width;\n      }\n\n      translate(content, x, y); // 将 label 平移至 x, y 指定的位置\n      labelShape = content;\n      labelGroup.add(content);\n    } else {\n      const fill = get(cfg, ['style', 'fill']);\n      labelShape = labelGroup.addShape('text', {\n        attrs: {\n          x: cfg.x,\n          y: cfg.y,\n          textAlign: cfg.textAlign,\n          textBaseline: get(cfg, 'textBaseline', 'middle'),\n          text: cfg.content,\n          ...cfg.style,\n          fill: isNull(fill) ? cfg.color : fill,\n        },\n        ...shapeAppendCfg,\n      });\n    }\n\n    if (cfg.rotate) {\n      rotate(labelShape, cfg.rotate);\n    }\n    return labelGroup;\n  }\n\n  // 根据type对label布局\n  private async doLayout(items: LabelItem[], shapes: Record<string, IShape | IGroup>, shapesMap: Record<string, IGroup>) {\n    if (this.layout) {\n      const layouts = isArray(this.layout) ? this.layout : [this.layout];\n      await Promise.all(layouts.map((layout: GeometryLabelLayoutCfg) => {\n        const layoutFn = getGeometryLabelLayout(get(layout, 'type', ''));\n        if (!layoutFn) return;\n\n        const labelShapes = [];\n        const geometryShapes = [];\n        each(shapesMap, (labelShape, id) => {\n          labelShapes.push(labelShape);\n          geometryShapes.push(shapes[labelShape.get('elementId')]);\n        });\n        // [todo] Refactor more layout into Worker.\n        return layoutFn(items, labelShapes, geometryShapes, this.region, layout.cfg);\n      }));\n    }\n  }\n\n  private renderLabelLine(labelItems: LabelItem[], shapesMap) {\n    each(labelItems, (labelItem) => {\n      const coordinate: Coordinate = get(labelItem, 'coordinate');\n      if (!labelItem || !coordinate) {\n        return;\n      }\n      const center = coordinate.getCenter();\n      const radius = coordinate.getRadius();\n      if (!labelItem.labelLine) {\n        // labelLine: null | false，关闭 label 对应的 labelLine\n        return;\n      }\n      const labelLineCfg = get(labelItem, 'labelLine', {});\n      const id = labelItem.id;\n      let path = labelLineCfg.path;\n      if (!path) {\n        const start = polarToCartesian(center.x, center.y, radius, labelItem.angle);\n        path = [\n          ['M', start.x, start.y],\n          ['L', labelItem.x, labelItem.y],\n        ];\n      }\n      const labelGroup = shapesMap[id];\n      if (!labelGroup.destroyed) {\n        labelGroup.addShape('path', {\n          capture: false, // labelLine 默认不参与事件捕获\n          attrs: {\n            path,\n            stroke: labelItem.color ? labelItem.color : get(labelItem, ['style', 'fill'], '#000'),\n            fill: null,\n            ...labelLineCfg.style,\n          },\n          id,\n          origin: labelItem.mappingData,\n          data: labelItem.data,\n          coordinate: labelItem.coordinate,\n        });\n      }\n    });\n  }\n\n  /**\n   * 绘制标签背景\n   * @param labelItems\n   */\n  private renderLabelBackground(labelItems: LabelItem[], shapesMap) {\n    each(labelItems, (labelItem) => {\n      const coordinate: Coordinate = get(labelItem, 'coordinate');\n      const background: LabelItem['background'] = get(labelItem, 'background');\n      if (!background || !coordinate) {\n        return;\n      }\n\n      const id = labelItem.id;\n      const labelGroup = shapesMap[id];\n      if (!labelGroup.destroyed) {\n        const labelContentShape = labelGroup.getChildren()[0];\n        if (labelContentShape) {\n          const { rotation, ...box } = getLabelBackgroundInfo(labelGroup, labelItem, background.padding);\n          const backgroundShape = labelGroup.addShape('rect', {\n            attrs: {\n              ...box,\n              ...(background.style || {}),\n            },\n            id,\n            origin: labelItem.mappingData,\n            data: labelItem.data,\n            coordinate: labelItem.coordinate,\n          });\n          backgroundShape.setZIndex(-1);\n\n          if (rotation) {\n            const matrix = labelContentShape.getMatrix();\n            backgroundShape.setMatrix(matrix);\n          }\n        }\n      }\n    });\n  }\n\n  private createOffscreenGroup() {\n    const container = this.container;\n    const GroupClass = container.getGroupBase(); // 获取分组的构造函数\n    const newGroup = new GroupClass({});\n    return newGroup;\n  }\n\n  private adjustLabel(items: LabelItem[], shapesMap) {\n    each(items, (item) => {\n      if (item) {\n        const id = item.id;\n        const labelGroup = shapesMap[id];\n        if (!labelGroup.destroyed) {\n          // fix: 如果说开发者的 label content 是一个 group，此处的偏移无法对 整个 content group 生效；场景类似 饼图 spider label 是一个含 2 个 textShape 的 gorup\n          const labelShapes = labelGroup.findAll((ele) => ele.get('type') !== 'path');\n          each(labelShapes, (labelShape) => {\n            if (labelShape) {\n              if (item.offsetX) {\n                labelShape.attr('x', labelShape.attr('x') + item.offsetX);\n              }\n              if (item.offsetY) {\n                labelShape.attr('y', labelShape.attr('y') + item.offsetY);\n              }\n            }\n          });\n        }\n      }\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}