{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { assign, memoize } from '@antv/util';\nimport { LEVEL, log } from '../../utils';\nimport { blend } from '../../utils/color/blend';\nimport { ID_FIELD, PATH_FIELD } from './constant';\nimport { computeTextCentres, intersectionAreaPath } from './layout/diagram';\nimport { scaleSolution, venn } from './layout/layout';\n/**\n * 获取 颜色映射\n * @usage colorMap.get(id) => color\n *\n * @returns Map<string, string>\n */\nexport var getColorMap = memoize(function (colorPalette, data, blendMode, setsField) {\n  var colorMap = new Map();\n  var colorPaletteLen = colorPalette.length;\n  data.forEach(function (d, idx) {\n    if (d[setsField].length === 1) {\n      colorMap.set(d[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);\n    } else {\n      /** 一般都是可以获取到颜色的，如果不正确 就是输入了非法数据 */\n      var colorArr = d[setsField].map(function (id) {\n        return colorMap.get(id);\n      });\n      colorMap.set(d[ID_FIELD], colorArr.slice(1).reduce(function (a, b) {\n        return blend(a, b, blendMode);\n      }, colorArr[0]));\n    }\n  });\n  return colorMap;\n}, function () {\n  var params = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    params[_i] = arguments[_i];\n  }\n  return JSON.stringify(params);\n});\n/**\n * 给韦恩图数据进行布局\n *\n * @param data\n * @param width\n * @param height\n * @param padding\n * @returns 韦恩图数据\n */\nexport function layoutVennData(options, width, height, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n  var data = options.data,\n    setsField = options.setsField,\n    sizeField = options.sizeField;\n  // 处理空数据的情况\n  if (data.length === 0) {\n    log(LEVEL.WARN, false, 'warn: %s', '数据不能为空');\n    return [];\n  }\n  var vennData = data.map(function (d) {\n    var _a;\n    return __assign(__assign({}, d), (_a = {\n      sets: d[setsField] || [],\n      size: d[sizeField]\n    }, _a[PATH_FIELD] = '', _a[ID_FIELD] = '', _a));\n  });\n  // 1. 进行排序，避免图形元素遮挡\n  vennData.sort(function (a, b) {\n    return a.sets.length - b.sets.length;\n  });\n  // todo 2. 可以在这里处理下非法数据输入，避免直接 crash\n  var solution = venn(vennData);\n  var circles = scaleSolution(solution, width, height, padding);\n  var textCenters = computeTextCentres(circles, vennData);\n  vennData.forEach(function (row) {\n    var sets = row.sets;\n    var id = sets.join(',');\n    row[ID_FIELD] = id;\n    // 保留 vennText 布局方法\n    var setCircles = sets.map(function (set) {\n      return circles[set];\n    });\n    var path = intersectionAreaPath(setCircles);\n    if (!/[zZ]$/.test(path)) {\n      path += ' Z';\n    }\n    row[PATH_FIELD] = path;\n    var center = textCenters[id] || {\n      x: 0,\n      y: 0\n    };\n    assign(row, center);\n  });\n  return vennData;\n}\n/**\n * 检查是否存在 非法元素\n * @param legalArr 合法集合：['A', 'B']\n * @param testArr 检查集合：['A', 'B', 'C'] or ['A', 'C']（存在非法 'C'）\n * @return boolean\n */\nexport function islegalSets(legalArr, testArr) {\n  for (var i = 0; i < testArr.length; i++) {\n    if (!legalArr.includes(testArr[i])) {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["assign","memoize","LEVEL","log","blend","ID_FIELD","PATH_FIELD","computeTextCentres","intersectionAreaPath","scaleSolution","venn","getColorMap","colorPalette","data","blendMode","setsField","colorMap","Map","colorPaletteLen","length","forEach","d","idx","set","colorArr","map","id","get","slice","reduce","a","b","params","_i","arguments","JSON","stringify","layoutVennData","options","width","height","padding","sizeField","WARN","vennData","__assign","_a","sets","size","sort","solution","circles","textCenters","row","join","setCircles","path","test","center","x","y","islegalSets","legalArr","testArr","i","includes"],"sources":["../../../src/plots/venn/utils.ts"],"sourcesContent":["import { assign, memoize } from '@antv/util';\nimport { LEVEL, log } from '../../utils';\nimport { blend } from '../../utils/color/blend';\nimport { ID_FIELD, PATH_FIELD } from './constant';\nimport { computeTextCentres, intersectionAreaPath } from './layout/diagram';\nimport { scaleSolution, venn } from './layout/layout';\nimport { VennData, VennOptions } from './types';\n\ntype ColorMapFunction = (\n  colorPalette: string[],\n  data: VennData,\n  blendMode: VennOptions['blendMode'],\n  setsField: VennOptions['setsField']\n) => Map<string, string>;\n\n/**\n * 获取 颜色映射\n * @usage colorMap.get(id) => color\n *\n * @returns Map<string, string>\n */\nexport const getColorMap = memoize(\n  ((colorPalette, data, blendMode, setsField) => {\n    const colorMap = new Map<string /** id */, string /** color */>();\n    const colorPaletteLen = colorPalette.length;\n    data.forEach((d, idx) => {\n      if (d[setsField].length === 1) {\n        colorMap.set(d[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);\n      } else {\n        /** 一般都是可以获取到颜色的，如果不正确 就是输入了非法数据 */\n        const colorArr = d[setsField].map((id) => colorMap.get(id));\n        colorMap.set(\n          d[ID_FIELD],\n          colorArr.slice(1).reduce((a, b) => blend(a, b, blendMode), colorArr[0])\n        );\n      }\n    });\n\n    return colorMap;\n  }) as ColorMapFunction,\n  (...params) => JSON.stringify(params)\n) as ColorMapFunction;\n\n/**\n * 给韦恩图数据进行布局\n *\n * @param data\n * @param width\n * @param height\n * @param padding\n * @returns 韦恩图数据\n */\nexport function layoutVennData(options: VennOptions, width: number, height: number, padding: number = 0): VennData {\n  const { data, setsField, sizeField } = options;\n\n  // 处理空数据的情况\n  if (data.length === 0) {\n    log(LEVEL.WARN, false, 'warn: %s', '数据不能为空');\n    return [];\n  }\n\n  const vennData: VennData = data.map((d) => ({\n    ...d,\n    sets: d[setsField] || [],\n    size: d[sizeField],\n    [PATH_FIELD]: '',\n    [ID_FIELD]: '',\n  }));\n  // 1. 进行排序，避免图形元素遮挡\n  vennData.sort((a, b) => a.sets.length - b.sets.length);\n  // todo 2. 可以在这里处理下非法数据输入，避免直接 crash\n\n  const solution = venn(vennData);\n  const circles = scaleSolution(solution, width, height, padding);\n  const textCenters = computeTextCentres(circles, vennData);\n  vennData.forEach((row) => {\n    const sets = row.sets;\n    const id = sets.join(',');\n    row[ID_FIELD] = id;\n    // 保留 vennText 布局方法\n    const setCircles = sets.map((set) => circles[set]);\n    let path = intersectionAreaPath(setCircles);\n    if (!/[zZ]$/.test(path)) {\n      path += ' Z';\n    }\n    row[PATH_FIELD] = path;\n    const center = textCenters[id] || { x: 0, y: 0 };\n    assign(row, center);\n  });\n  return vennData;\n}\n\n/**\n * 检查是否存在 非法元素\n * @param legalArr 合法集合：['A', 'B']\n * @param testArr 检查集合：['A', 'B', 'C'] or ['A', 'C']（存在非法 'C'）\n * @return boolean\n */\nexport function islegalSets(legalArr: any[], testArr: any[]): boolean {\n  for (let i = 0; i < testArr.length; i++) {\n    if (!legalArr.includes(testArr[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}