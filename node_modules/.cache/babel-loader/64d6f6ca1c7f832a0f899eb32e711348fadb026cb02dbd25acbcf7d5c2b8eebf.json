{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { vec2 } from '@antv/matrix-util';\nexport function points2Path(points, isInCircle) {\n  var path = [];\n  if (points.length) {\n    path.push(['M', points[0].x, points[0].y]);\n    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {\n      var item = points[i];\n      path.push(['L', item.x, item.y]);\n    }\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n  return path;\n}\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\nexport var smoothBezier = function (points, smooth, isLoop, constraint) {\n  var cps = [];\n  var prevPoint;\n  var nextPoint;\n  var hasConstraint = !!constraint;\n  var min;\n  var max;\n  if (hasConstraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      min = vec2.min([0, 0], min, point);\n      max = vec2.max([0, 0], max, point);\n    }\n    min = vec2.min([0, 0], min, constraint[0]);\n    max = vec2.max([0, 0], max, constraint[1]);\n  }\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(point);\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n    var v = [0, 0];\n    v = vec2.sub(v, nextPoint, prevPoint);\n    v = vec2.scale(v, v, smooth);\n    var d0 = vec2.distance(point, prevPoint);\n    var d1 = vec2.distance(point, nextPoint);\n    var sum = d0 + d1;\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n    var v1 = vec2.scale([0, 0], v, -d0);\n    var v2 = vec2.scale([0, 0], v, d1);\n    var cp0 = vec2.add([0, 0], point, v1);\n    var cp1 = vec2.add([0, 0], point, v2);\n    if (hasConstraint) {\n      cp0 = vec2.max([0, 0], cp0, min);\n      cp0 = vec2.min([0, 0], cp0, max);\n      cp1 = vec2.max([0, 0], cp1, min);\n      cp1 = vec2.min([0, 0], cp1, max);\n    }\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n  return cps;\n};\n/**\n * @ignore\n * 贝塞尔曲线\n */\nexport function catmullRom2bezier(crp, z, constraint) {\n  var isLoop = !!z;\n  var pointList = [];\n  for (var i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  var len = pointList.length;\n  var d1 = [];\n  var cp1;\n  var cp2;\n  var p;\n  for (var i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  return d1;\n}\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\nexport function getSplinePath(points, isInCircle, constaint) {\n  var data = [];\n  var first = points[0];\n  var prePoint = null;\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return points2Path(points, isInCircle);\n  }\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  }\n  var constraint = constaint || [\n  // 范围\n  [0, 0], [1, 1]];\n  var splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}","map":{"version":3,"names":["vec2","points2Path","points","isInCircle","path","length","push","x","y","i","length_1","item","smoothBezier","smooth","isLoop","constraint","cps","prevPoint","nextPoint","hasConstraint","min","max","Infinity","l","point","len","v","sub","scale","d0","distance","d1","sum","v1","v2","cp0","add","cp1","shift","catmullRom2bezier","crp","z","pointList","controlPointList","cp2","p","getSplinePath","constaint","data","first","prePoint","splinePath","unshift"],"sources":["../../src/utils/path.ts"],"sourcesContent":["import { vec2 } from '@antv/matrix-util';\nimport { Point, Position } from '../types/common';\n\nexport function points2Path(points: Point[], isInCircle: boolean) {\n  const path = [];\n  if (points.length) {\n    path.push(['M', points[0].x, points[0].y]);\n    for (let i = 1, length = points.length; i < length; i += 1) {\n      const item = points[i];\n      path.push(['L', item.x, item.y]);\n    }\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n  return path;\n}\n\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\nexport const smoothBezier = (\n  points: Position[],\n  smooth: number,\n  isLoop: boolean,\n  constraint: Position[]\n): Position[] => {\n  const cps = [];\n  let prevPoint: Position;\n  let nextPoint: Position;\n  const hasConstraint = !!constraint;\n  let min: Position;\n  let max: Position;\n  if (hasConstraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      min = vec2.min([0, 0], min, point) as [number, number];\n      max = vec2.max([0, 0], max, point) as [number, number];\n    }\n    min = vec2.min([0, 0], min, constraint[0]) as [number, number];\n    max = vec2.max([0, 0], max, constraint[1]) as [number, number];\n  }\n\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(point);\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n    let v: [number, number] = [0, 0];\n    v = vec2.sub(v, nextPoint, prevPoint) as [number, number];\n    v = vec2.scale(v, v, smooth) as [number, number];\n\n    let d0 = vec2.distance(point, prevPoint);\n    let d1 = vec2.distance(point, nextPoint);\n\n    const sum = d0 + d1;\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    const v1 = vec2.scale([0, 0], v, -d0);\n    const v2 = vec2.scale([0, 0], v, d1);\n\n    let cp0 = vec2.add([0, 0], point, v1);\n    let cp1 = vec2.add([0, 0], point, v2);\n\n    if (hasConstraint) {\n      cp0 = vec2.max([0, 0], cp0, min);\n      cp0 = vec2.min([0, 0], cp0, max);\n      cp1 = vec2.max([0, 0], cp1, min);\n      cp1 = vec2.min([0, 0], cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n  return cps;\n};\n\n/**\n * @ignore\n * 贝塞尔曲线\n */\nexport function catmullRom2bezier(crp: number[], z: boolean, constraint: Position[]) {\n  const isLoop = !!z;\n  const pointList = [];\n  for (let i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  const controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  const len = pointList.length;\n  const d1 = [];\n\n  let cp1: Position;\n  let cp2: Position;\n  let p: Position;\n\n  for (let i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  return d1;\n}\n\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\nexport function getSplinePath(points: Point[], isInCircle?: boolean, constaint?: Position[]) {\n  const data = [];\n  const first = points[0];\n  let prePoint = null;\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return points2Path(points, isInCircle);\n  }\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  }\n  const constraint = constaint || [\n    // 范围\n    [0, 0],\n    [1, 1],\n  ];\n  const splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}