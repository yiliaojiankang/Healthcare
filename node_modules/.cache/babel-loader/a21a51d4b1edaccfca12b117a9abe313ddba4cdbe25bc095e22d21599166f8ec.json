{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Supercluster = factory());\n})(this, function () {\n  'use strict';\n\n  function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) {\n      return;\n    }\n    var m = left + right >> 1;\n    select(ids, coords, m, left, right, depth % 2);\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n  }\n  function select(ids, coords, k, left, right, inc) {\n    while (right > left) {\n      if (right - left > 600) {\n        var n = right - left + 1;\n        var m = k - left + 1;\n        var z = Math.log(n);\n        var s = 0.5 * Math.exp(2 * z / 3);\n        var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n        var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n        var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n        select(ids, coords, k, newLeft, newRight, inc);\n      }\n      var t = coords[2 * k + inc];\n      var i = left;\n      var j = right;\n      swapItem(ids, coords, left, k);\n      if (coords[2 * right + inc] > t) {\n        swapItem(ids, coords, left, right);\n      }\n      while (i < j) {\n        swapItem(ids, coords, i, j);\n        i++;\n        j--;\n        while (coords[2 * i + inc] < t) {\n          i++;\n        }\n        while (coords[2 * j + inc] > t) {\n          j--;\n        }\n      }\n      if (coords[2 * left + inc] === t) {\n        swapItem(ids, coords, left, j);\n      } else {\n        j++;\n        swapItem(ids, coords, j, right);\n      }\n      if (j <= k) {\n        left = j + 1;\n      }\n      if (k <= j) {\n        right = j - 1;\n      }\n    }\n  }\n  function swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n  }\n  function swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n  function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var x, y;\n    while (stack.length) {\n      var axis = stack.pop();\n      var right = stack.pop();\n      var left = stack.pop();\n      if (right - left <= nodeSize) {\n        for (var i = left; i <= right; i++) {\n          x = coords[2 * i];\n          y = coords[2 * i + 1];\n          if (x >= minX && x <= maxX && y >= minY && y <= maxY) {\n            result.push(ids[i]);\n          }\n        }\n        continue;\n      }\n      var m = Math.floor((left + right) / 2);\n      x = coords[2 * m];\n      y = coords[2 * m + 1];\n      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {\n        result.push(ids[m]);\n      }\n      var nextAxis = (axis + 1) % 2;\n      if (axis === 0 ? minX <= x : minY <= y) {\n        stack.push(left);\n        stack.push(m - 1);\n        stack.push(nextAxis);\n      }\n      if (axis === 0 ? maxX >= x : maxY >= y) {\n        stack.push(m + 1);\n        stack.push(right);\n        stack.push(nextAxis);\n      }\n    }\n    return result;\n  }\n  function within(ids, coords, qx, qy, r, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var r2 = r * r;\n    while (stack.length) {\n      var axis = stack.pop();\n      var right = stack.pop();\n      var left = stack.pop();\n      if (right - left <= nodeSize) {\n        for (var i = left; i <= right; i++) {\n          if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) {\n            result.push(ids[i]);\n          }\n        }\n        continue;\n      }\n      var m = Math.floor((left + right) / 2);\n      var x = coords[2 * m];\n      var y = coords[2 * m + 1];\n      if (sqDist(x, y, qx, qy) <= r2) {\n        result.push(ids[m]);\n      }\n      var nextAxis = (axis + 1) % 2;\n      if (axis === 0 ? qx - r <= x : qy - r <= y) {\n        stack.push(left);\n        stack.push(m - 1);\n        stack.push(nextAxis);\n      }\n      if (axis === 0 ? qx + r >= x : qy + r >= y) {\n        stack.push(m + 1);\n        stack.push(right);\n        stack.push(nextAxis);\n      }\n    }\n    return result;\n  }\n  function sqDist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n  }\n  var defaultGetX = function (p) {\n    return p[0];\n  };\n  var defaultGetY = function (p) {\n    return p[1];\n  };\n  var KDBush = function KDBush(points, getX, getY, nodeSize, ArrayType) {\n    if (getX === void 0) getX = defaultGetX;\n    if (getY === void 0) getY = defaultGetY;\n    if (nodeSize === void 0) nodeSize = 64;\n    if (ArrayType === void 0) ArrayType = Float64Array;\n    this.nodeSize = nodeSize;\n    this.points = points;\n    var IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n    var ids = this.ids = new IndexArrayType(points.length);\n    var coords = this.coords = new ArrayType(points.length * 2);\n    for (var i = 0; i < points.length; i++) {\n      ids[i] = i;\n      coords[2 * i] = getX(points[i]);\n      coords[2 * i + 1] = getY(points[i]);\n    }\n    sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);\n  };\n  KDBush.prototype.range = function range$1(minX, minY, maxX, maxY) {\n    return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n  };\n  KDBush.prototype.within = function within$1(x, y, r) {\n    return within(this.ids, this.coords, x, y, r, this.nodeSize);\n  };\n  var defaultOptions = {\n    minZoom: 0,\n    // min zoom to generate clusters on\n    maxZoom: 16,\n    // max zoom level to cluster the points on\n    minPoints: 2,\n    // minimum points to form a cluster\n    radius: 40,\n    // cluster radius in pixels\n    extent: 512,\n    // tile extent (radius is calculated relative to it)\n    nodeSize: 64,\n    // size of the KD-tree leaf node, affects performance\n    log: false,\n    // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n    // a reduce function for calculating custom cluster properties\n    reduce: null,\n    // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: function (props) {\n      return props;\n    } // props => ({sum: props.my_value})\n  };\n\n  var fround = Math.fround || function (tmp) {\n    return function (x) {\n      tmp[0] = +x;\n      return tmp[0];\n    };\n  }(new Float32Array(1));\n  var Supercluster = function Supercluster(options) {\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n  };\n  Supercluster.prototype.load = function load(points) {\n    var ref = this.options;\n    var log = ref.log;\n    var minZoom = ref.minZoom;\n    var maxZoom = ref.maxZoom;\n    var nodeSize = ref.nodeSize;\n    if (log) {\n      console.time('total time');\n    }\n    var timerId = \"prepare \" + points.length + \" points\";\n    if (log) {\n      console.time(timerId);\n    }\n    this.points = points;\n\n    // generate a cluster object for each point and index input points into a KD-tree\n    var clusters = [];\n    for (var i = 0; i < points.length; i++) {\n      if (!points[i].geometry) {\n        continue;\n      }\n      clusters.push(createPointCluster(points[i], i));\n    }\n    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n    if (log) {\n      console.timeEnd(timerId);\n    }\n\n    // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n    for (var z = maxZoom; z >= minZoom; z--) {\n      var now = +Date.now();\n\n      // create a new set of clusters for the zoom and index them with a KD-tree\n      clusters = this._cluster(clusters, z);\n      this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n      if (log) {\n        console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n      }\n    }\n    if (log) {\n      console.timeEnd('total time');\n    }\n    return this;\n  };\n  Supercluster.prototype.getClusters = function getClusters(bbox, zoom) {\n    var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    var minLat = Math.max(-90, Math.min(90, bbox[1]));\n    var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n    if (bbox[2] - bbox[0] >= 360) {\n      minLng = -180;\n      maxLng = 180;\n    } else if (minLng > maxLng) {\n      var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n      var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n      return easternHem.concat(westernHem);\n    }\n    var tree = this.trees[this._limitZoom(zoom)];\n    var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    var clusters = [];\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n      var id = list[i];\n      var c = tree.points[id];\n      clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n    }\n    return clusters;\n  };\n  Supercluster.prototype.getChildren = function getChildren(clusterId) {\n    var originId = this._getOriginId(clusterId);\n    var originZoom = this._getOriginZoom(clusterId);\n    var errorMsg = 'No cluster with the specified id.';\n    var index = this.trees[originZoom];\n    if (!index) {\n      throw new Error(errorMsg);\n    }\n    var origin = index.points[originId];\n    if (!origin) {\n      throw new Error(errorMsg);\n    }\n    var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    var ids = index.within(origin.x, origin.y, r);\n    var children = [];\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n      var id = list[i];\n      var c = index.points[id];\n      if (c.parentId === clusterId) {\n        children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n      }\n    }\n    if (children.length === 0) {\n      throw new Error(errorMsg);\n    }\n    return children;\n  };\n  Supercluster.prototype.getLeaves = function getLeaves(clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n    var leaves = [];\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n    return leaves;\n  };\n  Supercluster.prototype.getTile = function getTile(z, x, y) {\n    var tree = this.trees[this._limitZoom(z)];\n    var z2 = Math.pow(2, z);\n    var ref = this.options;\n    var extent = ref.extent;\n    var radius = ref.radius;\n    var p = radius / extent;\n    var top = (y - p) / z2;\n    var bottom = (y + 1 + p) / z2;\n    var tile = {\n      features: []\n    };\n    this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);\n    if (x === 0) {\n      this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);\n    }\n    if (x === z2 - 1) {\n      this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);\n    }\n    return tile.features.length ? tile : null;\n  };\n  Supercluster.prototype.getClusterExpansionZoom = function getClusterExpansionZoom(clusterId) {\n    var expansionZoom = this._getOriginZoom(clusterId) - 1;\n    while (expansionZoom <= this.options.maxZoom) {\n      var children = this.getChildren(clusterId);\n      expansionZoom++;\n      if (children.length !== 1) {\n        break;\n      }\n      clusterId = children[0].properties.cluster_id;\n    }\n    return expansionZoom;\n  };\n  Supercluster.prototype._appendLeaves = function _appendLeaves(result, clusterId, limit, offset, skipped) {\n    var children = this.getChildren(clusterId);\n    for (var i = 0, list = children; i < list.length; i += 1) {\n      var child = list[i];\n      var props = child.properties;\n      if (props && props.cluster) {\n        if (skipped + props.point_count <= offset) {\n          // skip the whole cluster\n          skipped += props.point_count;\n        } else {\n          // enter the cluster\n          skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n          // exit the cluster\n        }\n      } else if (skipped < offset) {\n        // skip a single point\n        skipped++;\n      } else {\n        // add a single point\n        result.push(child);\n      }\n      if (result.length === limit) {\n        break;\n      }\n    }\n    return skipped;\n  };\n  Supercluster.prototype._addTileFeatures = function _addTileFeatures(ids, points, x, y, z2, tile) {\n    for (var i$1 = 0, list = ids; i$1 < list.length; i$1 += 1) {\n      var i = list[i$1];\n      var c = points[i];\n      var isCluster = c.numPoints;\n      var tags = void 0,\n        px = void 0,\n        py = void 0;\n      if (isCluster) {\n        tags = getClusterProperties(c);\n        px = c.x;\n        py = c.y;\n      } else {\n        var p = this.points[c.index];\n        tags = p.properties;\n        px = lngX(p.geometry.coordinates[0]);\n        py = latY(p.geometry.coordinates[1]);\n      }\n      var f = {\n        type: 1,\n        geometry: [[Math.round(this.options.extent * (px * z2 - x)), Math.round(this.options.extent * (py * z2 - y))]],\n        tags: tags\n      };\n\n      // assign id\n      var id = void 0;\n      if (isCluster) {\n        id = c.id;\n      } else if (this.options.generateId) {\n        // optionally generate id\n        id = c.index;\n      } else if (this.points[c.index].id) {\n        // keep id if already assigned\n        id = this.points[c.index].id;\n      }\n      if (id !== undefined) {\n        f.id = id;\n      }\n      tile.features.push(f);\n    }\n  };\n  Supercluster.prototype._limitZoom = function _limitZoom(z) {\n    return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n  };\n  Supercluster.prototype._cluster = function _cluster(points, zoom) {\n    var clusters = [];\n    var ref = this.options;\n    var radius = ref.radius;\n    var extent = ref.extent;\n    var reduce = ref.reduce;\n    var minPoints = ref.minPoints;\n    var r = radius / (extent * Math.pow(2, zoom));\n\n    // loop through each point\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      // if we've already visited the point at this zoom level, skip it\n      if (p.zoom <= zoom) {\n        continue;\n      }\n      p.zoom = zoom;\n\n      // find all nearby points\n      var tree = this.trees[zoom + 1];\n      var neighborIds = tree.within(p.x, p.y, r);\n      var numPointsOrigin = p.numPoints || 1;\n      var numPoints = numPointsOrigin;\n\n      // count the number of points in a potential cluster\n      for (var i$1 = 0, list = neighborIds; i$1 < list.length; i$1 += 1) {\n        var neighborId = list[i$1];\n        var b = tree.points[neighborId];\n        // filter out neighbors that are already processed\n        if (b.zoom > zoom) {\n          numPoints += b.numPoints || 1;\n        }\n      }\n\n      // if there were neighbors to merge, and there are enough points to form a cluster\n      if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n        var wx = p.x * numPointsOrigin;\n        var wy = p.y * numPointsOrigin;\n        var clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n        // encode both zoom and point index on which the cluster originated -- offset by total length of features\n        var id = (i << 5) + (zoom + 1) + this.points.length;\n        for (var i$2 = 0, list$1 = neighborIds; i$2 < list$1.length; i$2 += 1) {\n          var neighborId$1 = list$1[i$2];\n          var b$1 = tree.points[neighborId$1];\n          if (b$1.zoom <= zoom) {\n            continue;\n          }\n          b$1.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n          var numPoints2 = b$1.numPoints || 1;\n          wx += b$1.x * numPoints2; // accumulate coordinates for calculating weighted center\n          wy += b$1.y * numPoints2;\n          b$1.parentId = id;\n          if (reduce) {\n            if (!clusterProperties) {\n              clusterProperties = this._map(p, true);\n            }\n            reduce(clusterProperties, this._map(b$1));\n          }\n        }\n        p.parentId = id;\n        clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n      } else {\n        // left points as unclustered\n        clusters.push(p);\n        if (numPoints > 1) {\n          for (var i$3 = 0, list$2 = neighborIds; i$3 < list$2.length; i$3 += 1) {\n            var neighborId$2 = list$2[i$3];\n            var b$2 = tree.points[neighborId$2];\n            if (b$2.zoom <= zoom) {\n              continue;\n            }\n            b$2.zoom = zoom;\n            clusters.push(b$2);\n          }\n        }\n      }\n    }\n    return clusters;\n  };\n\n  // get index of the point from which the cluster originated\n  Supercluster.prototype._getOriginId = function _getOriginId(clusterId) {\n    return clusterId - this.points.length >> 5;\n  };\n\n  // get zoom of the point from which the cluster originated\n  Supercluster.prototype._getOriginZoom = function _getOriginZoom(clusterId) {\n    return (clusterId - this.points.length) % 32;\n  };\n  Supercluster.prototype._map = function _map(point, clone) {\n    if (point.numPoints) {\n      return clone ? extend({}, point.properties) : point.properties;\n    }\n    var original = this.points[point.index].properties;\n    var result = this.options.map(original);\n    return clone && result === original ? extend({}, result) : result;\n  };\n  function createCluster(x, y, id, numPoints, properties) {\n    return {\n      x: fround(x),\n      // weighted cluster center; round for consistency with Float32Array index\n      y: fround(y),\n      zoom: Infinity,\n      // the last zoom the cluster was processed at\n      id: id,\n      // encodes index of the first child of the cluster and its zoom level\n      parentId: -1,\n      // parent cluster id\n      numPoints: numPoints,\n      properties: properties\n    };\n  }\n  function createPointCluster(p, id) {\n    var ref = p.geometry.coordinates;\n    var x = ref[0];\n    var y = ref[1];\n    return {\n      x: fround(lngX(x)),\n      // projected point coordinates\n      y: fround(latY(y)),\n      zoom: Infinity,\n      // the last zoom the point was processed at\n      index: id,\n      // index of the source feature in the original input array,\n      parentId: -1 // parent cluster id\n    };\n  }\n\n  function getClusterJSON(cluster) {\n    return {\n      type: 'Feature',\n      id: cluster.id,\n      properties: getClusterProperties(cluster),\n      geometry: {\n        type: 'Point',\n        coordinates: [xLng(cluster.x), yLat(cluster.y)]\n      }\n    };\n  }\n  function getClusterProperties(cluster) {\n    var count = cluster.numPoints;\n    var abbrev = count >= 10000 ? Math.round(count / 1000) + \"k\" : count >= 1000 ? Math.round(count / 100) / 10 + \"k\" : count;\n    return extend(extend({}, cluster.properties), {\n      cluster: true,\n      cluster_id: cluster.id,\n      point_count: count,\n      point_count_abbreviated: abbrev\n    });\n  }\n\n  // longitude/latitude to spherical mercator in [0..1] range\n  function lngX(lng) {\n    return lng / 360 + 0.5;\n  }\n  function latY(lat) {\n    var sin = Math.sin(lat * Math.PI / 180);\n    var y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n  }\n\n  // spherical mercator to longitude/latitude\n  function xLng(x) {\n    return (x - 0.5) * 360;\n  }\n  function yLat(y) {\n    var y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n  }\n  function extend(dest, src) {\n    for (var id in src) {\n      dest[id] = src[id];\n    }\n    return dest;\n  }\n  function getX(p) {\n    return p.x;\n  }\n  function getY(p) {\n    return p.y;\n  }\n  return Supercluster;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","Supercluster","sortKD","ids","coords","nodeSize","left","right","depth","m","select","k","inc","n","z","Math","log","s","exp","sd","sqrt","newLeft","max","floor","newRight","min","t","i","j","swapItem","swap","arr","tmp","range","minX","minY","maxX","maxY","stack","length","result","x","y","axis","pop","push","nextAxis","within","qx","qy","r","r2","sqDist","ax","ay","bx","by","dx","dy","defaultGetX","p","defaultGetY","KDBush","points","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","prototype","range$1","within$1","defaultOptions","minZoom","maxZoom","minPoints","radius","extent","generateId","reduce","map","props","fround","Float32Array","options","extend","Object","create","trees","Array","load","ref","console","time","timerId","clusters","geometry","createPointCluster","timeEnd","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","lngX","latY","list","id","c","numPoints","getClusterJSON","index","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","pow","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","skipped","child","cluster","point_count","i$1","isCluster","tags","px","py","getClusterProperties","coordinates","f","type","round","undefined","neighborIds","numPointsOrigin","neighborId","b","wx","wy","clusterProperties","_map","i$2","list$1","neighborId$1","b$1","numPoints2","createCluster","i$3","list$2","neighborId$2","b$2","point","clone","original","Infinity","xLng","yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","dest","src"],"sources":["D:/桌面文件/C4大赛/作品源代码/vue/node_modules/supercluster/dist/supercluster.js"],"sourcesContent":["(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\ntypeof define === 'function' && define.amd ? define(factory) :\n(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Supercluster = factory());\n})(this, (function () { 'use strict';\n\nfunction sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) { return; }\n\n    var m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        var t = coords[2 * k + inc];\n        var i = left;\n        var j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) { swapItem(ids, coords, left, right); }\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) { i++; }\n            while (coords[2 * j + inc] > t) { j--; }\n        }\n\n        if (coords[2 * left + inc] === t) { swapItem(ids, coords, left, j); }\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) { left = j + 1; }\n        if (k <= j) { right = j - 1; }\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var x, y;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) { result.push(ids[i]); }\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) { result.push(ids[m]); }\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction within(ids, coords, qx, qy, r, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var r2 = r * r;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) { result.push(ids[i]); }\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        var x = coords[2 * m];\n        var y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) { result.push(ids[m]); }\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nvar defaultGetX = function (p) { return p[0]; };\nvar defaultGetY = function (p) { return p[1]; };\n\nvar KDBush = function KDBush(points, getX, getY, nodeSize, ArrayType) {\n    if ( getX === void 0 ) getX = defaultGetX;\n    if ( getY === void 0 ) getY = defaultGetY;\n    if ( nodeSize === void 0 ) nodeSize = 64;\n    if ( ArrayType === void 0 ) ArrayType = Float64Array;\n\n    this.nodeSize = nodeSize;\n    this.points = points;\n\n    var IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n    var ids = this.ids = new IndexArrayType(points.length);\n    var coords = this.coords = new ArrayType(points.length * 2);\n\n    for (var i = 0; i < points.length; i++) {\n        ids[i] = i;\n        coords[2 * i] = getX(points[i]);\n        coords[2 * i + 1] = getY(points[i]);\n    }\n\n    sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);\n};\n\nKDBush.prototype.range = function range$1 (minX, minY, maxX, maxY) {\n    return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n};\n\nKDBush.prototype.within = function within$1 (x, y, r) {\n    return within(this.ids, this.coords, x, y, r, this.nodeSize);\n};\n\nvar defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: function (props) { return props; } // props => ({sum: props.my_value})\n};\n\nvar fround = Math.fround || (function (tmp) { return (function (x) { tmp[0] = +x; return tmp[0]; }); })(new Float32Array(1));\n\nvar Supercluster = function Supercluster(options) {\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n};\n\nSupercluster.prototype.load = function load (points) {\n    var ref = this.options;\n        var log = ref.log;\n        var minZoom = ref.minZoom;\n        var maxZoom = ref.maxZoom;\n        var nodeSize = ref.nodeSize;\n\n    if (log) { console.time('total time'); }\n\n    var timerId = \"prepare \" + (points.length) + \" points\";\n    if (log) { console.time(timerId); }\n\n    this.points = points;\n\n    // generate a cluster object for each point and index input points into a KD-tree\n    var clusters = [];\n    for (var i = 0; i < points.length; i++) {\n        if (!points[i].geometry) { continue; }\n        clusters.push(createPointCluster(points[i], i));\n    }\n    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n    if (log) { console.timeEnd(timerId); }\n\n    // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n    for (var z = maxZoom; z >= minZoom; z--) {\n        var now = +Date.now();\n\n        // create a new set of clusters for the zoom and index them with a KD-tree\n        clusters = this._cluster(clusters, z);\n        this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) { console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now); }\n    }\n\n    if (log) { console.timeEnd('total time'); }\n\n    return this;\n};\n\nSupercluster.prototype.getClusters = function getClusters (bbox, zoom) {\n    var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    var minLat = Math.max(-90, Math.min(90, bbox[1]));\n    var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n    if (bbox[2] - bbox[0] >= 360) {\n        minLng = -180;\n        maxLng = 180;\n    } else if (minLng > maxLng) {\n        var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n        var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n        return easternHem.concat(westernHem);\n    }\n\n    var tree = this.trees[this._limitZoom(zoom)];\n    var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    var clusters = [];\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n        var id = list[i];\n\n            var c = tree.points[id];\n        clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n    }\n    return clusters;\n};\n\nSupercluster.prototype.getChildren = function getChildren (clusterId) {\n    var originId = this._getOriginId(clusterId);\n    var originZoom = this._getOriginZoom(clusterId);\n    var errorMsg = 'No cluster with the specified id.';\n\n    var index = this.trees[originZoom];\n    if (!index) { throw new Error(errorMsg); }\n\n    var origin = index.points[originId];\n    if (!origin) { throw new Error(errorMsg); }\n\n    var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    var ids = index.within(origin.x, origin.y, r);\n    var children = [];\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n        var id = list[i];\n\n            var c = index.points[id];\n        if (c.parentId === clusterId) {\n            children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n    }\n\n    if (children.length === 0) { throw new Error(errorMsg); }\n\n    return children;\n};\n\nSupercluster.prototype.getLeaves = function getLeaves (clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n\n    var leaves = [];\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n    return leaves;\n};\n\nSupercluster.prototype.getTile = function getTile (z, x, y) {\n    var tree = this.trees[this._limitZoom(z)];\n    var z2 = Math.pow(2, z);\n    var ref = this.options;\n        var extent = ref.extent;\n        var radius = ref.radius;\n    var p = radius / extent;\n    var top = (y - p) / z2;\n    var bottom = (y + 1 + p) / z2;\n\n    var tile = {\n        features: []\n    };\n\n    this._addTileFeatures(\n        tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n        tree.points, x, y, z2, tile);\n\n    if (x === 0) {\n        this._addTileFeatures(\n            tree.range(1 - p / z2, top, 1, bottom),\n            tree.points, z2, y, z2, tile);\n    }\n    if (x === z2 - 1) {\n        this._addTileFeatures(\n            tree.range(0, top, p / z2, bottom),\n            tree.points, -1, y, z2, tile);\n    }\n\n    return tile.features.length ? tile : null;\n};\n\nSupercluster.prototype.getClusterExpansionZoom = function getClusterExpansionZoom (clusterId) {\n    var expansionZoom = this._getOriginZoom(clusterId) - 1;\n    while (expansionZoom <= this.options.maxZoom) {\n        var children = this.getChildren(clusterId);\n        expansionZoom++;\n        if (children.length !== 1) { break; }\n        clusterId = children[0].properties.cluster_id;\n    }\n    return expansionZoom;\n};\n\nSupercluster.prototype._appendLeaves = function _appendLeaves (result, clusterId, limit, offset, skipped) {\n    var children = this.getChildren(clusterId);\n\n    for (var i = 0, list = children; i < list.length; i += 1) {\n        var child = list[i];\n\n            var props = child.properties;\n\n        if (props && props.cluster) {\n            if (skipped + props.point_count <= offset) {\n                // skip the whole cluster\n                skipped += props.point_count;\n            } else {\n                // enter the cluster\n                skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                // exit the cluster\n            }\n        } else if (skipped < offset) {\n            // skip a single point\n            skipped++;\n        } else {\n            // add a single point\n            result.push(child);\n        }\n        if (result.length === limit) { break; }\n    }\n\n    return skipped;\n};\n\nSupercluster.prototype._addTileFeatures = function _addTileFeatures (ids, points, x, y, z2, tile) {\n    for (var i$1 = 0, list = ids; i$1 < list.length; i$1 += 1) {\n        var i = list[i$1];\n\n            var c = points[i];\n        var isCluster = c.numPoints;\n\n        var tags = (void 0), px = (void 0), py = (void 0);\n        if (isCluster) {\n            tags = getClusterProperties(c);\n            px = c.x;\n            py = c.y;\n        } else {\n            var p = this.points[c.index];\n            tags = p.properties;\n            px = lngX(p.geometry.coordinates[0]);\n            py = latY(p.geometry.coordinates[1]);\n        }\n\n        var f = {\n            type: 1,\n            geometry: [[\n                Math.round(this.options.extent * (px * z2 - x)),\n                Math.round(this.options.extent * (py * z2 - y))\n            ]],\n            tags: tags\n        };\n\n        // assign id\n        var id = (void 0);\n        if (isCluster) {\n            id = c.id;\n        } else if (this.options.generateId) {\n            // optionally generate id\n            id = c.index;\n        } else if (this.points[c.index].id) {\n            // keep id if already assigned\n            id = this.points[c.index].id;\n        }\n\n        if (id !== undefined) { f.id = id; }\n\n        tile.features.push(f);\n    }\n};\n\nSupercluster.prototype._limitZoom = function _limitZoom (z) {\n    return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n};\n\nSupercluster.prototype._cluster = function _cluster (points, zoom) {\n    var clusters = [];\n    var ref = this.options;\n        var radius = ref.radius;\n        var extent = ref.extent;\n        var reduce = ref.reduce;\n        var minPoints = ref.minPoints;\n    var r = radius / (extent * Math.pow(2, zoom));\n\n    // loop through each point\n    for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        // if we've already visited the point at this zoom level, skip it\n        if (p.zoom <= zoom) { continue; }\n        p.zoom = zoom;\n\n        // find all nearby points\n        var tree = this.trees[zoom + 1];\n        var neighborIds = tree.within(p.x, p.y, r);\n\n        var numPointsOrigin = p.numPoints || 1;\n        var numPoints = numPointsOrigin;\n\n        // count the number of points in a potential cluster\n        for (var i$1 = 0, list = neighborIds; i$1 < list.length; i$1 += 1) {\n            var neighborId = list[i$1];\n\n                var b = tree.points[neighborId];\n            // filter out neighbors that are already processed\n            if (b.zoom > zoom) { numPoints += b.numPoints || 1; }\n        }\n\n        // if there were neighbors to merge, and there are enough points to form a cluster\n        if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n            var wx = p.x * numPointsOrigin;\n            var wy = p.y * numPointsOrigin;\n\n            var clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n            // encode both zoom and point index on which the cluster originated -- offset by total length of features\n            var id = (i << 5) + (zoom + 1) + this.points.length;\n\n            for (var i$2 = 0, list$1 = neighborIds; i$2 < list$1.length; i$2 += 1) {\n                var neighborId$1 = list$1[i$2];\n\n                    var b$1 = tree.points[neighborId$1];\n\n                if (b$1.zoom <= zoom) { continue; }\n                b$1.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                var numPoints2 = b$1.numPoints || 1;\n                wx += b$1.x * numPoints2; // accumulate coordinates for calculating weighted center\n                wy += b$1.y * numPoints2;\n\n                b$1.parentId = id;\n\n                if (reduce) {\n                    if (!clusterProperties) { clusterProperties = this._map(p, true); }\n                    reduce(clusterProperties, this._map(b$1));\n                }\n            }\n\n            p.parentId = id;\n            clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n        } else { // left points as unclustered\n            clusters.push(p);\n\n            if (numPoints > 1) {\n                for (var i$3 = 0, list$2 = neighborIds; i$3 < list$2.length; i$3 += 1) {\n                    var neighborId$2 = list$2[i$3];\n\n                        var b$2 = tree.points[neighborId$2];\n                    if (b$2.zoom <= zoom) { continue; }\n                    b$2.zoom = zoom;\n                    clusters.push(b$2);\n                }\n            }\n        }\n    }\n\n    return clusters;\n};\n\n// get index of the point from which the cluster originated\nSupercluster.prototype._getOriginId = function _getOriginId (clusterId) {\n    return (clusterId - this.points.length) >> 5;\n};\n\n// get zoom of the point from which the cluster originated\nSupercluster.prototype._getOriginZoom = function _getOriginZoom (clusterId) {\n    return (clusterId - this.points.length) % 32;\n};\n\nSupercluster.prototype._map = function _map (point, clone) {\n    if (point.numPoints) {\n        return clone ? extend({}, point.properties) : point.properties;\n    }\n    var original = this.points[point.index].properties;\n    var result = this.options.map(original);\n    return clone && result === original ? extend({}, result) : result;\n};\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id: id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints: numPoints,\n        properties: properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    var ref = p.geometry.coordinates;\n    var x = ref[0];\n    var y = ref[1];\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    var count = cluster.numPoints;\n    var abbrev =\n        count >= 10000 ? ((Math.round(count / 1000)) + \"k\") :\n        count >= 1000 ? ((Math.round(count / 100) / 10) + \"k\") : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    var sin = Math.sin(lat * Math.PI / 180);\n    var y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    var y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (var id in src) { dest[id] = src[id]; }\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n\nreturn Supercluster;\n\n}));\n"],"mappings":";;;;AAAA,CAAC,UAAUA,MAAM,EAAEC,OAAO,EAAE;EAC5B,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOC,MAAM,KAAK,WAAW,GAAGA,MAAM,CAACD,OAAO,GAAGD,OAAO,CAAC,CAAC,GACzF,OAAOG,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,GAAG,GAAGD,MAAM,CAACH,OAAO,CAAC,IAC3DD,MAAM,GAAG,OAAOM,UAAU,KAAK,WAAW,GAAGA,UAAU,GAAGN,MAAM,IAAIO,IAAI,EAAEP,MAAM,CAACQ,YAAY,GAAGP,OAAO,CAAC,CAAC,CAAC;AAC3G,CAAC,EAAE,IAAI,EAAG,YAAY;EAAE,YAAY;;EAEpC,SAASQ,MAAMA,CAACC,GAAG,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,KAAK,EAAEC,KAAK,EAAE;IACvD,IAAID,KAAK,GAAGD,IAAI,IAAID,QAAQ,EAAE;MAAE;IAAQ;IAExC,IAAII,CAAC,GAAIH,IAAI,GAAGC,KAAK,IAAK,CAAC;IAE3BG,MAAM,CAACP,GAAG,EAAEC,MAAM,EAAEK,CAAC,EAAEH,IAAI,EAAEC,KAAK,EAAEC,KAAK,GAAG,CAAC,CAAC;IAE9CN,MAAM,CAACC,GAAG,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,IAAI,EAAEG,CAAC,GAAG,CAAC,EAAED,KAAK,GAAG,CAAC,CAAC;IACrDN,MAAM,CAACC,GAAG,EAAEC,MAAM,EAAEC,QAAQ,EAAEI,CAAC,GAAG,CAAC,EAAEF,KAAK,EAAEC,KAAK,GAAG,CAAC,CAAC;EAC1D;EAEA,SAASE,MAAMA,CAACP,GAAG,EAAEC,MAAM,EAAEO,CAAC,EAAEL,IAAI,EAAEC,KAAK,EAAEK,GAAG,EAAE;IAE9C,OAAOL,KAAK,GAAGD,IAAI,EAAE;MACjB,IAAIC,KAAK,GAAGD,IAAI,GAAG,GAAG,EAAE;QACpB,IAAIO,CAAC,GAAGN,KAAK,GAAGD,IAAI,GAAG,CAAC;QACxB,IAAIG,CAAC,GAAGE,CAAC,GAAGL,IAAI,GAAG,CAAC;QACpB,IAAIQ,CAAC,GAAGC,IAAI,CAACC,GAAG,CAACH,CAAC,CAAC;QACnB,IAAII,CAAC,GAAG,GAAG,GAAGF,IAAI,CAACG,GAAG,CAAC,CAAC,GAAGJ,CAAC,GAAG,CAAC,CAAC;QACjC,IAAIK,EAAE,GAAG,GAAG,GAAGJ,IAAI,CAACK,IAAI,CAACN,CAAC,GAAGG,CAAC,IAAIJ,CAAC,GAAGI,CAAC,CAAC,GAAGJ,CAAC,CAAC,IAAIJ,CAAC,GAAGI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QACxE,IAAIQ,OAAO,GAAGN,IAAI,CAACO,GAAG,CAAChB,IAAI,EAAES,IAAI,CAACQ,KAAK,CAACZ,CAAC,GAAGF,CAAC,GAAGQ,CAAC,GAAGJ,CAAC,GAAGM,EAAE,CAAC,CAAC;QAC5D,IAAIK,QAAQ,GAAGT,IAAI,CAACU,GAAG,CAAClB,KAAK,EAAEQ,IAAI,CAACQ,KAAK,CAACZ,CAAC,GAAG,CAACE,CAAC,GAAGJ,CAAC,IAAIQ,CAAC,GAAGJ,CAAC,GAAGM,EAAE,CAAC,CAAC;QACpET,MAAM,CAACP,GAAG,EAAEC,MAAM,EAAEO,CAAC,EAAEU,OAAO,EAAEG,QAAQ,EAAEZ,GAAG,CAAC;MAClD;MAEA,IAAIc,CAAC,GAAGtB,MAAM,CAAC,CAAC,GAAGO,CAAC,GAAGC,GAAG,CAAC;MAC3B,IAAIe,CAAC,GAAGrB,IAAI;MACZ,IAAIsB,CAAC,GAAGrB,KAAK;MAEbsB,QAAQ,CAAC1B,GAAG,EAAEC,MAAM,EAAEE,IAAI,EAAEK,CAAC,CAAC;MAC9B,IAAIP,MAAM,CAAC,CAAC,GAAGG,KAAK,GAAGK,GAAG,CAAC,GAAGc,CAAC,EAAE;QAAEG,QAAQ,CAAC1B,GAAG,EAAEC,MAAM,EAAEE,IAAI,EAAEC,KAAK,CAAC;MAAE;MAEvE,OAAOoB,CAAC,GAAGC,CAAC,EAAE;QACVC,QAAQ,CAAC1B,GAAG,EAAEC,MAAM,EAAEuB,CAAC,EAAEC,CAAC,CAAC;QAC3BD,CAAC,EAAE;QACHC,CAAC,EAAE;QACH,OAAOxB,MAAM,CAAC,CAAC,GAAGuB,CAAC,GAAGf,GAAG,CAAC,GAAGc,CAAC,EAAE;UAAEC,CAAC,EAAE;QAAE;QACvC,OAAOvB,MAAM,CAAC,CAAC,GAAGwB,CAAC,GAAGhB,GAAG,CAAC,GAAGc,CAAC,EAAE;UAAEE,CAAC,EAAE;QAAE;MAC3C;MAEA,IAAIxB,MAAM,CAAC,CAAC,GAAGE,IAAI,GAAGM,GAAG,CAAC,KAAKc,CAAC,EAAE;QAAEG,QAAQ,CAAC1B,GAAG,EAAEC,MAAM,EAAEE,IAAI,EAAEsB,CAAC,CAAC;MAAE,CAAC,MAChE;QACDA,CAAC,EAAE;QACHC,QAAQ,CAAC1B,GAAG,EAAEC,MAAM,EAAEwB,CAAC,EAAErB,KAAK,CAAC;MACnC;MAEA,IAAIqB,CAAC,IAAIjB,CAAC,EAAE;QAAEL,IAAI,GAAGsB,CAAC,GAAG,CAAC;MAAE;MAC5B,IAAIjB,CAAC,IAAIiB,CAAC,EAAE;QAAErB,KAAK,GAAGqB,CAAC,GAAG,CAAC;MAAE;IACjC;EACJ;EAEA,SAASC,QAAQA,CAAC1B,GAAG,EAAEC,MAAM,EAAEuB,CAAC,EAAEC,CAAC,EAAE;IACjCE,IAAI,CAAC3B,GAAG,EAAEwB,CAAC,EAAEC,CAAC,CAAC;IACfE,IAAI,CAAC1B,MAAM,EAAE,CAAC,GAAGuB,CAAC,EAAE,CAAC,GAAGC,CAAC,CAAC;IAC1BE,IAAI,CAAC1B,MAAM,EAAE,CAAC,GAAGuB,CAAC,GAAG,CAAC,EAAE,CAAC,GAAGC,CAAC,GAAG,CAAC,CAAC;EACtC;EAEA,SAASE,IAAIA,CAACC,GAAG,EAAEJ,CAAC,EAAEC,CAAC,EAAE;IACrB,IAAII,GAAG,GAAGD,GAAG,CAACJ,CAAC,CAAC;IAChBI,GAAG,CAACJ,CAAC,CAAC,GAAGI,GAAG,CAACH,CAAC,CAAC;IACfG,GAAG,CAACH,CAAC,CAAC,GAAGI,GAAG;EAChB;EAEA,SAASC,KAAKA,CAAC9B,GAAG,EAAEC,MAAM,EAAE8B,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEhC,QAAQ,EAAE;IAC1D,IAAIiC,KAAK,GAAG,CAAC,CAAC,EAAEnC,GAAG,CAACoC,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;IAClC,IAAIC,MAAM,GAAG,EAAE;IACf,IAAIC,CAAC,EAAEC,CAAC;IAER,OAAOJ,KAAK,CAACC,MAAM,EAAE;MACjB,IAAII,IAAI,GAAGL,KAAK,CAACM,GAAG,CAAC,CAAC;MACtB,IAAIrC,KAAK,GAAG+B,KAAK,CAACM,GAAG,CAAC,CAAC;MACvB,IAAItC,IAAI,GAAGgC,KAAK,CAACM,GAAG,CAAC,CAAC;MAEtB,IAAIrC,KAAK,GAAGD,IAAI,IAAID,QAAQ,EAAE;QAC1B,KAAK,IAAIsB,CAAC,GAAGrB,IAAI,EAAEqB,CAAC,IAAIpB,KAAK,EAAEoB,CAAC,EAAE,EAAE;UAChCc,CAAC,GAAGrC,MAAM,CAAC,CAAC,GAAGuB,CAAC,CAAC;UACjBe,CAAC,GAAGtC,MAAM,CAAC,CAAC,GAAGuB,CAAC,GAAG,CAAC,CAAC;UACrB,IAAIc,CAAC,IAAIP,IAAI,IAAIO,CAAC,IAAIL,IAAI,IAAIM,CAAC,IAAIP,IAAI,IAAIO,CAAC,IAAIL,IAAI,EAAE;YAAEG,MAAM,CAACK,IAAI,CAAC1C,GAAG,CAACwB,CAAC,CAAC,CAAC;UAAE;QACjF;QACA;MACJ;MAEA,IAAIlB,CAAC,GAAGM,IAAI,CAACQ,KAAK,CAAC,CAACjB,IAAI,GAAGC,KAAK,IAAI,CAAC,CAAC;MAEtCkC,CAAC,GAAGrC,MAAM,CAAC,CAAC,GAAGK,CAAC,CAAC;MACjBiC,CAAC,GAAGtC,MAAM,CAAC,CAAC,GAAGK,CAAC,GAAG,CAAC,CAAC;MAErB,IAAIgC,CAAC,IAAIP,IAAI,IAAIO,CAAC,IAAIL,IAAI,IAAIM,CAAC,IAAIP,IAAI,IAAIO,CAAC,IAAIL,IAAI,EAAE;QAAEG,MAAM,CAACK,IAAI,CAAC1C,GAAG,CAACM,CAAC,CAAC,CAAC;MAAE;MAE7E,IAAIqC,QAAQ,GAAG,CAACH,IAAI,GAAG,CAAC,IAAI,CAAC;MAE7B,IAAIA,IAAI,KAAK,CAAC,GAAGT,IAAI,IAAIO,CAAC,GAAGN,IAAI,IAAIO,CAAC,EAAE;QACpCJ,KAAK,CAACO,IAAI,CAACvC,IAAI,CAAC;QAChBgC,KAAK,CAACO,IAAI,CAACpC,CAAC,GAAG,CAAC,CAAC;QACjB6B,KAAK,CAACO,IAAI,CAACC,QAAQ,CAAC;MACxB;MACA,IAAIH,IAAI,KAAK,CAAC,GAAGP,IAAI,IAAIK,CAAC,GAAGJ,IAAI,IAAIK,CAAC,EAAE;QACpCJ,KAAK,CAACO,IAAI,CAACpC,CAAC,GAAG,CAAC,CAAC;QACjB6B,KAAK,CAACO,IAAI,CAACtC,KAAK,CAAC;QACjB+B,KAAK,CAACO,IAAI,CAACC,QAAQ,CAAC;MACxB;IACJ;IAEA,OAAON,MAAM;EACjB;EAEA,SAASO,MAAMA,CAAC5C,GAAG,EAAEC,MAAM,EAAE4C,EAAE,EAAEC,EAAE,EAAEC,CAAC,EAAE7C,QAAQ,EAAE;IAC9C,IAAIiC,KAAK,GAAG,CAAC,CAAC,EAAEnC,GAAG,CAACoC,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;IAClC,IAAIC,MAAM,GAAG,EAAE;IACf,IAAIW,EAAE,GAAGD,CAAC,GAAGA,CAAC;IAEd,OAAOZ,KAAK,CAACC,MAAM,EAAE;MACjB,IAAII,IAAI,GAAGL,KAAK,CAACM,GAAG,CAAC,CAAC;MACtB,IAAIrC,KAAK,GAAG+B,KAAK,CAACM,GAAG,CAAC,CAAC;MACvB,IAAItC,IAAI,GAAGgC,KAAK,CAACM,GAAG,CAAC,CAAC;MAEtB,IAAIrC,KAAK,GAAGD,IAAI,IAAID,QAAQ,EAAE;QAC1B,KAAK,IAAIsB,CAAC,GAAGrB,IAAI,EAAEqB,CAAC,IAAIpB,KAAK,EAAEoB,CAAC,EAAE,EAAE;UAChC,IAAIyB,MAAM,CAAChD,MAAM,CAAC,CAAC,GAAGuB,CAAC,CAAC,EAAEvB,MAAM,CAAC,CAAC,GAAGuB,CAAC,GAAG,CAAC,CAAC,EAAEqB,EAAE,EAAEC,EAAE,CAAC,IAAIE,EAAE,EAAE;YAAEX,MAAM,CAACK,IAAI,CAAC1C,GAAG,CAACwB,CAAC,CAAC,CAAC;UAAE;QACvF;QACA;MACJ;MAEA,IAAIlB,CAAC,GAAGM,IAAI,CAACQ,KAAK,CAAC,CAACjB,IAAI,GAAGC,KAAK,IAAI,CAAC,CAAC;MAEtC,IAAIkC,CAAC,GAAGrC,MAAM,CAAC,CAAC,GAAGK,CAAC,CAAC;MACrB,IAAIiC,CAAC,GAAGtC,MAAM,CAAC,CAAC,GAAGK,CAAC,GAAG,CAAC,CAAC;MAEzB,IAAI2C,MAAM,CAACX,CAAC,EAAEC,CAAC,EAAEM,EAAE,EAAEC,EAAE,CAAC,IAAIE,EAAE,EAAE;QAAEX,MAAM,CAACK,IAAI,CAAC1C,GAAG,CAACM,CAAC,CAAC,CAAC;MAAE;MAEvD,IAAIqC,QAAQ,GAAG,CAACH,IAAI,GAAG,CAAC,IAAI,CAAC;MAE7B,IAAIA,IAAI,KAAK,CAAC,GAAGK,EAAE,GAAGE,CAAC,IAAIT,CAAC,GAAGQ,EAAE,GAAGC,CAAC,IAAIR,CAAC,EAAE;QACxCJ,KAAK,CAACO,IAAI,CAACvC,IAAI,CAAC;QAChBgC,KAAK,CAACO,IAAI,CAACpC,CAAC,GAAG,CAAC,CAAC;QACjB6B,KAAK,CAACO,IAAI,CAACC,QAAQ,CAAC;MACxB;MACA,IAAIH,IAAI,KAAK,CAAC,GAAGK,EAAE,GAAGE,CAAC,IAAIT,CAAC,GAAGQ,EAAE,GAAGC,CAAC,IAAIR,CAAC,EAAE;QACxCJ,KAAK,CAACO,IAAI,CAACpC,CAAC,GAAG,CAAC,CAAC;QACjB6B,KAAK,CAACO,IAAI,CAACtC,KAAK,CAAC;QACjB+B,KAAK,CAACO,IAAI,CAACC,QAAQ,CAAC;MACxB;IACJ;IAEA,OAAON,MAAM;EACjB;EAEA,SAASY,MAAMA,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE;IAC5B,IAAIC,EAAE,GAAGJ,EAAE,GAAGE,EAAE;IAChB,IAAIG,EAAE,GAAGJ,EAAE,GAAGE,EAAE;IAChB,OAAOC,EAAE,GAAGA,EAAE,GAAGC,EAAE,GAAGA,EAAE;EAC5B;EAEA,IAAIC,WAAW,GAAG,SAAAA,CAAUC,CAAC,EAAE;IAAE,OAAOA,CAAC,CAAC,CAAC,CAAC;EAAE,CAAC;EAC/C,IAAIC,WAAW,GAAG,SAAAA,CAAUD,CAAC,EAAE;IAAE,OAAOA,CAAC,CAAC,CAAC,CAAC;EAAE,CAAC;EAE/C,IAAIE,MAAM,GAAG,SAASA,MAAMA,CAACC,MAAM,EAAEC,IAAI,EAAEC,IAAI,EAAE5D,QAAQ,EAAE6D,SAAS,EAAE;IAClE,IAAKF,IAAI,KAAK,KAAK,CAAC,EAAGA,IAAI,GAAGL,WAAW;IACzC,IAAKM,IAAI,KAAK,KAAK,CAAC,EAAGA,IAAI,GAAGJ,WAAW;IACzC,IAAKxD,QAAQ,KAAK,KAAK,CAAC,EAAGA,QAAQ,GAAG,EAAE;IACxC,IAAK6D,SAAS,KAAK,KAAK,CAAC,EAAGA,SAAS,GAAGC,YAAY;IAEpD,IAAI,CAAC9D,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC0D,MAAM,GAAGA,MAAM;IAEpB,IAAIK,cAAc,GAAGL,MAAM,CAACxB,MAAM,GAAG,KAAK,GAAG8B,WAAW,GAAGC,WAAW;IAEtE,IAAInE,GAAG,GAAG,IAAI,CAACA,GAAG,GAAG,IAAIiE,cAAc,CAACL,MAAM,CAACxB,MAAM,CAAC;IACtD,IAAInC,MAAM,GAAG,IAAI,CAACA,MAAM,GAAG,IAAI8D,SAAS,CAACH,MAAM,CAACxB,MAAM,GAAG,CAAC,CAAC;IAE3D,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,MAAM,CAACxB,MAAM,EAAEZ,CAAC,EAAE,EAAE;MACpCxB,GAAG,CAACwB,CAAC,CAAC,GAAGA,CAAC;MACVvB,MAAM,CAAC,CAAC,GAAGuB,CAAC,CAAC,GAAGqC,IAAI,CAACD,MAAM,CAACpC,CAAC,CAAC,CAAC;MAC/BvB,MAAM,CAAC,CAAC,GAAGuB,CAAC,GAAG,CAAC,CAAC,GAAGsC,IAAI,CAACF,MAAM,CAACpC,CAAC,CAAC,CAAC;IACvC;IAEAzB,MAAM,CAACC,GAAG,EAAEC,MAAM,EAAEC,QAAQ,EAAE,CAAC,EAAEF,GAAG,CAACoC,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;EACvD,CAAC;EAEDuB,MAAM,CAACS,SAAS,CAACtC,KAAK,GAAG,SAASuC,OAAOA,CAAEtC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAE;IAC/D,OAAOJ,KAAK,CAAC,IAAI,CAAC9B,GAAG,EAAE,IAAI,CAACC,MAAM,EAAE8B,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAE,IAAI,CAAChC,QAAQ,CAAC;EAC9E,CAAC;EAEDyD,MAAM,CAACS,SAAS,CAACxB,MAAM,GAAG,SAAS0B,QAAQA,CAAEhC,CAAC,EAAEC,CAAC,EAAEQ,CAAC,EAAE;IAClD,OAAOH,MAAM,CAAC,IAAI,CAAC5C,GAAG,EAAE,IAAI,CAACC,MAAM,EAAEqC,CAAC,EAAEC,CAAC,EAAEQ,CAAC,EAAE,IAAI,CAAC7C,QAAQ,CAAC;EAChE,CAAC;EAED,IAAIqE,cAAc,GAAG;IACjBC,OAAO,EAAE,CAAC;IAAI;IACdC,OAAO,EAAE,EAAE;IAAG;IACdC,SAAS,EAAE,CAAC;IAAE;IACdC,MAAM,EAAE,EAAE;IAAI;IACdC,MAAM,EAAE,GAAG;IAAG;IACd1E,QAAQ,EAAE,EAAE;IAAE;IACdW,GAAG,EAAE,KAAK;IAAI;;IAEd;IACAgE,UAAU,EAAE,KAAK;IAEjB;IACAC,MAAM,EAAE,IAAI;IAAE;;IAEd;IACAC,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MAAE,OAAOA,KAAK;IAAE,CAAC,CAAC;EAC5C,CAAC;;EAED,IAAIC,MAAM,GAAGrE,IAAI,CAACqE,MAAM,IAAK,UAAUpD,GAAG,EAAE;IAAE,OAAQ,UAAUS,CAAC,EAAE;MAAET,GAAG,CAAC,CAAC,CAAC,GAAG,CAACS,CAAC;MAAE,OAAOT,GAAG,CAAC,CAAC,CAAC;IAAE,CAAC;EAAG,CAAC,CAAE,IAAIqD,YAAY,CAAC,CAAC,CAAC,CAAC;EAE5H,IAAIpF,YAAY,GAAG,SAASA,YAAYA,CAACqF,OAAO,EAAE;IAC9C,IAAI,CAACA,OAAO,GAAGC,MAAM,CAACC,MAAM,CAACC,MAAM,CAACf,cAAc,CAAC,EAAEY,OAAO,CAAC;IAC7D,IAAI,CAACI,KAAK,GAAG,IAAIC,KAAK,CAAC,IAAI,CAACL,OAAO,CAACV,OAAO,GAAG,CAAC,CAAC;EACpD,CAAC;EAED3E,YAAY,CAACsE,SAAS,CAACqB,IAAI,GAAG,SAASA,IAAIA,CAAE7B,MAAM,EAAE;IACjD,IAAI8B,GAAG,GAAG,IAAI,CAACP,OAAO;IAClB,IAAItE,GAAG,GAAG6E,GAAG,CAAC7E,GAAG;IACjB,IAAI2D,OAAO,GAAGkB,GAAG,CAAClB,OAAO;IACzB,IAAIC,OAAO,GAAGiB,GAAG,CAACjB,OAAO;IACzB,IAAIvE,QAAQ,GAAGwF,GAAG,CAACxF,QAAQ;IAE/B,IAAIW,GAAG,EAAE;MAAE8E,OAAO,CAACC,IAAI,CAAC,YAAY,CAAC;IAAE;IAEvC,IAAIC,OAAO,GAAG,UAAU,GAAIjC,MAAM,CAACxB,MAAO,GAAG,SAAS;IACtD,IAAIvB,GAAG,EAAE;MAAE8E,OAAO,CAACC,IAAI,CAACC,OAAO,CAAC;IAAE;IAElC,IAAI,CAACjC,MAAM,GAAGA,MAAM;;IAEpB;IACA,IAAIkC,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAItE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,MAAM,CAACxB,MAAM,EAAEZ,CAAC,EAAE,EAAE;MACpC,IAAI,CAACoC,MAAM,CAACpC,CAAC,CAAC,CAACuE,QAAQ,EAAE;QAAE;MAAU;MACrCD,QAAQ,CAACpD,IAAI,CAACsD,kBAAkB,CAACpC,MAAM,CAACpC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC;IACnD;IACA,IAAI,CAAC+D,KAAK,CAACd,OAAO,GAAG,CAAC,CAAC,GAAG,IAAId,MAAM,CAACmC,QAAQ,EAAEjC,IAAI,EAAEC,IAAI,EAAE5D,QAAQ,EAAEgF,YAAY,CAAC;IAElF,IAAIrE,GAAG,EAAE;MAAE8E,OAAO,CAACM,OAAO,CAACJ,OAAO,CAAC;IAAE;;IAErC;IACA;IACA,KAAK,IAAIlF,CAAC,GAAG8D,OAAO,EAAE9D,CAAC,IAAI6D,OAAO,EAAE7D,CAAC,EAAE,EAAE;MACrC,IAAIuF,GAAG,GAAG,CAACC,IAAI,CAACD,GAAG,CAAC,CAAC;;MAErB;MACAJ,QAAQ,GAAG,IAAI,CAACM,QAAQ,CAACN,QAAQ,EAAEnF,CAAC,CAAC;MACrC,IAAI,CAAC4E,KAAK,CAAC5E,CAAC,CAAC,GAAG,IAAIgD,MAAM,CAACmC,QAAQ,EAAEjC,IAAI,EAAEC,IAAI,EAAE5D,QAAQ,EAAEgF,YAAY,CAAC;MAExE,IAAIrE,GAAG,EAAE;QAAE8E,OAAO,CAAC9E,GAAG,CAAC,0BAA0B,EAAEF,CAAC,EAAEmF,QAAQ,CAAC1D,MAAM,EAAE,CAAC+D,IAAI,CAACD,GAAG,CAAC,CAAC,GAAGA,GAAG,CAAC;MAAE;IAC/F;IAEA,IAAIrF,GAAG,EAAE;MAAE8E,OAAO,CAACM,OAAO,CAAC,YAAY,CAAC;IAAE;IAE1C,OAAO,IAAI;EACf,CAAC;EAEDnG,YAAY,CAACsE,SAAS,CAACiC,WAAW,GAAG,SAASA,WAAWA,CAAEC,IAAI,EAAEC,IAAI,EAAE;IACnE,IAAIC,MAAM,GAAG,CAAC,CAACF,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG;IACtD,IAAIG,MAAM,GAAG7F,IAAI,CAACO,GAAG,CAAC,CAAC,EAAE,EAAEP,IAAI,CAACU,GAAG,CAAC,EAAE,EAAEgF,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACjD,IAAII,MAAM,GAAGJ,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,GAAG,GAAG,CAAC,CAACA,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG;IAC9E,IAAIK,MAAM,GAAG/F,IAAI,CAACO,GAAG,CAAC,CAAC,EAAE,EAAEP,IAAI,CAACU,GAAG,CAAC,EAAE,EAAEgF,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAEjD,IAAIA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;MAC1BE,MAAM,GAAG,CAAC,GAAG;MACbE,MAAM,GAAG,GAAG;IAChB,CAAC,MAAM,IAAIF,MAAM,GAAGE,MAAM,EAAE;MACxB,IAAIE,UAAU,GAAG,IAAI,CAACP,WAAW,CAAC,CAACG,MAAM,EAAEC,MAAM,EAAE,GAAG,EAAEE,MAAM,CAAC,EAAEJ,IAAI,CAAC;MACtE,IAAIM,UAAU,GAAG,IAAI,CAACR,WAAW,CAAC,CAAC,CAAC,GAAG,EAAEI,MAAM,EAAEC,MAAM,EAAEC,MAAM,CAAC,EAAEJ,IAAI,CAAC;MACvE,OAAOK,UAAU,CAACE,MAAM,CAACD,UAAU,CAAC;IACxC;IAEA,IAAIE,IAAI,GAAG,IAAI,CAACxB,KAAK,CAAC,IAAI,CAACyB,UAAU,CAACT,IAAI,CAAC,CAAC;IAC5C,IAAIvG,GAAG,GAAG+G,IAAI,CAACjF,KAAK,CAACmF,IAAI,CAACT,MAAM,CAAC,EAAEU,IAAI,CAACP,MAAM,CAAC,EAAEM,IAAI,CAACP,MAAM,CAAC,EAAEQ,IAAI,CAACT,MAAM,CAAC,CAAC;IAC5E,IAAIX,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAItE,CAAC,GAAG,CAAC,EAAE2F,IAAI,GAAGnH,GAAG,EAAEwB,CAAC,GAAG2F,IAAI,CAAC/E,MAAM,EAAEZ,CAAC,IAAI,CAAC,EAAE;MACjD,IAAI4F,EAAE,GAAGD,IAAI,CAAC3F,CAAC,CAAC;MAEZ,IAAI6F,CAAC,GAAGN,IAAI,CAACnD,MAAM,CAACwD,EAAE,CAAC;MAC3BtB,QAAQ,CAACpD,IAAI,CAAC2E,CAAC,CAACC,SAAS,GAAGC,cAAc,CAACF,CAAC,CAAC,GAAG,IAAI,CAACzD,MAAM,CAACyD,CAAC,CAACG,KAAK,CAAC,CAAC;IACzE;IACA,OAAO1B,QAAQ;EACnB,CAAC;EAEDhG,YAAY,CAACsE,SAAS,CAACqD,WAAW,GAAG,SAASA,WAAWA,CAAEC,SAAS,EAAE;IAClE,IAAIC,QAAQ,GAAG,IAAI,CAACC,YAAY,CAACF,SAAS,CAAC;IAC3C,IAAIG,UAAU,GAAG,IAAI,CAACC,cAAc,CAACJ,SAAS,CAAC;IAC/C,IAAIK,QAAQ,GAAG,mCAAmC;IAElD,IAAIP,KAAK,GAAG,IAAI,CAACjC,KAAK,CAACsC,UAAU,CAAC;IAClC,IAAI,CAACL,KAAK,EAAE;MAAE,MAAM,IAAIQ,KAAK,CAACD,QAAQ,CAAC;IAAE;IAEzC,IAAIE,MAAM,GAAGT,KAAK,CAAC5D,MAAM,CAAC+D,QAAQ,CAAC;IACnC,IAAI,CAACM,MAAM,EAAE;MAAE,MAAM,IAAID,KAAK,CAACD,QAAQ,CAAC;IAAE;IAE1C,IAAIhF,CAAC,GAAG,IAAI,CAACoC,OAAO,CAACR,MAAM,IAAI,IAAI,CAACQ,OAAO,CAACP,MAAM,GAAGhE,IAAI,CAACsH,GAAG,CAAC,CAAC,EAAEL,UAAU,GAAG,CAAC,CAAC,CAAC;IACjF,IAAI7H,GAAG,GAAGwH,KAAK,CAAC5E,MAAM,CAACqF,MAAM,CAAC3F,CAAC,EAAE2F,MAAM,CAAC1F,CAAC,EAAEQ,CAAC,CAAC;IAC7C,IAAIoF,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAI3G,CAAC,GAAG,CAAC,EAAE2F,IAAI,GAAGnH,GAAG,EAAEwB,CAAC,GAAG2F,IAAI,CAAC/E,MAAM,EAAEZ,CAAC,IAAI,CAAC,EAAE;MACjD,IAAI4F,EAAE,GAAGD,IAAI,CAAC3F,CAAC,CAAC;MAEZ,IAAI6F,CAAC,GAAGG,KAAK,CAAC5D,MAAM,CAACwD,EAAE,CAAC;MAC5B,IAAIC,CAAC,CAACe,QAAQ,KAAKV,SAAS,EAAE;QAC1BS,QAAQ,CAACzF,IAAI,CAAC2E,CAAC,CAACC,SAAS,GAAGC,cAAc,CAACF,CAAC,CAAC,GAAG,IAAI,CAACzD,MAAM,CAACyD,CAAC,CAACG,KAAK,CAAC,CAAC;MACzE;IACJ;IAEA,IAAIW,QAAQ,CAAC/F,MAAM,KAAK,CAAC,EAAE;MAAE,MAAM,IAAI4F,KAAK,CAACD,QAAQ,CAAC;IAAE;IAExD,OAAOI,QAAQ;EACnB,CAAC;EAEDrI,YAAY,CAACsE,SAAS,CAACiE,SAAS,GAAG,SAASA,SAASA,CAAEX,SAAS,EAAEY,KAAK,EAAEC,MAAM,EAAE;IAC7ED,KAAK,GAAGA,KAAK,IAAI,EAAE;IACnBC,MAAM,GAAGA,MAAM,IAAI,CAAC;IAEpB,IAAIC,MAAM,GAAG,EAAE;IACf,IAAI,CAACC,aAAa,CAACD,MAAM,EAAEd,SAAS,EAAEY,KAAK,EAAEC,MAAM,EAAE,CAAC,CAAC;IAEvD,OAAOC,MAAM;EACjB,CAAC;EAED1I,YAAY,CAACsE,SAAS,CAACsE,OAAO,GAAG,SAASA,OAAOA,CAAE/H,CAAC,EAAE2B,CAAC,EAAEC,CAAC,EAAE;IACxD,IAAIwE,IAAI,GAAG,IAAI,CAACxB,KAAK,CAAC,IAAI,CAACyB,UAAU,CAACrG,CAAC,CAAC,CAAC;IACzC,IAAIgI,EAAE,GAAG/H,IAAI,CAACsH,GAAG,CAAC,CAAC,EAAEvH,CAAC,CAAC;IACvB,IAAI+E,GAAG,GAAG,IAAI,CAACP,OAAO;IAClB,IAAIP,MAAM,GAAGc,GAAG,CAACd,MAAM;IACvB,IAAID,MAAM,GAAGe,GAAG,CAACf,MAAM;IAC3B,IAAIlB,CAAC,GAAGkB,MAAM,GAAGC,MAAM;IACvB,IAAIgE,GAAG,GAAG,CAACrG,CAAC,GAAGkB,CAAC,IAAIkF,EAAE;IACtB,IAAIE,MAAM,GAAG,CAACtG,CAAC,GAAG,CAAC,GAAGkB,CAAC,IAAIkF,EAAE;IAE7B,IAAIG,IAAI,GAAG;MACPC,QAAQ,EAAE;IACd,CAAC;IAED,IAAI,CAACC,gBAAgB,CACjBjC,IAAI,CAACjF,KAAK,CAAC,CAACQ,CAAC,GAAGmB,CAAC,IAAIkF,EAAE,EAAEC,GAAG,EAAE,CAACtG,CAAC,GAAG,CAAC,GAAGmB,CAAC,IAAIkF,EAAE,EAAEE,MAAM,CAAC,EACvD9B,IAAI,CAACnD,MAAM,EAAEtB,CAAC,EAAEC,CAAC,EAAEoG,EAAE,EAAEG,IAAI,CAAC;IAEhC,IAAIxG,CAAC,KAAK,CAAC,EAAE;MACT,IAAI,CAAC0G,gBAAgB,CACjBjC,IAAI,CAACjF,KAAK,CAAC,CAAC,GAAG2B,CAAC,GAAGkF,EAAE,EAAEC,GAAG,EAAE,CAAC,EAAEC,MAAM,CAAC,EACtC9B,IAAI,CAACnD,MAAM,EAAE+E,EAAE,EAAEpG,CAAC,EAAEoG,EAAE,EAAEG,IAAI,CAAC;IACrC;IACA,IAAIxG,CAAC,KAAKqG,EAAE,GAAG,CAAC,EAAE;MACd,IAAI,CAACK,gBAAgB,CACjBjC,IAAI,CAACjF,KAAK,CAAC,CAAC,EAAE8G,GAAG,EAAEnF,CAAC,GAAGkF,EAAE,EAAEE,MAAM,CAAC,EAClC9B,IAAI,CAACnD,MAAM,EAAE,CAAC,CAAC,EAAErB,CAAC,EAAEoG,EAAE,EAAEG,IAAI,CAAC;IACrC;IAEA,OAAOA,IAAI,CAACC,QAAQ,CAAC3G,MAAM,GAAG0G,IAAI,GAAG,IAAI;EAC7C,CAAC;EAEDhJ,YAAY,CAACsE,SAAS,CAAC6E,uBAAuB,GAAG,SAASA,uBAAuBA,CAAEvB,SAAS,EAAE;IAC1F,IAAIwB,aAAa,GAAG,IAAI,CAACpB,cAAc,CAACJ,SAAS,CAAC,GAAG,CAAC;IACtD,OAAOwB,aAAa,IAAI,IAAI,CAAC/D,OAAO,CAACV,OAAO,EAAE;MAC1C,IAAI0D,QAAQ,GAAG,IAAI,CAACV,WAAW,CAACC,SAAS,CAAC;MAC1CwB,aAAa,EAAE;MACf,IAAIf,QAAQ,CAAC/F,MAAM,KAAK,CAAC,EAAE;QAAE;MAAO;MACpCsF,SAAS,GAAGS,QAAQ,CAAC,CAAC,CAAC,CAACgB,UAAU,CAACC,UAAU;IACjD;IACA,OAAOF,aAAa;EACxB,CAAC;EAEDpJ,YAAY,CAACsE,SAAS,CAACqE,aAAa,GAAG,SAASA,aAAaA,CAAEpG,MAAM,EAAEqF,SAAS,EAAEY,KAAK,EAAEC,MAAM,EAAEc,OAAO,EAAE;IACtG,IAAIlB,QAAQ,GAAG,IAAI,CAACV,WAAW,CAACC,SAAS,CAAC;IAE1C,KAAK,IAAIlG,CAAC,GAAG,CAAC,EAAE2F,IAAI,GAAGgB,QAAQ,EAAE3G,CAAC,GAAG2F,IAAI,CAAC/E,MAAM,EAAEZ,CAAC,IAAI,CAAC,EAAE;MACtD,IAAI8H,KAAK,GAAGnC,IAAI,CAAC3F,CAAC,CAAC;MAEf,IAAIwD,KAAK,GAAGsE,KAAK,CAACH,UAAU;MAEhC,IAAInE,KAAK,IAAIA,KAAK,CAACuE,OAAO,EAAE;QACxB,IAAIF,OAAO,GAAGrE,KAAK,CAACwE,WAAW,IAAIjB,MAAM,EAAE;UACvC;UACAc,OAAO,IAAIrE,KAAK,CAACwE,WAAW;QAChC,CAAC,MAAM;UACH;UACAH,OAAO,GAAG,IAAI,CAACZ,aAAa,CAACpG,MAAM,EAAE2C,KAAK,CAACoE,UAAU,EAAEd,KAAK,EAAEC,MAAM,EAAEc,OAAO,CAAC;UAC9E;QACJ;MACJ,CAAC,MAAM,IAAIA,OAAO,GAAGd,MAAM,EAAE;QACzB;QACAc,OAAO,EAAE;MACb,CAAC,MAAM;QACH;QACAhH,MAAM,CAACK,IAAI,CAAC4G,KAAK,CAAC;MACtB;MACA,IAAIjH,MAAM,CAACD,MAAM,KAAKkG,KAAK,EAAE;QAAE;MAAO;IAC1C;IAEA,OAAOe,OAAO;EAClB,CAAC;EAEDvJ,YAAY,CAACsE,SAAS,CAAC4E,gBAAgB,GAAG,SAASA,gBAAgBA,CAAEhJ,GAAG,EAAE4D,MAAM,EAAEtB,CAAC,EAAEC,CAAC,EAAEoG,EAAE,EAAEG,IAAI,EAAE;IAC9F,KAAK,IAAIW,GAAG,GAAG,CAAC,EAAEtC,IAAI,GAAGnH,GAAG,EAAEyJ,GAAG,GAAGtC,IAAI,CAAC/E,MAAM,EAAEqH,GAAG,IAAI,CAAC,EAAE;MACvD,IAAIjI,CAAC,GAAG2F,IAAI,CAACsC,GAAG,CAAC;MAEb,IAAIpC,CAAC,GAAGzD,MAAM,CAACpC,CAAC,CAAC;MACrB,IAAIkI,SAAS,GAAGrC,CAAC,CAACC,SAAS;MAE3B,IAAIqC,IAAI,GAAI,KAAK,CAAE;QAAEC,EAAE,GAAI,KAAK,CAAE;QAAEC,EAAE,GAAI,KAAK,CAAE;MACjD,IAAIH,SAAS,EAAE;QACXC,IAAI,GAAGG,oBAAoB,CAACzC,CAAC,CAAC;QAC9BuC,EAAE,GAAGvC,CAAC,CAAC/E,CAAC;QACRuH,EAAE,GAAGxC,CAAC,CAAC9E,CAAC;MACZ,CAAC,MAAM;QACH,IAAIkB,CAAC,GAAG,IAAI,CAACG,MAAM,CAACyD,CAAC,CAACG,KAAK,CAAC;QAC5BmC,IAAI,GAAGlG,CAAC,CAAC0F,UAAU;QACnBS,EAAE,GAAG3C,IAAI,CAACxD,CAAC,CAACsC,QAAQ,CAACgE,WAAW,CAAC,CAAC,CAAC,CAAC;QACpCF,EAAE,GAAG3C,IAAI,CAACzD,CAAC,CAACsC,QAAQ,CAACgE,WAAW,CAAC,CAAC,CAAC,CAAC;MACxC;MAEA,IAAIC,CAAC,GAAG;QACJC,IAAI,EAAE,CAAC;QACPlE,QAAQ,EAAE,CAAC,CACPnF,IAAI,CAACsJ,KAAK,CAAC,IAAI,CAAC/E,OAAO,CAACP,MAAM,IAAIgF,EAAE,GAAGjB,EAAE,GAAGrG,CAAC,CAAC,CAAC,EAC/C1B,IAAI,CAACsJ,KAAK,CAAC,IAAI,CAAC/E,OAAO,CAACP,MAAM,IAAIiF,EAAE,GAAGlB,EAAE,GAAGpG,CAAC,CAAC,CAAC,CAClD,CAAC;QACFoH,IAAI,EAAEA;MACV,CAAC;;MAED;MACA,IAAIvC,EAAE,GAAI,KAAK,CAAE;MACjB,IAAIsC,SAAS,EAAE;QACXtC,EAAE,GAAGC,CAAC,CAACD,EAAE;MACb,CAAC,MAAM,IAAI,IAAI,CAACjC,OAAO,CAACN,UAAU,EAAE;QAChC;QACAuC,EAAE,GAAGC,CAAC,CAACG,KAAK;MAChB,CAAC,MAAM,IAAI,IAAI,CAAC5D,MAAM,CAACyD,CAAC,CAACG,KAAK,CAAC,CAACJ,EAAE,EAAE;QAChC;QACAA,EAAE,GAAG,IAAI,CAACxD,MAAM,CAACyD,CAAC,CAACG,KAAK,CAAC,CAACJ,EAAE;MAChC;MAEA,IAAIA,EAAE,KAAK+C,SAAS,EAAE;QAAEH,CAAC,CAAC5C,EAAE,GAAGA,EAAE;MAAE;MAEnC0B,IAAI,CAACC,QAAQ,CAACrG,IAAI,CAACsH,CAAC,CAAC;IACzB;EACJ,CAAC;EAEDlK,YAAY,CAACsE,SAAS,CAAC4C,UAAU,GAAG,SAASA,UAAUA,CAAErG,CAAC,EAAE;IACxD,OAAOC,IAAI,CAACO,GAAG,CAAC,IAAI,CAACgE,OAAO,CAACX,OAAO,EAAE5D,IAAI,CAACU,GAAG,CAACV,IAAI,CAACQ,KAAK,CAAC,CAACT,CAAC,CAAC,EAAE,IAAI,CAACwE,OAAO,CAACV,OAAO,GAAG,CAAC,CAAC,CAAC;EAC7F,CAAC;EAED3E,YAAY,CAACsE,SAAS,CAACgC,QAAQ,GAAG,SAASA,QAAQA,CAAExC,MAAM,EAAE2C,IAAI,EAAE;IAC/D,IAAIT,QAAQ,GAAG,EAAE;IACjB,IAAIJ,GAAG,GAAG,IAAI,CAACP,OAAO;IAClB,IAAIR,MAAM,GAAGe,GAAG,CAACf,MAAM;IACvB,IAAIC,MAAM,GAAGc,GAAG,CAACd,MAAM;IACvB,IAAIE,MAAM,GAAGY,GAAG,CAACZ,MAAM;IACvB,IAAIJ,SAAS,GAAGgB,GAAG,CAAChB,SAAS;IACjC,IAAI3B,CAAC,GAAG4B,MAAM,IAAIC,MAAM,GAAGhE,IAAI,CAACsH,GAAG,CAAC,CAAC,EAAE3B,IAAI,CAAC,CAAC;;IAE7C;IACA,KAAK,IAAI/E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,MAAM,CAACxB,MAAM,EAAEZ,CAAC,EAAE,EAAE;MACpC,IAAIiC,CAAC,GAAGG,MAAM,CAACpC,CAAC,CAAC;MACjB;MACA,IAAIiC,CAAC,CAAC8C,IAAI,IAAIA,IAAI,EAAE;QAAE;MAAU;MAChC9C,CAAC,CAAC8C,IAAI,GAAGA,IAAI;;MAEb;MACA,IAAIQ,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACgB,IAAI,GAAG,CAAC,CAAC;MAC/B,IAAI6D,WAAW,GAAGrD,IAAI,CAACnE,MAAM,CAACa,CAAC,CAACnB,CAAC,EAAEmB,CAAC,CAAClB,CAAC,EAAEQ,CAAC,CAAC;MAE1C,IAAIsH,eAAe,GAAG5G,CAAC,CAAC6D,SAAS,IAAI,CAAC;MACtC,IAAIA,SAAS,GAAG+C,eAAe;;MAE/B;MACA,KAAK,IAAIZ,GAAG,GAAG,CAAC,EAAEtC,IAAI,GAAGiD,WAAW,EAAEX,GAAG,GAAGtC,IAAI,CAAC/E,MAAM,EAAEqH,GAAG,IAAI,CAAC,EAAE;QAC/D,IAAIa,UAAU,GAAGnD,IAAI,CAACsC,GAAG,CAAC;QAEtB,IAAIc,CAAC,GAAGxD,IAAI,CAACnD,MAAM,CAAC0G,UAAU,CAAC;QACnC;QACA,IAAIC,CAAC,CAAChE,IAAI,GAAGA,IAAI,EAAE;UAAEe,SAAS,IAAIiD,CAAC,CAACjD,SAAS,IAAI,CAAC;QAAE;MACxD;;MAEA;MACA,IAAIA,SAAS,GAAG+C,eAAe,IAAI/C,SAAS,IAAI5C,SAAS,EAAE;QACvD,IAAI8F,EAAE,GAAG/G,CAAC,CAACnB,CAAC,GAAG+H,eAAe;QAC9B,IAAII,EAAE,GAAGhH,CAAC,CAAClB,CAAC,GAAG8H,eAAe;QAE9B,IAAIK,iBAAiB,GAAG5F,MAAM,IAAIuF,eAAe,GAAG,CAAC,GAAG,IAAI,CAACM,IAAI,CAAClH,CAAC,EAAE,IAAI,CAAC,GAAG,IAAI;;QAEjF;QACA,IAAI2D,EAAE,GAAG,CAAC5F,CAAC,IAAI,CAAC,KAAK+E,IAAI,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC3C,MAAM,CAACxB,MAAM;QAEnD,KAAK,IAAIwI,GAAG,GAAG,CAAC,EAAEC,MAAM,GAAGT,WAAW,EAAEQ,GAAG,GAAGC,MAAM,CAACzI,MAAM,EAAEwI,GAAG,IAAI,CAAC,EAAE;UACnE,IAAIE,YAAY,GAAGD,MAAM,CAACD,GAAG,CAAC;UAE1B,IAAIG,GAAG,GAAGhE,IAAI,CAACnD,MAAM,CAACkH,YAAY,CAAC;UAEvC,IAAIC,GAAG,CAACxE,IAAI,IAAIA,IAAI,EAAE;YAAE;UAAU;UAClCwE,GAAG,CAACxE,IAAI,GAAGA,IAAI,CAAC,CAAC;;UAEjB,IAAIyE,UAAU,GAAGD,GAAG,CAACzD,SAAS,IAAI,CAAC;UACnCkD,EAAE,IAAIO,GAAG,CAACzI,CAAC,GAAG0I,UAAU,CAAC,CAAC;UAC1BP,EAAE,IAAIM,GAAG,CAACxI,CAAC,GAAGyI,UAAU;UAExBD,GAAG,CAAC3C,QAAQ,GAAGhB,EAAE;UAEjB,IAAItC,MAAM,EAAE;YACR,IAAI,CAAC4F,iBAAiB,EAAE;cAAEA,iBAAiB,GAAG,IAAI,CAACC,IAAI,CAAClH,CAAC,EAAE,IAAI,CAAC;YAAE;YAClEqB,MAAM,CAAC4F,iBAAiB,EAAE,IAAI,CAACC,IAAI,CAACI,GAAG,CAAC,CAAC;UAC7C;QACJ;QAEAtH,CAAC,CAAC2E,QAAQ,GAAGhB,EAAE;QACftB,QAAQ,CAACpD,IAAI,CAACuI,aAAa,CAACT,EAAE,GAAGlD,SAAS,EAAEmD,EAAE,GAAGnD,SAAS,EAAEF,EAAE,EAAEE,SAAS,EAAEoD,iBAAiB,CAAC,CAAC;MAElG,CAAC,MAAM;QAAE;QACL5E,QAAQ,CAACpD,IAAI,CAACe,CAAC,CAAC;QAEhB,IAAI6D,SAAS,GAAG,CAAC,EAAE;UACf,KAAK,IAAI4D,GAAG,GAAG,CAAC,EAAEC,MAAM,GAAGf,WAAW,EAAEc,GAAG,GAAGC,MAAM,CAAC/I,MAAM,EAAE8I,GAAG,IAAI,CAAC,EAAE;YACnE,IAAIE,YAAY,GAAGD,MAAM,CAACD,GAAG,CAAC;YAE1B,IAAIG,GAAG,GAAGtE,IAAI,CAACnD,MAAM,CAACwH,YAAY,CAAC;YACvC,IAAIC,GAAG,CAAC9E,IAAI,IAAIA,IAAI,EAAE;cAAE;YAAU;YAClC8E,GAAG,CAAC9E,IAAI,GAAGA,IAAI;YACfT,QAAQ,CAACpD,IAAI,CAAC2I,GAAG,CAAC;UACtB;QACJ;MACJ;IACJ;IAEA,OAAOvF,QAAQ;EACnB,CAAC;;EAED;EACAhG,YAAY,CAACsE,SAAS,CAACwD,YAAY,GAAG,SAASA,YAAYA,CAAEF,SAAS,EAAE;IACpE,OAAQA,SAAS,GAAG,IAAI,CAAC9D,MAAM,CAACxB,MAAM,IAAK,CAAC;EAChD,CAAC;;EAED;EACAtC,YAAY,CAACsE,SAAS,CAAC0D,cAAc,GAAG,SAASA,cAAcA,CAAEJ,SAAS,EAAE;IACxE,OAAO,CAACA,SAAS,GAAG,IAAI,CAAC9D,MAAM,CAACxB,MAAM,IAAI,EAAE;EAChD,CAAC;EAEDtC,YAAY,CAACsE,SAAS,CAACuG,IAAI,GAAG,SAASA,IAAIA,CAAEW,KAAK,EAAEC,KAAK,EAAE;IACvD,IAAID,KAAK,CAAChE,SAAS,EAAE;MACjB,OAAOiE,KAAK,GAAGnG,MAAM,CAAC,CAAC,CAAC,EAAEkG,KAAK,CAACnC,UAAU,CAAC,GAAGmC,KAAK,CAACnC,UAAU;IAClE;IACA,IAAIqC,QAAQ,GAAG,IAAI,CAAC5H,MAAM,CAAC0H,KAAK,CAAC9D,KAAK,CAAC,CAAC2B,UAAU;IAClD,IAAI9G,MAAM,GAAG,IAAI,CAAC8C,OAAO,CAACJ,GAAG,CAACyG,QAAQ,CAAC;IACvC,OAAOD,KAAK,IAAIlJ,MAAM,KAAKmJ,QAAQ,GAAGpG,MAAM,CAAC,CAAC,CAAC,EAAE/C,MAAM,CAAC,GAAGA,MAAM;EACrE,CAAC;EAED,SAAS4I,aAAaA,CAAC3I,CAAC,EAAEC,CAAC,EAAE6E,EAAE,EAAEE,SAAS,EAAE6B,UAAU,EAAE;IACpD,OAAO;MACH7G,CAAC,EAAE2C,MAAM,CAAC3C,CAAC,CAAC;MAAE;MACdC,CAAC,EAAE0C,MAAM,CAAC1C,CAAC,CAAC;MACZgE,IAAI,EAAEkF,QAAQ;MAAE;MAChBrE,EAAE,EAAEA,EAAE;MAAE;MACRgB,QAAQ,EAAE,CAAC,CAAC;MAAE;MACdd,SAAS,EAAEA,SAAS;MACpB6B,UAAU,EAAEA;IAChB,CAAC;EACL;EAEA,SAASnD,kBAAkBA,CAACvC,CAAC,EAAE2D,EAAE,EAAE;IAC/B,IAAI1B,GAAG,GAAGjC,CAAC,CAACsC,QAAQ,CAACgE,WAAW;IAChC,IAAIzH,CAAC,GAAGoD,GAAG,CAAC,CAAC,CAAC;IACd,IAAInD,CAAC,GAAGmD,GAAG,CAAC,CAAC,CAAC;IACd,OAAO;MACHpD,CAAC,EAAE2C,MAAM,CAACgC,IAAI,CAAC3E,CAAC,CAAC,CAAC;MAAE;MACpBC,CAAC,EAAE0C,MAAM,CAACiC,IAAI,CAAC3E,CAAC,CAAC,CAAC;MAClBgE,IAAI,EAAEkF,QAAQ;MAAE;MAChBjE,KAAK,EAAEJ,EAAE;MAAE;MACXgB,QAAQ,EAAE,CAAC,CAAC,CAAC;IACjB,CAAC;EACL;;EAEA,SAASb,cAAcA,CAACgC,OAAO,EAAE;IAC7B,OAAO;MACHU,IAAI,EAAE,SAAS;MACf7C,EAAE,EAAEmC,OAAO,CAACnC,EAAE;MACd+B,UAAU,EAAEW,oBAAoB,CAACP,OAAO,CAAC;MACzCxD,QAAQ,EAAE;QACNkE,IAAI,EAAE,OAAO;QACbF,WAAW,EAAE,CAAC2B,IAAI,CAACnC,OAAO,CAACjH,CAAC,CAAC,EAAEqJ,IAAI,CAACpC,OAAO,CAAChH,CAAC,CAAC;MAClD;IACJ,CAAC;EACL;EAEA,SAASuH,oBAAoBA,CAACP,OAAO,EAAE;IACnC,IAAIqC,KAAK,GAAGrC,OAAO,CAACjC,SAAS;IAC7B,IAAIuE,MAAM,GACND,KAAK,IAAI,KAAK,GAAKhL,IAAI,CAACsJ,KAAK,CAAC0B,KAAK,GAAG,IAAI,CAAC,GAAI,GAAG,GAClDA,KAAK,IAAI,IAAI,GAAKhL,IAAI,CAACsJ,KAAK,CAAC0B,KAAK,GAAG,GAAG,CAAC,GAAG,EAAE,GAAI,GAAG,GAAIA,KAAK;IAClE,OAAOxG,MAAM,CAACA,MAAM,CAAC,CAAC,CAAC,EAAEmE,OAAO,CAACJ,UAAU,CAAC,EAAE;MAC1CI,OAAO,EAAE,IAAI;MACbH,UAAU,EAAEG,OAAO,CAACnC,EAAE;MACtBoC,WAAW,EAAEoC,KAAK;MAClBE,uBAAuB,EAAED;IAC7B,CAAC,CAAC;EACN;;EAEA;EACA,SAAS5E,IAAIA,CAAC8E,GAAG,EAAE;IACf,OAAOA,GAAG,GAAG,GAAG,GAAG,GAAG;EAC1B;EACA,SAAS7E,IAAIA,CAAC8E,GAAG,EAAE;IACf,IAAIC,GAAG,GAAGrL,IAAI,CAACqL,GAAG,CAACD,GAAG,GAAGpL,IAAI,CAACsL,EAAE,GAAG,GAAG,CAAC;IACvC,IAAI3J,CAAC,GAAI,GAAG,GAAG,IAAI,GAAG3B,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC,GAAGoL,GAAG,KAAK,CAAC,GAAGA,GAAG,CAAC,CAAC,GAAGrL,IAAI,CAACsL,EAAG;IAChE,OAAO3J,CAAC,GAAG,CAAC,GAAG,CAAC,GAAGA,CAAC,GAAG,CAAC,GAAG,CAAC,GAAGA,CAAC;EACpC;;EAEA;EACA,SAASmJ,IAAIA,CAACpJ,CAAC,EAAE;IACb,OAAO,CAACA,CAAC,GAAG,GAAG,IAAI,GAAG;EAC1B;EACA,SAASqJ,IAAIA,CAACpJ,CAAC,EAAE;IACb,IAAI4J,EAAE,GAAG,CAAC,GAAG,GAAG5J,CAAC,GAAG,GAAG,IAAI3B,IAAI,CAACsL,EAAE,GAAG,GAAG;IACxC,OAAO,GAAG,GAAGtL,IAAI,CAACwL,IAAI,CAACxL,IAAI,CAACG,GAAG,CAACoL,EAAE,CAAC,CAAC,GAAGvL,IAAI,CAACsL,EAAE,GAAG,EAAE;EACvD;EAEA,SAAS9G,MAAMA,CAACiH,IAAI,EAAEC,GAAG,EAAE;IACvB,KAAK,IAAIlF,EAAE,IAAIkF,GAAG,EAAE;MAAED,IAAI,CAACjF,EAAE,CAAC,GAAGkF,GAAG,CAAClF,EAAE,CAAC;IAAE;IAC1C,OAAOiF,IAAI;EACf;EAEA,SAASxI,IAAIA,CAACJ,CAAC,EAAE;IACb,OAAOA,CAAC,CAACnB,CAAC;EACd;EACA,SAASwB,IAAIA,CAACL,CAAC,EAAE;IACb,OAAOA,CAAC,CAAClB,CAAC;EACd;EAEA,OAAOzC,YAAY;AAEnB,CAAE,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}