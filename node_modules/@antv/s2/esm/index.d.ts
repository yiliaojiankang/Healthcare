import type { BBox } from '@antv/g-canvas';
import { Canvas } from '@antv/g-canvas';
import type * as CSS_2 from 'csstype';
import { DebouncedFunc } from 'lodash';
import EE from '@antv/event-emitter';
import { Event as GEvent } from '@antv/g-canvas';
import { GM } from '@antv/g-gesture';
import { Group } from '@antv/g-canvas';
import type { IElement } from '@antv/g-canvas';
import { IGroup } from '@antv/g-canvas';
import { IShape } from '@antv/g-canvas';
import { MemoizedFunction } from 'lodash';
import { Omit as Omit_2 } from 'lodash';
import { Point } from '@antv/g-canvas';
import { Shape } from '@antv/g-canvas';
import { ShapeAttrs } from '@antv/g-canvas';
import type { ShapeCfg } from '@antv/g-canvas';
import type { SimpleBBox } from '@antv/g-canvas';
import { Timer } from 'd3-timer';
import { Wheel } from '@antv/g-gesture';

/**
 * 根据文字样式计算文字实际绘制起始
 *
 * 以 textAlign=left 为例，g 绘制时取 text 最左侧的坐标值作为基准坐标
 *
 * 计算前：                                        计算后：
 * startX = textAreaRange.start = 中心点           startX = 最左侧坐标
 *
 *        textAreaRange.start                     startX
 *                |                                |
 *                v                                v
 *  +----------------------------+                +----------------------------+
 *  |    +------------------+    |                |+------------------+        |
 *  |    |   text    | icon |    |                ||   text    | icon |        |
 *  |    +------------------+    |                |+------------------+        |
 *  +----------------------------+                +----------------------------+
 *       <------------------>
 *         textAndIconSpace
 *  <---------------------------->
 *        textAreaRange.width
 *
 * @param textAreaRange 文本&icon 绘制坐标
 * @param actualTextWidth 文本实际宽度
 * @param actionIconSpace icon 区域实际宽度
 * @param textAlign 对齐样式
 * @returns 文字绘制起点坐标
 */
export declare const adjustColHeaderScrollingTextPosition: (textAreaRange: AreaRange, actualTextWidth: number, actionIconSpace: number, textAlign: TextAlign) => number;

/**
 * 根据单元格文字样式调整 viewport range，使文字在滚动时不会贴边展示
 *
 * 以 textAlign=left 情况为例，由大到小的矩形分别是 viewport、cellContent、cellText
 * 左图是未调整前，滚动相交判定在 viewport 最左侧，即 colCell 滚动到 viewport 左侧后，文字会贴左边绘制
 * 右图是调整后，range.start 提前了 padding.left 个像素，文字与 viewport 有一定间隙更加美观
 *
 *    range.start                                   range.start
 *         |                                             |
 *         |      range.width                            |  range.width
 *         v<---------------------->                     v<------------------>
 *
 *         +-----------------------+                 +-----------------------+
 *         |       viewport        |                 |       viewport        |
 *     +-------------------+       |             +-------------------+       |
 *     |   +---------+     |       |             |   |   +---------+ |       |
 *     |   |  text   |     |       |             |   |   |  text   | |       |
 *     |   +---------+     |       |             |   |   +---------+ |       |
 *     +-------------------+       |             +-------------------+       |
 *         +-----------------------+                 +-----------------------+
 *
 *                                                   <-->
 *                                                padding.left
 *
 * @param viewport 原始 viewport
 * @param textAlign 文字样式
 * @param textPadding 单元格 padding 样式
 * @returns viewport range
 */
export declare const adjustColHeaderScrollingViewport: (viewport: AreaRange, textAlign: TextAlign, textPadding?: Padding) => {
    start: number;
    width: number;
};

export declare const afterSelectDataCells: OnUpdateCells;

export declare enum Aggregation {
    SUM = "SUM",
    MIN = "MIN",
    MAX = "MAX",
    AVG = "AVG"
}

export declare interface AreaRange {
    start: number;
    width: number;
}

/**
 * 自动格式化
 * 规则
 *  1，小于1w，使用逗号分割，例如 3,459
 *  2，大于1w，使用语义化，例如 3.2万，3.4亿 2,234万
 * @param v
 * @param fixed
 * @param formatter
 */
export declare const auto: (v: number, fixed?: number, formatter?: (number[] | string[])[]) => string;

export declare interface AutoAdjustPositionOptions {
    position: TooltipPosition;
    tooltipContainer: HTMLElement;
    spreadsheet: SpreadSheet;
    autoAdjustBoundary: TooltipAutoAdjustBoundary;
}

export declare const BACK_GROUND_GROUP_CONTAINER_Z_INDEX = 0;

export declare interface Background {
    opacity?: number;
    color?: string;
}

export declare interface BarTheme {
    intervalPadding?: number;
    fill?: string;
    opacity?: number;
}

declare abstract class BaseBBox implements BBox {
    protected spreadsheet: SpreadSheet;
    protected facet: BaseFacet;
    protected layoutResult: LayoutResult;
    x: number;
    y: number;
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
    width: number;
    height: number;
    originalWidth: number;
    originalHeight: number;
    viewportHeight: number;
    viewportWidth: number;
    constructor(facet: BaseFacet, autoCalculateBBoxWhenCreated?: boolean);
    abstract calculateBBox(): void;
}

/**
 * 刷选基类, dataCell, rowCell, colCell 支持滚动刷选
 */
export declare class BaseBrushSelection extends BaseEvent implements BaseEventImplement {
    displayedCells: S2CellType[];
    prepareSelectMaskShape: IShape;
    startBrushPoint: BrushPoint;
    endBrushPoint: BrushPoint;
    brushRangeCells: S2CellType[];
    brushSelectionStage: InteractionBrushSelectionStage;
    brushSelectionMinimumMoveDistance: number;
    scrollAnimationComplete: boolean;
    mouseMoveDistanceFromCanvas: number;
    bindEvents(): void;
    protected getPrepareSelectMaskTheme(): InteractionStateTheme;
    protected initPrepareSelectMaskShape(): void;
    protected setBrushSelectionStage(stage: InteractionBrushSelectionStage): void;
    protected isPointInCanvas(point: Point): boolean;
    private setMoveDistanceFromCanvas;
    formatBrushPointForScroll: (delta: Point, isRowHeader?: boolean) => {
        x: {
            value: number;
            needScroll: boolean;
        };
        y: {
            value: number;
            needScroll: boolean;
        };
    };
    rectanglesIntersect: (rect1: Rect, rect2: Rect) => boolean;
    private autoScrollIntervalId;
    protected autoScrollConfig: BrushAutoScrollConfig;
    validateYIndex: (yIndex: number) => number;
    validateXIndex: (xIndex: number) => number;
    adjustNextColIndexWithFrozen: (colIndex: number, dir: ScrollDirection) => number;
    adjustNextRowIndexWithFrozen: (rowIndex: number, dir: ScrollDirection) => number;
    getWillScrollRowIndexDiff: (dir: ScrollDirection) => number;
    getDefaultWillScrollToRowIndex: (dir: ScrollDirection) => number;
    protected getWillScrollToRowIndex: (dir: ScrollDirection) => number;
    private getNextScrollDelta;
    private onScrollAnimationComplete;
    private autoScroll;
    protected handleScroll: DebouncedFunc<(x: number, y: number, isRowHeader?: any) => void>;
    protected clearAutoScroll: () => void;
    protected resetDrag(): void;
    isValidBrushSelection(): boolean;
    protected setDisplayedCells(): void;
    protected updatePrepareSelectMask(): void;
    hidePrepareSelectMaskShape(): void;
    protected resetScrollDelta(): void;
    protected getBrushPoint(event: GEvent): BrushPoint;
    getBrushRange(): BrushRange;
    protected getBrushRangeCells(): S2CellType[];
    protected onUpdateCells: OnUpdateCells;
    private showPrepareSelectedCells;
    protected mouseDown(event: GEvent): void;
    protected addBrushIntercepts(): void;
    protected bindMouseUp(enableScroll?: boolean): void;
    protected renderPrepareSelected: (point: Point) => void;
    autoBrushScroll(point: Point, isRowHeader?: boolean): boolean;
    emitBrushSelectionEvent(event: S2Event, scrollBrushRangeCells: S2CellType[]): void;
    getVisibleBrushRangeCells(nodeId: string): S2CellType<ViewMeta>;
    protected isInBrushRange(meta: ViewMeta | Node_2): boolean;
    protected bindMouseDown(): void;
    protected bindMouseMove(): void;
    protected updateSelectedCells(): void;
    protected getPrepareSelectMaskPosition(brushRange: BrushRange): Point;
}

export declare abstract class BaseCell<T extends SimpleBBox> extends Group {
    protected meta: T;
    protected spreadsheet: SpreadSheet;
    protected theme: S2Theme;
    protected backgroundShape: IShape;
    protected textShape: IShape;
    protected textShapes: IShape[];
    protected linkFieldShape: IShape;
    protected actualText: string;
    protected actualTextWidth: number;
    protected conditions: Conditions;
    protected conditionIntervalShape: IShape;
    protected conditionIconShape: GuiIcon;
    protected conditionIconShapes: GuiIcon[];
    protected stateShapes: Map<StateShapeLayer, IShape>;
    constructor(meta: T, spreadsheet: SpreadSheet, ...restOptions: unknown[]);
    getMeta(): T;
    setMeta(viewMeta: T): void;
    getIconStyle(): IconTheme;
    getTextAndIconPosition(iconCount?: number): {
        text: {
            x: number;
            y: number;
        };
        icon: {
            x: number;
            y: number;
        };
    };
    getActualText(): string;
    isTextOverflowing(): boolean;
    getFieldValue(): string;
    /**
     * in case there are more params to be handled
     * @param options any type's rest params
     */
    protected handleRestOptions(...options: unknown[]): void;
    /**
     * Return the type of the cell
     */
    abstract get cellType(): CellTypes;
    /**
     * Determine how to render this cell area
     */
    protected abstract initCell(): void;
    /**
     * Update cell's selected state
     */
    abstract update(): void;
    protected abstract getTextStyle(): TextTheme;
    protected abstract getFormattedFieldValue(): FormatResult;
    protected abstract getMaxTextWidth(): number;
    protected abstract getTextPosition(): Point;
    protected abstract findFieldCondition(conditions: Condition[]): Condition;
    protected abstract mappingValue(condition: Condition): MappingResult;
    protected shouldInit(): boolean;
    getStyle<K extends keyof S2Theme = keyof CellThemes>(name?: K): DefaultCellTheme | S2Theme[K];
    protected getResizeAreaStyle(): ResizeArea;
    protected shouldDrawResizeAreaByType(type: keyof ResizeInteractionOptions, cell: S2CellType): boolean | ((cell: S2CellType<ViewMeta>) => boolean) | ResizeType | ((resizeInfo: ResizeInfo) => boolean);
    getCellArea(): {
        x: number;
        y: number;
        height: number;
        width: number;
    };
    getContentArea(): {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    protected getIconPosition(iconCount?: number): {
        x: number;
        y: number;
    };
    protected drawTextShape(): void;
    protected drawLinkFieldShape(showLinkFieldShape: boolean, linkFillColor: string): void;
    protected getLinkFieldStyle(): string;
    protected drawLinkField(meta: Node_2 | ViewMeta): void;
    updateByState(stateName: InteractionStateName, cell: S2CellType): void;
    protected getInteractiveBorderShapeStyle<T>(style: T & number): {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    hideInteractionShape(): void;
    clearUnselectedState(): void;
    getTextShape(): IShape;
    getTextShapes(): IShape[];
    addTextShape(textShape: IShape): void;
    getConditionIconShape(): GuiIcon;
    getConditionIconShapes(): GuiIcon[];
    addConditionIconShape(iconShape: GuiIcon): void;
    resetTextAndConditionIconShapes(): void;
    get cellConditions(): Conditions;
    drawConditionIconShapes(): void;
    getTextConditionFill(textStyle: TextTheme): string;
    protected getCrossBackgroundColor(rowIndex: number): {
        backgroundColorOpacity: number;
        backgroundColor: string;
    };
}

export declare interface BaseChartData {
    type: MiniChartTypes;
    data: Data[];
    encode?: {
        x: keyof Data;
        y: keyof Data;
    };
}

export declare abstract class BaseDataSet {
    fields: Fields;
    meta: Meta[];
    originData: DataType[];
    totalData: DataType[];
    indexesData: Record<string, DataType[][] | DataType[]>;
    sortParams: SortParams;
    filterParams: FilterParam[];
    spreadsheet: SpreadSheet;
    displayFormattedValueMap: Map<string, string>;
    constructor(spreadsheet: SpreadSheet);
    protected displayData: DataType[];
    /**
     * 查找字段信息
     */
    getFieldMeta: ((field: string, meta?: Meta[]) => Meta) & MemoizedFunction;
    /**
     * 获得字段名称
     * @param field
     */
    getFieldName(field: string): string;
    /**
     * 获得字段格式方法
     * @param field
     */
    getFieldFormatter(field: string): Formatter;
    /**
     * 获得字段描述
     * @param field
     */
    getFieldDescription(field: string): string;
    setDataCfg(dataCfg: S2DataConfig): void;
    processMeta(meta: Meta[], defaultExtraFieldText: string): Meta[];
    getDisplayDataSet(): DataType[];
    isEmpty(): boolean;
    getEmptyViewIndexes(): Indexes;
    getValueRangeByField(field: string): ValueRange;
    /** ******************NEED IMPLEMENT BY USER CASE************************ */
    /**
     * Try to process dataConfig in different mode
     * @param dataCfg
     */
    abstract processDataCfg(dataCfg: S2DataConfig): S2DataConfig;
    /**
     * 1、query !== null
     * province  city => field
     *   辽宁省
     *          达州市
     *          芜湖市
     *  field = province
     *  query = {province: '辽宁省'}
     *  => [达州市,芜湖市]
     *
     *  2、query = null
     *  query param is not necessary, when just
     *  get some field's all dimension values
     *
     * @param field current dimensions
     * @param query dimension value query
     */
    abstract getDimensionValues(field: string, query?: Query): string[];
    /**
     * In most cases, this function to get the specific
     * cross data cell data
     * @param params
     */
    abstract getCellData(params: CellDataParams): DataType;
    /**
     * 获取符合 query 的所有单元格数据，如果 query 为空，返回空数组
     * @param query
     * @param params 默认获取符合 query 的所有数据，包括小计总计等汇总数据；
     *               如果只希望获取明细数据，请使用 { queryType: QueryDataType.DetailOnly }
     */
    abstract getMultiData(query: Query, params?: MultiDataParams): Data[];
    moreThanOneValue(): boolean;
    /**
     * get a row cells data including cell
     */
    abstract getRowData(cellMeta: CellMeta | ViewMeta | Node): RowData;
}

export declare abstract class BaseEvent {
    spreadsheet: SpreadSheet;
    constructor(spreadsheet: SpreadSheet);
    getCellAppendInfo<T extends Record<string, any> = CellAppendInfo>(eventTarget: GEvent['target']): T;
    isLinkFieldText: (eventTarget: GEvent['target']) => boolean;
    reset(): void;
    abstract bindEvents(): void;
}

export declare interface BaseEventImplement {
    bindEvents: () => void;
}

declare abstract class BaseFacet {
    spreadsheet: SpreadSheet;
    cornerBBox: CornerBBox;
    panelBBox: PanelBBox;
    backgroundGroup: IGroup;
    panelGroup: IGroup;
    foregroundGroup: IGroup;
    cfg: SpreadSheetFacetCfg;
    layoutResult: LayoutResult;
    viewCellWidths: number[];
    viewCellHeights: ViewCellHeights;
    protected mobileWheel: Wheel;
    protected timer: Timer;
    hScrollBar: ScrollBar;
    hRowScrollBar: ScrollBar;
    vScrollBar: ScrollBar;
    rowHeader: RowHeader;
    columnHeader: ColHeader;
    cornerHeader: CornerHeader;
    rowIndexHeader: SeriesNumberHeader;
    centerFrame: Frame;
    gridInfo: GridInfo;
    protected abstract doLayout(): LayoutResult;
    abstract getContentHeight(): number;
    abstract getViewCellHeights(layoutResult?: LayoutResult): ViewCellHeights;
    protected scrollDirection: ScrollDirection;
    protected scrollFrameId: ReturnType<typeof requestAnimationFrame>;
    get scrollBarTheme(): ScrollBarTheme;
    get scrollBarSize(): number;
    protected preCellIndexes: PanelIndexes;
    constructor(cfg: SpreadSheetFacetCfg);
    protected getCellCustomWidth(node: Node_2, width: CellCustomWidth): number;
    protected getCellDraggedWidth(node: Node_2): number;
    hideScrollBar: () => void;
    delayHideScrollBar: DebouncedFunc<() => void>;
    delayHideScrollbarOnMobile: () => void;
    showVerticalScrollBar: () => void;
    showHorizontalScrollBar: () => void;
    onContainerWheelForMobileCompatibility: () => void;
    onContainerWheel: () => void;
    getMobileWheelDeltaY: (deltaY: number) => number;
    onContainerWheelForPc: () => void;
    onContainerWheelForMobile: () => void;
    bindEvents: () => void;
    /**
     * Start render, call from outside
     */
    render(): void;
    /**
     * 在每次render, 校验scroll offset是否在合法范围中
     * 比如在滚动条已经滚动到100%的状态的前提下：（ maxAvailableScrollOffsetX = colsHierarchy.width - viewportBBox.width ）
     *     此时changeSheetSize，sheet从 small width 变为 big width
     *     导致后者 viewport 区域更大，其结果就是后者的 maxAvailableScrollOffsetX 更小
     *     此时就需要重置 scrollOffsetX，否则就会导致滚动过多，出现空白区域
     */
    protected adjustScrollOffset(): void;
    getSeriesNumberWidth(): number;
    getCanvasHW(): {
        width: number;
        height: number;
    };
    updateScrollOffset(offsetConfig: OffsetConfig): void;
    getPaginationScrollY(): number;
    destroy(): void;
    setScrollOffset: (scrollOffset: ScrollOffset) => void;
    getScrollOffset: () => ScrollOffset;
    emitPaginationEvent: () => void;
    private unbindEvents;
    clipPanelGroup: () => void;
    calculateCellWidthHeight: () => void;
    /**
     * The purpose of this rewrite is to take into account that when rowHeader supports scrollbars
     the panel viewable area must vary with the horizontal distance of the scroll
     * @param scrollX
     * @param scrollY
     * @public
     */
    calculateXYIndexes(scrollX: number, scrollY: number): PanelIndexes;
    getRealScrollX: (scrollX: number, hRowScroll?: number) => number;
    protected calculateCornerBBox(): void;
    protected calculatePanelBBox: () => void;
    getRealWidth: () => number;
    getCellRange(): {
        start: number;
        end: number;
    };
    getRealHeight: () => number;
    clearAllGroup: () => void;
    scrollWithAnimation: (offsetConfig?: OffsetConfig, duration?: number, cb?: () => void) => void;
    scrollImmediately: (offsetConfig?: OffsetConfig) => void;
    /**
     *
     * @param skipScrollEvent 不触发 S2Event.GLOBAL_SCROLL
     */
    startScroll: (skipScrollEvent?: boolean) => void;
    getRendererHeight: () => number;
    private getAdjustedScrollOffset;
    renderRowScrollBar: (rowHeaderScrollX: number) => void;
    getValidScrollBarOffset: (offset: number, maxOffset: number) => number;
    renderHScrollBar: (width: number, realWidth: number, scrollX: number) => void;
    private getScrollbarPosition;
    renderVScrollBar: (height: number, realHeight: number, scrollY: number) => void;
    getScrollBarOffset: (offset: number, scrollbar: ScrollBar) => number;
    isScrollOverThePanelArea: ({ offsetX, offsetY }: CellScrollOffset) => boolean;
    isScrollOverTheCornerArea: ({ offsetX, offsetY }: CellScrollOffset) => boolean;
    updateHorizontalRowScrollOffset: ({ offset, offsetX, offsetY, }: CellScrollOffset) => void;
    updateHorizontalScrollOffset: ({ offset, offsetX, offsetY, }: CellScrollOffset) => void;
    isScrollToLeft: ({ deltaX, offsetX, offsetY }: CellScrollOffset) => boolean;
    isScrollToRight: ({ deltaX, offsetX, offsetY }: CellScrollOffset) => boolean;
    isScrollToTop: (deltaY: number) => boolean;
    isScrollToBottom: (deltaY: number) => boolean;
    isVerticalScrollOverTheViewport: (deltaY: number) => boolean;
    isHorizontalScrollOverTheViewport: (scrollOffset: CellScrollOffset) => boolean;
    /**
     在当前表格滚动分两种情况:
     1. 当前表格无滚动条: 无需阻止外部容器滚动
     2. 当前表格有滚动条:
     - 未滚动到顶部或底部: 当前表格滚动, 阻止外部容器滚动
     - 滚动到顶部或底部: 恢复外部容器滚动
     */
    isScrollOverTheViewport: (scrollOffset: CellScrollOffset) => boolean;
    cancelScrollFrame: () => boolean;
    clearScrollFrameIdOnMobile: () => void;
    /**
     https://developer.mozilla.org/zh-CN/docs/Web/CSS/overscroll-behavior
     阻止外部容器滚动: 表格是虚拟滚动, 这里按照标准模拟浏览器的 [overscroll-behavior] 实现
     1. auto => 只有在滚动到表格顶部或底部时才触发外部容器滚动
     1. contain => 默认的滚动边界行为不变（“触底”效果或者刷新），但是临近的滚动区域不会被滚动链影响到
     2. none => 临近滚动区域不受到滚动链影响，而且默认的滚动到边界的表现也被阻止
     所以只要不为 `auto`, 或者表格内, 都需要阻止外部容器滚动
     */
    private stopScrollChainingIfNeeded;
    private stopScrollChaining;
    onWheel: (event: WheelEvent) => void;
    protected panelScrollGroupClip(scrollX: number, scrollY: number): void;
    protected clip(scrollX: number, scrollY: number): void;
    /**
     * Translate panelGroup, rowHeader, cornerHeader, columnHeader ect
     * according to new scroll offset
     * @param scrollX
     * @param scrollY
     * @param hRowScroll
     * @protected
     */
    protected translateRelatedGroups(scrollX: number, scrollY: number, hRowScroll: number): void;
    addCell: (cell: S2CellType<ViewMeta>) => void;
    realCellRender: (scrollX: number, scrollY: number) => void;
    protected init(): void;
    protected renderBackground(): void;
    /**
     * Render all scrollbars, default horizontal scrollbar only control viewport
     * area(it means not contains row header)
     * 1. individual row scrollbar
     * 2. horizontal scroll bar(can control whether contains row header)
     * 3. vertical scroll bar
     */
    protected renderScrollBars(): void;
    /**
     * Render all headers in {@link #foregroundGroup}, contains:
     * 1. row header
     * 2. col header
     * 3. center frame
     * 4. corner header
     * 5. series number header
     */
    protected renderHeaders(): void;
    protected getRowHeaderCfg(): RowHeaderConfig;
    protected getRowHeader(): RowHeader;
    protected getColHeader(): ColHeader;
    protected getCornerHeader(): CornerHeader;
    protected getSeriesNumberHeader(): SeriesNumberHeader;
    protected getCenterFrame(): Frame;
    protected getGridInfo: () => {
        cols: number[];
        rows: any[];
    };
    updatePanelScrollGroup(): void;
    /**
     *
     * @param skipScrollEvent: 如true则不触发GLOBAL_SCROLL事件
     * During scroll behavior, first call to this method fires immediately and then on interval.
     * @protected
     */
    protected dynamicRenderCell(skipScrollEvent?: boolean): void;
    private emitScrollEvent;
    protected onAfterScroll: DebouncedFunc<() => void>;
    protected saveInitColumnLeafNodes(columnNodes?: Node_2[]): void;
    getHiddenColumnsInfo(columnNode: Node_2): HiddenColumnsInfo | null;
    getCornerNodes(): Node_2[];
}

declare class BaseFrozenRowHeader extends RowHeader {
    scrollGroup: IGroup;
    frozenHeadGroup: IGroup;
    constructor(cfg: RowHeaderConfig);
    protected rowCellInRectXDir(item: Node_2): boolean;
    protected rowCellInRectYDir(item: Node_2): boolean;
    protected rowCellInRect(item: Node_2): boolean;
    protected getCellGroup(item: Node_2): IGroup;
    protected offset(): void;
    clip(): void;
    isFrozenRow(node: Node_2): boolean;
    getFrozenFirstRowHeight(): number;
    clear(): void;
}

/**
 * New Base Header for all headers(cornerHeader, rowHeader, colHeader)
 * NOTE: Do not use this.cfg(which lays in group) to get header config,
 * use {@see headerConfig} instead
 */
declare abstract class BaseHeader<T extends BaseHeaderConfig> extends Group {
    protected headerConfig: T;
    protected constructor(cfg: T);
    getConfig(): T;
    /**
     * 清空热区，为重绘做准备，防止热区重复渲染
     * @param type 当前重绘的header类型
     */
    protected clearResizeAreaGroup(type: string): void;
    render(type: string): void;
    /**
     * Scroll header group's x,y
     * @param scrollX hScrollBar horizontal offset
     * @param scrollY hScrollBar vertical offset
     * @param type
     */
    onScrollXY(scrollX: number, scrollY: number, type: string): void;
    /**
     * Only call when hRowScrollBar scrolls
     * @param rowHeaderScrollX  hRowScrollbar horizontal offset
     * @param type
     */
    onRowScrollX(rowHeaderScrollX: number, type: string): void;
    protected abstract layout(): any;
    protected abstract offset(): any;
    protected abstract clip(): any;
    clear(): void;
    /**
     * Check whether header cell in viewPort
     * @param gridPos
     * @param gridSize
     * @param viewportPos
     * @param viewportSize
     */
    protected isHeaderCellInViewport: (gridPos: any, gridSize: any, viewportPos: any, viewportSize: any) => boolean;
}

/**
 * Base header config interface
 */
declare interface BaseHeaderConfig {
    scrollX?: number;
    scrollY?: number;
    width: number;
    height: number;
    originalWidth?: number;
    originalHeight?: number;
    viewportWidth: number;
    viewportHeight: number;
    position: Point;
    data: Node_2[];
    spreadsheet: SpreadSheet;
    sortParam?: SortParam;
}

declare interface BaseNodeConfig {
    id: string;
    key: string;
    value: string;
    label?: string;
    level?: number;
    rowIndex?: number;
    colIndex?: number;
    parent?: Node_2;
    isTotals?: boolean;
    isSubTotals?: boolean;
    isCollapsed?: boolean;
    isGrandTotals?: boolean;
    isTotalRoot?: boolean;
    hierarchy?: Hierarchy;
    isPivotMode?: boolean;
    seriesNumberWidth?: number;
    field?: string;
    spreadsheet?: SpreadSheet;
    query?: Record<string, any>;
    belongsCell?: S2CellType;
    isTotalMeasure?: boolean;
    inCollapseNode?: boolean;
    isLeaf?: boolean;
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    padding?: number;
    children?: Node_2[];
    hiddenColumnsInfo?: HiddenColumnsInfo | null;
    extra?: Record<string, any>;
}

export declare class BaseRowCell extends HeaderCell {
    protected headerConfig: RowHeaderConfig;
    protected gm: GM;
    get cellType(): CellTypes;
    destroy(): void;
    protected initCell(): void;
    getBackgroundColor(): {
        backgroundColor: string;
        backgroundColorOpacity: number;
    };
    /**
     * 绘制hover悬停，刷选的外框
     */
    protected drawInteractiveBorderShape(): void;
    protected drawInteractiveBgShape(): void;
    protected showTreeIcon(): boolean;
    protected showTreeLeafNodeAlignDot(): boolean;
    protected getParentTreeIconCfg(): any;
    protected drawTreeIcon(): void;
    protected drawTreeLeafNodeAlignDot(): void;
    protected isBolderText(): boolean;
    protected drawTextShape(): void;
    protected drawRectBorder(): void;
    protected getResizeClipAreaBBox(): SimpleBBox;
    protected drawResizeAreaInLeaf(): void;
    protected getContentIndent(): number;
    protected getTextIndent(): number;
    protected isTreeLevel(): any;
    protected getIconPosition(): {
        x: any;
        y: any;
    };
    protected getMaxTextWidth(): number;
    protected getTextArea(): SimpleBBox;
    protected getAdjustTextAreaHeight(textArea: SimpleBBox, scrollY: number, viewportHeight: number): number;
    protected calculateTextY({ textArea, adjustTextAreaHeight, }: {
        textArea: SimpleBBox;
        adjustTextAreaHeight: number;
    }): number;
    protected getTextPosition(): Point;
    protected getIconYPosition(): number;
}

/**
 * Base tooltips component
 */
export declare class BaseTooltip {
    visible: boolean;
    spreadsheet: SpreadSheet;
    container: HTMLElement;
    options: TooltipShowOptions;
    position: TooltipPosition;
    constructor(spreadsheet: SpreadSheet);
    show<T = Element | string>(showOptions: TooltipShowOptions<T>): void;
    hide(): void;
    destroy(): void;
    renderContent<T = TooltipContentType>(content: T): void;
    clearContent(): void;
    disablePointerEvent(): void;
    private resetPosition;
    private getContainer;
}

export declare interface BaseTooltipConfig<T = TooltipContentType, Icon = Element | string, Text = string> {
    showTooltip?: boolean;
    content?: TooltipShowOptions<T>['content'];
    operation?: TooltipOperation<Icon, Text>;
    autoAdjustBoundary?: TooltipAutoAdjustBoundary;
    renderTooltip?: (spreadsheet: SpreadSheet) => BaseTooltip;
    adjustPosition?: (positionInfo: TooltipPositionInfo) => TooltipPosition;
    getContainer?: () => HTMLElement;
    className?: string | string[];
    style?: CSS_2.Properties;
}

export declare const BRUSH_AUTO_SCROLL_INITIAL_CONFIG: {
    x: {
        value: number;
        scroll: boolean;
    };
    y: {
        value: number;
        scroll: boolean;
    };
};

export declare interface BrushAutoScrollConfig {
    x: BrushAutoScrollConfigItem;
    y: BrushAutoScrollConfigItem;
}

export declare interface BrushAutoScrollConfigItem {
    value: number;
    scroll: boolean;
}

export declare interface BrushPoint {
    rowIndex: number;
    colIndex: number;
    x: number;
    y: number;
    scrollX?: number;
    scrollY?: number;
    /** 用于标记 row cell 和 col cell 点的 x, y 坐标 */
    headerX?: number;
    headerY?: number;
}

export declare interface BrushRange {
    start: BrushPoint;
    end: BrushPoint;
    width: number;
    height: number;
}

export declare interface BrushSelection {
    data?: boolean;
    row?: boolean;
    col?: boolean;
}

export declare interface BrushSelectionInfo {
    dataBrushSelection: boolean;
    rowBrushSelection: boolean;
    colBrushSelection: boolean;
}

export declare const buildTableHierarchy: (params: TableHeaderParams) => void;

export declare interface BulletTheme {
    progressBar: {
        widthPercent: number;
        height: number;
        innerHeight: number;
    };
    comparativeMeasure: {
        width: number;
        height: number;
        fill?: string;
        color?: string;
        opacity?: number;
    };
    rangeColors: RangeColors;
    backgroundColor: string;
}

export declare interface BulletValue {
    type: MiniChartTypes.Bullet;
    measure: number | string;
    target: number | string;
    [key: string]: unknown;
}

export declare interface CalcTotals {
    aggregation?: Aggregation;
    calcFunc?: (query: Query, arr: DataType[]) => number;
}

declare type CanvasEventHandler = (event: GEvent) => void;

export declare interface CellAppendInfo<T = Node_2> extends Partial<ResizeInfo> {
    isLinkFieldText?: boolean;
    cellData?: T;
}

export declare interface CellAttrs<T extends Record<string, unknown> = Node_2> extends ShapeAttrs {
    text?: string;
    appendInfo?: CellAppendInfo<T>;
}

export declare enum CellBorderPosition {
    TOP = "TOP",
    BOTTOM = "BOTTOM",
    LEFT = "LEFT",
    RIGHT = "RIGHT"
}

export declare type CellCallback<T extends BaseHeaderConfig> = (node: Node_2, spreadsheet: SpreadSheet, headerConfig: T) => S2CellType;

export declare interface CellCfg {
    width?: number;
    height?: number;
    valuesCfg?: {
        originalValueField?: string;
        widthPercent?: number[];
        showOriginalValue?: boolean;
    };
}

export declare type CellCustomWidth = number | ((node: Node_2) => number);

export declare interface CellDataParams {
    query: Query;
    isTotals?: boolean;
    rowNode?: Node_2;
    isRow?: boolean;
    totalStatus?: TotalStatus;
}

export declare interface CellMeta {
    id: string;
    colIndex: number;
    rowIndex: number;
    type: CellTypes;
    rowQuery?: Record<string, any>;
    [key: string]: unknown;
}

export declare interface CellScrollOffset {
    deltaX?: number;
    deltaY?: number;
    offset?: number;
    offsetX: number;
    offsetY: number;
}

export declare type CellScrollPosition = Required<ScrollOffset>;

export declare interface CellTheme {
    crossBackgroundColor?: string;
    backgroundColor?: string;
    backgroundColorOpacity?: number;
    horizontalBorderColor?: string;
    horizontalBorderColorOpacity?: number;
    verticalBorderColor?: string;
    verticalBorderColorOpacity?: number;
    horizontalBorderWidth?: number;
    verticalBorderWidth?: number;
    padding?: Padding;
    interactionState?: InteractionState;
    miniBarChartHeight?: number;
    miniBarChartFillColor?: string;
    /** 单元格边线虚线 */
    borderDash?: number[];
}

export declare type CellThemes = {
    [K in CellTypes]?: DefaultCellTheme;
};

export declare enum CellTypes {
    DATA_CELL = "dataCell",
    HEADER_CELL = "headerCell",
    ROW_CELL = "rowCell",
    COL_CELL = "colCell",
    CORNER_CELL = "cornerCell",
    MERGED_CELL = "mergedCell"
}

export declare interface CheckAccordQueryParams {
    dimensionValues: string;
    query: Query;
    dimensions: string[];
    field: string;
}

export declare const checkIsLinkField: (linkFields: string[] | ((meta: Node_2 | ViewMeta) => boolean), meta: Node_2 | ViewMeta) => boolean;

/**
 * @desc clear the interaction state information
 * @param spreadsheet sheet instance
 */
export declare const clearState: (spreadsheet: SpreadSheet) => boolean;

export declare class ColBrushSelection extends BaseBrushSelection {
    displayedCells: ColCell[];
    brushRangeCells: ColCell[];
    bindEvents(): void;
    protected bindMouseDown(): void;
    protected isPointInCanvas(point: {
        x: number;
        y: number;
    }): boolean;
    protected bindMouseMove(): void;
    protected setDisplayedCells(): void;
    /**
     * 用户判断 colCell 是否在当前刷选的范围内
     * @param meta colCell 位置等属性存储的对象
     * @returns boolean
     */
    protected isInBrushRange(meta: ViewMeta | Node_2): boolean;
    protected updateSelectedCells(): void;
    protected addBrushIntercepts(): void;
    protected onUpdateCells: OnUpdateCells;
}

export declare class ColCell extends HeaderCell {
    protected headerConfig: ColHeaderConfig;
    /** 文字绘制起始坐标 */
    protected textPosition: Point;
    get cellType(): CellTypes;
    protected initCell(): void;
    protected drawInteractiveBgShape(): void;
    /**
     * 绘制hover悬停，刷选的外框
     */
    protected drawInteractiveBorderShape(): void;
    protected getMaxTextWidth(): number;
    protected getIconPosition(): Point;
    protected isBolderText(): boolean;
    protected getTextPosition(): Point;
    protected getActionIconsWidth(): number;
    protected getColResizeAreaKey(): string;
    protected getColResizeArea(): IGroup;
    protected getHorizontalResizeAreaName(): string;
    protected drawHorizontalResizeArea(): void;
    protected shouldAddVerticalResizeArea(): boolean;
    protected getVerticalResizeAreaOffset(): {
        x: number;
        y: number;
    };
    protected drawVerticalResizeArea(): void;
    protected drawResizeArea(): void;
    protected drawHorizontalBorder(): void;
    protected drawVerticalBorder(dir: CellBorderPosition): void;
    protected drawBorders(): void;
    protected hasHiddenColumnCell(): boolean;
    protected getExpandIconTheme(): IconTheme;
    protected addExpandColumnSplitLine(): void;
    protected addExpandColumnIconShapes(): void;
    protected addExpandColumnIcons(): void;
    private addExpandColumnIcon;
    protected getExpandColumnIconConfig(isLastColumn: boolean): {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    protected isLastColumn(): boolean;
    protected isAllDisplaySiblingNodeHidden(): HiddenColumnsInfo;
}

export declare interface ColCfg {
    width?: CellCustomWidth;
    height?: number;
    widthByFieldValue?: Record<string, number>;
    heightByField?: Record<string, number>;
    hideMeasureColumn?: boolean;
}

/**
 * Column Header for SpreadSheet
 */
export declare class ColHeader extends BaseHeader<ColHeaderConfig> {
    protected scrollGroup: IGroup;
    protected background: IShape;
    constructor(cfg: ColHeaderConfig);
    /**
     * Make colHeader scroll with hScrollBar
     * @param scrollX horizontal offset
     * @param cornerWidth only has real meaning when scroll contains rowCell
     * @param type
     */
    onColScroll(scrollX: number, type: string): void;
    protected clip(): void;
    clear(): void;
    protected getCellInstance(item: Node_2, spreadsheet: SpreadSheet, headerConfig: ColHeaderConfig): ColCell;
    protected getCellGroup(node: Node_2): IGroup;
    protected isColCellInRect(node: Node_2): boolean;
    protected layout(): void;
    protected offset(): void;
}

export declare interface ColHeaderConfig extends BaseHeaderConfig {
    cornerWidth?: number;
    scrollContainsRowHeader?: boolean;
}

export declare type CollapsedRowsType = {
    collapsedRows: Record<string, boolean> & {
        [x: number]: any;
    };
    meta?: Node_2;
};

export declare interface ColumnNode {
    key: string;
    children?: Columns;
}

export declare type Columns = Array<ColumnNode | string>;

/**
 * One field can hold a condition
 */
export declare interface Condition {
    field?: string | RegExp;
    mapping: MappingFunction;
}

export declare interface Conditions {
    text?: Condition[];
    background?: Condition[];
    interval?: Condition[];
    icon?: IconCondition[];
}

export declare const convertString: (v: string) => string;

export declare type Copyable = CopyableItem | CopyableItem[];

export declare type CopyableItem = {
    type: CopyMIMEType;
    content: string;
};

/**
 * Copy data
 * @param sheetInstance
 * @param formatOptions 是否格式化数据
 * @param split
 */
export declare const copyData: (sheetInstance: SpreadSheet, split: string, formatOptions?: FormatOptions) => string;

export declare enum CopyMIMEType {
    PLAIN = "text/plain",
    HTML = "text/html"
}

export declare const copyToClipboard: (data: Copyable | string, sync?: boolean) => Promise<void>;

export declare const copyToClipboardByClipboard: (data: Copyable) => Promise<void>;

export declare const copyToClipboardByExecCommand: (data: Copyable) => Promise<void>;

export declare enum CopyType {
    ALL = 0,
    COL = 1,
    ROW = 2
}

export declare const CORNER_MAX_WIDTH_RATIO = 0.5;

declare class CornerBBox extends BaseBBox {
    calculateBBox(): void;
    private getCornerBBoxOriginalHeight;
    private getCornerBBoxHeight;
    private getCornerBBoxWidth;
    private adjustCornerBBoxWidth;
}

export declare class CornerCell extends HeaderCell {
    protected headerConfig: CornerHeaderConfig;
    protected isBolderText(): boolean;
    cornerType: CornerNodeType;
    get cellType(): CellTypes;
    protected initCell(): void;
    /**
     * @deprecated 已废弃, 请使用 drawTextShape
     */
    protected drawCellText(): void;
    protected drawTextShape(): void;
    /**
     * 绘制折叠展开的icon
     */
    protected drawTreeIcon(): void;
    /**
     * Render cell horizontalBorder border
     * @protected
     */
    protected drawBorderShape(): void;
    protected isLastRowCornerCell(): boolean;
    protected getResizeAreaEffect(): ResizeAreaEffect.Field | ResizeAreaEffect.Tree | ResizeAreaEffect.Series;
    protected drawResizeArea(): void;
    protected showTreeIcon(): boolean;
    protected getIconPosition(): Point;
    protected getTreeIconWidth(): number;
    protected getTextStyle(): TextTheme;
    protected getMaxTextWidth(): number;
    protected getTextPosition(): Point;
    protected getFormattedFieldValue(): FormatResult;
    protected getCornerText(): string;
}

export declare class CornerCellClick extends BaseEvent implements BaseEventImplement {
    bindEvents(): void;
    private bindCornerCellClick;
    private getRowNodesByField;
    private getRowCells;
    private showTooltip;
}

/**
 * Corner Header for SpreadSheet
 */
export declare class CornerHeader extends BaseHeader<CornerHeaderConfig> {
    /**
     * Get corner Header by config
     * @param panelBBox
     * @param cornerBBox
     * @param seriesNumberWidth
     * @param cfg
     * @param layoutResult
     * @param s2 spreadsheet
     */
    static getCornerHeader(panelBBox: PanelBBox, cornerBBox: CornerBBox, seriesNumberWidth: number, cfg: SpreadSheetFacetCfg, layoutResult: LayoutResult, s2: SpreadSheet): CornerHeader;
    static getCornerNodes(position: Point, width: number, height: number, rows: string[], columns: string[], rowsHierarchy: Hierarchy, colsHierarchy: Hierarchy, dataSet: BaseDataSet, seriesNumberWidth: number, s2: SpreadSheet): Node_2[];
    static getTreeCornerText(s2: SpreadSheet): string;
    constructor(cfg: CornerHeaderConfig);
    /**
     *  Make cornerHeader scroll with hScrollBar
     * @param scrollX
     */
    onCorScroll(scrollX: number, type: string): void;
    destroy(): void;
    protected layout(): void;
    protected renderCells(): void;
    protected offset(): void;
    protected clip(): void;
    getNodes(): Node_2[];
}

export declare type CornerHeaderCallback = (parent: S2CellType, spreadsheet: SpreadSheet, ...restOptions: unknown[]) => void;

export declare interface CornerHeaderConfig extends BaseHeaderConfig {
    hierarchyType: S2Options['hierarchyType'];
    hierarchyCollapse: boolean;
    rows: string[];
    columns: string[];
    seriesNumberWidth: number;
}

export declare enum CornerNodeType {
    Row = "row",
    Col = "col",
    Series = "series"
}

/**
 * the label names of rows or columns.
 * Using the ID_SEPARATOR('[&]') to join two labels
 * when there are hierarchical relations between them.
 */
export declare interface CustomHeaderCells {
    cellLabels: string[];
    mode?: 'pick' | 'omit';
}

export declare interface CustomInteraction {
    key: string;
    interaction: InteractionConstructor;
}

export declare const customMerge: (...objects: unknown[]) => any;

export declare interface CustomSVGIcon {
    name: string;
    svg: string;
}

export declare interface CustomTreeItem {
    key: string;
    title: string;
    collapsed?: boolean;
    description?: string;
    children?: CustomTreeItem[];
}

export declare class CustomTreePivotDataSet extends PivotDataSet {
    getCellData(params: CellDataParams): DataType;
    processDataCfg(dataCfg: S2DataConfig): S2DataConfig;
}

export declare type Data = Record<string, DataItem>;

/**
 * DataCell for panelGroup area
 * ----------------------------
 * |                  |       |
 * |interval      text| icon  |
 * |                  |       |
 * ----------------------------
 * There are four conditions({@see BaseCell.conditions}) to determine how to render
 * 1、background color
 * 2、icon align in right with size {@link ICON_SIZE}
 * 3、left rect area is interval(in left) and text(in right)
 */
export declare class DataCell extends BaseCell<ViewMeta> {
    get cellType(): CellTypes;
    get valueRangeByField(): ValueRange;
    protected handleByStateName(cells: CellMeta[], stateName: InteractionStateName): void;
    protected handleSearchResult(cells: CellMeta[]): void;
    protected handleSelect(cells: CellMeta[]): void;
    protected handleHover(cells: CellMeta[]): void;
    update(): void;
    setMeta(viewMeta: Partial<ViewMeta>): void;
    protected drawTextShape(): void;
    protected initCell(): void;
    /**
     * 获取默认字体颜色：根据字段标记背景颜色，设置字体颜色
     * @param textStyle
     * @private
     */
    private getDefaultTextFill;
    protected getTextStyle(): TextTheme;
    getIconStyle(): IconCfg | undefined;
    protected drawConditionIntervalShape(): void;
    protected shouldHideRowSubtotalData(): boolean;
    protected getFormattedFieldValue(): FormatResult;
    protected getMaxTextWidth(): number;
    protected getTextPosition(): Point;
    getBackgroundColor(): {
        backgroundColor: string;
        backgroundColorOpacity: number;
        intelligentReverseTextColor?: undefined;
    } | {
        backgroundColor: string;
        backgroundColorOpacity: number;
        intelligentReverseTextColor: boolean;
    };
    /**
     * Draw cell background
     */
    protected drawBackgroundShape(): void;
    /**
     * 绘制hover悬停，刷选的外框
     */
    protected drawInteractiveBorderShape(): void;
    /**
     * Draw interactive color
     */
    protected drawInteractiveBgShape(): void;
    protected changeRowColSelectState(indexType: ViewMetaIndexType): void;
    /**
     * Render cell border controlled by verticalBorder & horizontalBorder
     * @protected
     */
    protected drawBorderShape(): void;
    /**
     * Find current field related condition
     * @param conditions
     */
    findFieldCondition(conditions: Condition[]): Condition;
    /**
     * Mapping value to get condition related attrs
     * @param condition
     */
    mappingValue(condition: Condition): MappingResult;
    updateByState(stateName: InteractionStateName): void;
    clearUnselectedState(): void;
    private toggleConditionIntervalShapeOpacity;
    protected drawLeftBorder(): void;
}

export declare class DataCellBrushSelection extends BaseBrushSelection {
    displayedCells: DataCell[];
    brushRangeCells: DataCell[];
    protected bindMouseDown(): void;
    protected bindMouseMove(): void;
    protected isInBrushRange(meta: ViewMeta): boolean;
    getSelectedCellMetas: (brushRange: BrushRange) => CellMeta[];
    protected updateSelectedCells(): void;
    /**
     * @name 获取刷选 (含滚动后不再可视范围内) 的单元格
     * @description DataCell 存在滚动刷选, 由于按需加载的特性, 非可视范围内的单元格已被注销
     * 如果在可视范围, 直接返回 DataCell, 非可视范围, 由于实例已被销毁, 构造实例后返回
     */
    private getScrollBrushRangeCells;
    protected bindMouseUp(): void;
    protected getPrepareSelectMaskPosition(brushRange: BrushRange): Point;
}

export declare type DataCellCallback = (viewMeta: ViewMeta) => S2CellType;

export declare class DataCellClick extends BaseEvent implements BaseEventImplement {
    bindEvents(): void;
    private bindDataCellClick;
    private getTooltipOperator;
    private showTooltip;
    private emitLinkFieldClickEvent;
}

export declare class DataCellMultiSelection extends BaseEvent implements BaseEventImplement {
    private isMultiSelection;
    bindEvents(): void;
    reset(): void;
    private bindKeyboardDown;
    private bindKeyboardUp;
    private bindMouseMove;
    private getSelectedCells;
    private bindDataCellClick;
}

export declare type DataItem = SimpleDataItem | MultiData;

export declare type DataPathParams = {
    rowDimensionValues: string[];
    colDimensionValues: string[];
    rowPivotMeta: PivotMeta;
    colPivotMeta: PivotMeta;
    rowFields: string[];
    colFields: string[];
    isFirstCreate?: boolean;
    onFirstCreate?: (params: {
        careRepeated?: boolean;
        dimension: string;
        dimensionPath: string;
    }) => void;
    prefix?: string;
};

export declare type DataType = Record<string, any>;

export declare const DEBUG_HEADER_LAYOUT = "Header Layout";

export declare const DEBUG_TRANSFORM_DATA = "Transform Data";

export declare const DEBUG_VIEW_RENDER = "Data Cell Render";

export declare class DebuggerUtil {
    private static instance;
    private debug;
    static getInstance(): DebuggerUtil;
    setDebug(debug: boolean): void;
    debugCallback: (info: string, callback: () => void) => void;
    logger: (info: string, ...params: unknown[]) => void;
}

export declare const DEFAULT_DATA_CONFIG: Readonly<S2DataConfig>;

export declare const DEFAULT_FONT_COLOR = "#000000";

export declare const DEFAULT_OPTIONS: Readonly<S2Options>;

export declare const DEFAULT_PAGE_INDEX = 1;

export declare const DEFAULT_STYLE: Readonly<Style>;

export declare const DEFAULT_TREE_ROW_WIDTH = 120;

export declare const DEFAULT_VALUE_RANGES: {};

export declare interface DefaultCellTheme extends GridAnalysisCellTheme {
    bolderText?: TextTheme;
    text?: TextTheme;
    seriesText?: TextTheme;
    measureText?: TextTheme;
    cell?: CellTheme;
    icon?: IconTheme;
    miniChart?: MiniChartTheme;
    seriesNumberWidth?: number;
}

/**
 * 对比两个TempMergedCell，返回 mainTempMergedCells 中存在的，但是 otherTempMergedCells 中不存在的的 TempMergedCell
 * @param mainTempMergedCells
 * @param compareTempMergedCells
 */
export declare const differenceTempMergedCells: (mainTempMergedCells: TempMergedCell[], compareTempMergedCells: TempMergedCell[]) => TempMergedCell[];

export declare const download: (str: string, fileName: string) => void;

/**
 *  绘制单元格内的 mini 柱状图
 */
export declare const drawBar: (chartData: BaseChartData, cell: S2CellType) => void;

/**
 *  绘制单元格内的 mini子弹图
 */
export declare const drawBullet: (value: BulletValue, cell: S2CellType) => void;

/**
 *  绘制单元格内的 条件格式 柱图
 */
export declare const drawInterval: (cell: DataCell) => IShape;

/**
 *  绘制单元格内的 mini 折线图
 */
export declare const drawLine: (chartData: BaseChartData, cell: S2CellType) => void;

/**
 * @desc draw text shape of object
 * @param cell
 * @multiData 自定义文本内容
 * @useCondition 是否使用条件格式
 */
export declare const drawObjectText: (cell: S2CellType, multiData?: MultiData, useCondition?: boolean) => void;

export declare const ELLIPSIS_SYMBOL = "...";

export declare interface EmitterType {
    /** ================ Global ================  */
    [S2Event.GLOBAL_ACTION_ICON_CLICK]: CanvasEventHandler;
    [S2Event.GLOBAL_ACTION_ICON_HOVER]: CanvasEventHandler;
    [S2Event.GLOBAL_ACTION_ICON_HOVER_OFF]: CanvasEventHandler;
    [S2Event.GLOBAL_COPIED]: (data: string) => void;
    [S2Event.GLOBAL_KEYBOARD_DOWN]: KeyboardEventHandler;
    [S2Event.GLOBAL_KEYBOARD_UP]: KeyboardEventHandler;
    [S2Event.GLOBAL_MOUSE_UP]: MouseEventHandler;
    [S2Event.GLOBAL_MOUSE_MOVE]: MouseEventHandler;
    [S2Event.LAYOUT_RESIZE_MOUSE_DOWN]: CanvasEventHandler;
    [S2Event.LAYOUT_RESIZE_MOUSE_UP]: CanvasEventHandler;
    [S2Event.LAYOUT_RESIZE_MOUSE_MOVE]: CanvasEventHandler;
    [S2Event.GLOBAL_CONTEXT_MENU]: CanvasEventHandler;
    [S2Event.GLOBAL_CLICK]: CanvasEventHandler;
    [S2Event.GLOBAL_DOUBLE_CLICK]: CanvasEventHandler;
    [S2Event.GLOBAL_RESET]: EventHandler_2;
    [S2Event.GLOBAL_HOVER]: CanvasEventHandler;
    [S2Event.GLOBAL_SELECTED]: SelectedHandler;
    [S2Event.GLOBAL_SCROLL]: (position: CellScrollPosition) => void;
    /** ================ Sort ================  */
    [S2Event.RANGE_SORT]: (info: SortParams) => void;
    [S2Event.RANGE_SORTED]: SortedHandler | CanvasEventHandler;
    /** ================ Filter ================  */
    [S2Event.RANGE_FILTER]: (info: FilterParam) => void;
    [S2Event.RANGE_FILTERED]: (data: Data[]) => any;
    /** ================ Cell ================  */
    [S2Event.GLOBAL_LINK_FIELD_JUMP]: (data: {
        key: string;
        cellData: Node_2;
        record: Data;
    }) => void;
    /** ================ Date Cell ================  */
    [S2Event.DATA_CELL_MOUSE_DOWN]: CanvasEventHandler;
    [S2Event.DATA_CELL_MOUSE_UP]: CanvasEventHandler;
    [S2Event.DATA_CELL_MOUSE_MOVE]: CanvasEventHandler;
    [S2Event.DATA_CELL_HOVER]: CanvasEventHandler;
    [S2Event.DATA_CELL_CLICK]: CanvasEventHandler;
    [S2Event.DATA_CELL_DOUBLE_CLICK]: CanvasEventHandler;
    [S2Event.DATA_CELL_CONTEXT_MENU]: CanvasEventHandler;
    [S2Event.DATA_CELL_TREND_ICON_CLICK]: (data: ViewMeta) => void;
    [S2Event.DATA_CELL_BRUSH_SELECTION]: (cells: (DataCell | CellMeta)[]) => void;
    [S2Event.DATA_CELL_SELECT_MOVE]: (metas: CellMeta[]) => void;
    /** ================ Row Cell ================  */
    [S2Event.ROW_CELL_MOUSE_DOWN]: CanvasEventHandler;
    [S2Event.ROW_CELL_MOUSE_MOVE]: CanvasEventHandler;
    [S2Event.ROW_CELL_HOVER]: CanvasEventHandler;
    [S2Event.ROW_CELL_CLICK]: CanvasEventHandler;
    [S2Event.ROW_CELL_DOUBLE_CLICK]: CanvasEventHandler;
    [S2Event.ROW_CELL_CONTEXT_MENU]: CanvasEventHandler;
    [S2Event.ROW_CELL_MOUSE_UP]: CanvasEventHandler;
    [S2Event.ROW_CELL_COLLAPSE_TREE_ROWS]: (data: RowCellCollapseTreeRowsType) => void;
    [S2Event.ROW_CELL_SCROLL]: (position: CellScrollPosition) => void;
    [S2Event.ROW_CELL_BRUSH_SELECTION]: (cells: RowCell[]) => void;
    /** ================ Col Cell ================  */
    [S2Event.COL_CELL_MOUSE_DOWN]: CanvasEventHandler;
    [S2Event.COL_CELL_MOUSE_MOVE]: CanvasEventHandler;
    [S2Event.COL_CELL_HOVER]: CanvasEventHandler;
    [S2Event.COL_CELL_CLICK]: CanvasEventHandler;
    [S2Event.COL_CELL_DOUBLE_CLICK]: CanvasEventHandler;
    [S2Event.COL_CELL_CONTEXT_MENU]: CanvasEventHandler;
    [S2Event.COL_CELL_MOUSE_UP]: CanvasEventHandler;
    [S2Event.COL_CELL_BRUSH_SELECTION]: (cells: ColCell[]) => void;
    /** ================ Corner Cell ================  */
    [S2Event.CORNER_CELL_MOUSE_MOVE]: CanvasEventHandler;
    [S2Event.CORNER_CELL_MOUSE_DOWN]: CanvasEventHandler;
    [S2Event.CORNER_CELL_HOVER]: CanvasEventHandler;
    [S2Event.CORNER_CELL_CLICK]: CanvasEventHandler;
    [S2Event.CORNER_CELL_DOUBLE_CLICK]: CanvasEventHandler;
    [S2Event.CORNER_CELL_CONTEXT_MENU]: CanvasEventHandler;
    [S2Event.CORNER_CELL_MOUSE_UP]: CanvasEventHandler;
    /** ================ Merged Cells ================  */
    [S2Event.MERGED_CELLS_MOUSE_DOWN]: CanvasEventHandler;
    [S2Event.MERGED_CELLS_MOUSE_MOVE]: CanvasEventHandler;
    [S2Event.MERGED_CELLS_HOVER]: CanvasEventHandler;
    [S2Event.MERGED_CELLS_MOUSE_UP]: CanvasEventHandler;
    [S2Event.MERGED_CELLS_CLICK]: CanvasEventHandler;
    [S2Event.MERGED_CELLS_CONTEXT_MENU]: CanvasEventHandler;
    [S2Event.MERGED_CELLS_DOUBLE_CLICK]: CanvasEventHandler;
    /** ================ Layout ================  */
    [S2Event.LAYOUT_COLLAPSE_ROWS]: (data: CollapsedRowsType) => void;
    [S2Event.LAYOUT_AFTER_COLLAPSE_ROWS]: (data: CollapsedRowsType) => void;
    [S2Event.LAYOUT_TREE_ROWS_COLLAPSE_ALL]: (hierarchyCollapse: boolean) => void;
    [S2Event.LAYOUT_PAGINATION]: (data: {
        pageSize: number;
        pageCount: number;
        total: number;
        current: number;
    }) => void;
    [S2Event.LAYOUT_AFTER_HEADER_LAYOUT]: (data: LayoutResult) => void;
    [S2Event.LAYOUT_AFTER_REAL_DATA_CELL_RENDER]: (options: {
        add: [number, number][];
        remove: [number, number][];
        spreadsheet: SpreadSheet;
    }) => void;
    /** @deprecated 请使用 S2Event.GLOBAL_SCROLL 代替 */
    [S2Event.LAYOUT_CELL_SCROLL]: (position: CellScrollPosition) => void;
    [S2Event.LAYOUT_COLS_EXPANDED]: (expandedNode: Node_2) => void;
    [S2Event.LAYOUT_COLS_HIDDEN]: (currentHiddenColumnsInfo: HiddenColumnsInfo, hiddenColumnsDetail: HiddenColumnsInfo[]) => void;
    [S2Event.LAYOUT_BEFORE_RENDER]: () => void;
    [S2Event.LAYOUT_AFTER_RENDER]: () => void;
    [S2Event.LAYOUT_DESTROY]: () => void;
    /** ================ Layout Resize ================  */
    [S2Event.LAYOUT_RESIZE]: ResizeHandler;
    [S2Event.LAYOUT_RESIZE_SERIES_WIDTH]: ResizeHandler;
    [S2Event.LAYOUT_RESIZE_ROW_WIDTH]: ResizeHandler;
    [S2Event.LAYOUT_RESIZE_ROW_HEIGHT]: ResizeHandler;
    [S2Event.LAYOUT_RESIZE_COL_WIDTH]: ResizeHandler;
    [S2Event.LAYOUT_RESIZE_COL_HEIGHT]: ResizeHandler;
    [S2Event.LAYOUT_RESIZE_TREE_WIDTH]: ResizeHandler;
}

export declare const EMPTY_EXTRA_FIELD_PLACEHOLDER = "$$empty_extra_placeholder$$";

export declare const EMPTY_FIELD_VALUE = "$$empty_field_value$$";

export declare const EMPTY_PLACEHOLDER = "-";

export declare class EventController {
    spreadsheet: SpreadSheet;
    private target;
    canvasEventHandlers: EventHandler[];
    s2EventHandlers: S2EventHandler[];
    domEventListeners: EventListener_2[];
    isCanvasEffect: boolean;
    canvasMousemoveEvent: GEvent;
    constructor(spreadsheet: SpreadSheet);
    get canvasContainer(): Canvas;
    get isAutoResetSheetStyle(): boolean;
    bindEvents(): void;
    private isGuiIconShape;
    private onKeyboardCopy;
    private onKeyboardEsc;
    private resetSheetStyle;
    private isMouseEvent;
    private isMouseOnTheCanvasContainer;
    private getContainerRect;
    private isMouseOnTheTooltip;
    private isResizeArea;
    private activeResizeArea;
    private resetResizeArea;
    private onCanvasMousedown;
    private onCanvasMousemove;
    private hasBrushSelectionIntercepts;
    private onCanvasMouseup;
    private onCanvasClick;
    private onCanvasDoubleClick;
    private onCanvasMouseout;
    private onCanvasContextMenu;
    clear(): void;
    private unbindEvents;
    private addCanvasEvent;
    private addS2Event;
    private addDomEventListener;
    clearAllEvents(): void;
}

declare interface EventHandler {
    type: string;
    handler: (event: GEvent) => void;
}

declare type EventHandler_2 = (event: Event) => void;

declare interface EventHandler_3 {
    target: IElement;
    type: keyof HTMLElementEventMap;
    handler: (e: MouseEvent | TouchEvent) => void;
}

declare interface EventListener_2 {
    target: EventTarget;
    type: string;
    handler: EventListenerOrEventListenerObject;
    options?: AddEventListenerOptions | boolean;
}

declare interface EventListenerReturn {
    remove: () => void;
}

/**
 * 拓展locale配置
 */
export declare const extendLocale: (extraLocale: LocaleType) => void;

/**
 * Strategy mode's value type
 * data's key size must be equals fields.length
 * value can be empty
 * FieldC(Last fields is real value field)
 * example:
 * {
 *   fields: [fieldA, fieldB, fieldC],
 *   data: [
 *   {
 *     fieldA: 'valueA',
 *     fieldB: 'valueB',
 *     fieldC: 'valueC',
 *   }
 *   {
 *     fieldA: 'valueA',
 *     fieldB: '',
 *     fieldC: 'valueC',
 *   }
 *   ]
 * }
 */
export declare interface Extra {
    key: string;
    collapse: boolean;
    remark: string;
}

export declare const EXTRA_COLUMN_FIELD = "$$extra_column$$";

export declare const EXTRA_FIELD = "$$extra$$";

export declare interface Fields {
    rows?: string[];
    customTreeItems?: CustomTreeItem[];
    columns?: Columns;
    values?: string[];
    valueInCols?: boolean;
    customValueOrder?: number;
}

export declare type FilterDataItemCallback = (valueField: string, data: DataItem) => DataItem;

export declare interface FilterParam {
    filterKey: string;
    filteredValues?: unknown[];
    customFilter?: (row: DataType) => boolean;
}

export declare type FlattingIndexesData = DataType[][] | DataType[] | DataType;

export declare const FONT_FAMILY = "Roboto, PingFangSC, BlinkMacSystemFont, Microsoft YaHei, Arial, sans-serif";

declare type FormatOptions = boolean | {
    isFormatHeader?: boolean;
    isFormatData?: boolean;
};

export declare interface FormatResult {
    formattedValue: string;
    value: DataItem;
}

export declare type Formatter = (v: unknown, data?: Data | Data[], meta?: Node_2 | ViewMeta) => string;

declare interface FractionDigitsOptions {
    min: number;
    max: number;
}

export declare class Frame extends Group {
    cfg: FrameConfig;
    constructor(cfg: FrameConfig);
    layout(): void;
    /**
     * 渲染
     */
    render(): void;
    onBorderScroll(scrollX: number): void;
    onChangeShadowVisibility(scrollX: number, maxScrollX: number): void;
    private addCornerRightBorder;
    private addCornerBottomBorder;
    private addSplitLineShadow;
    private addSplitLineLeftShadow;
    private addSplitLineRightShadow;
}

export declare type FrameCallback = (cfg: FrameConfig) => Frame;

export declare interface FrameConfig {
    position: {
        x: number;
        y: number;
    };
    scrollX?: number;
    width: number;
    height: number;
    viewportWidth: number;
    viewportHeight: number;
    showViewportLeftShadow: boolean;
    showViewportRightShadow: boolean;
    scrollContainsRowHeader: boolean;
    isPivotMode: boolean;
    spreadsheet: SpreadSheet;
}

export declare const FRONT_GROUND_GROUP_BRUSH_SELECTION_Z_INDEX = 5;

export declare const FRONT_GROUND_GROUP_CONTAINER_Z_INDEX = 3;

export declare const FRONT_GROUND_GROUP_FROZEN_Z_INDEX = 4;

export declare const FRONT_GROUND_GROUP_RESIZE_AREA_Z_INDEX = 5;

export declare const FRONT_GROUND_GROUP_SCROLL_Z_INDEX = 3;

export declare const FrozenCellGroupMap: {
    row: string;
    col: string;
    trailingCol: string;
    trailingRow: string;
    scroll: string;
    top: string;
    bottom: string;
};

export declare interface FrozenCellIndex {
    x: number;
    y: number;
}

export declare enum FrozenCellType {
    ROW = "row",
    COL = "col",
    TRAILING_ROW = "trailingRow",
    TRAILING_COL = "trailingCol",
    SCROLL = "scroll",
    TOP = "top",
    BOTTOM = "bottom"
}

export declare enum FrozenGroup {
    FROZEN_COL = "frozenCol",
    FROZEN_ROW = "frozenRow",
    FROZEN_TRAILING_COL = "frozenTrailingCol",
    FROZEN_TRAILING_ROW = "frozenTrailingRow"
}

declare class FrozenGroup_2 extends GridGroup {
}

export declare interface FrozenOpts {
    frozenRowCount?: number;
    frozenColCount?: number;
    frozenTrailingRowCount?: number;
    frozenTrailingColCount?: number;
}

/**
 * Row and column header node id generator.
 * @param parentId
 * @param value
 */
export declare const generateId: (parentId: string, value: string) => string;

/**
 * 根据 S2 内置色板及自选主题色生成新色板
 * @param paletteMeta @PaletteMeta
 * @returns 新色板
 */
export declare const generatePalette: (paletteMeta?: PaletteMeta) => Palette;

/**
 * 生成 s2 设计规范下的标准色（共 11 个）
 *
 * - 第 1~5 为主题色加白
 * - 第 6 为主题色
 * - 第 7~11 为主题色加黑
 *
 * @param brandColor 主题色
 * @returns 标准色卡
 */
export declare const generateStandardColors: (brandColor: string) => string[];

/**
 * get the active cells' info as the default info of merged cells
 * @param sheet
 */
export declare const getActiveCellsInfo: (sheet: SpreadSheet) => MergedCellInfo[];

/**
 * @description Return all the row cells or column cells which are needed to be highlighted.
 * @param id rowId or colId
 * @param headerCells all the rowHeader cells or all the colHeader cells
 * @param isRowInHierarchyTreeType  The tree mode will only highlight the leaf nodes at the head of the row
 */
export declare const getActiveHoverRowColCells: (id: string, headerCells: ColCell[] | RowCell[], isRowInHierarchyTreeType?: boolean) => (ColCell | RowCell)[];

/**
 * calculate tooltip show position
 */
export declare const getAutoAdjustPosition: ({ spreadsheet, position, tooltipContainer, autoAdjustBoundary, }: AutoAdjustPositionOptions) => TooltipPosition;

export declare const getBaseCellData: (event: GEvent) => TargetCellInfo;

export declare const getBorderPositionAndStyle: (position: CellBorderPosition, contentBox: SimpleBBox, style: CellTheme) => {
    position: {
        x1: any;
        x2: any;
        y1: any;
        y2: any;
    };
    style: any;
};

/**
 * 根据当前值和目标值获取子弹图填充色
 */
export declare const getBulletRangeColor: (measure: number | string, target: number | string, rangeColors: RangeColors) => string;

export declare type GetCellMeta = (rowIndex?: number, colIndex?: number) => ViewMeta;

export declare const getCellMeta: (cell: S2CellType) => CellMeta;

export declare const getCellsTooltipData: (spreadsheet: SpreadSheet) => TooltipData[];

/**
 * 根据 cellCfg 配置获取当前单元格宽度
 */
export declare const getCellWidth: (cellCfg: CellCfg, labelSize?: number) => number;

export declare const getClassNameWithPrefix: (...classNames: string[]) => string;

export declare const getColHeaderByCellId: (cellId: string, s2: SpreadSheet) => Node_2[];

/**
 * -----------------------------
 * |           padding         |
 * |  |---------------------|  |
 * |  |                     |  |
 * |  |                     |  |
 * |  |---------------------|  |
 * |           padding         |
 * -----------------------------
 */
export declare const getContentArea: (bbox: SimpleBBox, padding: Padding) => {
    x: number;
    y: number;
    width: number;
    height: number;
};

/**
 * @desc 获取多指标情况下每一个指标的内容包围盒
 * --------------------------------------------
 * |  text icon  |  text icon  |  text icon  |
 * |-------------|-------------|-------------|
 * |  text icon  |  text icon  |  text icon  |
 * --------------------------------------------
 * @param box SimpleBBox 整体绘制内容包围盒
 * @param texts  SimpleDataItem[][] 指标集合
 * @param widthPercent number[] 每行指标的宽度百分比
 */
export declare const getContentAreaForMultiData: (box: SimpleBBox, textValues: SimpleDataItem[][], widthPercent?: number[]) => SimpleBBox[][];

export declare function getCopyData(spreadsheet: SpreadSheet, copyType: CopyType, copyFormat: CopyMIMEType): string;

export declare function getCopyData(spreadsheet: SpreadSheet, copyType: CopyType, copyFormat: CopyMIMEType[]): string[];

export declare function getCopyData(spreadsheet: SpreadSheet, copyType: CopyType): string;

export declare const getDataByRowData: (spreadsheet: SpreadSheet, rowData: RowData) => Copyable;

export declare const getDataCellId: (rowIndex: string, colIndex: string) => string;

export declare const getDescription: (targetCell: S2CellType) => string;

/**
 * @desc 改良版 获取文本的 ... 文本（可传入 优先文本片段）
 * @param measureTextWidth 文本长度计算函数
 * @param text 需要计算的文本
 * @param maxWidth
 * @param font optional 文本字体 或 优先显示的文本
 * @param priority optional 优先显示的文本
 */
export declare const getEllipsisText: ({ measureTextWidth, text, maxWidth, fontParam, priorityParam, placeholder, }: {
    measureTextWidth: (text: number | string, font: unknown) => number;
    text: string | number;
    maxWidth: number;
    fontParam?: unknown;
    priorityParam?: string[];
    placeholder?: string;
}) => any;

/**
 * 获取文本的 ... 文本。
 * 算法（减少每次 measureText 的长度，measureText 的性能跟字符串时间相关）：
 * 1. 先通过 STEP 逐步计算，找到最后一个小于 maxWidth 的字符串
 * 2. 然后对最后这个字符串二分计算
 * @param measureTextWidth 文本宽度预估函数
 * @param text 需要计算的文本, 由于历史原因 除了支持string，还支持空值,number和数组等
 * @param maxWidth
 * @param font
 */
export declare const getEllipsisTextInner: (measureTextWidth: (text: number | string, font: unknown) => number, text: any, maxWidth: number, font: CSSStyleDeclaration) => any;

/**
 * 获取自定义空值占位符
 */
export declare const getEmptyPlaceholder: (meta: Record<string, any>, placeHolder: string | ((meta: Record<string, any>) => string)) => string;

export declare const getFieldFormatter: (spreadsheet: SpreadSheet, field: string) => (v: unknown, data?: Data) => string | number;

export declare const getFieldList: (spreadsheet: SpreadSheet, fields: string[], activeData: TooltipDataItem) => TooltipDetailListItem[];

export declare const getFriendlyVal: (val: any) => number | string;

/**
 * 获取选中格行/列头信息
 * @param spreadsheet
 * @param activeData
 */
export declare const getHeadInfo: (spreadsheet: SpreadSheet, activeData: TooltipDataItem, options?: TooltipOptions) => TooltipHeadInfo;

export declare const getIcon: (name: string) => string;

export declare const getInteractionCells: (cell: CellMeta, s2: SpreadSheet) => Array<CellMeta>;

export declare const getInteractionCellsBySelectedCells: (selectedCells: CellMeta[], s2: SpreadSheet) => Array<CellMeta>;

/**
 * get cells on the outside of visible area through mergeCellInfo
 * @param invisibleCellInfo
 * @param sheet
 */
export declare const getInvisibleInfo: (invisibleCellInfo: MergedCellInfo[], sheet: SpreadSheet) => {
    cells: S2CellType<ViewMeta>[];
    cellsMeta: ViewMeta;
};

export declare const getLang: () => LangType;

export declare const getListItem: (spreadsheet: SpreadSheet, { data, field, valueField, useCompleteDataForFormatter, }: {
    data: TooltipDataItem;
    field: string;
    valueField?: string;
    useCompleteDataForFormatter?: boolean;
}) => TooltipDetailListItem;

export declare const getLocale: () => LocaleType;

export declare const getMaxTextWidth: (contentWidth: number, iconCfg?: IconCfg) => number;

/**
 * 创建 merged cell 实例
 * @param spreasheet 表格实例
 * @param cells 待合并的单元格
 * @param meta 元信息
 * @returns
 */
export declare const getMergedCellInstance: MergedCellCallback;

export declare const getMergedQuery: (meta: ViewMeta) => {
    [x: string]: any;
};

/**
 * return the edge according to the  coordinate of current edge
 * eg: curEdge: [[0,0], [100,0]] then the next edge: [[100, 0 ], [100, 100]]
 * @param curEdge the  coordinate of current edge
 * @param edges the collection of edges
 */
export declare const getNextEdge: (curEdge: number[][], edges: number[][][]) => number[][];

/**
 * 获取当前的主题色板
 * @param type 主题名
 */
export declare const getPalette: (type?: ThemeName) => Palette;

/**
 * return all the points of the polygon
 * @param cells the collection of information of cells which needed be merged
 */
export declare const getPolygonPoints: (cells: S2CellType[]) => number[][];

export declare function getRangeIndex<T extends CellMeta | ViewMeta>(start: T, end: T): {
    start: {
        rowIndex: number;
        colIndex: number;
    };
    end: {
        rowIndex: number;
        colIndex: number;
    };
};

/**
 *  according to the coordinates of the starting point of the rectangle,
 * return the four sides of the rectangle in a clockwise direction.
 * [TopLeft] --- [TopRight]
 *    |               |
 * [BottomLeft] -[BottomRight]
 * @param x
 * @param y
 * @param width
 * @param height
 */
export declare const getRectangleEdges: (x: number, y: number, width: number, height: number) => number[][][];

export declare function getRowCellForSelectedCell(meta: ViewMeta, spreadsheet: SpreadSheet): (ColCell | RowCell | TableSeriesCell)[];

export declare const getRowHeaderByCellId: (cellId: string, s2: SpreadSheet) => Node_2[];

export declare const getSafetyDataConfig: (...dataConfig: Partial<S2DataConfig>[]) => S2DataConfig;

export declare const getSafetyOptions: (options: Partial<S2Options>) => any;

export declare const getScrollOffsetForCol: (colIndex: number, direction: ScrollDirection, spreadsheet: SpreadSheet) => number;

export declare const getScrollOffsetForRow: (rowIndex: number, direction: ScrollDirection, spreadsheet: SpreadSheet) => number;

export declare const getSelectedCellIndexes: (spreadsheet: SpreadSheet, layoutResult: LayoutResult) => any[];

export declare const getSelectedCellsData: (spreadsheet: SpreadSheet, targetCell: S2CellType, showSingleTips?: boolean) => TooltipDataItem[];

/**
 * 返回选中数据单元格生成的二维数组（ CellMeta[][]）
 * @param { CellMeta[] } cells
 * @return { CellMeta[][] }
 */
export declare const getSelectedCellsMeta: (cells: CellMeta[]) => CellMeta[][];

export declare const getSelectedData: (spreadsheet: SpreadSheet) => string;

/**
 * 获取 “按数值排序” 的排序参考数据
 *
 * 本函数可用以下结构的交叉表理解
 * rows：province、city
 * cols：type、subType
 * vals：price、account
 */
export declare const getSortByMeasureValues: (params: SortActionParams) => DataType[];

/**
 * 对 pivot meta 中的内容进行排序，返回新的 sorted pivot meta
 */
export declare const getSortedPivotMeta: (params: SortPivotMetaParams) => PivotMeta;

export declare const getSortTypeIcon: (sortParam: SortParam, isSortCell?: boolean) => "groupAsc" | "groupDesc" | "SortDown";

export declare const getSummaries: (params: SummaryParam) => TooltipSummaryOptions[];

export declare const getSummaryName: (spreadsheet: SpreadSheet, currentField: string, isTotals: boolean) => string;

/**
 * get the data cell and meta that make up the mergedCell
 * @param cellsInfos
 * @param allVisibleCells
 * @param sheet
 */
export declare const getTempMergedCell: (allVisibleCells: S2CellType[], sheet?: SpreadSheet, cellsInfos?: MergedCellInfo[]) => TempMergedCell;

export declare const getTextAndFollowingIconPosition: (contentBox: SimpleBBox, textCfg: TextAlignCfg, textWidth?: number, iconCfg?: IconCfg, iconCount?: number) => {
    text: {
        x: number;
        y: number;
    };
    icon: {
        x: number;
        y: number;
    };
};

/**
 * 在给定视窗和单元格的情况下，计算单元格文字区域的坐标信息
 * 计算遵循原则：
 * 1. 若可视范围小，尽可能多展示文字
 * 2. 若可视范围大，居中展示文字
 * @param viewport 视窗坐标信息
 * @param content content 列头单元格 content 区域坐标信息
 * @param textWidth 文字实际绘制区域宽度（含icon）
 * @returns 文字绘制位置（start 为文字区域的中点坐标值）
 */
export declare const getTextAreaRange: (viewport: AreaRange, content: AreaRange, textWidth: number) => AreaRange;

export declare const getTextPosition: (contentBox: SimpleBBox, textCfg: TextAlignCfg) => {
    x: number;
    y: number;
};

/**
 * @describe generate the theme according to the type
 * @param themeCfg
 */
export declare const getTheme: (themeCfg: Omit<ThemeCfg, 'theme'> & {
    spreadsheet?: SpreadSheet;
}) => S2Theme;

export declare const getTooltipData: (params: TooltipDataParam) => TooltipData;

export declare const getTooltipDefaultOptions: <Icon = string | Element, Text_1 = string>(options?: TooltipOptions<Icon, Text_1>) => TooltipOptions<Icon, Text_1>;

/**
 * 获取数据明细
 * @param spreadsheet
 * @param activeData
 * @param options
 */
export declare const getTooltipDetailList: (spreadsheet: SpreadSheet, activeData: TooltipDataItem, options: TooltipOptions) => TooltipDetailListItem[];

export declare const getTooltipOperatorHiddenColumnsMenu: () => TooltipOperatorMenu;

export declare const getTooltipOperatorSortMenus: () => TooltipOperatorMenu[];

export declare const getTooltipOperatorTableSortMenus: () => TooltipOperatorMenu[];

export declare const getTooltipOperatorTrendMenu: () => TooltipOperatorMenu;

export declare const getTooltipOptions: (spreadsheet: SpreadSheet, event: GEvent | MouseEvent | Event) => Tooltip;

export declare const getTooltipOptionsByCellType: (cellTooltipConfig: Tooltip, cellType: CellTypes) => Tooltip;

export declare const getTooltipVisibleOperator: (operation: TooltipOperation, options: {
    defaultMenus?: TooltipOperatorMenu[];
    cell: S2CellType;
}) => TooltipOperatorOptions;

export declare const getValidFrozenOptions: (opts: S2TableSheetOptions, colLength: number, dataLength?: number) => S2TableSheetOptions;

export declare const getVerticalPosition: ({ y, height }: SimpleBBox, textBaseline: TextBaseline, size?: number) => number;

/**
 * get { cells, invisibleCellInfo, cellsMeta } in the inside of visible area through mergeCellInfo
 * @param cellsInfos
 * @param allVisibleCells
 * @returns { cells, invisibleCellInfo, cellsMeta }
 */
export declare const getVisibleInfo: (cellsInfos: MergedCellInfo[], allVisibleCells: S2CellType[]) => {
    cells: S2CellType<ViewMeta>[];
    invisibleCellInfo: MergedCellInfo[];
    cellsMeta: Node | ViewMeta;
};

export { GEvent }

export declare interface GridAnalysisCellTheme {
    minorText?: TextTheme;
    derivedMeasureText?: {
        mainUp: string;
        mainDown: string;
        minorUp: string;
        minorDown: string;
    };
}

declare class GridGroup extends Group {
    protected s2: SpreadSheet;
    constructor(cfg: any);
    protected gridGroup: IGroup;
    protected gridInfo: GridInfo;
    updateGrid: (gridInfo: GridInfo, id?: string) => void;
}

export declare interface GridInfo {
    cols: number[];
    rows: number[];
}

/**
 * 使用 iconfont 上的 svg 来创建 Icon
 */
export declare class GuiIcon extends Group {
    static type: string;
    iconImageShape: Shape.Image;
    constructor(cfg: GuiIconCfg);
    getImage(name: string, cacheKey: string, fill?: string): Promise<HTMLImageElement>;
    /**
     * 1. https://xxx.svg
     * 2. http://xxx.svg
     * 3. //xxx.svg
     */
    isOnlineLink: (src: string) => boolean;
    private render;
    setImageAttrs(attrs: Partial<{
        name: string;
        fill: string;
    }>): void;
}

declare interface GuiIconCfg extends ShapeAttrs {
    readonly name: string;
}

export declare const handleDataItem: (data: Data, callback?: FilterDataItemCallback | MappingDataItemCallback) => DataItem | Record<string, string | number>;

export declare const handleSortAction: (params: SortActionParams) => string[];

declare class HdAdapter {
    private viewport;
    private devicePixelRatioMedia;
    private spreadsheet;
    private isDevicePixelRatioChange;
    constructor(spreadsheet: SpreadSheet);
    init: () => void;
    destroy: () => void;
    private initDevicePixelRatioListener;
    private removeDevicePixelRatioListener;
    private initDeviceZoomListener;
    private removeDeviceZoomListener;
    /**
     * DPR 改变也会触发 visualViewport 的 resize 事件, 预期是只监听双指缩放, 所以这里规避掉
     * @see https://github.com/antvis/S2/issues/2072
     */
    private renderByZoomScaleWithoutResizeEffect;
    private renderByDevicePixelRatioChanged;
    private renderByDevicePixelRatio;
    private renderByZoomScale;
}

export declare interface HeaderActionIcon {
    iconNames: string[];
    belongsCell: Omit<CellTypes, 'dataCell'>;
    defaultHide?: boolean | ((meta: Node_2, iconName: string) => boolean);
    displayCondition?: (mete: Node_2, iconName: string) => boolean;
    /**
     * 点击后的执行函数
     * @deprecated 使用 onClick 代替
     */
    action?: (headerIconClickParams: HeaderIconClickParams) => void;
    onClick?: (headerIconClickParams: HeaderIconClickParams) => void;
    onHover?: (headerIconHoverParams: HeaderIconHoverParams) => void;
}

export declare interface HeaderActionIconOptions {
    iconName: string;
    x: number;
    y: number;
    /** @deprecated 使用 onClick 代替 */
    action: (props: HeaderIconClickParams) => void;
    onClick: (headerIconClickParams: HeaderIconClickParams) => void;
    onHover: (headerIconHoverParams: HeaderIconHoverParams) => void;
    defaultHide?: boolean;
}

export declare type HeaderActionIconProps = HeaderIconClickParams;

export declare abstract class HeaderCell extends BaseCell<Node_2> {
    protected headerConfig: BaseHeaderConfig;
    protected treeIcon: GuiIcon | undefined;
    protected treeLeafNodeAlignDot: IShape | undefined;
    protected actionIcons: GuiIcon[];
    protected hasDefaultHiddenIcon: boolean;
    protected abstract isBolderText(): boolean;
    protected handleRestOptions(...[headerConfig]: [BaseHeaderConfig, unknown]): void;
    protected initCell(): void;
    getTreeIcon(): GuiIcon;
    protected getInteractiveBorderShapeStyle(border: number): {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    protected getFormattedFieldValue(): FormatResult;
    /**
     * 获取操作 icons
     */
    protected getActionIconCfg(): HeaderActionIcon;
    protected showSortIcon(): boolean;
    protected getActionIconsCount(): number;
    protected getActionIconsWidth(): number;
    protected drawSortIcons(): void;
    protected hasDefaultHideActionIcon(): boolean;
    protected addActionIcon(options: HeaderActionIconOptions): void;
    protected drawActionIcons(): void;
    protected drawBackgroundShape(): void;
    protected isSortCell(): boolean;
    protected handleByStateName(cells: CellMeta[], stateName: InteractionStateName): void;
    protected handleSearchResult(cells: CellMeta[]): void;
    protected handleHover(cells: CellMeta[]): void;
    protected handleSelect(cells: CellMeta[], nodes: Node_2[]): void;
    protected getTextStyle(): TextTheme;
    getBackgroundColor(): {
        backgroundColor: string;
        backgroundColorOpacity: number;
    };
    protected getBackgroundColorByCondition(backgroundColor: string, backgroundColorOpacity: number): {
        backgroundColor: string;
        backgroundColorOpacity: number;
    };
    toggleActionIcon(id: string): void;
    update(): void;
    updateByState(stateName: InteractionStateName): void;
    hideInteractionShape(): void;
    isMeasureField(): boolean;
    mappingValue(condition: Condition): MappingResult;
    findFieldCondition(conditions: Condition[]): Condition;
}

export declare interface HeaderIconClickParams {
    iconName: string;
    meta: Node_2;
    event?: GEvent;
}

export declare interface HeaderIconHoverParams extends HeaderIconClickParams {
    hovering: boolean;
}

export declare interface HiddenColumnsInfo {
    hideColumnNodes: Node_2[];
    displaySiblingNode: {
        prev: Node_2;
        next: Node_2;
    };
}

/**
 * Row and Column hierarchy to handle all contained nodes
 */
export declare class Hierarchy {
    rows: string[];
    width: number;
    height: number;
    maxLevel: number;
    sampleNodesForAllLevels?: Node_2[];
    sampleNodeForLastLevel?: Node_2;
    private allNodesWithoutRoot;
    private indexNode;
    getLeaves(): Node_2[];
    /**
     * Get all or level-related nodes in hierarchy
     * @param level
     */
    getNodes(level?: number): Node_2[];
    /**
     * Get all or less than level-related nodes in hierarchy
     * @param lessThanLevel
     */
    getNodesLessThanLevel(lessThanLevel: number): Node_2[];
    /**
     * Add new node
     * @param value
     * @param insetIndex
     */
    pushNode(value: Node_2, insetIndex?: number): void;
    pushIndexNode(value: Node_2): void;
    getIndexNodes(): Node_2[];
}

export declare type HierarchyCallback = (spreadsheet: SpreadSheet, node: Node_2) => HierarchyResult;

export declare type HierarchyResult = {
    nodes: Node_2[];
    push: boolean;
};

export declare const HORIZONTAL_RESIZE_AREA_KEY_PRE = "horizontal-resize-area-";

export declare const HOVER_FOCUS_DURATION = 800;

/**
 * @description Hover event for data cells, row cells and col cells
 */
export declare class HoverEvent extends BaseEvent implements BaseEventImplement {
    bindEvents(): void;
    updateRowColCells(meta: ViewMeta): void;
    /**
     * @description change the data cell state from hover to hover focus
     * @param cell
     * @param event
     * @param meta
     */
    private changeStateToHoverFocus;
    /**
     * @description handle the row or column header hover state
     * @param event
     */
    private handleHeaderHover;
    private showEllipsisTooltip;
    private getCellData;
    bindDataCellHover(): void;
    bindRowCellHover(): void;
    bindColCellHover(): void;
    bindCornerCellHover(): void;
}

export declare interface HoverFocusOptions {
    duration?: number;
}

export declare const i18n: (key: string, defaultValue?: string) => string;

export declare type IconCfg = Pick<IconTheme, 'size' | 'margin'> & Pick<IconCondition, 'position'>;

export declare interface IconCondition extends Condition {
    position?: IconPosition;
}

export declare type IconPosition = 'left' | 'right';

export declare interface IconTheme {
    fill?: string;
    downIconColor?: string;
    upIconColor?: string;
    size?: number;
    margin?: Margin;
}

export declare const ID_SEPARATOR = "[&]";

export declare const IMAGE = "image";

/**
 * @description  Determine if the current cell belongs to Cells
 * @param cells active cells
 * @param currentCell current activated cell
 */
export declare const includeCell: (cells: CellMeta[], currentCell: S2CellType) => boolean;

declare type Indexes = [number?, number?, number?, number?];

export declare const INTERACTION_STATE_INFO_KEY = "interactionStateInfo";

export declare enum InteractionBrushSelectionStage {
    CLICK = "click",
    UN_DRAGGED = "unDragged",
    DRAGGED = "dragged"
}

export declare interface InteractionCellHighlight {
    rowHeader?: boolean;
    colHeader?: boolean;
    currentRow?: boolean;
    currentCol?: boolean;
}

export declare type InteractionConstructor = new (spreadsheet: SpreadSheet) => BaseEvent;

export declare enum InteractionEvent {
    DATA_CELL_CLICK_EVENT = "interaction:data-cell-click",
    MERGED_CELLS_CLICK_EVENT = "interaction:merged-cells-click",
    CORNER_TEXT_CLICK_EVENT = "interaction:corner-cell-text-click",
    ROW_COLUMN_CLICK_EVENT = "interaction:row-column-click",
    ROW_TEXT_CLICK_EVENT = "interaction:row-text-click",
    HOVER_EVENT = "interaction:hover",
    TREND_ICON_CLICK = "interaction:trend-icon-click"
}

export declare enum InteractionKeyboardKey {
    SHIFT = "Shift",
    COPY = "c",
    ESC = "Escape",
    META = "Meta",
    CONTROL = "Control",
    ARROW_UP = "ArrowUp",
    ARROW_DOWN = "ArrowDown",
    ARROW_LEFT = "ArrowLeft",
    ARROW_RIGHT = "ArrowRight"
}

export declare enum InteractionName {
    CORNER_CELL_CLICK = "cornerCellClick",
    DATA_CELL_CLICK = "dataCellClick",
    MERGED_CELLS_CLICK = "mergedCellsClick",
    ROW_COLUMN_CLICK = "rowColumnClick",
    ROW_TEXT_CLICK = "rowTextClick",
    HOVER = "hover",
    BRUSH_SELECTION = "brushSelection",
    ROW_BRUSH_SELECTION = "rowBrushSelection",
    COL_BRUSH_SELECTION = "colBrushSelection",
    COL_ROW_RESIZE = "rowColResize",
    DATA_CELL_MULTI_SELECTION = "dataCellMultiSelection",
    RANGE_SELECTION = "rangeSelection",
    SELECTED_CELL_MOVE = "selectedCellMove"
}

export declare interface InteractionOptions {
    linkFields?: string[] | ((meta: Node_2 | ViewMeta) => boolean);
    selectedCellsSpotlight?: boolean;
    hoverHighlight?: boolean | InteractionCellHighlight;
    hoverFocus?: boolean | HoverFocusOptions;
    enableCopy?: boolean;
    copyWithFormat?: boolean;
    copyWithHeader?: boolean;
    autoResetSheetStyle?: boolean;
    hiddenColumnFields?: string[];
    scrollSpeedRatio?: ScrollSpeedRatio;
    resize?: boolean | ResizeInteractionOptions;
    brushSelection?: boolean | BrushSelection;
    multiSelection?: boolean;
    rangeSelection?: boolean;
    selectedCellMove?: boolean;
    scrollbarPosition?: ScrollbarPositionType;
    eventListenerOptions?: boolean | AddEventListenerOptions;
    selectedCellHighlight?: boolean | InteractionCellHighlight;
    overscrollBehavior?: 'auto' | 'none' | 'contain';
    hoverAfterScroll?: boolean;
    /** ***********CUSTOM INTERACTION HOOKS**************** */
    customInteractions?: CustomInteraction[];
}

export declare type InteractionState = {
    [K in InteractionStateName]?: InteractionStateTheme;
};

export declare interface InteractionStateInfo {
    stateName?: InteractionStateName;
    cells?: CellMeta[];
    interactedCells?: S2CellType[];
    nodes?: Node_2[];
    force?: boolean;
    /** 交互行为改变后，会被更新和重绘的单元格回调 */
    onUpdateCells?: OnUpdateCells;
}

export declare enum InteractionStateName {
    ALL_SELECTED = "allSelected",
    SELECTED = "selected",
    BRUSH_SELECTED = "brushSelected",
    UNSELECTED = "unselected",
    HOVER = "hover",
    HOVER_FOCUS = "hoverFocus",
    HIGHLIGHT = "highlight",
    SEARCH_RESULT = "searchResult",
    PREPARE_SELECT = "prepareSelect"
}

export declare interface InteractionStateTheme {
    backgroundOpacity?: number;
    backgroundColor?: string;
    textOpacity?: number;
    borderColor?: string;
    borderWidth?: number;
    borderOpacity?: number;
    opacity?: number;
}

export declare type Intercept = InterceptType[keyof InterceptType];

export declare enum InterceptType {
    HOVER = "hover",
    CLICK = "click",
    BRUSH_SELECTION = "brushSelection",
    ROW_BRUSH_SELECTION = "rowBrushSelection",
    COL_BRUSH_SELECTION = "colBrushSelection",
    MULTI_SELECTION = "multiSelection",
    RESIZE = "resize"
}

export declare const INTERVAL_BAR_HEIGHT = 12;

export declare interface IntervalTheme {
    height: number;
    fill: string;
}

export declare const isAscSort: (sortMethod: any) => boolean;

export declare const isDataCell: (cell: CellMeta) => boolean;

export declare const isDescSort: (sortMethod: any) => boolean;

export declare function isIPhoneX(): boolean;

export declare function isMobile(device?: string): boolean;

export declare const isMouseEventWithMeta: (e: MouseEvent) => boolean;

export declare const isMultiSelectionKey: (e: KeyboardEvent) => boolean;

/**
 * Determines whether the data is actually equal to 0 or empty or nil or equals to compareValue
 * example: "0.00%" => true
 * @param value
 * @param compareValue
 */
export declare const isUnchangedValue: (value: number | string, compareValue: number | string) => boolean;

/**
 * To decide whether the data is positive or negative.
 * Two cases needed to be considered since  the derived value could be number or string.
 * @param value
 * @param font
 */
export declare const isUpDataValue: (value: number | string) => boolean;

export declare function isWindows(): boolean;

/**
 * Determines whether the data is actually equal to 0 or empty or nil
 * example: "0.00%" => true
 * @param value
 */
export declare const isZeroOrEmptyValue: (value: number | string) => boolean;

export declare const KEY_COL_REAL_WIDTH_INFO = "col-real-width-info";

export declare const KEY_GROUP_BACK_GROUND = "backGroundGroup";

export declare const KEY_GROUP_COL_FROZEN = "colFrozenGroup";

export declare const KEY_GROUP_COL_FROZEN_TRAILING = "colFrozenTrailingGroup";

export declare const KEY_GROUP_COL_HORIZONTAL_RESIZE_AREA = "colHorizontalResizeAreaGroup";

export declare const KEY_GROUP_COL_RESIZE_AREA = "colResizeAreaGroup";

export declare const KEY_GROUP_COL_SCROLL = "colScrollGroup";

export declare const KEY_GROUP_CORNER_RESIZE_AREA = "cornerResizeAreaGroup";

export declare const KEY_GROUP_FORE_GROUND = "foreGroundGroup";

export declare const KEY_GROUP_FROZEN_COL_RESIZE_AREA = "colFrozenResizeAreaGroup";

export declare const KEY_GROUP_FROZEN_ROW_RESIZE_AREA = "rowFrozenResizeAreaGroup";

export declare const KEY_GROUP_FROZEN_SPLIT_LINE = "frozenSplitLine";

export declare const KEY_GROUP_GRID_GROUP = "gridGroup";

export declare const KEY_GROUP_MERGED_CELLS = "mergedCellsGroup";

export declare const KEY_GROUP_PANEL_FROZEN_BOTTOM = "frozenBottomGroup";

export declare const KEY_GROUP_PANEL_FROZEN_COL = "frozenColGroup";

export declare const KEY_GROUP_PANEL_FROZEN_ROW = "frozenRowGroup";

export declare const KEY_GROUP_PANEL_FROZEN_TOP = "frozenTopGroup";

export declare const KEY_GROUP_PANEL_FROZEN_TRAILING_COL = "frozenTrailingColGroup";

export declare const KEY_GROUP_PANEL_FROZEN_TRAILING_ROW = "frozenTrailingRowGroup";

export declare const KEY_GROUP_PANEL_GROUND = "panelGroup";

export declare const KEY_GROUP_PANEL_SCROLL = "panelScrollGroup";

export declare const KEY_GROUP_ROW_HEADER_FROZEN = "rowHeaderFrozenGroup";

export declare const KEY_GROUP_ROW_INDEX_RESIZE_AREA = "rowIndexResizeAreaGroup";

export declare const KEY_GROUP_ROW_RESIZE_AREA = "rowResizeAreaGroup";

export declare const KEY_GROUP_ROW_SCROLL = "rowScrollGroup";

export declare const KEY_SERIES_NUMBER_NODE = "series-number-node";

declare type KeyboardEventHandler = (event: KeyboardEvent) => void;

export declare function keyEqualTo(key: string, compareKey: string): boolean;

export declare type LangType = 'zh_CN' | 'en_US';

/** 布局采样数 */
export declare const LAYOUT_SAMPLE_COUNT = 50;

/**
 * determine the order of every row/column tree branch
 */
export declare type LayoutArrange = (spreadsheet: SpreadSheet, parent: Node_2, field: string, fieldValues: string[]) => string[];

export declare type LayoutArrangeCallback = (spreadsheet: SpreadSheet, parent: Node_2, field: string, fieldValues: string[]) => string[];

export declare type LayoutCallback = (spreadsheet: SpreadSheet, rowNode: Node_2, colNode: Node_2) => void;

export declare type LayoutCol = [number, string, string];

/**
 * determine the location(x,y,width,height eg..) of every node
 */
export declare type LayoutCoordinate = (spreadsheet: SpreadSheet, rowNode: Node_2, colNode: Node_2) => void;

/**
 * determine the data of cells in Cartesian coordinates
 */
export declare type LayoutDataPosition = (spreadsheet: SpreadSheet, getCellData: GetCellMeta) => GetCellMeta;

/**
 * determine what does row/column hierarchy look like
 * eg: add/delete some nodes in the specified position
 */
export declare type LayoutHierarchy = (spreadsheet: SpreadSheet, node: Node_2) => LayoutHierarchyReturnType;

export declare interface LayoutHierarchyReturnType {
    push?: Node_2[];
    unshift?: Node_2[];
    delete?: boolean;
}

export declare interface LayoutResult {
    colNodes: Node_2[];
    colsHierarchy: Hierarchy;
    rowNodes: Node_2[];
    rowsHierarchy: Hierarchy;
    rowLeafNodes: Node_2[];
    colLeafNodes: Node_2[];
    getCellMeta: GetCellMeta;
    spreadsheet: SpreadSheet;
}

export declare type LayoutRow = [number, string, string];

/**
 * 布局类型：
 * adaptive: 行列等宽，均分整个 canvas 画布宽度
 * colAdaptive：列等宽，行头紧凑布局，列等分画布宽度减去行头宽度的剩余宽度
 * compact：行列紧凑布局，指标维度少的时候无法布满整个画布
 */
export declare type LayoutWidthType = 'adaptive' | 'colAdaptive' | 'compact';

export declare enum LayoutWidthTypes {
    Adaptive = "adaptive",
    ColAdaptive = "colAdaptive",
    Compact = "compact"
}

export declare interface LineTheme {
    point?: {
        size: number;
        fill?: string;
        opacity?: number;
    };
    linkLine?: {
        size: number;
        fill?: string;
        opacity?: number;
    };
}

export declare interface ListSortParams {
    sortFieldId: string;
    sortMethod: string;
}

export declare type LocaleType = {
    [K in LangType]: Record<string, string>;
};

export declare type MappingDataItemCallback = (valueField: string, data: DataItem) => Record<string, string | number> | DataItem;

export declare type MappingFunction = (fieldValue: number | string, data: Record<string, any>) => MappingResult | null | undefined;

export declare interface MappingResult extends ValueRange {
    icon?: string;
    fill: string;
    isCompare?: boolean;
    /**
     * @description only used in background condition, when the background color is too light, the font color will be white
     * @version 1.34.0
     */
    intelligentReverseTextColor?: boolean;
    /**
     * @description custom the interval condition's width
     * @version 1.38.0
     */
    fieldValue?: number;
}

export declare type Margin = Padding;

declare type MatrixTransformer = (data: string[][]) => CopyableItem;

/**
 * 计算文本在画布中的宽度
 * @deprecated 已废弃，1.30.0 版本后移除。该方法计算宽度不准确，请使用 spreadsheet 实例上的同名方法
 */
export declare const measureTextWidth: ((text: number | string, font: unknown) => number) & MemoizedFunction;

/**
 * 追求性能，粗略的计算文本的宽高！
 *
 * 算法逻辑：
 * 计算一个字符串中，符号[0-255]，中文（其他）的个数
 * 然后分别乘以中文、符号的宽度
 * @param text
 * @param font
 * @deprecated 已废弃，1.30.0 版本后移除。该方法计算宽度不准确，请使用 spreadsheet 实例上的同名方法
 */
export declare const measureTextWidthRoughly: (text: any, font?: any) => number;

/**
 * draw the background of the merged cell
 * @param sheet the base sheet instance
 * @param cellsInfo
 * @param hideData
 */
export declare const mergeCell: (sheet: SpreadSheet, cellsInfo?: MergedCellInfo[], hideData?: boolean) => void;

export declare const mergeCellInfo: (cells: S2CellType[]) => TooltipData[];

/**
 * Cell for panelGroup area
 */
export declare class MergedCell extends DataCell {
    cells: S2CellType[];
    constructor(spreadsheet: SpreadSheet, cells: S2CellType[], meta?: ViewMeta);
    handleRestOptions(...[cells]: [S2CellType[]]): void;
    get cellType(): CellTypes;
    update(): void;
    protected initCell(): void;
    /**
     * Draw merged cells background
     */
    protected drawBackgroundShape(): void;
    /**
     * Render data text
     */
    drawTextShape(): void;
}

export declare type MergedCellCallback = (spreadsheet: SpreadSheet, cells: S2CellType[], meta?: ViewMeta) => MergedCell;

export declare class MergedCellClick extends BaseEvent implements BaseEventImplement {
    bindEvents(): void;
    private bindDataCellClick;
}

/**
 * 将 MergedCell 转换成 TempMergedCell
 * @param oldMergedCells
 * @constructor
 */
export declare const MergedCellConvertTempMergedCells: (oldMergedCells: MergedCell[]) => {
    cells: S2CellType<ViewMeta>[];
    viewMeta: ViewMeta;
}[];

/**
 * the index of rows or columns.
 */
export declare interface MergedCellInfo {
    colIndex?: number;
    rowIndex?: number;
    showText?: boolean;
}

/**
 * 合并 TempMergedCell, 通过 cell.viewMeta.id 判断 TempMergedCell 是否是同一个。
 * @param TempMergedCells
 * @param otherTempMergedCells
 */
export declare const mergeTempMergedCell: (TempMergedCells: TempMergedCell[], otherTempMergedCells: TempMergedCell[]) => TempMergedCell[];

export declare interface Meta {
    field?: string;
    name?: string;
    description?: string;
    formatter?: Formatter;
}

export declare const MIN_CELL_HEIGHT = 16;

export declare const MIN_CELL_WIDTH = 28;

export declare const MIN_DEVICE_PIXEL_RATIO = 1;

export declare type MiniChartData = BaseChartData | BulletValue;

export declare interface MiniChartTheme {
    line?: LineTheme;
    bar?: BarTheme;
    bullet?: BulletTheme;
    interval?: IntervalTheme;
}

/** mini 图类型 */
export declare enum MiniChartTypes {
    Line = "line",
    Bar = "bar",
    Bullet = "bullet"
}

declare type MouseEventHandler = (event: MouseEvent) => void;

export declare const MULTI_VALUE = "$$multi$$";

/** use for gridAnalysisSheet
 *  eg. { label: '余额女',
 values: [
 ['最近7天登端天数', 1, 3423423, 323],
 ['自然月新登用户数', 1, 3423423, 323],
 ['最近7天登端天数', 1, 3423423, 323],
 ['自然月新登用户数', 1, 3423423, 323],
 ],
 }
 */
export declare interface MultiData<T = SimpleDataItem[][] | MiniChartData> {
    values: T;
    originalValues?: T;
    label?: string;
    [key: string]: unknown;
}

export declare interface MultiDataParams {
    drillDownFields?: string[];
    queryType?: QueryDataType;
}

/**
 * Node for cornerHeader, colHeader, rowHeader
 */
declare class Node_2 {
    isTotalMeasure: boolean;
    constructor(cfg: BaseNodeConfig);
    /**
     * Get node's field path
     * eg: node.id = root[&]东北[&]黑龙江
     * => [area, province]
     * @param node
     */
    static getFieldPath(node: Node_2, isDrillDown?: boolean): string[];
    /**
     * Get all leaves in this node branch, eg:
     *        c1
     *    b1〈
     *        c2
     * a〈
     *        c3
     *    b2〈
     *        c4
     * get a branch's all leaves(c1~c4)
     * @param node
     */
    static getAllLeaveNodes(node: Node_2): Node_2[];
    /**
     * Get all children nodes in this node branch, eg:
     *        c1
     *    b1〈
     *        c2
     * a〈
     *        c3
     *    b2〈
     *        c4
     * get a branch's all nodes(c1~c4, b1, b2)
     * @param node
     */
    static getAllChildrenNodes(node: Node_2): Node_2[];
    /**
     * Get all children branch in this node branch, eg:
     *        c1
     *    b1〈
     *        c2
     * a〈
     *        c3
     *    b2〈
     *        c4
     * get all branch [[b1,c1],[b1,c2],[b2,c3],[b2,c4]]
     * @param parent
     */
    static getAllBranch(parent: Node_2): Node_2[][];
    id: string;
    x: number;
    y: number;
    width: number;
    height: number;
    label: string;
    key: string;
    value: string;
    colIndex: number;
    level: number;
    rowIndex: number;
    parent: Node_2;
    isLeaf: boolean;
    isTotals: boolean;
    colId: string;
    static blankNode(): Node_2;
    isCollapsed: boolean;
    children: Node_2[];
    padding: number;
    hierarchy: Hierarchy;
    isPivotMode: boolean;
    seriesNumberWidth: number;
    field: string;
    spreadsheet: SpreadSheet;
    query?: Record<string, any>;
    belongsCell?: S2CellType;
    inCollapseNode?: boolean;
    cornerType?: CornerNodeType;
    isGrandTotals?: boolean;
    isSubTotals?: boolean;
    isTotalRoot?: boolean;
    /**
     * @deprecated 已废弃, 该属性只记录相邻一级的隐藏信息，将会在未来版本中移除
     */
    hiddenChildNodeInfo?: HiddenColumnsInfo | null;
    extra?: Record<string, any>;
    [key: string]: any;
    static rootNode(): Node_2;
    toJSON(): Omit_2<this, "parent" | "hierarchy" | "spreadsheet" | "config">;
    getHeadLeafChild(): Node_2;
    /**
     * 获取树状模式下，当前节点以及其所有子节点的高度总和
     * */
    getTotalHeightForTreeHierarchy(): number;
}
export { Node_2 as Node }

export declare interface OffsetConfig {
    rowHeaderOffsetX?: {
        value: number | undefined;
        animate?: boolean;
    };
    offsetX?: {
        value: number | undefined;
        animate?: boolean;
    };
    offsetY?: {
        value: number | undefined;
        animate?: boolean;
    };
}

export declare type OnUpdateCells = (root: RootInteraction, defaultOnUpdateCells: () => void) => void;

export declare interface OrderOption {
    sortMethod: 'ASC' | 'DESC';
    type: 'globalAsc' | 'globalDesc' | 'groupAsc' | 'groupDesc' | 'none';
    name: string;
}

export declare const ORIGIN_FIELD = "$$origin$$";

export declare interface OriginalEvent extends GEvent {
    layerX: number;
    layerY: number;
}

export declare enum OriginEventType {
    MOUSE_DOWN = "mousedown",
    MOUSE_MOVE = "mousemove",
    MOUSE_OUT = "mouseout",
    MOUSE_LEAVE = "mouseleave",
    MOUSE_UP = "mouseup",
    KEY_DOWN = "keydown",
    KEY_UP = "keyup",
    CLICK = "click",
    HOVER = "hover",
    DOUBLE_CLICK = "dblclick",
    CONTEXT_MENU = "contextmenu"
}

export declare interface Padding {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
}

export declare const PADDING_DOWN = 2;

export declare const PADDING_LEFT = 3;

export declare const PADDING_RIGHT = 1;

export declare const PADDING_TOP = 0;

export declare interface Pagination {
    pageSize: number;
    current: number;
    total?: number;
}

export declare interface Palette extends PaletteMeta {
    basicColors: string[];
}

export declare const PALETTE_MAP: Record<string, Palette>;

export declare interface PaletteMeta {
    /** 主题色 */
    brandColor: string;
    /**
     * basicColors 与标准色卡 standardColors 数组下标的对应关系
     * @see generateStandardColors
     */
    basicColorRelations: Array<{
        basicColorIndex: number;
        standardColorIndex: number;
    }>;
    semanticColors: {
        red?: string;
        green?: string;
        yellow?: string;
        [key: string]: string;
    };
    others?: {
        [key: string]: string;
    };
}

export declare const PANEL_GROUP_FROZEN_GROUP_Z_INDEX = 2;

export declare const PANEL_GROUP_GROUP_CONTAINER_Z_INDEX = 1;

export declare const PANEL_GROUP_HOVER_BOX_GROUP_Z_INDEX = 1;

export declare const PANEL_GROUP_SCROLL_GROUP_Z_INDEX = 1;

declare class PanelBBox extends BaseBBox {
    calculateBBox(): void;
}

declare type PanelIndexes = {
    center: Indexes;
    frozenRow?: Indexes;
    frozenCol?: Indexes;
    frozenTrailingRow?: Indexes;
    frozenTrailingCol?: Indexes;
};

declare class PanelScrollGroup extends GridGroup {
    protected mergedCellsGroup: IGroup;
    constructor(cfg: any);
    protected initMergedCellsGroup(): void;
    updateMergedCells(): void;
    addMergeCell(mergeCell: MergedCell): void;
    update(gridInfo: GridInfo): void;
}

export declare interface PartDrillDownDataCache {
    rowId: string;
    drillLevel: number;
    drillField: string;
    drillData: Record<string, string | number>[];
}

export declare interface PartDrillDownFieldInLevel {
    drillField: string;
    drillLevel: number;
}

export declare type PickEssential<O> = {
    [K in keyof O as Pick<Partial<O>, K> extends Pick<O, K> ? never : K]: O[K];
};

export declare class PivotDataSet extends BaseDataSet {
    rowPivotMeta: PivotMeta;
    colPivotMeta: PivotMeta;
    sortedDimensionValues: SortedDimensionValues;
    getExistValuesByDataItem(data: DataType, values: string[]): string[];
    /**
     * When data related config changed, we need
     * 1、re-process config
     * 2、re-transform origin data
     * 3、sort and other things
     * @param dataCfg
     */
    setDataCfg(dataCfg: S2DataConfig): void;
    transformIndexesData(data: DataType[], rows: string[]): TransformResult;
    /**
     * Provide a way to append some drill-down data in indexesData
     * @param extraRowField
     * @param drillDownData
     * @param rowNode
     */
    transformDrillDownData(extraRowField: string, drillDownData: DataType[], rowNode: Node_2): void;
    /**
     * Clear drill down data by rowNodeId
     * rowNodeId is undefined => clear all
     * @param rowNodeId
     */
    clearDrillDownData(rowNodeId?: string): boolean;
    /**
     * 排序优先级：
     * 1、sortParams里的条件优先级高于原始数据
     * 2、sortParams多个item：按照顺序优先级，排在后面的优先级高
     * 3、item中多个条件：sortByField > sortFunc > sortBy > sortMethod
     */
    handleDimensionValuesSort: () => void;
    protected handlePivotMetaSort(sortFieldId: string, sortedDimensionValues: string[]): void;
    processDataCfg(dataCfg: S2DataConfig): S2DataConfig;
    protected getFieldsAndPivotMetaByField(field: string): {
        dimensions: string[];
        pivotMeta: PivotMeta;
    } | {
        dimensions?: undefined;
        pivotMeta?: undefined;
    };
    getDimensionValues(field: string, query?: Query): string[];
    getTotalValue(query: Query, totalStatus?: TotalStatus): {
        $$value$$: number;
    };
    getCellData(params: CellDataParams): DataType;
    getTotalStatus: (query: Query) => {
        isRowTotal: boolean;
        isRowSubTotal: boolean;
        isColTotal: boolean;
        isColSubTotal: boolean;
    };
    protected getQueryExtraFields(query: Query): any[];
    /**
     * 获取符合 query 的所有单元格数据，如果 query 为空，返回空数组
     * @param query
     * @param params 默认获取符合 query 的所有数据，包括小计总计等汇总数据；
     *               如果只希望获取明细数据，请使用 { queryType: QueryDataType.DetailOnly }
     */
    getMultiData(query: Query, params?: MultiDataParams): Data[];
    /**
     * 获取符合 query 的所有单元格数据，如果 query 为空，返回空数组
     * @deprecated 该入参形式已经被废弃，请替换为另一个入参形式
     * @param query
     * @param isTotals
     * @param isRow
     * @param drillDownFields
     * @param includeTotalData 用于标记是否包含汇总数据，例如在排序功能中需要汇总数据，在计算汇总值中只取明细数据
     */
    getMultiData(query: Query, isTotals?: boolean, isRow?: boolean, drillDownFields?: string[], includeTotalData?: boolean): Data[];
    getFieldFormatter(field: string, cellMeta?: ViewMeta): Formatter;
    private getFieldFormatterForTotalValue;
    /**
     * 自定义度量组位置值
     * @param customValueOrder 用户配置度量组位置，从 0 开始
     * @param fields Rows || Columns
     */
    private handleCustomMeasuresOrder;
    private isCustomMeasuresPosition;
    getRowData(cell: CellMeta): RowData;
}

export declare type PivotMeta = Map<string, PivotMetaValue>;

export declare type PivotMetaValue = {
    id: string;
    dimensions: string[];
    value: string;
    level: number;
    children: PivotMeta;
    childField?: string;
};

export declare class PivotRowHeader extends BaseFrozenRowHeader {
    createCellInstance(node: Node_2): RowCell;
}

export declare class PivotSheet extends SpreadSheet {
    getDataSet(options: S2Options): any;
    getContentHeight(): number;
    /**
     * Check if is pivot mode
     */
    isPivotMode(): boolean;
    /**
     * Check if is pivot mode
     */
    isTableMode(): boolean;
    /**
     * tree type must be in strategy mode
     */
    isHierarchyTreeType(): boolean;
    /**
     * Check whether scroll contains row header
     * For now contains row header in ListSheet mode by default
     */
    isScrollContainsRowHeader(): boolean;
    /**
     * Scroll Freeze Row Header
     */
    isFrozenRowHeader(): boolean;
    /**
     * Check if the value is in the columns
     */
    isValueInCols(): boolean;
    clearDrillDownData(rowNodeId?: string, preventRender?: boolean): void;
    protected getFacetCfgFromDataSetAndOptions(): SpreadSheetFacetCfg;
    protected buildFacet(): void;
    protected bindEvents(): void;
    protected handleRowCellCollapseTreeRows(data: RowCellCollapseTreeRowsType): void;
    protected handleTreeRowsCollapseAll(isCollapsed: boolean): void;
    groupSortByMethod(sortMethod: SortMethod, meta: Node_2): void;
    handleGroupSort(event: GEvent, meta: Node_2): void;
    protected initPanelGroupChildren(): void;
    protected isCellType(cell?: GEvent['target']): boolean;
}

declare interface PointObject {
    x: number;
    y: number;
}

export declare const PRECISION = 16;

export declare const processCopyData: (displayData: DataType[], cells: CellMeta[][], spreadsheet: SpreadSheet) => Copyable;

export declare const processSort: (params: SortActionParams) => string[];

export declare type Query = Record<string, any>;

export declare enum QueryDataType {
    All = "all",
    DetailOnly = "detailOnly"
}

export declare interface RangeColors {
    good: string;
    satisfactory: string;
    bad: string;
}

export declare class RangeSelection extends BaseEvent implements BaseEventImplement {
    private isRangeSelection;
    bindEvents(): void;
    reset(): void;
    private bindKeyboardDown;
    private bindKeyboardUp;
    private bindMouseMove;
    private bindColCellClick;
    private bindDataCellClick;
    private handleColClick;
    private handleSeriesNumberRowSelected;
    private handleRowSelected;
    private handleColSelected;
}

export declare interface ReachedBorderId {
    rowId?: string;
    colId?: string;
}

export declare interface Rect {
    maxX: number;
    minX: number;
    maxY: number;
    minY: number;
}

export declare const registerIcon: (name: string, svg: string) => void;

export declare function registerTransformer(type: CopyMIMEType, transformer: MatrixTransformer): void;

/**
 * remove unmergedCells Info, return new mergedCell info
 * @param removeMergedCell
 * @param mergedCellsInfo
 */
export declare const removeUnmergedCellsInfo: (removeMergedCell: MergedCell, mergedCellsInfo: MergedCellInfo[][]) => MergedCellInfo[][];

export declare function renderCircle(group: Group, attrs: ShapeAttrs): IShape;

export declare function renderIcon(group: Group, iconCfg: GuiIconCfg): GuiIcon;

export declare function renderLine(group: Group, coordinate: {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
}, lineStyle: ShapeAttrs): IShape;

export declare const renderMiniChart: (cell: S2CellType, data?: MiniChartData) => void;

export declare function renderPolygon(group: Group, attrs: ShapeAttrs): IShape;

export declare function renderPolyline(group: Group, attrs: ShapeAttrs): IShape;

export declare function renderRect(group: Group, attrs: ShapeAttrs, extraParams?: Omit<ShapeCfg, 'attrs'>): IShape;

export declare function renderText(group: Group, shapes: IShape[], x: number, y: number, text: string, textStyle: TextTheme, extraStyle?: ShapeAttrs, originalText?: string): IShape;

export declare function renderTreeIcon(group: Group, area: SimpleBBox, fill: string, isCollapse: boolean, onClick?: () => void): GuiIcon;

export declare const RESIZE_END_GUIDE_LINE_ID = "RESIZE_END_GUIDE_LINE";

export declare const RESIZE_MASK_ID = "RESIZE_MASK";

export declare const RESIZE_START_GUIDE_LINE_ID = "RESIZE_START_GUIDE_LINE";

export declare interface ResizeArea {
    size?: number;
    background?: string;
    guideLineColor?: string;
    guideLineDisableColor?: string;
    guideLineDash?: number[];
    backgroundOpacity?: number;
    interactionState?: InteractionState;
}

export declare enum ResizeAreaEffect {
    Field = "field",
    Cell = "cell",
    Tree = "tree",
    Series = "series"
}

export declare interface ResizeDetail {
    eventType: ResizeEvent;
    style?: Style;
    seriesNumberWidth?: number;
}

export declare enum ResizeDirectionType {
    Horizontal = "col",
    Vertical = "row"
}

export declare type ResizeEvent = S2Event.LAYOUT_RESIZE | S2Event.LAYOUT_RESIZE_SERIES_WIDTH | S2Event.LAYOUT_RESIZE_ROW_WIDTH | S2Event.LAYOUT_RESIZE_COL_WIDTH | S2Event.LAYOUT_RESIZE_ROW_HEIGHT | S2Event.LAYOUT_RESIZE_COL_HEIGHT | S2Event.LAYOUT_RESIZE_TREE_WIDTH;

export declare type ResizeGuideLinePath = [operation: 'M' | 'L', x: number, y: number];

export declare interface ResizeGuideLinePosition {
    start: {
        x: number;
        y: number;
    };
    end: {
        x: number;
        y: number;
    };
}

declare type ResizeHandler = (data: {
    info: ResizeInfo;
    style?: Style;
    seriesNumberWidth?: number;
}) => void;

export declare interface ResizeInfo {
    theme: ResizeArea;
    type: ResizeDirectionType;
    offsetX: number;
    offsetY: number;
    width: number;
    height: number;
    size: number;
    /** 改动影响区域 */
    effect: ResizeAreaEffect;
    isResizeArea?: boolean;
    /** 字段id */
    id?: string;
    /** 当前拖拽热区对应的节点信息 */
    meta: Node_2 | ViewMeta;
    /** 拖拽后的宽度 */
    resizedWidth?: number;
    /** 拖拽后的高度 */
    resizedHeight?: number;
}

export declare interface ResizeInteractionOptions {
    rowCellVertical?: boolean;
    cornerCellHorizontal?: boolean;
    colCellHorizontal?: boolean;
    colCellVertical?: boolean;
    rowResizeType?: ResizeType;
    disable?: (resizeInfo: ResizeInfo) => boolean;
    visible?: (cell: S2CellType) => boolean;
}

export declare interface ResizeParams {
    info: ResizeInfo;
    style: Style;
}

export declare interface ResizePosition {
    offsetX?: number;
    offsetY?: number;
    clientX?: number;
    clientY?: number;
}

export declare enum ResizeType {
    ALL = "all",
    CURRENT = "current"
}

export declare const REVERSE_FONT_COLOR = "#FFFFFF";

export declare const ROOT_BEGINNING_REGEX: RegExp;

export declare const ROOT_ID = "root";

export declare class RootInteraction {
    spreadsheet: SpreadSheet;
    interactions: Map<string, BaseEvent>;
    intercepts: Set<Intercept>;
    private hoverTimer;
    eventController: EventController;
    private defaultState;
    constructor(spreadsheet: SpreadSheet);
    destroy(): void;
    reset(): void;
    private onTriggerInteractionsResetEffect;
    setState(interactionStateInfo: InteractionStateInfo): void;
    getState(): InteractionStateInfo;
    setInteractedCells(cell: S2CellType): void;
    getInteractedCells(): S2CellType<ViewMeta>[];
    resetState(): void;
    getCurrentStateName(): InteractionStateName;
    isEqualStateName(stateName: InteractionStateName): boolean;
    private isStateOf;
    isSelectedState(): boolean;
    isAllSelectedState(): boolean;
    isHoverFocusState(): boolean;
    isHoverState(): boolean;
    isActiveCell(cell: S2CellType): boolean;
    isSelectedCell(cell: S2CellType): boolean;
    getCells(cellType?: CellTypes[]): CellMeta[];
    getActiveCells(): S2CellType[];
    clearStyleIndependent(): void;
    getPanelGroupAllUnSelectedDataCells(): DataCell[];
    getPanelGroupAllDataCells(): DataCell[];
    getAllRowHeaderCells(): RowCell[];
    getAllColHeaderCells(): ColCell[];
    getRowColActiveCells(ids: string[]): S2CellType<ViewMeta>[];
    getAllCells(): S2CellType<ViewMeta>[];
    selectAll: () => void;
    getCellChildrenNodes: (cell: S2CellType) => Node_2[];
    selectHeaderCell: (selectHeaderCellInfo?: SelectHeaderCellInfo) => boolean;
    highlightNodes: (nodes?: Node_2[]) => void;
    mergeCells: (cellsInfo?: MergedCellInfo[], hideData?: boolean) => void;
    unmergeCell: (removedCells: MergedCell) => void;
    hideColumns(hiddenColumnFields?: string[], forceRender?: boolean): void;
    private getBrushSelectionInfo;
    private getDefaultInteractions;
    private registerInteractions;
    private registerEventController;
    draw(): void;
    clearState(): void;
    changeState(interactionStateInfo: InteractionStateInfo): void;
    updatePanelGroupAllDataCells(): void;
    updateCells(cells?: S2CellType[]): void;
    addIntercepts(interceptTypes?: InterceptType[]): void;
    hasIntercepts(interceptTypes?: InterceptType[]): boolean;
    removeIntercepts(interceptTypes?: InterceptType[]): void;
    clearHoverTimer(): void;
    setHoverTimer(timer: number): void;
    getHoverTimer(): number;
    getSelectedCellHighlight(): InteractionCellHighlight;
    getHoverAfterScroll(): boolean;
    getHoverHighlight(): InteractionCellHighlight;
    getBrushSelection(): BrushSelection;
}

export declare class RowBrushSelection extends BaseBrushSelection {
    protected bindMouseDown(): void;
    protected isPointInCanvas(point: Point): boolean;
    protected bindMouseMove(): void;
    protected setDisplayedCells(): void;
    protected isInBrushRange: (meta: ViewMeta | Node_2) => boolean;
    protected updateSelectedCells(): void;
    protected addBrushIntercepts(): void;
    protected onUpdateCells: OnUpdateCells;
    private getSelectedRowNodes;
    private getScrollBrushRangeCells;
    /**
     * 行头的非叶子节点滚动刷选, 以当前节点所对应 [可视范围] 内叶子节点为基准
     * 例: 当前刷选 [浙江省] 行头的这一列, 向 🔽 滚动以 [纸张] 为准, 向 🔼滚动以 [桌子] 为准
     ---------------------------------------
     * |       | 杭州市 | 家具    | 🔼 [桌子]   |
     * |       |       |        | 沙发   |
     * |       |       | 办公用品 | 笔    |
     * |       |       |         | 纸张  |
     * | 浙江省 |       |         |      |
     * |       | 绍兴市 | 家具     | 桌子  |
     * |       |       |         | 沙发  |
     * |       |       | 办公用品 | 笔    |
     * |       |       |         | 🔽 [纸张] |
     * -------------------------------------
     */
    private getVisibleRowLeafCellByScrollDirection;
    protected getWillScrollToRowIndex: (dir: ScrollDirection) => number;
    protected getPrepareSelectMaskPosition(brushRange: BrushRange): Point;
}

/**
 * Adapting the frozen first row for cells pivot table
 */
export declare class RowCell extends BaseRowCell {
    /**
     * To indicate whether the current node is a frozen node
     *
     * PS: It is a specific config for the cell node, so it should not be extended in the headerConfig.
     */
    protected frozenRowCell: boolean;
    protected handleRestOptions(...[headerConfig, ...options]: [BaseHeaderConfig, boolean]): void;
    protected getAdjustTextAreaHeight(textArea: SimpleBBox, scrollY: number, viewportHeight: number): number;
    protected calculateTextY({ textArea, adjustTextAreaHeight, }: {
        textArea: SimpleBBox;
        adjustTextAreaHeight: number;
    }): number;
    protected getResizeClipAreaBBox(): SimpleBBox;
    private getFrozenFirstRowHeight;
}

export declare type RowCellCollapseTreeRowsType = {
    id: string;
    isCollapsed: boolean;
    node: Node_2;
};

export declare interface RowCfg {
    width?: CellCustomWidth;
    widthByField?: Record<string, number>;
    heightByField?: Record<string, number>;
    /**
     * @deprecated (已废弃, 请使用 style.treeRowsWidth 代替) tree row width(拖拽产生的，无需主动设置)
     */
    treeRowsWidth?: number;
}

export declare class RowColumnClick extends BaseEvent implements BaseEventImplement {
    private isMultiSelection;
    bindEvents(): void;
    reset(): void;
    private bindKeyboardDown;
    private bindKeyboardUp;
    private bindMouseMove;
    private bindRowCellClick;
    private bindColCellClick;
    private handleRowColClick;
    private showTooltip;
    private getTooltipOperator;
    private bindTableColExpand;
    private getHideColumnField;
    /**
     * 隐藏选中的列
     * 每次点击存储两个信息
     * 1. [hiddenColumnFields]: 当前选中 (单/多选) 的 field, 对应 dataCfg 里面的 column
     *    用于点击展开按钮后还原, 区别于 options.hiddenColumnFields, 这里需要分段存储, 比如现在有两个隐藏的列
     *    [1,2, (3隐藏), 4, 5, (6隐藏), 7]
     *    展开按钮在 4, 7, 点击任意按钮, 应该只展开所对应的那组 : 4 => [3], 7 => [6]
     * 2. [displaySiblingNode]: 当前这一组的列隐藏后, 需要将展开按钮显示到对应的兄弟节点
     * 这样不用每次 render 的时候实时计算, 渲染列头单元格 直接取数据即可
     */
    hideSelectedColumns(): void;
    private handleExpandIconClick;
}

export declare class RowColumnResize extends BaseEvent implements BaseEventImplement {
    private resizeTarget;
    resizeReferenceGroup: IGroup;
    resizeStartPosition: ResizePosition;
    bindEvents(): void;
    private initResizeGroup;
    private getResizeAreaTheme;
    private setResizeTarget;
    private getGuideLineWidthAndHeight;
    private getResizeShapes;
    private setResizeMaskCursor;
    private updateResizeGuideLinePosition;
    private bindMouseDown;
    private bindMouseMove;
    private getResizeGuideLinePosition;
    private getDisAllowResizeInfo;
    private getResizeWidthDetail;
    private getResizeHeightDetail;
    private getResizeDetail;
    private showResizeGroup;
    private hideResizeGroup;
    private bindMouseUp;
    private resizeMouseMove;
    private updateResizeGuideLineTheme;
    private updateHorizontalResizingEndGuideLinePosition;
    private updateVerticalResizingEndGuideLinePosition;
    private renderResizedResult;
    private getResizeInfo;
    private render;
}

export declare type RowData = Data | DataType;

/**
 * Row Header for SpreadSheet
 */
export declare class RowHeader extends BaseHeader<RowHeaderConfig> {
    private gm;
    constructor(cfg: RowHeaderConfig);
    destroy(): void;
    protected rowCellInRect(item: Node_2): boolean;
    createCellInstance(node: Node_2): RowCell;
    protected getCellGroup(node: Node_2): IGroup;
    protected getCustomRowCell(): CellCallback<RowHeaderConfig>;
    protected layout(): void;
    protected offset(): void;
    protected clip(): void;
}

export declare interface RowHeaderConfig extends BaseHeaderConfig {
    hierarchyType: S2Options['hierarchyType'];
    linkFields: string[] | ((meta: Node_2 | ViewMeta) => boolean);
    seriesNumberWidth: number;
}

/**
 * Row header click navigation interaction
 */
export declare class RowTextClick extends BaseEvent implements BaseEventImplement {
    bindEvents(): void;
    private bindRowCellClick;
    private getRowData;
}

export declare const S2_PREFIX_CLS = "antv-s2";

export declare interface S2BasicOptions<T = TooltipContentType, P = Pagination, Icon = Element | string, Text = string> {
    width?: number;
    height?: number;
    debug?: boolean;
    hierarchyType?: 'grid' | 'tree' | 'customTree';
    conditions?: Conditions;
    totals?: Totals;
    tooltip?: Tooltip<T, Icon, Text>;
    interaction?: InteractionOptions;
    pagination?: P;
    frozenRowHeader?: boolean;
    showSeriesNumber?: boolean;
    showDefaultHeaderActionIcon?: boolean;
    headerActionIcons?: HeaderActionIcon[];
    customSVGIcons?: CustomSVGIcon[];
    style?: Style;
    hdAdapter?: boolean;
    mergedCellsInfo?: MergedCellInfo[][];
    placeholder?: ((meta: Record<string, any>) => string) | string;
    cornerText?: string;
    cornerExtraFieldText?: string;
    supportCSSTransform?: boolean;
    devicePixelRatio?: number;
    /** ***********CUSTOM CELL/HEADER HOOKS**************** */
    dataCell?: DataCellCallback;
    cornerCell?: CellCallback<CornerHeaderConfig>;
    rowCell?: CellCallback<RowHeaderConfig>;
    colCell?: CellCallback<ColHeaderConfig>;
    mergedCell?: MergedCellCallback;
    frame?: FrameCallback;
    cornerHeader?: CornerHeaderCallback;
    /** ***********CUSTOM LIFECYCLE HOOKS**************** */
    layoutHierarchy?: LayoutHierarchy;
    layoutArrange?: LayoutArrange;
    layoutCoordinate?: LayoutCoordinate;
    layoutDataPosition?: LayoutDataPosition;
    /** ***********CUSTOM DATA CELL RENDER HOOKS**************** */
    filterDisplayDataItem?: FilterDataItemCallback;
    mappingDisplayDataItem?: MappingDataItemCallback;
}

export declare type S2CellType<T extends SimpleBBox = ViewMeta> = DataCell | HeaderCell | ColCell | CornerCell | RowCell | BaseRowCell | MergedCell | BaseCell<T>;

export declare interface S2DataConfig {
    data: Data[];
    totalData?: Data[];
    fields: Fields;
    meta?: Meta[];
    sortParams?: SortParams;
    filterParams?: FilterParam[];
    [key: string]: unknown;
}

export declare enum S2Event {
    /** ================ Row Cell ================  */
    ROW_CELL_HOVER = "row-cell:hover",
    ROW_CELL_CLICK = "row-cell:click",
    ROW_CELL_DOUBLE_CLICK = "row-cell:double-click",
    ROW_CELL_CONTEXT_MENU = "row-cell:context-menu",
    ROW_CELL_MOUSE_DOWN = "row-cell:mouse-down",
    ROW_CELL_MOUSE_UP = "row-cell:mouse-up",
    ROW_CELL_MOUSE_MOVE = "row-cell:mouse-move",
    ROW_CELL_COLLAPSE_TREE_ROWS = "row-cell:collapsed-tree-rows",
    ROW_CELL_SCROLL = "row-cell:scroll",
    ROW_CELL_BRUSH_SELECTION = "row-cell:brush-selection",
    /** ================ Col Cell ================  */
    COL_CELL_HOVER = "col-cell:hover",
    COL_CELL_CLICK = "col-cell:click",
    COL_CELL_DOUBLE_CLICK = "col-cell:double-click",
    COL_CELL_CONTEXT_MENU = "col-cell:context-menu",
    COL_CELL_MOUSE_DOWN = "col-cell:mouse-down",
    COL_CELL_MOUSE_UP = "col-cell:mouse-up",
    COL_CELL_MOUSE_MOVE = "col-cell:mouse-move",
    COL_CELL_BRUSH_SELECTION = "col-cell:brush-selection",
    /** ================ Data Cell ================  */
    DATA_CELL_HOVER = "data-cell:hover",
    DATA_CELL_CLICK = "data-cell:click",
    DATA_CELL_DOUBLE_CLICK = "data-cell:double-click",
    DATA_CELL_CONTEXT_MENU = "data-cell:context-menu",
    DATA_CELL_MOUSE_UP = "data-cell:mouse-up",
    DATA_CELL_MOUSE_DOWN = "data-cell:mouse-down",
    DATA_CELL_MOUSE_MOVE = "data-cell:mouse-move",
    DATA_CELL_TREND_ICON_CLICK = "data-cell:trend-icon-click",
    DATA_CELL_BRUSH_SELECTION = "data-cell:brush-selection",
    DATA_CELL_SELECT_MOVE = "data-cell:select-move",
    /** ================ Corner Cell ================  */
    CORNER_CELL_HOVER = "corner-cell:hover",
    CORNER_CELL_CLICK = "corner-cell:click",
    CORNER_CELL_DOUBLE_CLICK = "corner-cell:double-click",
    CORNER_CELL_CONTEXT_MENU = "corner-cell:context-menu",
    CORNER_CELL_MOUSE_DOWN = "corner-cell:mouse-down",
    CORNER_CELL_MOUSE_UP = "corner-cell:mouse-up",
    CORNER_CELL_MOUSE_MOVE = "corner-cell:mouse-move",
    /** ================ Merged Cells ================  */
    MERGED_CELLS_HOVER = "merged-cells:hover",
    MERGED_CELLS_CLICK = "merged-cells:click",
    MERGED_CELLS_DOUBLE_CLICK = "merged-cells:double-click",
    MERGED_CELLS_CONTEXT_MENU = "merged-cell:context-menu",
    MERGED_CELLS_MOUSE_DOWN = "merged-cells:mouse-down",
    MERGED_CELLS_MOUSE_UP = "merged-cells:mouse-up",
    MERGED_CELLS_MOUSE_MOVE = "merged-cells:mouse-move",
    /** ================ Sort ================  */
    RANGE_SORT = "sort:range-sort",
    RANGE_SORTED = "sort:range-sorted",
    /** ================ Table Filter ================  */
    RANGE_FILTER = "filter:range-filter",
    RANGE_FILTERED = "filter:range-filtered",
    /** ================ Table Layout ================  */
    LAYOUT_AFTER_HEADER_LAYOUT = "layout:after-header-layout",
    /** @deprecated 已废弃, 请使用 S2Event.GLOBAL_SCROLL 代替 */
    LAYOUT_CELL_SCROLL = "layout:cell-scroll",
    LAYOUT_PAGINATION = "layout:pagination",
    LAYOUT_COLLAPSE_ROWS = "layout:collapsed-rows",
    LAYOUT_AFTER_COLLAPSE_ROWS = "layout:after-collapsed-rows",
    LAYOUT_AFTER_REAL_DATA_CELL_RENDER = "layout:after-real-data-cell-render",
    LAYOUT_TREE_ROWS_COLLAPSE_ALL = "layout:toggle-collapse-all",
    LAYOUT_COLS_EXPANDED = "layout:table-col-expanded",
    LAYOUT_COLS_HIDDEN = "layout:table-col-hidden",
    LAYOUT_AFTER_RENDER = "layout:after-render",
    LAYOUT_BEFORE_RENDER = "layout:before-render",
    LAYOUT_DESTROY = "layout:destroy",
    /** ================ Table Layout Resize ================  */
    LAYOUT_RESIZE = "layout:resize",
    LAYOUT_RESIZE_SERIES_WIDTH = "layout:resize-series-width",
    LAYOUT_RESIZE_ROW_WIDTH = "layout:resize-row-width",
    LAYOUT_RESIZE_ROW_HEIGHT = "layout:resize-row-height",
    LAYOUT_RESIZE_COL_WIDTH = "layout:resize-column-width",
    LAYOUT_RESIZE_COL_HEIGHT = "layout:resize-column-height",
    LAYOUT_RESIZE_TREE_WIDTH = "layout:resize-tree-width",
    LAYOUT_RESIZE_MOUSE_DOWN = "layout:resize:mouse-down",
    LAYOUT_RESIZE_MOUSE_MOVE = "layout:resize:mouse-move",
    LAYOUT_RESIZE_MOUSE_UP = "layout:resize-mouse-up",
    /** ================ Global ================  */
    GLOBAL_KEYBOARD_DOWN = "global:keyboard-down",
    GLOBAL_KEYBOARD_UP = "global:keyboard-up",
    GLOBAL_COPIED = "global:copied",
    GLOBAL_MOUSE_UP = "global:mouse-up",
    GLOBAL_MOUSE_MOVE = "global:mouse-move",
    GLOBAL_ACTION_ICON_CLICK = "global:action-icon-click",
    GLOBAL_ACTION_ICON_HOVER = "global:action-icon-hover",
    GLOBAL_ACTION_ICON_HOVER_OFF = "global:action-icon-hover-off",
    GLOBAL_CONTEXT_MENU = "global:context-menu",
    GLOBAL_CLICK = "global:click",
    GLOBAL_DOUBLE_CLICK = "global:double-click",
    GLOBAL_SELECTED = "global:selected",
    GLOBAL_HOVER = "global:hover",
    GLOBAL_RESET = "global:reset",
    GLOBAL_LINK_FIELD_JUMP = "global:link-field-jump",
    GLOBAL_SCROLL = "global:scroll"
}

declare interface S2EventHandler {
    type: keyof EmitterType;
    handler: EmitterType[keyof EmitterType];
}

export declare type S2MountContainer = string | Element;

export declare interface S2Options<T = TooltipContentType, P = Pagination, Icon = Element | string, Text = string> extends S2BasicOptions<T, P, Icon, Text>, S2TableSheetOptions, S2PivotSheetOptions {
    dataSet?: (spreadsheet: SpreadSheet) => BaseDataSet;
}

export declare interface S2PivotSheetOptions {
    frozenFirstRow?: boolean;
}

export declare interface S2RenderOptions {
    reloadData?: boolean;
    reBuildDataSet?: boolean;
    reBuildHiddenColumnsDetail?: boolean;
}

export declare interface S2TableSheetOptions {
    frozenRowCount?: number;
    frozenColCount?: number;
    frozenTrailingRowCount?: number;
    frozenTrailingColCount?: number;
}

export declare interface S2Theme extends CellThemes {
    resizeArea?: ResizeArea;
    scrollBar?: ScrollBarTheme;
    splitLine?: SplitLine;
    prepareSelectMask?: InteractionStateTheme;
    background?: Background;
}

export declare const safeJsonParse: (val: string) => any;

/**
 *  坐标转换
 */
export declare const scale: (chartData: BaseChartData, cell: S2CellType) => {
    points: number[][];
    box: any[];
};

declare class ScrollBar extends Group {
    isHorizontal: boolean;
    trackLen: number;
    thumbLen: number;
    position: PointObject;
    thumbOffset: number;
    scrollTargetMaxOffset: number;
    theme: ScrollBarTheme;
    scrollBarGroup: IGroup;
    trackShape: IShape;
    thumbShape: IShape;
    private startPos;
    private isMobile;
    private clearEvents;
    private eventHandlers;
    private scrollFrameId;
    constructor(scrollBarCfg: ScrollBarCfg);
    private getCoordinatesName;
    /**
     * Antv/g 4.x 版本计算 bbox 有bug, 实际渲染的宽度会比给定的宽度大, 需要对其做修正
     * 详情: https://github.com/antvis/S2/pull/1566/files#diff-3f08348041906ddf1e4f094bfe2ac32b35ff668918d3fbb952e9227ae462cc08R52
     */
    private getCoordinatesWithBBoxExtraPadding;
    /**
     * 当前滑块滑动的位置 0 ~ 1
     */
    current: () => number;
    /**
     * 更新滑块长度
     * @param newThumbLen 新的滑道长度
     */
    updateThumbLen: (newThumbLen: number) => void;
    /**
     * 更新滑块的 offset 值
     * @param offset
     */
    updateThumbOffset: (offset: number, emitScrollChange?: boolean) => void;
    /**
     * 只更新位置属性，而不emit滚动事件
     * @param offset
     */
    onlyUpdateThumbOffset: (offset: number) => void;
    emitScrollChange: (offset: number, updateThumbOffset?: boolean) => void;
    protected addEventListener: (target: EventTarget, eventType: keyof HTMLElementEventMap, callback: EventListenerOrEventListenerObject) => EventListenerReturn;
    protected addEvent: (target: EventHandler_3['target'], type: EventHandler_3['type'], handler: EventHandler_3['handler']) => void;
    private initScrollBar;
    private createScrollBarGroup;
    private createTrackShape;
    private createThumbShape;
    private bindEvents;
    private onStartEvent;
    private bindLaterEvent;
    private onTrackClick;
    private onMouseMove;
    private onMouseUp;
    private onTrackMouseOver;
    private onTrackMouseOut;
    private validateRange;
}

declare interface ScrollBarCfg {
    readonly isHorizontal?: boolean;
    readonly trackLen: number;
    readonly thumbLen: number;
    readonly position: PointObject;
    readonly thumbOffset?: number;
    readonly scrollTargetMaxOffset: number;
    readonly theme?: ScrollBarTheme;
}

export declare enum ScrollbarPositionType {
    CONTENT = "content",
    CANVAS = "canvas"
}

export declare interface ScrollBarTheme {
    trackColor?: string;
    thumbHoverColor?: string;
    thumbColor?: string;
    thumbHorizontalMinSize?: number;
    thumbVerticalMinSize?: number;
    size?: number;
    hoverSize?: number;
    /** 指定如何绘制每一条线段末端，lineCap?: 'butt' | 'round' | 'square'; */
    lineCap?: ShapeAttrs['lineCap'];
}

export declare enum ScrollDirection {
    SCROLL_UP = "scrollUp",
    SCROLL_DOWN = "scrollDown"
}

export declare enum ScrollDirectionRowIndexDiff {
    SCROLL_UP = -1,
    SCROLL_DOWN = 1
}

export declare interface ScrollOffset {
    scrollX?: number;
    scrollY?: number;
    rowHeaderScrollX?: number;
}

export declare interface ScrollSpeedRatio {
    horizontal?: number;
    vertical?: number;
}

export declare const selectCells: (spreadsheet: SpreadSheet, cells: CellMeta[]) => void;

export declare interface Selected {
    type: 'cell' | 'row' | 'brush' | 'col' | 'column' | 'row&col' | 'column-multiple';
    indexes: [number | number[], number | number[]];
}

export declare class SelectedCellMove extends BaseEvent implements BaseEventImplement {
    startCell: CellMeta | null;
    endCell: CellMeta | null;
    constructor(spreadsheet: SpreadSheet);
    private isCanvasEffect;
    bindEvents(): void;
    private getCellMetaFromViewMeta;
    private handleMove;
    private generateCellMeta;
    private getRangeCells;
    private getMoveInfo;
    private calculateOffset;
    scrollToActiveCell(spreadsheet: SpreadSheet, rowIndex: number, colIndex: number): void;
}

declare type SelectedHandler = (cells: S2CellType[]) => void;

export declare interface SelectHeaderCellInfo {
    cell: S2CellType<ViewMeta>;
    isMultiSelection?: boolean;
}

export declare const SERIES_NUMBER_FIELD = "$$series_number$$";

export declare class SeriesNumberCell extends RowCell {
    protected initCell(): void;
    protected getTextStyle(): TextTheme;
    protected getTextPosition(): Point;
    protected getActionIconsCount(): number;
    getIconStyle(): IconTheme;
    protected drawResizeAreaInLeaf(): void;
    update(): void;
    findFieldCondition(): Condition | undefined;
    mappingValue(): MappingResult | undefined;
}

export declare class SeriesNumberHeader extends BaseFrozenRowHeader {
    /**
     * Get seriesNumber header by config
     * @param viewportBBox
     * @param seriesNumberWidth
     * @param leafNodes
     * @param spreadsheet
     * @param cornerWidth
     */
    static getSeriesNumberHeader({ viewportBBox, seriesNumberWidth, leafNodes, spreadsheet, cornerWidth, }: {
        viewportBBox: PanelBBox;
        seriesNumberWidth: number;
        leafNodes: Node_2[];
        spreadsheet: SpreadSheet;
        cornerWidth: number;
    }): SeriesNumberHeader;
    createCellInstance(node: Node_2): RowCell;
    protected getCustomRowCell(): any;
}

/**
 * 设置语言
 * @param lang
 */
export declare const setLang: (langType: LangType) => void;

/**
 * @desc set the interaction state information
 * @param spreadsheet sheet instance
 * @param interactionStateInfo
 */
export declare const setState: (spreadsheet: SpreadSheet, interactionStateInfo: InteractionStateInfo) => void;

export declare const setTooltipContainerStyle: (container: HTMLElement, options: {
    visible?: boolean;
    style?: CSS_2.Properties;
    className?: string[];
}) => void;

export declare const SHAPE_ATTRS_MAP: {
    textShape: string[];
    textShapes: string[];
    linkFieldShape: string[];
    interactiveBgShape: string[];
    interactiveBorderShape: string[];
};

export declare const SHAPE_STYLE_MAP: {
    textOpacity: string;
    backgroundOpacity: string;
    backgroundColor: string;
    borderOpacity: string;
    borderColor: string;
    borderWidth: string;
    opacity: string;
};

/**
 * 智能反色使用
 * @param color
 */
export declare const shouldReverseFontColor: (color: string) => boolean;

export declare const shouldUpdateBySelectedCellsHighlight: (s2: SpreadSheet) => boolean;

export declare type SimpleDataItem = string | number;

export declare interface Sort {
    /** 字段id，业务中一般是displayId */
    sortFieldId: string;
    sortMethod?: SortMethod;
    /** 自定义排序 */
    sortBy?: string[];
    /** 按照数值字段排序 */
    sortByMeasure?: string;
    /** 筛选条件，缩小排序范围 */
    query?: Record<string, any>;
    /** 组内排序用来显示icon */
    type?: string;
}

/**
 * 执行排序
 * @param list - 待排序数组
 * @param sortMethod - 升、降序
 * @param key - 根据key数值排序，如果有key代表根据维度值排序，故按数字排，如果没有按照字典排
 */
export declare const sortAction: (list: Array<string | number | DataType>, sortMethod?: SortMethod, key?: string) => (string | number | DataType)[];

export declare interface SortActionParams {
    dataSet?: BaseDataSet;
    sortParam?: SortParam;
    originValues?: string[];
    measureValues?: string[] | DataType[];
    sortByValues?: string[];
    isSortByMeasure?: boolean;
}

export declare const sortByCustom: (params: SortActionParams) => string[];

export declare const sortByFunc: (params: SortActionParams) => string[];

export declare const sortByMethod: (params: SortActionParams) => string[];

export declare type SortedDimensionValues = Record<string, string[]>;

declare type SortedHandler = (rangeData: Data[]) => any;

export declare interface SortFuncParam extends Sort {
    data: Array<string | Record<string, any>>;
}

export declare type SortMethod = 'ASC' | 'DESC' | 'asc' | 'desc';

export declare enum SortMethodType {
    ASC = "ASC",
    DESC = "DESC"
}

export declare interface SortParam extends Sort {
    /** 自定义func */
    sortFunc?: (v: SortFuncParam) => Array<string | Record<string, any>>;
}

export declare type SortParams = SortParam[];

export declare interface SortPivotMetaParams {
    pivotMeta: PivotMeta;
    dimensions: string[];
    sortedDimensionValues: string[];
    sortFieldId: string;
}

export declare interface SplitLine {
    horizontalBorderColor?: string;
    horizontalBorderColorOpacity?: number;
    horizontalBorderWidth?: number;
    verticalBorderColor?: string;
    verticalBorderColorOpacity?: number;
    verticalBorderWidth?: number;
    showShadow?: boolean;
    shadowWidth?: number;
    shadowColors?: {
        left: string;
        right: string;
    };
    /** 分割线虚线 */
    borderDash?: number[];
}

export declare abstract class SpreadSheet extends EE {
    theme: S2Theme;
    store: Store;
    dataCfg: S2DataConfig;
    options: S2Options;
    /**
     * processed data structure, include {@link Fields}, {@link Meta}
     * {@link Data}, {@link SortParams}
     */
    dataSet: BaseDataSet;
    /**
     * Facet: determine how to render headers/cell
     */
    facet: BaseFacet;
    tooltip: BaseTooltip;
    container: Canvas;
    backgroundGroup: IGroup;
    panelGroup: IGroup;
    panelScrollGroup: PanelScrollGroup;
    frozenRowGroup: FrozenGroup_2;
    frozenColGroup: FrozenGroup_2;
    frozenTrailingRowGroup: FrozenGroup_2;
    frozenTrailingColGroup: FrozenGroup_2;
    frozenTopGroup: FrozenGroup_2;
    frozenBottomGroup: FrozenGroup_2;
    foregroundGroup: IGroup;
    interaction: RootInteraction;
    hdAdapter: HdAdapter;
    private untypedOn;
    private untypedEmit;
    on: <K extends keyof EmitterType>(event: K, listener: EmitterType[K]) => this;
    emit: <K extends keyof EmitterType>(event: K, ...args: Parameters<EmitterType[K]>) => boolean;
    constructor(dom: S2MountContainer, dataCfg: S2DataConfig, options: S2Options);
    private setOverscrollBehavior;
    private restoreOverscrollBehavior;
    private setDebug;
    private initTheme;
    private getMountContainer;
    private initHdAdapter;
    private initInteraction;
    private initTooltip;
    private renderTooltip;
    protected abstract bindEvents(): void;
    abstract getDataSet(options: S2Options): BaseDataSet;
    /**
     * Check if is pivot mode
     */
    abstract isPivotMode(): boolean;
    /**
     * tree type must be in strategy mode
     */
    abstract isHierarchyTreeType(): boolean;
    /**
     * Check whether scroll contains row header
     * For now contains row header in ListSheet mode by default
     */
    abstract isScrollContainsRowHeader(): boolean;
    /**
     * Scroll Freeze Row Header
     */
    abstract isFrozenRowHeader(): boolean;
    /**
     * Check if is pivot mode
     */
    abstract isTableMode(): boolean;
    /**
     * Check if the value is in the columns
     */
    abstract isValueInCols(): boolean;
    /**
     * 避免每次新增、变更dataSet和options时，生成SpreadSheetFacetCfg
     * 要多出定义匹配的问题，直接按需&部分拆分options/dataSet合并为facetCfg
     */
    protected abstract getFacetCfgFromDataSetAndOptions(): SpreadSheetFacetCfg;
    protected abstract buildFacet(): void;
    abstract clearDrillDownData(rowNodeId?: string, preventRender?: boolean): void;
    abstract handleGroupSort(event: GEvent, meta: Node_2): void;
    showTooltip<T = TooltipContentType>(showOptions: TooltipShowOptions<T>): void;
    showTooltipWithInfo(event: GEvent | MouseEvent, cellInfos: TooltipData[], options?: TooltipOptions): void;
    hideTooltip(): void;
    destroyTooltip(): void;
    registerIcons(): void;
    /**
     * Update data config and keep pre-sort operations
     * Group sort params kept in {@see store} and
     * Priority: group sort > advanced sort
     * @param dataCfg
     * @param reset 是否使用传入的 dataCfg 重置已保存的 dataCfg
     *
     * @example setDataCfg(dataCfg, true) 直接使用传入的 DataCfg，不再与上次数据进行合并
     */
    setDataCfg<T extends boolean = false>(dataCfg: T extends true ? S2DataConfig : Partial<S2DataConfig>, reset?: T): void;
    setOptions(options: Partial<S2Options>, reset?: boolean): void;
    /**
     * 配置都是 merge 操作, 但是隐藏列配置比较特殊, 变更时, 应该是全量覆盖, 而不应该是合并
     * https://github.com/antvis/S2/issues/2495
     */
    private resetHiddenColumnsDetailInfoIfNeeded;
    render(reloadData?: boolean, options?: S2RenderOptions): void;
    destroy(): void;
    setThemeCfg(themeCfg?: ThemeCfg): void;
    setTheme(theme: S2Theme): void;
    /**
     * Update pagination config which store in {@see options}
     * @param pagination
     */
    updatePagination(pagination: Pagination): void;
    /**
     * 获取当前表格实际内容高度
     */
    getContentHeight(): number;
    /**
     * @param width
     * @param height
     * @deprecated 该方法将会在2.0被移除, 请使用 changeSheetSize 代替
     */
    changeSize(width?: number, height?: number): void;
    /**
     * 修改表格画布大小，不用重新加载数据
     * @param width
     * @param height
     */
    changeSheetSize(width?: number, height?: number): void;
    /**
     * 获取 <canvas/> HTML元素
     */
    getCanvasElement(): HTMLCanvasElement;
    getLayoutWidthType(): LayoutWidthType;
    getRowNodes(level?: number): Node_2[];
    getRowLeafNodes(): Node_2[];
    /**
     * get columnNode in levels,
     * @param level -1 = get all
     */
    getColumnNodes(level?: number): Node_2[];
    getColumnLeafNodes(): Node_2[];
    /**
     * Update scroll's offset, the value can be undefined,
     * indicate not update current value
     * @param offsetConfig
     * default offsetX(horizontal scroll need animation)
     * but offsetY(vertical scroll don't need animation)
     */
    updateScrollOffset(offsetConfig: OffsetConfig): void;
    getTooltipDataItemMappingCallback(): MappingDataItemCallback;
    protected isCellType(cell?: GEvent['target']): boolean;
    getCell<T extends S2CellType = S2CellType>(target: GEvent['target']): T;
    getCellType(target: GEvent['target']): CellTypes;
    /**
     * get total's config by dimension id
     * @param dimension unique dimension id
     */
    getTotalsConfig(dimension: string): Partial<Totals['row']>;
    /**
     * Create all related groups, contains:
     * 1. container -- base canvas group
     * 2. backgroundGroup
     * 3. panelGroup -- main facet group belongs to
     * 4. foregroundGroup
     * @param dom
     * @private
     */
    protected initGroups(dom: S2MountContainer): void;
    protected updateContainerStyle(): void;
    protected initPanelGroupChildren(): void;
    getInitColumnLeafNodes(): Node_2[];
    /**
     * @deprecated 已废弃, 请使用 clearInitColumnLeafNodes
     */
    clearColumnLeafNodes(): void;
    clearInitColumnLeafNodes(): void;
    private initHiddenColumnsDetail;
    private clearCanvasEvent;
    /**
     * 获取文本在画布中的测量信息
     * @param text 待计算的文本
     * @param font 文本 css 样式
     * @returns 文本测量信息 TextMetrics
     */
    measureText: ((text: number | string, font: unknown) => TextMetrics) & MemoizedFunction;
    /**
     * 计算文本在画布中的宽度
     * @param text 待计算的文本
     * @param font 文本 css 样式
     * @returns 文本宽度
     */
    measureTextWidth: (text: number | string, font: unknown) => number;
    /**
     * 计算文本在画布中的宽度 https://developer.mozilla.org/zh-CN/docs/Web/API/TextMetrics
     * @param text 待计算的文本
     * @param font 文本 css 样式
     * @returns 文本高度
     */
    measureTextHeight: (text: number | string, font: unknown) => number;
    /**
     * 粗略计算文本在画布中的宽度
     * @param text 待计算的文本
     * @param font 文本 css 样式
     * @returns 文本宽度
     */
    measureTextWidthRoughly: (text: any, font?: any) => number;
    updateSortMethodMap(nodeId: string, sortMethod: SortMethod, replace?: boolean): void;
    getMenuDefaultSelectedKeys(nodeId: string): string[];
}

/**
 * Spreadsheet facet config
 */
export declare interface SpreadSheetFacetCfg extends Fields, S2BasicOptions, S2TableSheetOptions, Style {
    spreadsheet: SpreadSheet;
    dataSet: BaseDataSet;
    meta?: Meta[];
}

export declare const SQUARE_LINE_CAP = "square";

export declare type StateShapeLayer = 'interactiveBgShape' | 'interactiveBorderShape';

/**
 * Store something in {@link SpreadSheet} temporary along with it's lifecycle
 * All the keys need be declare in {@see StoreKey} first
 */
export declare class Store {
    private store;
    set<T extends keyof StoreKey>(key: T, value: StoreKey[T]): Map<keyof StoreKey, unknown>;
    get<T extends keyof StoreKey>(key: T, defaultValue?: StoreKey[T]): StoreKey[T];
    clear(): void;
    size(): number;
}

/**
 * All stored keys need type define here
 */
export declare interface StoreKey {
    scrollX: number;
    scrollY: number;
    rowHeaderScrollX: number;
    sortParam: SortParam;
    drillDownIdPathMap: Map<string, number[][]>;
    drillDownNode: Node_2;
    drillItemsNum: number;
    drillDownFieldInLevel: PartDrillDownFieldInLevel[];
    interactionStateInfo: InteractionStateInfo;
    originalDataCfg: Partial<S2DataConfig>;
    panelBBox: BBox;
    activeResizeArea: Group;
    valueRanges: ValueRanges;
    initColumnLeafNodes: Node_2[];
    /**
     * 隐藏列详情
     *  | a, b, [c,d 隐藏] [icon e ] , [f 隐藏], [icon g]   |
     */
    hiddenColumnsDetail: HiddenColumnsInfo[];
    lastRenderedColumnFields: string[];
    resized: boolean;
    visibleActionIcons: GuiIcon[];
    lastClickedCell: S2CellType<ViewMeta>;
    initOverscrollBehavior: InteractionOptions['overscrollBehavior'];
    sortMethodMap: Record<string, SortMethod>;
    [key: string]: unknown;
}

export declare interface Style {
    layoutWidthType?: LayoutWidthType;
    showTreeLeafNodeAlignDot?: boolean;
    treeRowsWidth?: number;
    hierarchyCollapse?: boolean;
    rowExpandDepth?: number;
    collapsedRows?: Record<string, boolean>;
    collapsedCols?: Record<string, boolean>;
    cellCfg?: CellCfg;
    colCfg?: ColCfg;
    rowCfg?: RowCfg;
    device?: 'pc' | 'mobile';
}

export declare interface SummaryParam extends TooltipDataParams {
    cellInfos?: TooltipDataItem[];
}

export declare const TABLE_COL_HORIZONTAL_RESIZE_AREA_KEY = "table-col-horizontal-resize-area";

export declare class TableColCell extends ColCell {
    protected handleRestOptions(...[headerConfig]: [any]): void;
    protected isFrozenCell(): boolean;
    protected getFormattedFieldValue(): FormatResult;
    protected shouldAddVerticalResizeArea(): boolean;
    protected getVerticalResizeAreaOffset(): {
        x: number;
        y: number;
    };
    protected getColResizeArea(): Group | IGroup;
    protected isSortCell(): boolean;
    protected showSortIcon(): boolean;
    protected getTextStyle(): TextTheme;
    getContentArea(): {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    protected getHorizontalResizeAreaName(): string;
    protected drawBackgroundShape(): void;
}

export declare class TableCornerCell extends TableColCell {
    getStyle(name?: string): any;
    protected showSortIcon(): boolean;
    protected drawLeftBorder(): void;
    protected drawBorders(): void;
}

export declare class TableDataCell extends DataCell {
    protected getLinkFieldStyle(): string;
    protected drawBorderShape(): void;
    shouldDrawResizeArea(): boolean;
    drawResizeArea(): void;
}

export declare class TableDataSet extends BaseDataSet {
    protected displayData: DataType[];
    processDataCfg(dataCfg: S2DataConfig): S2DataConfig;
    setDataCfg(dataCfg: S2DataConfig): void;
    /**
     * 返回顶部冻结行
     * @returns
     */
    protected getStartFrozenRows(displayData: DataType[]): DataType[];
    /**
     * 返回底部冻结行
     * @returns
     */
    protected getEndFrozenRows(displayData: DataType[]): DataType[];
    protected getDisplayData(displayData: DataType[]): DataType[];
    handleDimensionValueFilter: () => void;
    handleDimensionValuesSort: () => void;
    getDimensionValues(): string[];
    getCellData({ query }: CellDataParams): DataType;
    getMultiData(query: Query): DataType[];
    getRowData(cell: CellMeta): RowData;
}

declare interface TableHeaderParams {
    parentNode: Node_2;
    facetCfg: SpreadSheetFacetCfg;
    hierarchy: Hierarchy;
}

export declare class TableSeriesCell extends TableDataCell {
    get cellType(): CellTypes;
    protected getTextStyle(): TextTheme;
}

export declare class TableSheet extends SpreadSheet {
    getDataSet(options: S2Options): any;
    /**
     * Check if is pivot mode
     */
    isPivotMode(): boolean;
    /**
     * Check if is pivot mode
     */
    isTableMode(): boolean;
    /**
     * tree type must be in strategy mode
     */
    isHierarchyTreeType(): boolean;
    /**
     * Check whether scroll contains row header
     * For now contains row header in ListSheet mode by default
     */
    isScrollContainsRowHeader(): boolean;
    /**
     * Scroll Freeze Row Header
     */
    isFrozenRowHeader(): boolean;
    clearDrillDownData(): void;
    /**
     * Check if the value is in the columns
     */
    isValueInCols(): boolean;
    protected bindEvents(): void;
    protected initPanelGroupChildren(): void;
    protected getFacetCfgFromDataSetAndOptions(): SpreadSheetFacetCfg;
    protected buildFacet(): void;
    protected clearFrozenGroups(): void;
    destroy(): void;
    onSortTooltipClick: ({ key }: {
        key: SortMethod;
    }, meta: Node_2) => void;
    handleGroupSort(event: GEvent, meta: Node_2): void;
}

export declare interface TableSortParam extends SortParam {
    sortKey: string;
}

export declare interface TargetCellInfo {
    target: S2CellType;
    event: GEvent;
    viewMeta: Node_2;
}

/**
 * the data cell and meta that make up the mergedCell, temporary use
 */
export declare type TempMergedCell = {
    cells: S2CellType[];
    viewMeta: ViewMeta;
};

export declare type TextAlign = 'left' | 'center' | 'right';

export declare interface TextAlignCfg {
    textAlign?: TextAlign;
    textBaseline?: TextBaseline;
}

export declare type TextBaseline = 'top' | 'middle' | 'bottom';

export declare interface TextTheme extends TextAlignCfg, Pick<ShapeAttrs, 'fontStyle' | 'fontVariant'> {
    fontFamily?: string;
    fontSize?: number;
    fontWeight?: number | 'normal' | 'bold' | 'bolder' | 'lighter';
    fill?: string;
    linkTextFill?: string;
    opacity?: number;
}

export declare interface ThemeCfg {
    theme?: S2Theme;
    palette?: Pick<Palette, 'basicColors' | 'semanticColors' | 'others'>;
    name?: ThemeName;
}

export declare type ThemeName = 'default' | 'colorful' | 'gray';

export declare interface Tooltip<T = TooltipContentType, Icon = Element | string, Text = string> extends BaseTooltipConfig<T, Icon, Text> {
    row?: BaseTooltipConfig<T, Icon, Text>;
    col?: BaseTooltipConfig<T, Icon, Text>;
    corner?: BaseTooltipConfig<T, Icon, Text>;
    data?: BaseTooltipConfig<T, Icon, Text>;
}

export declare const TOOLTIP_CONTAINER_CLS: string;

export declare const TOOLTIP_CONTAINER_HIDE_CLS: string;

export declare const TOOLTIP_CONTAINER_SHOW_CLS: string;

export declare const TOOLTIP_OPERATION_PREFIX_CLS: string;

export declare const TOOLTIP_POSITION_OFFSET: TooltipPosition;

export declare const TOOLTIP_PREFIX_CLS: string;

export declare type TooltipAutoAdjustBoundary = 'body' | 'container';

export declare type TooltipContentType = Element | string;

export declare type TooltipData = {
    summaries?: TooltipSummaryOptions[];
    details?: TooltipDetailListItem[];
    headInfo?: TooltipHeadInfo;
    name?: string;
    tips?: string;
    infos?: string;
    interpretation?: TooltipInterpretationOptions;
    colIndex?: number;
    rowIndex?: number;
    description?: string;
};

export declare type TooltipDataItem = Record<string, any>;

export declare interface TooltipDataParam extends TooltipDataParams {
    cellInfos: TooltipDataItem[];
}

export declare type TooltipDataParams = {
    spreadsheet: SpreadSheet;
    options?: TooltipOptions;
    targetCell: S2CellType;
};

export declare type TooltipDetailListItem = {
    name: string;
    value: string | number;
    icon?: Element | string;
};

export declare type TooltipDetailProps = {
    list: TooltipDetailListItem[];
};

export declare type TooltipHeadInfo = {
    rows: TooltipDetailListItem[];
    cols: TooltipDetailListItem[];
};

export declare type TooltipInterpretationOptions = {
    name: string;
    icon?: Element | string;
    text?: string;
    render?: Element | string;
};

export declare interface TooltipNameTipsOptions {
    name?: string;
    tips?: string;
}

export declare interface TooltipOperation<Icon = Element | string, Text = string> extends TooltipOperatorOptions<Icon, Text> {
    hiddenColumns?: boolean;
    trend?: boolean;
    sort?: boolean;
    tableSort?: boolean;
}

export declare interface TooltipOperationOptions {
    plot: SpreadSheet;
    sortFieldId: string;
    sortQuery: {
        [key: string]: string;
    };
}

export declare interface TooltipOperationState {
    sortParam: SortParam;
}

export declare interface TooltipOperatorMenu<Icon = Element | string, Text = string> {
    key: string;
    icon?: Icon;
    text?: Text;
    onClick?: (cell: S2CellType) => void;
    visible?: boolean | ((cell: S2CellType) => boolean);
    children?: TooltipOperatorMenu<Icon, Text>[];
}

export declare interface TooltipOperatorOptions<Icon = Element | string, Text = string> {
    onClick?: (...args: unknown[]) => void;
    menus?: TooltipOperatorMenu<Icon, Text>[];
    defaultSelectedKeys?: string[];
}

export declare interface TooltipOptions<Icon = Element | string, Text = string> {
    hideSummary?: boolean;
    operator?: TooltipOperatorOptions<Icon, Text>;
    enterable?: boolean;
    isTotals?: boolean;
    showSingleTips?: boolean;
    onlyMenu?: boolean;
    enableFormat?: boolean;
    forceRender?: boolean;
    data?: TooltipData;
}

export declare interface TooltipPosition {
    x: number;
    y: number;
}

export declare interface TooltipPositionInfo {
    position: TooltipPosition;
    event: GEvent | MouseEvent;
}

export declare type TooltipShowOptions<T = TooltipContentType, Icon = Element | string, Text = string> = {
    position: TooltipPosition;
    data?: TooltipData;
    cellInfos?: TooltipDataItem[];
    options?: TooltipOptions<Icon, Text>;
    content?: ((cell: S2CellType, defaultTooltipShowOptions: TooltipShowOptions<T, Icon, Text>) => T) | T;
    event?: GEvent | MouseEvent;
};

export declare interface TooltipSummaryOptions {
    name: string | null;
    selectedData: TooltipDataItem[];
    value: TooltipSummaryOptionsValue;
    originValue?: TooltipSummaryOptionsValue;
}

export declare type TooltipSummaryOptionsValue = number | string | undefined | null;

export declare interface TooltipSummaryProps {
    summaries: TooltipSummaryOptions[];
}

export declare interface Total {
    /** 是否显示总计 */
    showGrandTotals: boolean;
    /** 是否显示小计 */
    showSubTotals: boolean | {
        /** 当子维度个数 <=1 时，仍然展示小计：默认 true */
        always: boolean;
    };
    calcTotals?: CalcTotals;
    calcSubTotals?: CalcTotals;
    /** 小计的汇总维度 */
    subTotalsDimensions: string[];
    /** 总计布局位置，默认是下或右 */
    reverseLayout: boolean;
    /** 小计布局位置，默认下或者右 */
    reverseSubLayout: boolean;
    label?: string;
    subLabel?: string;
    /** 总计分组维度 */
    totalsGroupDimensions?: string[];
    /** 小计分组维度 */
    subTotalsGroupDimensions?: string[];
}

export declare const TOTAL_VALUE = "$$total$$";

/**
 * tableau的英文是这个，这里有个绕的概念
 * 如，某行维度需要展示小计，实际上是将对应的一列数据进行聚合，所以文案上显示的应该是“展示列小计”
 * 但是内部配置我倾向于仍然按照字段所属维度区，即配置的row，代表的是行维度而不是行小计
 */
export declare interface Totals {
    row?: Partial<Total>;
    col?: Partial<Total>;
}

export declare interface TotalsStatus {
    isRowTotal: boolean;
    isRowSubTotal: boolean;
    isColTotal: boolean;
    isColSubTotal: boolean;
}

export declare interface TotalStatus {
    isRowTotal: boolean;
    isRowSubTotal: boolean;
    isColTotal: boolean;
    isColSubTotal: boolean;
}

export declare const transformRatioToPercent: (ratio: number | string, fractionDigits?: FractionDigitsOptions | number) => string | number;

declare interface TransformResult {
    paths: (string | number)[];
    indexesData: Record<string, DataType[][] | DataType[]>;
    rowPivotMeta: PivotMeta;
    colPivotMeta: PivotMeta;
    sortedDimensionValues: SortedDimensionValues;
}

/**
 * return the edges without overlapping edges
 * @param edges the collection of edges
 */
export declare const unique: (edges: number[][][]) => number[][][];

/**
 * unmerge MergedCell
 * @param removedCells
 * @param sheet
 */
export declare const unmergeCell: (sheet: SpreadSheet, removedCells: MergedCell) => void;

export declare const updateAllColHeaderCellState: (colId: string, colHeaderCells: ColCell[], stateName: InteractionStateName) => void;

export declare const updateBySelectedCellsHighlight: (cells: CellMeta[], dataCell: DataCell, s2: SpreadSheet) => void;

/**
 * highlight cells
 * @param cells cells selected
 * @param dataCell cell to render
 */
export declare const updateCurrentCellState: (cells: CellMeta[], dataCell: DataCell) => void;

/**
 * highlight cells of the column
 * @param cells cells selected
 * @param dataCell cell to render
 */
export declare const updateCurrentColumnCellState: (cells: CellMeta[], dataCell: DataCell) => void;

/**
 * highlight cells of the row
 * @param cells cells selected
 * @param dataCell cell to render
 */
export declare const updateCurrentRowCellState: (cells: CellMeta[], dataCell: DataCell) => void;

export declare function updateFillOpacity(shape: IShape, opacity: number): void;

/**
 * update the mergedCell
 * @param sheet the base sheet instance
 */
export declare const updateMergedCells: (sheet: SpreadSheet, mergedCellsGroup: IGroup) => void;

export declare function updateShapeAttr<K extends keyof ShapeAttrs>(shapeGroup: IShape | GuiIcon | Array<IShape | GuiIcon>, attribute: K, value: ShapeAttrs[K]): void;

export declare function updateStrokeOpacity(shape: IShape, opacity: number): void;

export declare const VALUE_FIELD = "$$value$$";

export declare const VALUE_RANGES_KEY = "valueRanges";

export declare interface ValueRange {
    minValue?: number;
    maxValue?: number;
}

export declare type ValueRanges = Record<string, ValueRange>;

export declare const verifyTheElementInTooltip: (parent: HTMLElement, child: Node) => boolean;

export declare const version = "@antv/s2-v1.54.5";

declare interface ViewCellHeights {
    getCellOffsetY: (index: number) => number;
    getTotalHeight: () => number;
    getTotalLength: () => number;
    getIndexRange: (minHeight: number, maxHeight: number) => {
        start: number;
        end: number;
    };
}

export declare interface ViewMeta {
    spreadsheet: SpreadSheet;
    id: string;
    x: number;
    y: number;
    width: number;
    height: number;
    data: Record<string, any>;
    rowIndex: number;
    colIndex: number;
    valueField: string;
    fieldValue: DataItem;
    isTotals?: boolean;
    rowQuery?: Query;
    colQuery?: Query;
    rowId?: string;
    colId?: string;
    field?: string;
    isFrozenCorner?: boolean;
    label?: string;
    value?: string | number;
    query?: Query;
    [key: string]: unknown;
}

export declare type ViewMetaIndexType = keyof Pick<ViewMeta, 'colIndex' | 'rowIndex'>;

export { }
