import { __assign, __extends } from "tslib";
import EE from '@antv/event-emitter';
import * as d3Ease from 'd3-ease';
import { GM } from '../gm';
import { clock } from '../utils/clock';
// 看那个曲线跟合适了
var ease = d3Ease.easeCubicIn;
var TOTAL_MS = 800; // 惯性滚动时间；调参工程师，或者根据速度来计算这个时间
var SWIPE = 'swipe';
var PAN = 'pan';
var WHEEL = 'wheel';
/**
 * 给 view 添加移动端的滚动能力：
 *  - 监听 touch 事件，emit wheel 事件
 *  - 滚动惯性包装
 *  - 和 pc 的 wheel 事件保持基本一致
 */
var Wheel = /** @class */ (function (_super) {
    __extends(Wheel, _super);
    function Wheel(element) {
        var _this = _super.call(this) || this;
        _this.rafMs = 0;
        /**
         * pan 事件
         * @param ev
         */
        _this.onPan = function (ev) {
            // pan 时取消掉 swipe 的延时回调
            if (_this.raf) {
                cancelAnimationFrame(_this.raf);
            }
            var deltaX = ev.deltaX, deltaY = ev.deltaY;
            var e = _this.getWrapperEvent(ev, deltaX, deltaY);
            _this.emit(WHEEL, e);
        };
        /**
         * 当出现 swipe 事件的时候
         * @param ev
         */
        _this.onSwipe = function (ev) {
            var speedX = ev.speedX, speedY = ev.speedY;
            // raf 循环执行的时间戳
            _this.rafMs = clock.now();
            _this.ms = _this.rafMs;
            // 对于没有滑动的情况下，不做处理
            if (speedX !== 0 || speedY !== 0) {
                _this.rafInertia(ev);
            }
        };
        _this.element = element;
        _this.gm = new GM(element, { gestures: ['Pan', 'Swipe'] });
        _this.gm.on(SWIPE, _this.onSwipe);
        _this.gm.on(PAN, _this.onPan);
        return _this;
    }
    Wheel.prototype.destroy = function () {
        window.cancelAnimationFrame(this.raf);
        this.gm.destroy();
        this.off();
    };
    // 使用 raf 进行惯性滑动
    Wheel.prototype.rafInertia = function (ev) {
        var _this = this;
        var speedX = ev.speedX, speedY = ev.speedY;
        this.raf = window.requestAnimationFrame(function () {
            var now = clock.now();
            var ratio = (now - _this.ms) / TOTAL_MS;
            if (ratio < 1) {
                ratio = ease(1 - ratio);
                // 折损之后的速度 * 时间，等于距离
                var t = now - _this.rafMs;
                var movedX = speedX * ratio * t;
                var movedY = speedY * ratio * t;
                var e = _this.getWrapperEvent(ev, movedX, movedY);
                // 发出 wheel 事件
                _this.emit(WHEEL, e);
                _this.rafMs = now; // 记录时间
                // 进行下一次
                _this.rafInertia(ev);
            }
        });
    };
    Wheel.prototype.getWrapperEvent = function (ev, deltaX, deltaY) {
        // 移动端的滑动应该是跟随手指
        return __assign(__assign({}, ev), { deltaX: -deltaX, deltaY: -deltaY });
    };
    return Wheel;
}(EE));
export { Wheel };
//# sourceMappingURL=wheel.js.map