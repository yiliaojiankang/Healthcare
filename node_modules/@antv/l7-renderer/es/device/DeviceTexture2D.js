import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { TextureUsage as DeviceTextureUsage, FilterMode, Format, MipmapFilterMode } from '@antv/g-device-api';
import { TextureUsage, gl } from '@antv/l7-core';
import { wrapModeMap } from "./constants";
import { extend3ChannelsTo4 } from "./utils/typedarray";
export function isTexture2D(t) {
  return !!(t && t['texture']);
}
var DeviceTexture2D = /*#__PURE__*/function () {
  function DeviceTexture2D(device, options) {
    _classCallCheck(this, DeviceTexture2D);
    _defineProperty(this, "isDestroy", false);
    this.device = device;
    this.options = options;
    var _options$wrapS = options.wrapS,
      wrapS = _options$wrapS === void 0 ? gl.CLAMP_TO_EDGE : _options$wrapS,
      _options$wrapT = options.wrapT,
      wrapT = _options$wrapT === void 0 ? gl.CLAMP_TO_EDGE : _options$wrapT,
      aniso = options.aniso,
      _options$mipmap = options.mipmap,
      mipmap = _options$mipmap === void 0 ? false : _options$mipmap,
      _options$mag = options.mag,
      mag = _options$mag === void 0 ? gl.NEAREST : _options$mag,
      _options$min = options.min,
      min = _options$min === void 0 ? gl.NEAREST : _options$min;
    this.createTexture(options);
    this.sampler = device.createSampler({
      addressModeU: wrapModeMap[wrapS],
      addressModeV: wrapModeMap[wrapT],
      minFilter: min === gl.NEAREST ? FilterMode.POINT : FilterMode.BILINEAR,
      magFilter: mag === gl.NEAREST ? FilterMode.POINT : FilterMode.BILINEAR,
      mipmapFilter: MipmapFilterMode.NO_MIP,
      // lodMinClamp: 0,
      // lodMaxClamp: 0,
      maxAnisotropy: aniso
    });
  }
  _createClass(DeviceTexture2D, [{
    key: "createTexture",
    value: function createTexture(options) {
      var _options$type = options.type,
        type = _options$type === void 0 ? gl.UNSIGNED_BYTE : _options$type,
        width = options.width,
        height = options.height,
        _options$flipY = options.flipY,
        flipY = _options$flipY === void 0 ? false : _options$flipY,
        _options$format = options.format,
        format = _options$format === void 0 ? gl.RGBA : _options$format,
        aniso = options.aniso,
        _options$alignment = options.alignment,
        alignment = _options$alignment === void 0 ? 1 : _options$alignment,
        _options$usage = options.usage,
        usage = _options$usage === void 0 ? TextureUsage.SAMPLED : _options$usage,
        _options$unorm = options.unorm,
        unorm = _options$unorm === void 0 ? false : _options$unorm,
        label = options.label;
      var data = options.data;
      this.width = width;
      this.height = height;
      var pixelFormat = Format.U8_RGBA_RT;
      if (type === gl.UNSIGNED_BYTE && format === gl.RGBA) {
        pixelFormat = unorm ? Format.U8_RGBA_NORM : Format.U8_RGBA_RT;
      } else if (type === gl.UNSIGNED_BYTE && format === gl.LUMINANCE) {
        pixelFormat = Format.U8_LUMINANCE;
      } else if (type === gl.FLOAT && format === gl.RGB) {
        // @see https://github.com/antvis/L7/pull/2262
        if (this.device.queryVendorInfo().platformString === 'WebGPU') {
          if (data) {
            // @ts-ignore
            data = extend3ChannelsTo4(data, 0);
          }
          pixelFormat = Format.F32_RGBA;
        } else {
          pixelFormat = Format.F32_RGB;
        }
      } else if (type === gl.FLOAT && format === gl.RGBA) {
        pixelFormat = Format.F32_RGBA;
      } else if (type === gl.FLOAT && format === gl.RED) {
        pixelFormat = Format.F32_R;
      } else {
        throw new Error("create texture error, type: ".concat(type, ", format: ").concat(format));
      }
      this.texture = this.device.createTexture({
        format: pixelFormat,
        width: width,
        height: height,
        usage: usage === TextureUsage.SAMPLED ? DeviceTextureUsage.SAMPLED : DeviceTextureUsage.RENDER_TARGET,
        pixelStore: {
          unpackFlipY: flipY,
          packAlignment: alignment
        },
        // mipLevelCount: usage === TextureUsage.RENDER_TARGET ? 1 : mipmap ? 1 : 0,
        mipLevelCount: 1
      });
      if (label) {
        this.device.setResourceName(this.texture, label);
      }
      if (data) {
        // @ts-ignore
        this.texture.setImageData([data]);
      }
    }
  }, {
    key: "get",
    value: function get() {
      return this.texture;
    }
  }, {
    key: "update",
    value: function update(props) {
      var data = props.data;
      this.texture.setImageData([data]);
    }
  }, {
    key: "bind",
    value: function bind() {
      // this.texture._texture.bind();
    }
  }, {
    key: "resize",
    value: function resize(_ref) {
      var width = _ref.width,
        height = _ref.height;
      if (this.width !== width || this.height !== height) {
        this.destroy();
      }
      this.options.width = width;
      this.options.height = height;
      this.createTexture(this.options);
      this.isDestroy = false;
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return [this.width, this.height];
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // @ts-ignore
      if (!this.isDestroy && !this.texture.destroyed) {
        var _this$texture;
        (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
      }
      this.isDestroy = true;
    }
  }]);
  return DeviceTexture2D;
}();
export { DeviceTexture2D as default };