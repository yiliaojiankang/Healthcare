import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
var _dec, _class;
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { Format, TextureUsage, TransparentBlack, ViewportOrigin, WebGLDeviceContribution, WebGPUDeviceContribution, colorNewFromRGBA } from '@antv/g-device-api';
import { lodashUtil } from '@antv/l7-utils';
import { injectable } from 'inversify';
import 'reflect-metadata';
import DeviceAttribute from "./DeviceAttribute";
import DeviceBuffer from "./DeviceBuffer";
import { RenderCache } from "./DeviceCache";
import DeviceElements from "./DeviceElements";
import DeviceFramebuffer from "./DeviceFramebuffer";
import DeviceModel from "./DeviceModel";
import DeviceTexture2D from "./DeviceTexture2D";
import { isWebGL2 } from "./utils/webgl";
var isUndefined = lodashUtil.isUndefined;

/**
 * Device API renderer
 */
var DeviceRendererService = (_dec = injectable(), _dec(_class = /*#__PURE__*/function () {
  function DeviceRendererService() {
    var _this = this;
    _classCallCheck(this, DeviceRendererService);
    _defineProperty(this, "uniformBuffers", []);
    _defineProperty(this, "queryVerdorInfo", function () {
      return _this.device.queryVendorInfo().platformString;
    });
    _defineProperty(this, "createModel", function (options) {
      return new DeviceModel(_this.device, options, _this);
    });
    _defineProperty(this, "createAttribute", function (options) {
      return new DeviceAttribute(_this.device, options);
    });
    _defineProperty(this, "createBuffer", function (options) {
      return new DeviceBuffer(_this.device, options);
    });
    _defineProperty(this, "createElements", function (options) {
      return new DeviceElements(_this.device, options);
    });
    _defineProperty(this, "createTexture2D", function (options) {
      return new DeviceTexture2D(_this.device, options);
    });
    _defineProperty(this, "createFramebuffer", function (options) {
      return new DeviceFramebuffer(_this.device, options);
    });
    _defineProperty(this, "useFramebuffer", function (framebuffer, drawCommands) {
      _this.currentFramebuffer = framebuffer;
      _this.beginFrame();
      drawCommands();
      _this.endFrame();
      _this.currentFramebuffer = null;
    });
    _defineProperty(this, "useFramebufferAsync", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(framebuffer, drawCommands) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this.currentFramebuffer = framebuffer;
              _this.preRenderPass = _this.renderPass;
              _this.beginFrame();
              _context.next = 5;
              return drawCommands();
            case 5:
              _this.endFrame();
              _this.currentFramebuffer = null;
              _this.renderPass = _this.preRenderPass;
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
    _defineProperty(this, "clear", function (options) {
      // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clear-the-draw-buffer
      var color = options.color,
        depth = options.depth,
        stencil = options.stencil,
        _options$framebuffer = options.framebuffer,
        framebuffer = _options$framebuffer === void 0 ? null : _options$framebuffer;
      if (framebuffer) {
        // @ts-ignore
        framebuffer.clearOptions = {
          color: color,
          depth: depth,
          stencil: stencil
        };
      } else {
        var platformString = _this.queryVerdorInfo();
        if (platformString === 'WebGL1') {
          var gl = _this.getGLContext();
          if (!isUndefined(stencil)) {
            gl.clearStencil(stencil);
            gl.clear(gl.STENCIL_BUFFER_BIT);
          } else if (!isUndefined(depth)) {
            gl.clearDepth(depth);
            gl.clear(gl.DEPTH_BUFFER_BIT);
          }
        } else if (platformString === 'WebGL2') {
          var _gl = _this.getGLContext();
          if (!isUndefined(stencil)) {
            _gl.clearBufferiv(_gl.STENCIL, 0, [stencil]);
          } else if (!isUndefined(depth)) {
            _gl.clearBufferfv(_gl.DEPTH, 0, [depth]);
          }
        }
      }
      // Recreate render pass
      // this.beginFrame();
    });
    _defineProperty(this, "viewport", function (_ref2) {
      var width = _ref2.width,
        height = _ref2.height;
      // @see https://observablehq.com/@antv/g-device-api#cell-267
      _this.swapChain.configureSwapChain(width, height);
      _this.createMainColorDepthRT(width, height);
      _this.width = width;
      _this.height = height;
    });
    _defineProperty(this, "readPixels", function (options) {
      var framebuffer = options.framebuffer,
        x = options.x,
        y = options.y,
        width = options.width,
        height = options.height;
      var readback = _this.device.createReadback();
      var texture = framebuffer['colorTexture'];
      var result = readback.readTextureSync(texture, x,
      /**
       * Origin is at lower-left corner. Width / height is already multiplied by dpr.
       * WebGPU needs flipY
       */
      _this.viewportOrigin === ViewportOrigin.LOWER_LEFT ? y : _this.height - y, width, height, new Uint8Array(width * height * 4));
      readback.destroy();
      return result;
    });
    _defineProperty(this, "readPixelsAsync", /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {
        var framebuffer, x, y, width, height, readback, texture, result, j, t;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              framebuffer = options.framebuffer, x = options.x, y = options.y, width = options.width, height = options.height;
              readback = _this.device.createReadback();
              texture = framebuffer['colorTexture'];
              _context2.next = 5;
              return readback.readTexture(texture, x,
              /**
               * Origin is at lower-left corner. Width / height is already multiplied by dpr.
               * WebGPU needs flipY
               */
              _this.viewportOrigin === ViewportOrigin.LOWER_LEFT ? y : _this.height - y, width, height, new Uint8Array(width * height * 4));
            case 5:
              result = _context2.sent;
              // Since we use U8_RGBA_RT format in render target, need to change bgranorm -> rgba here.
              if (_this.viewportOrigin !== ViewportOrigin.LOWER_LEFT) {
                for (j = 0; j < result.length; j += 4) {
                  // Switch b and r components.
                  t = result[j];
                  result[j] = result[j + 2];
                  result[j + 2] = t;
                }
              }
              readback.destroy();
              return _context2.abrupt("return", result);
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function (_x3) {
        return _ref3.apply(this, arguments);
      };
    }());
    _defineProperty(this, "getViewportSize", function () {
      // FIXME: add viewport size in Device API.
      return {
        width: _this.width,
        height: _this.height
      };
    });
    _defineProperty(this, "getContainer", function () {
      var _this$canvas;
      return (_this$canvas = _this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.parentElement;
    });
    _defineProperty(this, "getCanvas", function () {
      return _this.canvas;
    });
    _defineProperty(this, "getGLContext", function () {
      // @ts-ignore
      return _this.device['gl'];
    });
    _defineProperty(this, "destroy", function () {
      var _this$uniformBuffers;
      // this.canvas = null 清除对 webgl 实例的引用
      // @ts-ignore
      _this.canvas = null;
      (_this$uniformBuffers = _this.uniformBuffers) === null || _this$uniformBuffers === void 0 || _this$uniformBuffers.forEach(function (buffer) {
        buffer.destroy();
      });
      _this.device.destroy();
      _this.renderCache.destroy();

      // make sure release webgl context
      // this.gl?._gl?.getExtension('WEBGL_lose_context')?.loseContext();

      // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clean-up
      // this.gl.destroy();

      // @ts-ignore
      // this.gl = null;
    });
  }
  _createClass(DeviceRendererService, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(canvas, cfg) {
        var enableWebGPU, shaderCompilerPath, deviceContribution, swapChain, gl;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              enableWebGPU = cfg.enableWebGPU, shaderCompilerPath = cfg.shaderCompilerPath; // this.$container = $container;
              this.canvas = canvas;

              // TODO: use antialias from cfg
              deviceContribution = enableWebGPU ? new WebGPUDeviceContribution({
                shaderCompilerPath: shaderCompilerPath
              }) : new WebGLDeviceContribution({
                // Use WebGL2 first and downgrade to WebGL1 if WebGL2 is not supported.
                targets: ['webgl2', 'webgl1'],
                onContextLost: function onContextLost(e) {
                  console.warn('context lost', e);
                },
                onContextCreationError: function onContextCreationError(e) {
                  console.warn('context creation error', e);
                },
                onContextRestored: function onContextRestored(e) {
                  console.warn('context restored', e);
                }
              });
              _context3.next = 5;
              return deviceContribution.createSwapChain(canvas);
            case 5:
              swapChain = _context3.sent;
              swapChain.configureSwapChain(canvas.width, canvas.height);
              this.device = swapChain.getDevice();
              this.swapChain = swapChain;
              this.renderCache = new RenderCache(this.device);

              // Create default RT
              this.currentFramebuffer = null;
              this.viewportOrigin = this.device.queryVendorInfo().viewportOrigin;

              // @ts-ignore
              gl = this.device['gl'];
              this.extensionObject = {
                // @ts-ignore
                OES_texture_float: !isWebGL2(gl) && this.device['OES_texture_float']
              };
              this.createMainColorDepthRT(canvas.width, canvas.height);
            case 15:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function init(_x4, _x5) {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "createMainColorDepthRT",
    value: function createMainColorDepthRT(width, height) {
      if (this.mainColorRT) {
        this.mainColorRT.destroy();
      }
      if (this.mainDepthRT) {
        this.mainDepthRT.destroy();
      }
      this.mainColorRT = this.device.createRenderTargetFromTexture(this.device.createTexture({
        format: Format.U8_RGBA_RT,
        width: width,
        height: height,
        usage: TextureUsage.RENDER_TARGET
      }));
      this.mainDepthRT = this.device.createRenderTargetFromTexture(this.device.createTexture({
        format: Format.D24_S8,
        width: width,
        height: height,
        usage: TextureUsage.RENDER_TARGET
      }));
    }
  }, {
    key: "beginFrame",
    value: function beginFrame() {
      this.device.beginFrame();
      var currentFramebuffer = this.currentFramebuffer,
        swapChain = this.swapChain,
        mainColorRT = this.mainColorRT,
        mainDepthRT = this.mainDepthRT;
      var colorAttachment = currentFramebuffer ? currentFramebuffer['colorRenderTarget'] : mainColorRT;
      var colorResolveTo = currentFramebuffer ? null : swapChain.getOnscreenTexture();
      var depthStencilAttachment = currentFramebuffer ? currentFramebuffer['depthRenderTarget'] : mainDepthRT;
      var _ref4 =
        // @ts-ignore
        (currentFramebuffer === null || currentFramebuffer === void 0 ? void 0 : currentFramebuffer.clearOptions) || {},
        _ref4$color = _ref4.color,
        color = _ref4$color === void 0 ? [0, 0, 0, 0] : _ref4$color,
        _ref4$depth = _ref4.depth,
        depth = _ref4$depth === void 0 ? 1 : _ref4$depth,
        _ref4$stencil = _ref4.stencil,
        stencil = _ref4$stencil === void 0 ? 0 : _ref4$stencil;
      var colorClearColor = colorAttachment ? colorNewFromRGBA(color[0] * 255, color[1] * 255, color[2] * 255, color[3]) : TransparentBlack;
      var depthClearValue = depthStencilAttachment ? depth : undefined;
      var stencilClearValue = depthStencilAttachment ? stencil : undefined;
      var renderPass = this.device.createRenderPass({
        colorAttachment: [colorAttachment],
        colorResolveTo: [colorResolveTo],
        colorClearColor: [colorClearColor],
        // colorStore: [!!currentFramebuffer],
        colorStore: [true],
        depthStencilAttachment: depthStencilAttachment,
        depthClearValue: depthClearValue,
        stencilClearValue: stencilClearValue
      });
      this.renderPass = renderPass;
    }
  }, {
    key: "endFrame",
    value: function endFrame() {
      this.device.submitPass(this.renderPass);
      this.device.endFrame();
    }
  }, {
    key: "getPointSizeRange",
    value: function getPointSizeRange() {
      // @ts-ignore
      var gl = this.device['gl'];
      // FIXME: implement this method in Device API.
      return gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
    }
  }, {
    key: "testExtension",
    value: function testExtension(name) {
      // OES_texture_float
      return !!this.getGLContext().getExtension(name);
    }
  }, {
    key: "setState",
    value:
    // TODO: 临时方法
    function setState() {
      // this.gl({
      //   cull: {
      //     enable: false,
      //     face: 'back',
      //   },
      //   viewport: {
      //     x: 0,
      //     y: 0,
      //     height: this.width,
      //     width: this.height,
      //   },
      //   blend: {
      //     enable: true,
      //     equation: 'add',
      //   },
      //   framebuffer: null,
      // });
      // this.gl._refresh();
    }
  }, {
    key: "setBaseState",
    value: function setBaseState() {
      // this.gl({
      //   cull: {
      //     enable: false,
      //     face: 'back',
      //   },
      //   viewport: {
      //     x: 0,
      //     y: 0,
      //     height: this.width,
      //     width: this.height,
      //   },
      //   blend: {
      //     enable: false,
      //     equation: 'add',
      //   },
      //   framebuffer: null,
      // });
      // this.gl._refresh();
    }
  }, {
    key: "setCustomLayerDefaults",
    value: function setCustomLayerDefaults() {
      // const gl = this.getGLContext();
      // gl.disable(gl.CULL_FACE);
    }
  }, {
    key: "setDirty",
    value: function setDirty(flag) {
      this.isDirty = flag;
    }
  }, {
    key: "getDirty",
    value: function getDirty() {
      return this.isDirty;
    }
  }]);
  return DeviceRendererService;
}()) || _class);
export { DeviceRendererService as default };