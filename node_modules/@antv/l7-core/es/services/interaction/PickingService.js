import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _initializerDefineProperty from "@babel/runtime/helpers/esm/initializerDefineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/esm/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/esm/initializerWarningHelper";
var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { decodePickingColor, DOM } from '@antv/l7-utils';
import { inject, injectable } from 'inversify';
import 'reflect-metadata';
import { TYPES } from "../../types";
import { isEventCrash } from "../../utils/dom";
import { InteractionEvent } from "../interaction/IInteractionService";
import { TextureUsage } from "../renderer/ITexture2D";
var PickingService = (_dec = injectable(), _dec2 = inject(TYPES.IMapService), _dec3 = inject(TYPES.IRendererService), _dec4 = inject(TYPES.IGlobalConfigService), _dec5 = inject(TYPES.IInteractionService), _dec6 = inject(TYPES.ILayerService), _dec(_class = (_class2 = /*#__PURE__*/function () {
  function PickingService() {
    var _this = this;
    _classCallCheck(this, PickingService);
    _defineProperty(this, "pickedColors", void 0);
    _defineProperty(this, "pickedTileLayers", []);
    _initializerDefineProperty(this, "mapService", _descriptor, this);
    _initializerDefineProperty(this, "rendererService", _descriptor2, this);
    _initializerDefineProperty(this, "configService", _descriptor3, this);
    _initializerDefineProperty(this, "interactionService", _descriptor4, this);
    _initializerDefineProperty(this, "layerService", _descriptor5, this);
    _defineProperty(this, "pickingFBO", void 0);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    _defineProperty(this, "alreadyInPicking", false);
    _defineProperty(this, "pickBufferScale", 1.0);
    _defineProperty(this, "pickFromPickingFBO", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(layer, _ref) {
        var x, y, lngLat, type, target, isPicked, _this$rendererService, readPixelsAsync, getContainer, _this$getContainerSiz, width, height, _layer$getLayerConfig, enableHighlight, enableSelect, xInDevicePixel, yInDevicePixel, pickedColors, pickedFeatureIdx, rawFeature, layerTarget, _layerTarget, selectedId;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              x = _ref.x, y = _ref.y, lngLat = _ref.lngLat, type = _ref.type, target = _ref.target;
              isPicked = false;
              _this$rendererService = _this.rendererService, readPixelsAsync = _this$rendererService.readPixelsAsync, getContainer = _this$rendererService.getContainer;
              _this$getContainerSiz = _this.getContainerSize(getContainer()), width = _this$getContainerSiz.width, height = _this$getContainerSiz.height;
              width *= DOM.DPR;
              height *= DOM.DPR;
              _layer$getLayerConfig = layer.getLayerConfig(), enableHighlight = _layer$getLayerConfig.enableHighlight, enableSelect = _layer$getLayerConfig.enableSelect;
              xInDevicePixel = x * DOM.DPR;
              yInDevicePixel = y * DOM.DPR;
              if (!(xInDevicePixel > width - 1 * DOM.DPR || xInDevicePixel < 0 || yInDevicePixel > height - 1 * DOM.DPR || yInDevicePixel < 0)) {
                _context.next = 11;
                break;
              }
              return _context.abrupt("return", false);
            case 11:
              _context.next = 13;
              return readPixelsAsync({
                x: Math.floor(xInDevicePixel / _this.pickBufferScale),
                // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
                y: Math.floor((height - (y + 1) * DOM.DPR) / _this.pickBufferScale),
                width: 1,
                height: 1,
                data: new Uint8Array(1 * 1 * 4),
                framebuffer: _this.pickingFBO
              });
            case 13:
              pickedColors = _context.sent;
              _this.pickedColors = pickedColors;
              if (pickedColors[0] !== 0 || pickedColors[1] !== 0 || pickedColors[2] !== 0) {
                pickedFeatureIdx = decodePickingColor(pickedColors); // 瓦片数据获取性能问题需要优化
                rawFeature = layer.layerPickService.getFeatureById(pickedFeatureIdx);
                if (pickedFeatureIdx !== layer.getCurrentPickId() && type === 'mousemove') {
                  type = 'mouseenter';
                }
                layerTarget = {
                  x: x,
                  y: y,
                  type: type,
                  lngLat: lngLat,
                  featureId: pickedFeatureIdx,
                  feature: rawFeature,
                  target: target
                };
                if (!rawFeature) {

                  // this.logger.error(
                  //   '未找到颜色编码解码后的原始 feature，请检查 fragment shader 中末尾是否添加了 `gl_FragColor = filterColor(gl_FragColor);`',
                  // );
                } else {
                  // trigger onHover/Click callback on layer
                  isPicked = true;
                  layer.setCurrentPickId(pickedFeatureIdx);
                  _this.triggerHoverOnLayer(layer, layerTarget); // 触发拾取事件
                }
              } else {
                // 未选中
                _layerTarget = {
                  x: x,
                  y: y,
                  lngLat: lngLat,
                  type: layer.getCurrentPickId() !== null && type === 'mousemove' ? 'mouseout' : 'un' + type,
                  featureId: null,
                  target: target,
                  feature: null
                };
                _this.triggerHoverOnLayer(layer, _objectSpread(_objectSpread({}, _layerTarget), {}, {
                  type: 'unpick'
                }));
                _this.triggerHoverOnLayer(layer, _layerTarget);
                layer.setCurrentPickId(null);
              }
              if (enableHighlight) {
                layer.layerPickService.highlightPickedFeature(pickedColors);
              }
              if (enableSelect && type === 'click' && (pickedColors === null || pickedColors === void 0 ? void 0 : pickedColors.toString()) !== [0, 0, 0, 0].toString()) {
                selectedId = decodePickingColor(pickedColors);
                if (layer.getCurrentSelectedId() === null || selectedId !== layer.getCurrentSelectedId()) {
                  layer.layerPickService.selectFeature(pickedColors);
                  layer.setCurrentSelectedId(selectedId);
                } else {
                  layer.layerPickService.selectFeature(new Uint8Array([0, 0, 0, 0])); // toggle select
                  layer.setCurrentSelectedId(null);
                }
              }
              return _context.abrupt("return", isPicked);
            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }());
  }
  _createClass(PickingService, [{
    key: "init",
    value: function init(id) {
      var _this$rendererService2 = this.rendererService,
        createTexture2D = _this$rendererService2.createTexture2D,
        createFramebuffer = _this$rendererService2.createFramebuffer,
        getContainer = _this$rendererService2.getContainer;
      var _this$getContainerSiz2 = this.getContainerSize(getContainer()),
        width = _this$getContainerSiz2.width,
        height = _this$getContainerSiz2.height;
      width *= DOM.DPR;
      height *= DOM.DPR;
      this.pickBufferScale = this.configService.getSceneConfig(id).pickBufferScale || 1;
      width = Math.round(width / this.pickBufferScale);
      height = Math.round(height / this.pickBufferScale);
      // 创建 picking framebuffer，后续实时 resize
      var pickingColorTexture = createTexture2D({
        width: width,
        height: height,
        // wrapS: gl.CLAMP_TO_EDGE,
        // wrapT: gl.CLAMP_TO_EDGE,
        usage: TextureUsage.RENDER_TARGET,
        label: 'Picking Texture'
      });
      this.pickingFBO = createFramebuffer({
        color: pickingColorTexture,
        depth: true,
        width: width,
        height: height
      });

      // 监听 hover 事件
      this.interactionService.on(InteractionEvent.Hover, this.pickingAllLayer.bind(this));
    }
  }, {
    key: "boxPickLayer",
    value: function () {
      var _boxPickLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(layer, box, cb) {
        var _this2 = this;
        var _this$rendererService3, useFramebufferAsync, clear, features;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _this$rendererService3 = this.rendererService, useFramebufferAsync = _this$rendererService3.useFramebufferAsync, clear = _this$rendererService3.clear;
              this.resizePickingFBO();
              layer.hooks.beforePickingEncode.call();
              _context3.next = 5;
              return useFramebufferAsync(this.pickingFBO, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
                return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      clear({
                        framebuffer: _this2.pickingFBO,
                        color: [0, 0, 0, 0],
                        stencil: 0,
                        depth: 1
                      });
                      layer.renderModels({
                        ispick: true
                      });
                    case 2:
                    case "end":
                      return _context2.stop();
                  }
                }, _callee2);
              })));
            case 5:
              layer.hooks.afterPickingEncode.call();
              _context3.next = 8;
              return this.pickBox(layer, box);
            case 8:
              features = _context3.sent;
              cb(features);
            case 10:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function boxPickLayer(_x3, _x4, _x5) {
        return _boxPickLayer.apply(this, arguments);
      }
      return boxPickLayer;
    }()
  }, {
    key: "pickBox",
    value: function () {
      var _pickBox = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(layer, box) {
        var _this3 = this;
        var _box$map, _box$map2, xMin, yMin, xMax, yMax, _this$rendererService4, readPixelsAsync, getContainer, _this$getContainerSiz3, width, height, w, h, pickedColors, features, featuresIdMap, i, color, pickedFeatureIdx, rawFeature;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _box$map = box.map(function (v) {
                var tmpV = v < 0 ? 0 : v;
                return Math.floor(tmpV * DOM.DPR / _this3.pickBufferScale);
              }), _box$map2 = _slicedToArray(_box$map, 4), xMin = _box$map2[0], yMin = _box$map2[1], xMax = _box$map2[2], yMax = _box$map2[3];
              _this$rendererService4 = this.rendererService, readPixelsAsync = _this$rendererService4.readPixelsAsync, getContainer = _this$rendererService4.getContainer;
              _this$getContainerSiz3 = this.getContainerSize(getContainer()), width = _this$getContainerSiz3.width, height = _this$getContainerSiz3.height;
              width *= DOM.DPR;
              height *= DOM.DPR;
              if (!(xMin > (width - 1) * DOM.DPR / this.pickBufferScale || xMax < 0 || yMin > (height - 1) * DOM.DPR / this.pickBufferScale || yMax < 0)) {
                _context4.next = 7;
                break;
              }
              return _context4.abrupt("return", []);
            case 7:
              w = Math.min(width / this.pickBufferScale, xMax) - xMin;
              h = Math.min(height / this.pickBufferScale, yMax) - yMin;
              _context4.next = 11;
              return readPixelsAsync({
                x: xMin,
                // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
                y: Math.floor(height / this.pickBufferScale - (yMax + 1)),
                width: w,
                height: h,
                data: new Uint8Array(w * h * 4),
                framebuffer: this.pickingFBO
              });
            case 11:
              pickedColors = _context4.sent;
              features = [];
              featuresIdMap = {};
              for (i = 0; i < pickedColors.length / 4; i = i + 1) {
                color = pickedColors.slice(i * 4, i * 4 + 4);
                pickedFeatureIdx = decodePickingColor(color);
                if (pickedFeatureIdx !== -1 && !featuresIdMap[pickedFeatureIdx]) {
                  rawFeature = layer.layerPickService.getFeatureById(pickedFeatureIdx);
                  features.push(_objectSpread(_objectSpread({}, rawFeature), {}, {
                    pickedFeatureIdx: pickedFeatureIdx
                  }));
                  featuresIdMap[pickedFeatureIdx] = true;
                }
              }
              return _context4.abrupt("return", features);
            case 16:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function pickBox(_x6, _x7) {
        return _pickBox.apply(this, arguments);
      }
      return pickBox;
    }() // 动态设置鼠标光标
  }, {
    key: "handleCursor",
    value: function handleCursor(layer, type) {
      var _layer$getLayerConfig2 = layer.getLayerConfig(),
        _layer$getLayerConfig3 = _layer$getLayerConfig2.cursor,
        cursor = _layer$getLayerConfig3 === void 0 ? '' : _layer$getLayerConfig3,
        cursorEnabled = _layer$getLayerConfig2.cursorEnabled;
      if (cursorEnabled) {
        var version = this.mapService.version;
        var domContainer = version === 'GAODE2.x' ? this.mapService.getMapContainer() : this.mapService.getMarkerContainer();
        // const domContainer = this.mapService.getMarkerContainer();
        // const domContainer = this.mapService.getMapContainer();
        var defaultCursor = domContainer === null || domContainer === void 0 ? void 0 : domContainer.style.getPropertyValue('cursor');
        if (type === 'unmousemove' && defaultCursor !== '') {
          domContainer === null || domContainer === void 0 || domContainer.style.setProperty('cursor', '');
        } else if (type === 'mousemove') {
          domContainer === null || domContainer === void 0 || domContainer.style.setProperty('cursor', cursor);
        }
      }
      // const domContainer = this.mapService.getMapContainer()
      // domContainer?.style.setProperty('cursor', 'move');
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.pickingFBO.destroy();
      // this.pickingFBO = null; 清除对 webgl 实例的引用
      // @ts-ignore
      this.pickingFBO = null;
    }
  }, {
    key: "getContainerSize",
    value:
    // 获取容器的大小 - 兼容小程序环境
    function getContainerSize(container) {
      if (container.getContext) {
        return {
          width: container.width / DOM.DPR,
          height: container.height / DOM.DPR
        };
      } else {
        return container.getBoundingClientRect();
      }
    }
  }, {
    key: "pickingAllLayer",
    value: function () {
      var _pickingAllLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(target) {
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!(!this.layerService.needPick(target.type) || !this.isPickingAllLayer())) {
                _context5.next = 2;
                break;
              }
              return _context5.abrupt("return");
            case 2:
              this.alreadyInPicking = true;
              _context5.next = 5;
              return this.pickingLayers(target);
            case 5:
              this.layerService.renderLayers();
              this.alreadyInPicking = false;
            case 7:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function pickingAllLayer(_x8) {
        return _pickingAllLayer.apply(this, arguments);
      }
      return pickingAllLayer;
    }()
  }, {
    key: "isPickingAllLayer",
    value: function isPickingAllLayer() {
      // this.alreadyInPicking 避免多次重复拾取

      if (this.alreadyInPicking) {
        return false;
      }
      // this.layerService.alreadyInRendering 一个渲染序列中只进行一次拾取操作
      if (this.layerService.alreadyInRendering) {
        return false;
      }
      // this.interactionService.dragging amap2 在点击操作的时候同时会触发 dragging 的情况（避免舍去）
      if (this.interactionService.indragging) {
        return false;
      }

      // 判断当前进行 shader pick 拾取判断
      if (!this.layerService.getShaderPickStat()) {
        return false;
      }

      // 进行拾取
      return true;
    }
  }, {
    key: "resizePickingFBO",
    value: function resizePickingFBO() {
      var getContainer = this.rendererService.getContainer;
      var _this$getContainerSiz4 = this.getContainerSize(getContainer()),
        width = _this$getContainerSiz4.width,
        height = _this$getContainerSiz4.height;
      width *= DOM.DPR;
      height *= DOM.DPR;
      if (this.width !== width || this.height !== height) {
        this.pickingFBO.resize({
          width: Math.round(width / this.pickBufferScale),
          height: Math.round(height / this.pickBufferScale)
        });
        this.width = width;
        this.height = height;
      }
    }
  }, {
    key: "pickingLayers",
    value: function () {
      var _pickingLayers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(target) {
        var _this4 = this;
        var _this$rendererService5, clear, useFramebufferAsync, layers, _iterator, _step, _loop;
        return _regeneratorRuntime.wrap(function _callee7$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _this$rendererService5 = this.rendererService, clear = _this$rendererService5.clear, useFramebufferAsync = _this$rendererService5.useFramebufferAsync;
              this.resizePickingFBO();
              layers = this.layerService.getRenderList();
              _iterator = _createForOfIteratorHelper(layers.filter(function (layer) {
                return layer.needPick(target.type);
              }).reverse());
              _context8.prev = 4;
              _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {
                var layer, isPicked;
                return _regeneratorRuntime.wrap(function _loop$(_context7) {
                  while (1) switch (_context7.prev = _context7.next) {
                    case 0:
                      layer = _step.value;
                      if (!layer.tileLayer) {
                        layer.hooks.beforePickingEncode.call();
                      }
                      _context7.next = 4;
                      return useFramebufferAsync(_this4.pickingFBO, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
                        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
                          while (1) switch (_context6.prev = _context6.next) {
                            case 0:
                              clear({
                                framebuffer: _this4.pickingFBO,
                                color: [0, 0, 0, 0],
                                stencil: 0,
                                depth: 1
                              });
                              layer.layerPickService.pickRender(target);
                            case 2:
                            case "end":
                              return _context6.stop();
                          }
                        }, _callee6);
                      })));
                    case 4:
                      if (!layer.tileLayer) {
                        layer.hooks.afterPickingEncode.call();
                      }
                      _context7.next = 7;
                      return _this4.pickFromPickingFBO(layer, target);
                    case 7:
                      isPicked = _context7.sent;
                      _this4.layerService.pickedLayerId = isPicked ? +layer.id : -1;
                      if (!(isPicked && !layer.getLayerConfig().enablePropagation)) {
                        _context7.next = 11;
                        break;
                      }
                      return _context7.abrupt("return", 1);
                    case 11:
                    case "end":
                      return _context7.stop();
                  }
                }, _loop);
              });
              _iterator.s();
            case 7:
              if ((_step = _iterator.n()).done) {
                _context8.next = 13;
                break;
              }
              return _context8.delegateYield(_loop(), "t0", 9);
            case 9:
              if (!_context8.t0) {
                _context8.next = 11;
                break;
              }
              return _context8.abrupt("break", 13);
            case 11:
              _context8.next = 7;
              break;
            case 13:
              _context8.next = 18;
              break;
            case 15:
              _context8.prev = 15;
              _context8.t1 = _context8["catch"](4);
              _iterator.e(_context8.t1);
            case 18:
              _context8.prev = 18;
              _iterator.f();
              return _context8.finish(18);
            case 21:
            case "end":
              return _context8.stop();
          }
        }, _callee7, this, [[4, 15, 18, 21]]);
      }));
      function pickingLayers(_x9) {
        return _pickingLayers.apply(this, arguments);
      }
      return pickingLayers;
    }()
  }, {
    key: "triggerHoverOnLayer",
    value: function triggerHoverOnLayer(layer, target) {
      // layer.emit(target.type, target);
      // 判断是否发生事件冲突
      if (isEventCrash(target)) {
        // Tip: 允许用户动态设置鼠标光标
        this.handleCursor(layer, target.type);
        layer.emit(target.type, target);
      }
    }
  }]);
  return PickingService;
}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "mapService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "rendererService", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "configService", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "interactionService", [_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "layerService", [_dec6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
export { PickingService as default };