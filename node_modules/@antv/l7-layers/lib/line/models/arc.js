"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _l7Utils = require("@antv/l7-utils");
var _BaseModel2 = _interopRequireDefault(require("../../core/BaseModel"));
var _CommonStyleAttribute = require("../../core/CommonStyleAttribute");
var _triangulation = require("../../core/triangulation");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/* babel-plugin-inline-import '../shaders/arc/line_arc_frag.glsl' */
var arc_line_frag = "\n#define Animate 0.0\n#define LineTexture 1.0\nuniform sampler2D u_texture;\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array;\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float segmentNumber;\n  float u_lineDir: 1.0;\n  float u_icon_step: 100;\n  float u_line_texture: 0.0;\n  float u_textureBlend;\n  float u_blur : 0.9;\n  float u_line_type: 0.0;\n  float u_time;\n  float u_linearColor: 0.0;\n};\n\nin vec4 v_color;\nin vec2 v_iconMapUV;\nin vec4 v_lineData;\n//dash\nin vec4 v_dash_array;\nin float v_distance_ratio;\n\nout vec4 outputColor;\n#pragma include \"picking\"\n\nvoid main() {\n  if(u_dash_array!=vec4(0.0)){\n    float dashLength = mod(v_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(!(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z))) {\n      discard;\n    };\n  }\n  float animateSpeed = 0.0; // \u8FD0\u52A8\u901F\u5EA6\n  outputColor = v_color;\n  if(u_animate.x == Animate && u_line_texture != LineTexture) {\n      animateSpeed = u_time / u_animate.y;\n      float alpha =1.0 - fract( mod(1.0- v_lineData.b, u_animate.z)* (1.0/ u_animate.z) + u_time / u_animate.y);\n      alpha = (alpha + u_animate.w -1.0) / u_animate.w;\n      // alpha = smoothstep(0., 1., alpha);\n      alpha = clamp(alpha, 0.0, 1.0);\n      outputColor.a *= alpha;\n  }\n\n  // \u5F53\u5B58\u5728\u8D34\u56FE\u65F6\u5728\u5E95\u8272\u4E0A\u8D34\u4E0A\u8D34\u56FE\n  if(u_line_texture == LineTexture) { // while load texture\n    float arcRadio = smoothstep( 0.0, 1.0, (v_lineData.r / segmentNumber));\n    // float arcRadio = smoothstep( 0.0, 1.0, d_distance_ratio);\n\n    float count = v_lineData.g; // \u8D34\u56FE\u5728\u5F27\u7EBF\u4E0A\u91CD\u590D\u7684\u6570\u91CF\n\n    float time = 0.0;\n    if(u_animate.x == Animate) {\n      time = u_time / u_animate.y;\n    }\n    float redioCount = arcRadio * count;\n\n    float u = fract(redioCount - time);\n    float v = v_lineData.a; // \u6A2A\u5411 v\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n\n    vec4 pattern = texture(SAMPLER_2D(u_texture), uv);\n\n    if(u_animate.x == Animate) {\n      float currentPlane = floor(redioCount - time);\n      float textureStep = floor(count * u_animate.z);\n      float a = mod(currentPlane, textureStep);\n      if(a < textureStep - 1.0) {\n        pattern = vec4(0.0);\n      }\n    }\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      outputColor = filterColor(outputColor + pattern);\n    } else { // replace\n        pattern.a *= v_color.a;\n        if(outputColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        outputColor = filterColor(pattern);\n    }\n    \n  } else {\n     outputColor = filterColor(outputColor);\n  }\n}";
/* babel-plugin-inline-import '../shaders/arc/line_arc_vert.glsl' */
var arc_line_vert = "#define Animate 0.0\n#define LineTexture 1.0\nlayout(location = 0) in vec3 a_Position;\nlayout(location = 1) in vec4 a_Color;\nlayout(location = 9) in float a_Size;\nlayout(location = 12) in vec4 a_Instance;\nlayout(location = 14) in vec2 a_iconMapUV;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array;\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float segmentNumber;\n  float u_lineDir: 1.0;\n  float u_icon_step: 100;\n  float u_line_texture: 0.0;\n  float u_textureBlend;\n  float u_blur : 0.9;\n  float u_line_type: 0.0;\n  float u_time;\n  float u_linearColor: 0.0;\n};\nout vec4 v_color;\nout vec2 v_iconMapUV;\nout vec4 v_lineData;\n//dash\nout vec4 v_dash_array;\nout float v_distance_ratio;\n\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1. - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\nvec2 midPoint(vec2 source, vec2 target, float arcThetaOffset) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = arcThetaOffset;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\n  if(u_lineDir == 1.0) { // \u6B63\u5411\n    return mid;\n  } else { // \u9006\u5411\n    // (mid + vmin)/2 = (s + t)/2\n    vec2 vmid = source + target - mid;\n    return vmid;\n  }\n  // return mid;\n}\nfloat getSegmentRatio(float index) {\n    // dash: index / (segmentNumber - 1.);\n    // normal: smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n    //  return index / (segmentNumber - 1.);\n}\nvec2 interpolate (vec2 source, vec2 target, float t, float arcThetaOffset) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  vec2 mid = midPoint(source, target, arcThetaOffset);\n  vec3 x = vec3(source.x, mid.x, target.x);\n  vec3 y = vec3(source.y, mid.y, target.y);\n  return vec2(bezier3(x ,t), bezier3(y,t));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\n}\n\nvoid main() {\n  //vs\u4E2D\u8BA1\u7B97\u6E10\u53D8\u8272\n  if(u_linearColor==1.0){\n    float d_segmentIndex = a_Position.x + 1.0; // \u5F53\u524D\u9876\u70B9\u5728\u5F27\u7EBF\u4E2D\u6240\u5904\u7684\u5206\u6BB5\u4F4D\u7F6E\n    v_color = mix(u_sourceColor, u_targetColor, d_segmentIndex/segmentNumber);\n  }\n  else{\n    v_color = a_Color;\n  }\n  v_color.a = v_color.a * opacity;\n\n  vec2 source = a_Instance.rg;  // \u8D77\u59CB\u70B9\n  vec2 target =  a_Instance.ba; // \u7EC8\u70B9\n\n\n\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  //\u8BA1\u7B97dashArray\u548CdistanceRatio \u8F93\u51FA\u5230\u7247\u5143\n  vec2 s = source;\n  vec2 t = target;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    s = unProjCustomCoord(source);\n    t = unProjCustomCoord(target);\n  }\n  float total_Distance = pixelDistance(s, t) / 2.0 * PI;\n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / total_Distance;\n  v_distance_ratio = segmentIndex / segmentNumber;\n\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  float d_distance_ratio;\n  \n  if(u_animate.x == Animate) {\n      d_distance_ratio = segmentIndex / segmentNumber;\n      if(u_lineDir != 1.0) {\n        d_distance_ratio = 1.0 - d_distance_ratio;\n      }\n  }\n\n  v_lineData.b = d_distance_ratio;\n\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio, thetaOffset), 0.0, 1.0));\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio, thetaOffset), 0.0, 1.0));\n\n  \n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n\n\n  float d_segmentIndex = a_Position.x + 1.0; // \u5F53\u524D\u9876\u70B9\u5728\u5F27\u7EBF\u4E2D\u6240\u5904\u7684\u5206\u6BB5\u4F4D\u7F6E\n  v_lineData.r = d_segmentIndex;\n\n  if(LineTexture == u_line_texture) { // \u5F00\u542F\u8D34\u56FE\u6A21\u5F0F\n\n    float arcDistrance = length(source - target); // \u8D77\u59CB\u70B9\u548C\u7EC8\u70B9\u7684\u8DDD\u79BB\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20) { // amap\n      arcDistrance *= 1000000.0;\n    }\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) { // mapbox\n      // arcDistrance *= 8.0;\n      arcDistrance = project_pixel_allmap(arcDistrance);\n    }\n    v_iconMapUV = a_iconMapUV;\n\n    float pixelLen = project_pixel_texture(u_icon_step); // \u8D34\u56FE\u6CBF\u5F27\u7EBF\u65B9\u5411\u7684\u957F\u5EA6 - \u968F\u5730\u56FE\u7F29\u653E\u6539\u53D8\n    float texCount = floor(arcDistrance/pixelLen); // \u8D34\u56FE\u5728\u5F27\u7EBF\u4E0A\u91CD\u590D\u7684\u6570\u91CF\n    v_lineData.g = texCount;\n\n    float lineOffsetWidth = length(offset + offset * sign(a_Position.y)); // \u7EBF\u6A2A\u5411\u504F\u79FB\u7684\u8DDD\u79BB\n    float linePixelSize = project_pixel(a_Size); // \u5B9A\u70B9\u4F4D\u7F6E\u504F\u79FB\n    v_lineData.a = lineOffsetWidth/linePixelSize; // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n  }\n\n  gl_Position = project_common_position_to_clipspace_v2(vec4(curr.xy + offset, 0, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n";
var lineStyleObj = {
  solid: 0.0,
  dash: 1.0
};
var isNumber = _l7Utils.lodashUtil.isNumber;
var ArcModel = exports.default = /*#__PURE__*/function (_BaseModel) {
  (0, _inherits2.default)(ArcModel, _BaseModel);
  var _super = _createSuper(ArcModel);
  function ArcModel() {
    var _this;
    (0, _classCallCheck2.default)(this, ArcModel);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;
      if (_this.texture) {
        _this.texture.update({
          data: _this.iconService.getCanvas()
        });
        _this.layer.render();
        return;
      }
      _this.texture = createTexture2D({
        data: _this.iconService.getCanvas(),
        mag: _l7Core.gl.NEAREST,
        min: _l7Core.gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: _this.iconService.canvasHeight || 128
      });
      _this.textures = [_this.texture];
    });
    return _this;
  }
  (0, _createClass2.default)(ArcModel, [{
    key: "getCommonUniformsInfo",
    value: function getCommonUniformsInfo() {
      var _ref = this.layer.getLayerConfig(),
        sourceColor = _ref.sourceColor,
        targetColor = _ref.targetColor,
        _ref$textureBlend = _ref.textureBlend,
        textureBlend = _ref$textureBlend === void 0 ? 'normal' : _ref$textureBlend,
        _ref$lineType = _ref.lineType,
        lineType = _ref$lineType === void 0 ? 'solid' : _ref$lineType,
        _ref$dashArray = _ref.dashArray,
        dashArray = _ref$dashArray === void 0 ? [10, 5] : _ref$dashArray,
        _ref$forward = _ref.forward,
        forward = _ref$forward === void 0 ? true : _ref$forward,
        _ref$lineTexture = _ref.lineTexture,
        lineTexture = _ref$lineTexture === void 0 ? false : _ref$lineTexture,
        _ref$iconStep = _ref.iconStep,
        iconStep = _ref$iconStep === void 0 ? 100 : _ref$iconStep,
        _ref$segmentNumber = _ref.segmentNumber,
        segmentNumber = _ref$segmentNumber === void 0 ? 30 : _ref$segmentNumber;
      var _ref2 = this.layer.getLayerConfig(),
        animateOption = _ref2.animateOption;
      var u_dash_array = dashArray;
      if (lineType !== 'dash') {
        u_dash_array = [0, 0];
      }
      if (u_dash_array.length === 2) {
        u_dash_array.push(0, 0);
      }

      // 转化渐变色
      var useLinearColor = 0; // 默认不生效
      var sourceColorArr = [0, 0, 0, 0];
      var targetColorArr = [0, 0, 0, 0];
      if (sourceColor && targetColor) {
        sourceColorArr = (0, _l7Utils.rgb2arr)(sourceColor);
        targetColorArr = (0, _l7Utils.rgb2arr)(targetColor);
        useLinearColor = 1;
      }
      if (this.rendererService.getDirty()) {
        this.texture.bind();
      }
      var commonOptions = {
        u_animate: this.animateOption2Array(animateOption),
        u_dash_array: u_dash_array,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr,
        u_textSize: [1024, this.iconService.canvasHeight || 128],
        segmentNumber: segmentNumber,
        u_lineDir: forward ? 1 : -1,
        u_icon_step: iconStep,
        u_line_texture: lineTexture ? 1.0 : 0.0,
        // 传入线的标识
        u_textureBlend: textureBlend === 'normal' ? 0.0 : 1.0,
        u_blur: 0.9,
        u_line_type: lineStyleObj[lineType || 'solid'],
        u_time: this.layer.getLayerAnimateTime() || 0,
        // // 纹理支持参数
        // u_texture: this.texture, // 贴图
        // 渐变色支持参数
        u_linearColor: useLinearColor
      };
      var commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
      return commonBufferInfo;
    }

    // public getAnimateUniforms(): IModelUniform {
    //   const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;
    //   return {
    //     u_animate: this.animateOption2Array(animateOption as IAnimateOption),
    //     u_time: this.layer.getLayerAnimateTime(),
    //   };
    // }
  }, {
    key: "initModels",
    value: function () {
      var _initModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.updateTexture();
              this.iconService.on('imageUpdate', this.updateTexture);
              return _context.abrupt("return", this.buildModels());
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function initModels() {
        return _initModels.apply(this, arguments);
      }
      return initModels;
    }()
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
      this.iconService.off('imageUpdate', this.updateTexture);
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      return {
        frag: arc_line_frag,
        vert: arc_line_vert,
        type: ''
      };
    }
  }, {
    key: "buildModels",
    value: function () {
      var _buildModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var _ref3, _ref3$segmentNumber, segmentNumber, _this$getShaders, frag, vert, type, model;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this.initUniformsBuffer();
              _ref3 = this.layer.getLayerConfig(), _ref3$segmentNumber = _ref3.segmentNumber, segmentNumber = _ref3$segmentNumber === void 0 ? 30 : _ref3$segmentNumber;
              _this$getShaders = this.getShaders(), frag = _this$getShaders.frag, vert = _this$getShaders.vert, type = _this$getShaders.type; //
              _context2.next = 5;
              return this.layer.buildLayerModel({
                moduleName: 'lineArc2d' + type,
                vertexShader: vert,
                fragmentShader: frag,
                inject: this.getInject(),
                triangulation: _triangulation.LineArcTriangulation,
                depth: {
                  enable: false
                },
                styleOption: {
                  segmentNumber: segmentNumber
                }
              });
            case 5:
              model = _context2.sent;
              return _context2.abrupt("return", [model]);
            case 7:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function buildModels() {
        return _buildModels.apply(this, arguments);
      }
      return buildModels;
    }()
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          shaderLocation: _CommonStyleAttribute.ShaderLocation.SIZE,
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 1,
          update: function update(feature) {
            var _feature$size = feature.size,
              size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'instance',
        // 弧线起始点信息
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Instance',
          shaderLocation: 12,
          buffer: {
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 4,
          update: function update(feature, featureIdx, vertex) {
            return [vertex[3], vertex[4], vertex[5], vertex[6]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_iconMapUV',
          shaderLocation: 14,
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature) {
            var iconMap = _this2.iconService.getIconMap();
            var texture = feature.texture;
            var _ref4 = iconMap[texture] || {
                x: 0,
                y: 0
              },
              x = _ref4.x,
              y = _ref4.y;
            return [x, y];
          }
        }
      });
    }
  }]);
  return ArcModel;
}(_BaseModel2.default);