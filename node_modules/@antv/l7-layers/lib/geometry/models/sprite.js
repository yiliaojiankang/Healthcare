"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _BaseModel2 = _interopRequireDefault(require("../../core/BaseModel"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/* babel-plugin-inline-import '../shaders/sprite_frag.glsl' */
var spriteFrag = "\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_mapFlag;\n  float u_Scale;\n};\nuniform sampler2D u_texture;\n\nin vec3 v_Color;\nin float v_d;\nout vec4 outputColor;\n\nvoid main() {\n\n  if(v_d < 0.0) {\n    discard;\n  }\n\n  if(u_mapFlag > 0.0) {\n    outputColor = texture(SAMPLER_2D(u_texture), gl_PointCoord);\n    outputColor.a *= u_opacity;\n  } else {\n    outputColor = vec4(v_Color, u_opacity);\n  }\n}\n";
/* babel-plugin-inline-import '../shaders/sprite_vert.glsl' */
var spriteVert = "layout(location = 0) in vec3 a_Position;\nlayout(location = 1) in vec3 a_Color;\n\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_mapFlag;\n  float u_Scale;\n};\n\nout vec3 v_Color;\nout float v_d;\n\n#pragma include \"projection\"\nvoid main() {\n   v_Color = a_Color.xyz;\n  \n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n   v_d = a_Position.z;\n\n  gl_Position = project_common_position_to_clipspace_v2(vec4(project_pos.xy, a_Position.z, 1.0));\ngl_PointSize = pow((u_Zoom - 1.0), 2.0) * u_Scale;\n}\n";
var SPRITE_ANIMATE_DIR = /*#__PURE__*/function (SPRITE_ANIMATE_DIR) {
  SPRITE_ANIMATE_DIR["UP"] = "up";
  SPRITE_ANIMATE_DIR["DOWN"] = "down";
  return SPRITE_ANIMATE_DIR;
}(SPRITE_ANIMATE_DIR || {});
var SpriteModel = exports.default = /*#__PURE__*/function (_BaseModel) {
  (0, _inherits2.default)(SpriteModel, _BaseModel);
  var _super = _createSuper(SpriteModel);
  function SpriteModel() {
    var _this;
    (0, _classCallCheck2.default)(this, SpriteModel);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "planeGeometryUpdateTriangulation", function () {
      var _ref = _this.layer.getLayerConfig(),
        _ref$spriteBottom = _ref.spriteBottom,
        spriteBottom = _ref$spriteBottom === void 0 ? -100000 : _ref$spriteBottom;
      var updateZ = _this.spriteUpdate;
      var bottomZ = spriteBottom;
      var topZ = _this.spriteTop;
      for (var i = 0; i < _this.positions.length; i += 5) {
        if (_this.spriteAnimate === SPRITE_ANIMATE_DIR.UP) {
          _this.positions[i + 2] += updateZ;
          if (_this.positions[i + 2] > topZ) {
            _this.positions[i + 2] = bottomZ;
          }
        } else {
          _this.positions[i + 2] -= updateZ;
          if (_this.positions[i + 2] < bottomZ) {
            _this.positions[i + 2] = topZ;
          }
        }
      }
      return {
        vertices: _this.positions,
        indices: _this.indices,
        size: 5
      };
    });
    /**
     * Recalculate and update position attribute.
     */
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "updatePosition", function () {
      var _this$styleAttributeS;
      _this.planeGeometryUpdateTriangulation();
      var vertexAttribute = (_this$styleAttributeS = _this.styleAttributeService.getLayerStyleAttribute('position')) === null || _this$styleAttributeS === void 0 ? void 0 : _this$styleAttributeS.vertexAttribute;
      if (vertexAttribute) {
        // [x1, y1, z1, x2, y2, z2...]
        var updated = [];
        for (var i = 0; i < _this.positions.length; i += 5) {
          updated.push(_this.positions[i], _this.positions[i + 1], _this.positions[i + 2]);
        }
        vertexAttribute.updateBuffer({
          data: updated,
          offset: 0
        });
      }
      _this.layerService.throttleRenderLayers();
      _this.timer = requestAnimationFrame(_this.updatePosition);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "planeGeometryTriangulation", function () {
      var _this2;
      var _ref2 = _this.layer.getLayerConfig(),
        _ref2$center = _ref2.center,
        center = _ref2$center === void 0 ? [120, 30] : _ref2$center,
        _ref2$spriteCount = _ref2.spriteCount,
        spriteCount = _ref2$spriteCount === void 0 ? 100 : _ref2$spriteCount,
        _ref2$spriteRadius = _ref2.spriteRadius,
        spriteRadius = _ref2$spriteRadius === void 0 ? 10 : _ref2$spriteRadius;
      var _this$initSprite = (_this2 = _this).initSprite.apply(_this2, [spriteRadius, spriteCount].concat((0, _toConsumableArray2.default)(center))),
        indices = _this$initSprite.indices,
        positions = _this$initSprite.positions;
      _this.positions = positions;
      _this.indices = indices;
      return {
        vertices: positions,
        indices: indices,
        size: 5
      };
    });
    return _this;
  }
  (0, _createClass2.default)(SpriteModel, [{
    key: "initSprite",
    value: function initSprite() {
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      var spriteCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      var lng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 120;
      var lat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;
      var indices = [];
      var positions = [];
      var mapService = this.mapService;
      var heightLimit = this.spriteAnimate === SPRITE_ANIMATE_DIR.UP ? -this.spriteTop : this.spriteTop;
      for (var i = 0; i < spriteCount; i++) {
        var height = Math.random() * heightLimit;
        positions.push.apply(positions, (0, _toConsumableArray2.default)(getPos(height)));
      }
      for (var _i = 0; _i < spriteCount; _i++) {
        indices.push(_i);
      }
      function getPos(z) {
        var randomX = radius * Math.random();
        var randomY = radius * Math.random();
        var x = -radius / 2 + randomX;
        var y = -radius / 2 + randomY;
        if (mapService.version === 'GAODE2.x') {
          // @ts-ignore
          var _ref3 = mapService.lngLatToCoord([x + lng, -y + lat]),
            _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
            a = _ref4[0],
            b = _ref4[1];
          return [a, b, z, 0, 0];
        } else {
          return [x + lng, -y + lat, z, 0, 0];
        }
      }
      return {
        indices: indices,
        positions: positions
      };
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      var commoninfo = this.getCommonUniformsInfo();
      var attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
      this.updateStyleUnifoms();
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
    }
  }, {
    key: "getCommonUniformsInfo",
    value: function getCommonUniformsInfo() {
      var _ref5 = this.layer.getLayerConfig(),
        opacity = _ref5.opacity,
        mapTexture = _ref5.mapTexture,
        _ref5$spriteScale = _ref5.spriteScale,
        spriteScale = _ref5$spriteScale === void 0 ? 1 : _ref5$spriteScale;
      if (this.mapTexture !== mapTexture) {
        var _this$texture;
        this.mapTexture = mapTexture;
        (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
        this.textures = [];
        this.updateTexture(mapTexture);
      }
      var commonOptions = {
        u_opacity: opacity || 1,
        u_mapFlag: mapTexture ? 1 : 0,
        u_Scale: spriteScale,
        u_texture: this.texture
      };
      this.textures = [this.texture];
      var commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
      return commonBufferInfo;
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture2;
      cancelAnimationFrame(this.timer);
      (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
      this.textures = [];
    }
  }, {
    key: "initModels",
    value: function () {
      var _initModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var _this3 = this;
        var _ref6, mapTexture, _ref6$spriteTop, spriteTop, _ref6$spriteUpdate, spriteUpdate, _ref6$spriteAnimate, spriteAnimate, createTexture2D, model;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _ref6 = this.layer.getLayerConfig(), mapTexture = _ref6.mapTexture, _ref6$spriteTop = _ref6.spriteTop, spriteTop = _ref6$spriteTop === void 0 ? 5000000 : _ref6$spriteTop, _ref6$spriteUpdate = _ref6.spriteUpdate, spriteUpdate = _ref6$spriteUpdate === void 0 ? 10000 : _ref6$spriteUpdate, _ref6$spriteAnimate = _ref6.spriteAnimate, spriteAnimate = _ref6$spriteAnimate === void 0 ? SPRITE_ANIMATE_DIR.DOWN : _ref6$spriteAnimate;
              this.initUniformsBuffer();
              this.mapTexture = mapTexture;
              this.spriteTop = spriteTop;
              this.spriteUpdate = spriteUpdate;
              spriteAnimate === 'up' ? this.spriteAnimate = SPRITE_ANIMATE_DIR.UP : this.spriteAnimate = SPRITE_ANIMATE_DIR.DOWN;
              createTexture2D = this.rendererService.createTexture2D;
              this.texture = createTexture2D({
                height: 0,
                width: 0
              });
              this.updateTexture(mapTexture);
              setTimeout(function () {
                _this3.updatePosition();
              }, 100);
              _context.next = 12;
              return this.layer.buildLayerModel({
                moduleName: 'geometrySprite',
                vertexShader: spriteVert,
                fragmentShader: spriteFrag,
                triangulation: this.planeGeometryTriangulation,
                inject: this.getInject(),
                primitive: _l7Core.gl.POINTS,
                depth: {
                  enable: false
                },
                blend: this.getBlend()
              });
            case 12:
              model = _context.sent;
              return _context.abrupt("return", [model]);
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function initModels() {
        return _initModels.apply(this, arguments);
      }
      return initModels;
    }()
  }, {
    key: "buildModels",
    value: function () {
      var _buildModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this.initModels());
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function buildModels() {
        return _buildModels.apply(this, arguments);
      }
      return buildModels;
    }()
  }, {
    key: "updateTexture",
    value: function updateTexture(mapTexture) {
      var _this4 = this;
      var createTexture2D = this.rendererService.createTexture2D;
      if (mapTexture) {
        var img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function () {
          _this4.texture = createTexture2D({
            data: img,
            width: img.width,
            height: img.height,
            wrapS: _l7Core.gl.CLAMP_TO_EDGE,
            wrapT: _l7Core.gl.CLAMP_TO_EDGE
          });
          _this4.layerService.reRender();
        };
        img.src = mapTexture;
      } else {
        this.texture = createTexture2D({
          width: 1,
          height: 1
        });
      }
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      return '';
    }
  }]);
  return SpriteModel;
}(_BaseModel2.default);